% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: 20010806GPaHsap-20011109SCphuMmus_lib.nw,v 1.3 2002-05-09 12:49:58 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
\usepackage{verbatim}
%\usepackage{version}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}

<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\parsctn}[1]{\paragraph{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
  \item[$\triangleright$] [\textit{Section}~\ref{#2}, 
                           \textit{page}~\pageref{#2}]\\ {#1}
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\shorttit{\textbf{Human + Mouse}}
\def\tit{\textsc{\shortstack{Human Genome Annotation\\using Mouse Homology\\[ 20010806GPaHsap vs 20011109SCphuMmus ]}}}
%
\def\mtauthor{
 \htmladdnormallink{\texttt{author@imim.es}}
                   {MAILTO:author@imim.es?subject=[humus]}
 } % def mtauthor
%
\def\authorslist{
 The Author/s {\mdseries\small\dotfill \mtauthor } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF; Parra, G; Guig\'o, R
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
This document describes the steps that were used to produce the {\sgp} gene-predictions on {\lhsap} genome (Golden Path assembly, version 20010806), based on homology from {\lmmus} preliminar assembly (Sanger Center Phusion assembly, version 20011109)} % def progdesc
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\shorttit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
\newcommand{\mylst}[2]{
 \begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{#1}
   \begin{itemize}
     #2
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}
} % newcommand->mylst
\newcommand{\whtlst}[1]{\mylst{What to do here:}{#1}} % newcommand->chklst
\newcommand{\chklst}[1]{\mylst{Check points:}{#1}} % newcommand->chklst
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es?subject=[HuMus]}}
\def\mtgparra{\htmladdnormallink{\textbf{gparra@imim.es}}{MAILTO:gparra@imim.es?subject=[HuMus]}}
\def\mtrguigo{\htmladdnormallink{\textbf{rguigo@imim.es}}{MAILTO:rguigo@imim.es?subject=[HuMus]}}
\def\mthomology{\htmladdnormallink{\textbf{homology@viaken.com}}{MAILTO:homology@viaken.com?subject=[HuMus]}}
@ 
<<HIDE: new LaTeX definitions>>=
\def\perl{\textsc{Perl}}
\def\biop{\textsc{BioPerl}}
\def\ps{\textsc{PostScript}}
\def\rptm{\textsc{RepeatMasker}}
\def\bl{\textsc{Blast}}
\def\bn{\textsc{blastn}}
\def\bx{\textsc{blastx}}
\def\bp{\textsc{blastp}}
\def\tbn{\textsc{tblastn}}
\def\tbx{\textsc{tblastx}}
\def\pb{\texttt{parseblast}}
\def\gnid{\texttt{geneid}}
\def\gnsc{\texttt{genscan}}
\def\twsc{\texttt{twinscan}}
\def\slam{\textsc{slam}}
\def\sgp{\textsc{sgp}}
\def\gps{\texttt{gff2ps}}
\def\aps{\texttt{gff2aplot}}
\def\apo{\textsl{Apollo}}
\def\refseq{\textsc{RefSeq}}
\def\ens{\textit{\texttt{emsembl}}}
\def\hsap{\textit{H. sapiens}}
\def\lhsap{\textit{Homo sapiens}}
\def\mmus{\textit{M. musculus}}
\def\lmmus{\textit{Mus musculus}}
@ 
<<HIDE: new defs TODO>>=
@ 

%

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\textbf{\Huge \tit}\\[5ex]

% \textbf{\Large Authors List Here}\\[1ex]
\textbf{\Large Josep F. Abril}\\[1ex]
\textbf{\Large Gen\'{\i}s Parra}\\[1ex]
\textbf{\Large Roderic Guig\'o}\\[5ex] % \raisebox{0.85ex}{\footnotesize$\,\dag$}\\[0.5ex]

\textbf{\large --- \today ---}\\[10ex]

\begin{abstract}
\begin{center}
\parbox{0.75\linewidth}{
\progdesc
} % parbox
\end{center}
\end{abstract}

\vfill

\begin{raggedleft}
\showaffiliation
\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: {\mtjabril}, {\mtgparra} and {\mtrguigo}}\\
\end{raggedleft}
\end{center}

\end{titlepage} %'

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}

\ \ \\
% EMPTY PAGE

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: 20010806GPaHsap-20011109SCphuMmus_lib.nw,v 1.3 2002-05-09 12:49:58 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Global}

\subsctn{Main job collector}

<<JOB COLLECTOR>>=
####>#########>################################################################<#
### 
### Collecting step records for each pipeline job
###
####>#########>################################################################<#
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling: mySQL param' $WORK/$nwfile.nw ; } | bash ;
#
notangle -R'JOBS: Sequence Analysis'                   $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/annotation.job ;
notangle -R'JOBS: HsapGPa x MmusPHa WUTBLASTX'         $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/tblastx.job ;
notangle -R'JOBS: Running GENEID standard'             $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/geneid.job ;
notangle -R'JOBS: SGP with HSAPgpa x MMUSpha homology' $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/sgp.job ;
notangle -R'JOBS: Visualizing Results with Apollo'     $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/apollo.job ;
#
$MySQLPAR/admin_db_Hsapiens.pl ;
#
@ 

<<Global: >>=
#
#
# HUMUS="$BASE/H.sapiens" -> .project_VARS
#
MkDirs $HUMUS/.ftp $HUMUS/.ftp/PankajAgarwal
#
@

\subsctn{Retrieving sequence IDs and lengths}

<<Global: >>=
#
# Retrieving Golden path sequence names and length
#
##
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806";
##
HUMUS="/projects/H.sapiens/20011222.UCSCgp";
MkDirs $HUMUS
##
# 
# getfastadesc.pl must be executed after table update
#   on mySQL database (after admin_db_Hsapiens.pl)
#
$BIN/getfastadesc.pl $MySQLPAR/chrs.tbl $HSAP/chromosomes \
                     > $HUMUS/seqid_list 2> $HUMUS/seqid_list.rpt ;
#
###################################################################
##
## Fixing Pankaj TBLASTX files
#
FTPATH="/project/H.sapiens/.ftp/PankajAgarwal/20020111.tbx-20010806UCSCgp-20011109SCphusion";
##
ls -1 $FTPATH/ | grep -c '^chr' ;

## Checking header (if it contains TBLASTX at the beginning)
ls -1 $FTPATH/ | while read n; do head -1 $n; done | sort | uniq -c | sort -nr ;

## FILES WITH BAD TBX HEADER

## FIXING BAD HEADERS !!!
errsfound=0 ;
ls -1 $FTPATH/ | grep '^chr' | \
  while read n ; 
    do {
      head -1 $FTPATH/$n | \
        gawk 'BEGIN{ fl=ARGV[1]; ARGV[1]="" }
              $1 !~ "TBLASTX" {print fl}' $n - ;
    } ;
  done > $FTPATH.bad_header_files ;
cat $FTPATH.bad_header_files | \
  while read m ;
    do {
      errsfound=`expr $errsfound + 1` ;
      perl -e ' use strict;
my $ifile = shift @ARGV;
my $fl = "";
($ifile =~ m%/([^/]*)$%o) && ($fl = $1);
print STDERR "# Working on $ifile --> $fl \n";
#
open(TBX,"< $ifile") || die("### CANNOT OPEN FILE $ifile $!");
my $prt = 0;
while (<TBX>) {
    $prt && do { print STDOUT $_ };
    $_ =~ /^Sequences producing High-scoring Segment Pairs:/io && do {
        $prt = 1;
        &prthead($fl);
        print STDOUT $_;
    };
}; # while TBX
close(TBX);
exit(0);
#
sub prthead() {
    my $query = shift;
    print STDOUT <<"+++EOT+++" 
TBLASTX 2.0MP-WashU [13-Dec-2000] [decunix4.0-ev5-L64 09:44:13 06-Sep-2001]

Copyright (C) 1996-2000 Washington University, Saint Louis, Missouri USA.
All Rights Reserved.

Reference:  Gish, W. (1996-2000) http://blast.wustl.edu

Notice:  statistical significance is estimated under the assumption that the
equivalent of one entire reading frame of the query sequence and one entire
reading frame of the database code for protein and that significant alignments
will only involve coding reading frames.

Query=  $query
        (100,300 letters)

  Translating both strands of query sequence in all 6 reading frames

Database:  MusPhusion
           431,480 sequences; 2,374,690,634 total letters.
Searching....10....20....30....40....50....60....70....80....90....100% done

                                                                     Smallest
                                                                       Sum
                                                     Reading  High  Probability
+++EOT+++
} # prthead
      ' $IDIR/$m > $IDIR/$m.tmp ;
      mv -v $IDIR/$m.tmp $IDIR/$m ;
    } ;
  done ; 
echo "### BAD TBLASTX FILE HEADERS FOUND FOR $errsfound FILES..." ;
#
@


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Sequence Analysis}

\whtlst{
\item Get annotations for each sequence from Golden Path annotation.
\item Get fragment lengths, fragment number.
\item Get coords of N-masked regions from assembly gaps.
\item Get G+C content.
}

<<JOBheader: Sequence Analysis>>=
####>#########>#######################<########################################<#
#># JOB_ID    HSAP_GP_ANNOTATION
#># JOB_DESC  Homo sapiens Golden Path annotation.
#>#        :  Processing files downloaded from Golden-Path server
#>#        :  ( URL: http://genome.ucsc.edu/ ).
#>#        :  We retrieve fasta sequences, gaps, annotation (RefSeq and 
#>#        :  Ensembl), genscan predicted genes and so on.
#>#        :  Last UCSC-GP version being analyzed is August, 2001.
#># JOB_PATH  annotation
#># JOB_XID   $HSAPID
#># JOB_FILE  ${LIBSTEP}/annotation.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Sequence Analysis>>=
<<STEPS(Sequence Analysis): INITIALIZE>>
<<STEPS(Sequence Analysis): ASSEMBLY GAPS>>
<<STEPS(Sequence Analysis): ORIGINAL MASKING>>
<<STEPS(Sequence Analysis): REFSEQ>>
<<STEPS(Sequence Analysis): ENSEMBL>>
<<STEPS(Sequence Analysis): GENSCAN>>
<<STEPS(Sequence Analysis): Evaluating genscan results>>
@

\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

<<STEPS(Sequence Analysis): INITIALIZE>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_INITIALIZE
#># STEP_DESC Preparing files for current chromosome.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<#
CheckFile R $IDIR/seqid_list ;
gawk 'BEGIN{ chrom="\^"ARGV[1]"\$"; ARGV[1]=""; }
      $1 ~ chrom { print $0; }
     ' $CHR $IDIR/seqid_list > $ODIR/desc || TheEnd GAWKKO ;
gawk '{ print $2, $3; }' $ODIR/desc > $ODIR/length || TheEnd GAWKKO ;
gawk 'BEGIN{ OFS="\t"; ofile=ARGV[1]; s="Sequence"; d="." }
      { print $1,s,s,1,$2,d,d,d,1 > ofile"."$1".gff"; }
     ' $ODIR/length || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Retrieving annotations from Golden Path}

<<STEPS(Sequence Analysis): REFSEQ>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_REFSEQ
#># STEP_DESC Retrieving RefSeq annotated genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH refseq
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/refseq" ;
#<# MkDirs $ODIR $EDIR ;
CheckFile R $IDIR/refGene.txt ;
# ALL features
$BIN/gp2gff.pl --exonori-nuclfix 1 -- \
               $SEQ refseq $IDIR/refGene.txt \
             > $ODIR/$SEQ.fullgff 2> $EDIR/$SEQ.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
# Avoiding overlap hack for evaluation program...
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ refseq $IDIR/refGene.txt \
             > $ODIR/$SEQ.eval.fullgff 2> $EDIR/$SEQ.eval.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.eval.fullgff > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl -l $<STEP{.}{HSAP_GP_INITIALIZE}{STEP_ODIR}>/length.$SEQ.gff \
                       $ODIR/$SEQ.eval.gff ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

<<STEPS(Sequence Analysis): ENSEMBL>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ENSEMBL
#># STEP_DESC Retrieving Ensembl annotated genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH ensembl
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID" ;
#<# MkDirs $ODIR $EDIR ;
CheckFile R $IDIR/ensGene.txt ;
# ALL features
$BIN/gp2gff.pl --exonori-nuclfix 1 -- \
               $SEQ ensembl $IDIR/ensGene.txt \
             > $ODIR/$SEQ.fullgff 2> $EDIR/$SEQ.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
# Avoiding overlap hack for evaluation program...
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ ensembl $IDIR/ensGene.txt \
             > $ODIR/$SEQ.eval.fullgff 2> $EDIR/$SEQ.eval.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.eval.fullgff > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl -l $<STEP{.}{HSAP_GP_INITIALIZE}{STEP_ODIR}>/length.$SEQ.gff \
                       $ODIR/$SEQ.eval.gff ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item Annotations for {\refseq} and {\ens} genes.
}


\subsubsctn{Preparing annotation files for evaluation}

<<Sequence: >>=
#
# TO BE redefined................ include frame0-mapping too
function pre_eval {
  gawk 'BEGIN{
          src = ARGV[1]; len = ARGV[2]; ARGV[1] = ARGV[2] = ""; 
          print "chr22\t"src"\tsequence\t1\t"len"\t.\t.\t."
       }' $n $lenaug > $TDIR/${HSAPIDaug}_seqlength.gff ;
  sort +3n -5 $TDIR/${HSAPIDaug}_$n.gff > $TDIR/${HSAPIDaug}.tmp ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  gawk '$7 == "+" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  gawk '$7 == "-" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  /bin/rm -v $TDIR/${HSAPIDaug}.tmp ;
} ;
#
@ 

\chklst{
\item Evaluation files for {\refseq} and {\ens} genes: SR projection of features when mapping all frames to 0, and forward/reverse selection of non-overlapping genes.
}


\subsubsctn{Retrieving gaps and masked regions from annotated sequences}

<<STEPS(Sequence Analysis): ASSEMBLY GAPS>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ASSEMBLY_GAPS
#># STEP_DESC Retrieving assembly gaps coords for current 
#>#         : H. sapiens Golden Path sequence (masked with N's).
#># STEP_PATH gaps
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/gaps" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/${SEQ}_gap.txt ;
perl -e '
  ($seq,$ori,$end,$char,$size,$type) = (1,2,3,5,6,7);
  $n = 1;
  while (<STDIN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      defined($l[$type]) || ($l[$type] = "gap");
      print STDOUT join("\t", $l[$seq],"sequence","gap",
                              @l[$ori,$end],".",".",".",
            $l[$type].".".($n++)." # $l[$type]\: $l[$size]bp ($l[$char])\n");
  }; # while   
  ' < $IDIR/${SEQ}_gap.txt \
    > $ODIR/${SEQ}.gff || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

<<STEPS(Sequence Analysis): ORIGINAL MASKING>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ORI_MASKED
#># STEP_DESC Retrieving masked regions coords for current H. sapiens Golden
#>#         : Path sequence (original masking of repetitive regions).
#># STEP_PATH repeats
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/repeats" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/${SEQ}_rmsk.txt ;
perl -e '
  ($sco,$seq,$ori,$end,$str,$name,$class,$fam) = (1,5,6,7,9,10,11,12);
  $n = 1;
  while (<STDIN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      print STDOUT join("\t", $l[$seq],"repeatmasker","repeat",
                              @l[$ori,$end,$sco,$str],".",
                              $l[$class].".".($n++))." # @l[$name,$fam]\n";
  }; # while 
  ' < $IDIR/${SEQ}_rmsk.txt \
    > $ODIR/${SEQ}.gff || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Retrieving gene prediction results from Golden Path ({\gnsc})}

<<STEPS(Sequence Analysis): GENSCAN>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_GENSCAN
#># STEP_DESC Retrieving genscan predicted genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH genscan
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/genscan" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/genscan.txt ;
# ALL features
$BIN/gp2gff.pl --exonori-nuclfix 1 -- \
               $SEQ genscan $IDIR/genscan.txt \
             > $ODIR/$SEQ.fullgff 2> $EDIR/$SEQ.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item Annotations for {\gnsc} genes.
}


\subsubsctn{Evaluating {\gnsc} results from Golden Path versus annotation}

<<STEPS(Sequence Analysis): Evaluating genscan results>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_GENSCAN_EVAL
#># STEP_DESC Evaluation of genscan predictions as they were provided
#>#         : accompanying H. sapiens Golden Path sequence.
#># STEP_PATH eval
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{HSAP_GP_GENSCAN}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{HSAP_GP_GENSCAN}{STEP_PATH}>/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{HSAP_GP_GENSCAN}{STEP_PATH}>/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
# Avoiding overlap hack for evaluation program...
IFILE="$<STEP{.}{HSAP_GP_GENSCAN}{STEP_IDIR}>/genscan.txt" ;
CheckFile R $IFILE ;
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ genscan $IFILE \
             > $ODIR/$SEQ.eval.fullgff 2> $EDIR/$SEQ.eval.report ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.eval.fullgff > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl $ODIR/$SEQ.eval.gff ; # no sequence length record required here
#
A_REFSEQ="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_REFSEQ}{STEP_PATH}>/$SEQ.eval" ;
A_ENSEMBL="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_ENSEMBL}{STEP_PATH}>/$SEQ.eval" ;
cat > $ODIR/${SEQ}.summary <<EOT ;
#
# Evaluation summary results for genscan on CHROM[$CHR] - SEQ[$SEQ]
#
EOT
#
CheckFile R $A_REFSEQ.fwd.gff  $A_REFSEQ.rev.gff  \
            $A_ENSEMBL.fwd.gff $A_ENSEMBL.rev.gff ;
#
$BIN/runeval.pl $A_REFSEQ.fwd.gff $ODIR/$SEQ.eval.fwd.gff                      \
           "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::FWD::GENSCAN::genscan_GP::."  \
           >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.genscan_refseq.fwd ;
$BIN/runeval.pl $A_REFSEQ.rev.gff $ODIR/$SEQ.eval.rev.gff                      \
           "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::REV::GENSCAN::genscan_GP::."  \
           >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.genscan_refseq.rev ;
$BIN/runeval.pl $A_ENSEMBL.fwd.gff $ODIR/$SEQ.eval.fwd.gff                     \
           "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::FWD::GENSCAN::genscan_GP::." \
            >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.genscan_ensembl.fwd ;
$BIN/runeval.pl $A_ENSEMBL.rev.gff $ODIR/$SEQ.eval.rev.gff                     \
           "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::REV::GENSCAN::genscan_GP::." \
           >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.genscan_ensembl.rev ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 
\subsctn{Sequence analysis: \textit{M.musculus}}

<<Sequence: M.musculus>>=
#
# 
#
MMUS="/seq/genomes/M.musculus/sanger_phusion_20011109" ;
MMUSID="20011109"
ODIR="" ;
#
#

@ 

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Masking sequences} %%%%%%%%%%%%%%%%%%%%%%

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
    \item Human genome assembly from UCSC Golden Path August release (20010806).
    \item Pankaj run {\rptm} with the following parameters:\\[-3ex]
\begin{small}
\begin{verbatim}
###
I used the masked sequence from UCSC and masked it again. I used -s
"slow" option. We actually used RepeatBlaster and not Repeatmasker. RB
is faster version of RM that uses Blast instead of crossmatch.
\end{verbatim}
\end{small}
   \end{itemize}
  \end{minipage}
% } % fbox
\end{center}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Processing {\tbx} results from human and mouse genome comparison} %%%%%%

\begin{comment}
Ensembl:
	http://www.ensembl.org/Homo_sapiens/
	http://www.ensembl.org/Mus_musculus/
Ensembl mouse assembly v1.0
Sanger Institute Phusion Nov 6 Assembly
Whitehead Arachne Oct 26 Assembly
\end{comment}
\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
 \item Process {\tbx} results from Pankaj:
  \begin{itemize}
   \item Human genome assembly from UCSC Golden Path August release (20010806).
   \item Mouse genome assembly from Sanger Center Phusion assembly (20011106).\\[-3ex]
\begin{verbatim}
# Database:  /bioinfo/gapdb/blastdb/MusPhusion
# Title:  MusPhusion
# # of letters in database:  2,374,690,634  (Z = 3000000000)
# # of sequences in database:  431,480
# Format:  XDF-1
# Created:  5:32:13 PM EST Dec 10, 2001
# Posted:  5:32:14 PM EST Dec 10, 2001
\end{verbatim}
   \item {\tbx} was run with the following parameters:\\[-3ex]
%	   \begin{center}
%	   \begin{minipage}[c]{0.75\linewidth}
\begin{verbatim}
W=5  Z=3000000000
matrix=blosum62mod  filter=xnu+seg
nogaps  hspmax=500  topcomboN=100
B=9000  V=9000  E=0.01  E2=0.01  S2=80
warnings  cpus=4  ctxfactor=36.0
\end{verbatim}
% tail -54 ori/chr22_* | sort | uniq -c | sort +0nr | more
%	   \end{minipage}
%	   \end{center}
  \end{itemize}
\item Get HSPs $\Rightarrow$ SRs $\Rightarrow$ HSP-SRs
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}


<<JOBheader: HsapGPa x MmusPHa WUTBLASTX>>=
####>#########>#######################<########################################<#
#># JOB_ID    HSAPgpa_MMUSpha_WUTBLASTX
#># JOB_DESC  Homology search by WU-TBLASTX for H.sapiens UCSC Golden Path 
#>#        :  assembly against M.musculus Sanger Center Phusion assembly 
#>#        :  (TBLASTX results obtained by Pankaj Agarwal,  
#>#        :   last update was jan 11, 2002, downladed from GSBP).
#># JOB_PATH  tblastx
#># JOB_XID   $FTPTBXID
#># JOB_FILE  ${LIBSTEP}/tblastx.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: HsapGPa x MmusPHa WUTBLASTX>>=
<<STEPS(HsGPa*MmPHa WUTBLASTX): retrieve blast output>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): parsing blast output>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): project HSPs into SRs>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): evaluating SRs>>
@ 

\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

\subsctn{Unpacking {\tbx} results obtained by Pankaj}

<<STEPS(HsGPa*MmPHa WUTBLASTX): retrieve blast output>>=
####>#########>#######################<########################################<#
#># STEP_ID   TBLASTX_OUTPUT
#># STEP_DESC Unpacking TBLASTX results obtained by Pankaj Agarwal
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH ori
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $FTPTBX
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/.ftp/PankajAgarwal/20020111.tbxPhusion" ;
#<# IDIR="$HUMUS/.ftp/PankajAgarwal/20020111.tbxPhusion" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/ori" ;
#<# MkDirs $ODIR ;
MkDirs $ODIR/$SEQ ;
( mega "cp -v" $IDIR '^'$SEQ'_[0-9]' $ODIR/$SEQ 1>&2 ) || TheEnd FUNCKO ;
# exit status has been implemented on sbp_checkblastout.pl
$BIN/sbp_checkblastout.pl $SEQ $ODIR/$SEQ > $ODIR/$SEQ.report ; 
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item get number of sequences from DB matching each chromosome fragment.
\item do the regions without HSPs correspond to N regions at original sequences (being gaps or masked) ? (maybe using [[evaluation]])
}

\subsctn{Retrieving {\tbx} results by chromosome}

\begin{figure}[!t]
\begin{center}
 \input psfigures/blast_frames.tex
\end{center}
\end{figure}

We had to deal with the frame issue of the HSPs fragments; once the HSP coords were mapped to the chromosome, frames also must be recomputed taking into account if HSP was in forward or in reverse strand (see figure~\ref{fig:blastframes}).

<<STEPS(HsGPa*MmPHa WUTBLASTX): parsing blast output>>=
####>#########>#######################<########################################<#
#># STEP_ID   PARSING_TBLASTX
#># STEP_DESC Retrieving HSPs from raw TBLASTX output
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH hsp
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{TBLASTX_OUTPUT}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/ori" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/hsp" ;
#<# MkDirs $ODIR ;
#<# LEN="$HUMUS/$NCHR/annotation/$HSAPID/length" ;
LEN="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/length" ;
# exit status has been implemented on sbp_blast2gff.pl
/bin/rm -vf $IDIR/$SEQ.parseblast.err 1>&2 ;
$BIN/sbp_blast2gff.pl $SEQ $LEN $IDIR/$SEQ $IDIR/$SEQ.report \
         > $ODIR/$SEQ.fullgff 2> $EDIR/$SEQ.report ;
#
( perl -ne '/^#/o && next;
          /^\s+$/o && next; 
          $_ =~ s/;\s+Strand//o; 
          $_ =~ s/;\s+Frame//o; 
          $_ =~ s/;\s+E_value.*$//o;
          print STDOUT $_;' $ODIR/$SEQ.fullgff | \
          sort +3n -6 +6 -7 - > $ODIR/$SEQ.gff ) || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item find number of HSPs per fragment and total per chromosome.
}

\subsubsctn{Projecting HSPs into SRs}

<<STEPS(HsGPa*MmPHa WUTBLASTX): project HSPs into SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   PROJECTING_HSPs
#># STEP_DESC Projecting HSPs into SRs
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH sr
#># STEP_XID  $<STEP{.}{PARSING_TBLASTX}{STEP_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{PARSING_TBLASTX}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/hsp" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/sr" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/$SEQ.gff ;
$BIN/blast2gff -vg $IDIR/$SEQ.gff > $ODIR/$SEQ.gff || TheEnd CKO ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; t=b["+"]=b["-"]=b["."]=0; }
  ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) { t++; a[$7,$8]++; b[$7]++; c[$8]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse, %s without strand.\n", 
           t, chr, b["+"], b["-"], b["."];
    for (i in c) {
      printf "#\t%s : %6s\t\|\t%s : %6s\t|\t%s : %6s\n", 
             "+"i, a["+",c[i]] ? a["+",i] : 0,
             "-"i, a["-",c[i]] ? a["-",i] : 0,
             "."i, a[".",c[i]] ? a[".",i] : 0;
    };
  }
' $SEQ $ODIR/$SEQ.gff > $EDIR/$SEQ.report || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item Get SRs number for each sequence.
\item ...
}

\subsubsctn{Evaluating SRs versus annotation}

<<STEPS(HsGPa*MmPHa WUTBLASTX): evaluating SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   EVALUATING_SRs
#># STEP_DESC Evaluating SRs versus different annotations
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH eval
#># STEP_XID  $<STEP{.}{PARSING_TBLASTX}{STEP_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{PROJECTING_HSPs}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/sr" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/eval" ;
CheckFile R $IDIR/$SEQ.gff ;
gawk 'BEGIN{ OFS="\t"; }
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/ && $3 ~ "SR") { print $0,"1" }' \
               $IDIR/$SEQ.gff > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl $ODIR/$SEQ.eval.gff ; # no sequence length record required here
#
A_REFSEQ="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_REFSEQ}{STEP_PATH}>/$SEQ.eval" ;
A_ENSEMBL="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_ENSEMBL}{STEP_PATH}>/$SEQ.eval" ;
cat > $ODIR/${SEQ}.summary <<EOT ;
#
# Evaluation summary results for similarity regions on CHROM[$CHR] - SEQ[$SEQ]
#
EOT
#
CheckFile R $A_REFSEQ.fwd.gff  $A_REFSEQ.rev.gff  \
            $A_ENSEMBL.fwd.gff $A_ENSEMBL.rev.gff ;
#
$BIN/runeval.pl $A_REFSEQ.fwd.gff $ODIR/$SEQ.eval.fwd.gff             \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::FWD::SRs::.::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sr_refseq.fwd ;
$BIN/runeval.pl $A_REFSEQ.rev.gff $ODIR/$SEQ.eval.rev.gff             \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::REV::SRs::.::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sr_refseq.rev ;
$BIN/runeval.pl $A_ENSEMBL.fwd.gff $ODIR/$SEQ.eval.fwd.gff             \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::FWD::SRs::.::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sr_ensembl.fwd ;
$BIN/runeval.pl $A_ENSEMBL.rev.gff $ODIR/$SEQ.eval.rev.gff             \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::REV::SRs::.::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sr_ensembl.rev ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item Evaluation records (extended and brief) for each seq and for each chromosome.
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Gene Prediction} %%%%%%%%%%%%%%%%%%%%%%

\subsctn{Initialization}

\subsctn{Gene Prediction: {\gnid}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Run {\gnid} without homology, then evaluate results.
\item Remember to run [[/projects/sgp/src/geneid_v1.1]] 
\item ...
}

<<JOBheader: Running GENEID standard>>=
####>#########>#######################<########################################<#
#># JOB_ID    GENEID_STD
#># JOB_DESC  Running "geneid" on unmasked H.sapiens UCSC Golden Path 
#>#        :  assembly sequences.
#># JOB_PATH  geneid
#># JOB_XID   $HSAPID
#># JOB_FILE  ${LIBSTEP}/geneid.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Running GENEID standard>>=
<<STEPS(geneid): Initialization>>
<<STEPS(geneid std): Running geneid on raw sequences>>
<<STEPS(geneid std): Processing geneid output>>
<<STEPS(geneid std): Evaluating geneid results>>
@ 

<<STEPS(geneid): Initialization>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_INITIALIZE
#># STEP_DESC Preparing subdirectories for geneid results.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<
#
#<# ODIR="$HUMUS/$NCHR/geneid/$XID" ; MkDirs $ODIR ;
#
( for c in out gff gtf2 cds prot logs tmp ;
    do {
      MkDirs $ODIR/$c ;
      } ;
    done ) || TheEnd BASHKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Running {\gnid} (without homology)}


<<STEPS(geneid std): Running geneid on raw sequences>>=
####>#########>#######################<########################################<#
#># STEP_ID   RUNNING_GENEID
#># STEP_DESC Running geneid (without homology) on Hsapiens sequences from
#>#         : Golden Path assembly.
#># STEP_PATH out
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/logs
#># STEP_CODE   --------------------------------------------------------------#<#
#<# 
GENEID="$SRC/geneid_v1.1/bin/geneid" ; # geneid v1.1
PARAM="$SRC/geneid_v1.1/param/human3iso.param" ;
EW=0 ; # add to exon weigth
#
#<# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ; 
#<# IDIR="$HUMUS/$NCHR/geneid/$XID/" ;
#<# ODIR="$HUMUS/$NCHR/geneid/$XID/out" ;
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSEQ/$SEQ.fa" ;
#
CheckFile R $PARAM $ISEQ ;
#
GENEID_CMDLN="-v -DE $EW -P $PARAM $ISEQ" ;
echo "$GENEID $GENEID_CMDLN 2> $EDIR/$SEQ.geneid" 1>&2 ;
( $GENEID $GENEID_CMDLN 2> $EDIR/$SEQ.geneid || TheEnd CKO ) \
           | grep -v 'evidence' > $ODIR/$SEQ ;
#
( cat $EDIR/$SEQ.geneid 1>&2 ) || TheEnd CMDKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\gnid} (without homology)}

<<STEPS(geneid std): Processing geneid output>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_OUTPUT
#># STEP_DESC Processing geneid format from geneid output (without homology).
#># STEP_PATH gff
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/geneid/$XID" ;
#
CheckFile R $IDIR/out/$SEQ ;
#
$BIN/geneid_raw2GFF.pl $SEQ $IDIR $IDIR/out/$SEQ ;
#
( ls -1 $IDIR/gff/$SEQ.sg/ | egrep "^$SEQ" | \
    while read n;
      do {
        cat $IDIR/gff/$SEQ.sg/$n;
        };
      done | sort +3n +4n -5 - > $IDIR/gff/$SEQ ) || TheEnd BASHKO ;
#
get_geneid_genes $IDIR/gff/$SEQ > $IDIR/$SEQ.gene_list || TheEnd FUNCKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\gnid} predictions (without homology)}

<<STEPS(geneid std): Evaluating geneid results>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_EVALUATION
#># STEP_DESC Evaluation of geneid predictions (without homology).
#># STEP_PATH eval
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{GENEID_OUTPUT}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/geneid/$XID" ;
CheckFile R $IDIR/$SEQ ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $IDIR/$SEQ > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl $ODIR/$SEQ.eval.gff ; # no sequence length record required here
#
A_REFSEQ="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_REFSEQ}{STEP_PATH}>/$SEQ.eval" ;
A_ENSEMBL="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_ENSEMBL}{STEP_PATH}>/$SEQ.eval" ;
cat > $ODIR/${SEQ}.summary <<EOT ;
#
# Evaluation summary results for geneid on CHROM[$CHR] - SEQ[$SEQ]
#
EOT
#
CheckFile R $A_REFSEQ.fwd.gff  $A_REFSEQ.rev.gff  \
            $A_ENSEMBL.fwd.gff $A_ENSEMBL.rev.gff ;
#
$BIN/runeval.pl $A_REFSEQ.fwd.gff $ODIR/$SEQ.eval.fwd.gff                  \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::FWD::GENEID::1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.geneid_refseq.fwd ;
$BIN/runeval.pl $A_REFSEQ.rev.gff $ODIR/$SEQ.eval.rev.gff                  \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::REV::GENEID::1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.geneid_refseq.rev ;
$BIN/runeval.pl $A_ENSEMBL.fwd.gff $ODIR/$SEQ.eval.fwd.gff                  \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::FWD::GENEID::1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.geneid_ensembl.fwd ;
$BIN/runeval.pl $A_ENSEMBL.rev.gff $ODIR/$SEQ.eval.rev.gff                  \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::REV::GENEID::1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.geneid_ensembl.rev ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Gene Prediction: {\sgp}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Re-score similarity regions: SRs to HSP-SRs.
\item Initialize any auxiliarly file (like those [[*.termini]]).
\item Run {\sgp} with homology, then evaluate results.
\item Run {\sgp} with homology plus evidences, then evaluate results.
}

<<JOBheader: SGP with HSAPgpa x MMUSpha homology>>=
####>#########>#######################<########################################<#
#># JOB_ID    SGP_HSAPgpa_MMUSpha_TBX
#># JOB_DESC  Running "SGP" on unmasked H.sapiens UCSC Golden Path 
#>#        :  assembly sequences, using TBLASTX homology results as
#>#        :  homology evidences once they have been projected into SRs.
#># JOB_PATH  sgp
#># JOB_XID   ${HSAPSTR}-${MMUSSTR}
#># JOB_FILE  ${LIBSTEP}/sgp.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: SGP with HSAPgpa x MMUSpha homology>>=
<<STEPS(SGP): Initialization>>
<<STEPS(SGP HSAPgpa x MMUSpha): Auxiliarly files>>
<<STEPS(SGP HSAPgpa x MMUSpha): Re-scoring SRs>>
<<STEPS(SGP HSAPgpa x MMUSpha): Running SGP>>
<<STEPS(SGP HSAPgpa x MMUSpha): Processing SGP results>>
<<STEPS(SGP HSAPgpa x MMUSpha): Evaluating SGP results>>
@ 

<<STEPS(SGP): Initialization>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_INITIALIZE
#># STEP_DESC Preparing subdirectories for sgp results.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<
#
#<# ODIR="$HUMUS/$NCHR/sgp/$XID" ; MkDirs $ODIR ;
#
( for c in out gff gtf2 cds prot hsp-sr logs tmp ;
    do { 
      MkDirs $ODIR/$c ;
      } ;
    done ) || TheEnd BASHKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Re-scoring SRs}

<<STEPS(SGP HSAPgpa x MMUSpha): Re-scoring SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   RE-SCORING_SRs
#># STEP_DESC Re-scoring SRs to produce HSP-SRs
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH hsp-sr
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_PATH}>/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_XID}>/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{PROJECTING_HSPs}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_PATH}>/$XID/sr" ;
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/hsp-sr" ;
#
CheckFile R $IDIR/$SEQ.gff ;
$BIN/getHSPSR.pl $SEQ < $IDIR/$SEQ.gff \
                      > $ODIR/$SEQ.gff 2> $EDIR/$SEQ.report || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item ...
}

\subsubsctn{Preparing auxiliarly files}

<<STEPS(SGP HSAPgpa x MMUSpha): Auxiliarly files>>=
####>#########>#######################<########################################<#
#># STEP_ID   AUX_FILES
#># STEP_DESC Preparing auxiliarly files: CHR.termini
#># STEP_PATH tmp
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/tmp" ;
#<# LEN="$HUMUS/$NCHR/annotation/$HSAPID/length" ;
LEN="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/length" ;
#
CheckFile R $LEN ;
#
perl -e '
  use strict;
  my $chr = shift @ARGV;
  my %SEQlen;
  my $seqln = shift @ARGV;
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  print STDOUT join("\t", $chr, qw/ force cap  -2  0 . + 0 / )."\n";
  print STDOUT join("\t", $chr, qw/ force poly /,
                        ($SEQlen{$chr} - 1) x 2, qw/ . + 0/ )."\n";
' $SEQ $LEN > $ODIR/$SEQ.termini || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item ...
}

\subsubsctn{Running {\sgp} ({\gnid} with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Running SGP>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_HSAPgpa_MMUSpha
#># STEP_DESC Running geneid on Hsapiens sequences from Golden Path assembly
#>#         : with homology evidences taken from Mmusculus Phusion assembly.
#># STEP_PATH out
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/logs
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# 
#
GENEID="$SRC/geneid_v1.1-sgp/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SRC/geneid_v1.1-sgp/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
#<# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ; 
#<# IDIR="$HUMUS/$NCHR/sgp/$XID/" ;
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/out" ;
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSEQ/$SEQ.fa" ;
#
HOMOLOGY="$HUMUS/$NCHR/sgp/$XID/hsp-sr/$SEQ.gff" ;
if [ -f "$HOMOLOGY" ] ;
  then
    echo "### Using homology data from: $HOMOLOGY" 1>&2 ;
    HOMOLOGY_PAR="-S $HOMOLOGY" ;
  else
    echo "### Homology file NOT found: $HOMOLOGY" 1>&2 ;
    HOMOLOGY_PAR="" ;
  fi ;
#
TERMINI="$IDIR/tmp/$SEQ.termini" ;
if [ -f "$TERMINI" ] ;
  then
    echo "### Using termini file: $TERMINI" 1>&2 ;
    TERMINI_PAR="-R $TERMINI" ;
  else
    TERMINI_PAR="" ;
  fi ;
#
CheckFile R $PARAM $ISEQ ;
#
GENEID_CMDLN="-v -DE $EW -P $PARAM $HOMOLOGY_PAR $TERMINI_PAR $ISEQ" ;
echo "$GENEID $GENEID_CMDLN 2> $EDIR/$SEQ.sgp" 1>&2 ;
( $GENEID $GENEID_CMDLN 2> $EDIR/$SEQ.sgp || TheEnd CKO ) \
           | grep -v 'evidence' > $ODIR/$SEQ ;
#
( cat $EDIR/$SEQ.sgp 1>&2 ) || TheEnd CMDKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\sgp} (with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Processing SGP results>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_OUTPUT
#># STEP_DESC Processing geneid format from sgp output (with homology).
#># STEP_PATH gff
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/sgp/$XID" ;
#
CheckFile R $IDIR/out/$SEQ ;
#
$BIN/geneid_raw2GFF.pl $SEQ $IDIR $IDIR/out/$SEQ ;
#
( ls -1 $IDIR/gff/$SEQ.sg/ | egrep "^$SEQ" | \
    while read n;
      do {
        cat $IDIR/gff/$SEQ.sg/$n;
        };
      done | sort +3n +4n -5 - > $IDIR/gff/$SEQ ) || TheEnd BASHKO ;
#
get_geneid_genes $IDIR/gff/$SEQ > $IDIR/$SEQ.gene_list || TheEnd FUNCKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\sgp} predictions (with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Evaluating SGP results>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_EVALUATION
#># STEP_DESC Evaluation of SGP predictions (geneid with homology).
#># STEP_PATH eval
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{SGP_OUTPUT}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/sgp/$XID" ;
CheckFile R $IDIR/$SEQ ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $IDIR/$SEQ > $ODIR/$SEQ.eval.gff || TheEnd GAWKKO ;
$BIN/gffsplitstrand.pl $ODIR/$SEQ.eval.gff ; # no sequence length record required here
#
A_REFSEQ="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_REFSEQ}{STEP_PATH}>/$SEQ.eval" ;
A_ENSEMBL="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/$<STEP{HSAP_GP_ANNOTATION}{HSAP_GP_ENSEMBL}{STEP_PATH}>/$SEQ.eval" ;
cat > $ODIR/${SEQ}.summary <<EOT ;
#
# Evaluation summary results for SGP on CHROM[$CHR] - SEQ[$SEQ]
#
EOT
#
CheckFile R $A_REFSEQ.fwd.gff  $A_REFSEQ.rev.gff  \
            $A_ENSEMBL.fwd.gff $A_ENSEMBL.rev.gff ;
#
$BIN/runeval.pl $A_REFSEQ.fwd.gff $ODIR/$SEQ.eval.fwd.gff                      \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::FWD::SGP::geneid_1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sgp_refseq.fwd ;
$BIN/runeval.pl $A_REFSEQ.rev.gff $ODIR/$SEQ.eval.rev.gff                      \
                "${CHR}::${HSAPID}x${MMUSID}::REFSEQ::REV::SGP::geneid_1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sgp_refseq.rev ;
$BIN/runeval.pl $A_ENSEMBL.fwd.gff $ODIR/$SEQ.eval.fwd.gff                      \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::FWD::SGP::geneid_1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sgp_ensembl.fwd ;
$BIN/runeval.pl $A_ENSEMBL.rev.gff $ODIR/$SEQ.eval.rev.gff                      \
                "${CHR}::${HSAPID}x${MMUSID}::ENSEMBL::REV::SGP::geneid_1.1::." \
                >> $ODIR/${SEQ}.summary 2> $ODIR/${SEQ}.sgp_ensembl.rev ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item ...
}



\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Visualizing results}

<<JOBheader: Visualizing Results with Apollo>>=
####>#########>#######################<########################################<#
#># JOB_ID    APOLLO_VIEWER
#># JOB_DESC  Preparing all the files required to show the results on the Apollo
#>#        :  genomic annotations browser. Apollo is a collaborative project 
#>#        :  between the Berkeley Drosophila Genome Project (www.bdgp.org) and 
#>#        :  Ensembl (www.ensembl.org). 
#>#        :  URL: http://www.ensembl.org/apollo/
#># JOB_PATH  apollo
#># JOB_XID   20020225
#># JOB_FILE  ${LIBSTEP}/apollo.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Visualizing Results with Apollo>>=
<<STEPS(Apollo Browser): >>
@ 

\subsctn{Visualizing annotations with {\apo}}

\subsubsctn{Preparing GFF files for {\apo}}

<<STEPS(Apollo Browser): >>=
@ 
<<Visualizing: >>=
#
IDIR="$HUMUS/$NCHR" ;
ODIR="$IDIR/apollo" ;
#
MkDirs $ODIR $ODIR/$XID ;
#
ODIR="$ODIR/$XID" ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $6=1; 
          print $1,$2,$3,$4,$5,$6,$7,$8,$9;
      }
     ' $IDIR/annotation/$HSAPID/gaps/${CHR}.gff \
     > $ODIR/${CHR}_gaps.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          print $1,$2,$3,$4,$5,$6,$7,$8,$9;
      }
     ' $IDIR/annotation/$HSAPID/repeats/${CHR}.gff \
     > $ODIR/${CHR}_repeats.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $3="exon"; $6=1; print $0;
      }
     ' $IDIR/annotation/$HSAPID/refseq/${CHR}.gff \
     > $ODIR/${CHR}_refseq.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $3="exon";
          $6=1;
          gsub(/ENST0+/,"ENST",$9);
          print $0;
      }
     ' $IDIR/annotation/$HSAPID/ensembl/${CHR}.gff \
     > $ODIR/${CHR}_ensembl.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $3="exon"; $6=1; print $0;
      }
     ' $IDIR/annotation/$HSAPID/genscan/${CHR}.gff \
     > $ODIR/${CHR}_genscan.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $2="geneid";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/geneid/$XID/gff/${CHR} \
     > $ODIR/${CHR}_geneid.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $2="homology";
          $3="hsp-sr";
          $8=".";
          print $0;
      }
     ' $IDIR/sgp/20020122/hsp-sr/${CHR}.gff \
     > $ODIR/${CHR}_hsp-sr.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $2="sgp";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/sgp/20020122/gff/${CHR} \
     > $ODIR/${CHR}_sgp.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $2="homology+";
          $3="hsp-sr"; 
          $8=".";
          print $0;
      }
     ' $IDIR/sgp+/20020212/hsp-sr/${CHR}.gff \
     > $ODIR/${CHR}_hsp-sr+.gff ;
#
gawk 'BEGIN{OFS="\t"}
      ($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
          $2="sgp+";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/sgp+/20020212/gff/${CHR} \
     > $ODIR/${CHR}_sgp+.gff ;
#
cat $ODIR/${CHR}_gaps.gff    \
    $ODIR/${CHR}_repeats.gff \
    $ODIR/${CHR}_refseq.gff  \
    $ODIR/${CHR}_ensembl.gff \
    $ODIR/${CHR}_genscan.gff \
    $ODIR/${CHR}_geneid.gff  \
    $ODIR/${CHR}_hsp-sr.gff  \
    $ODIR/${CHR}_sgp.gff     \
    $ODIR/${CHR}_hsp-sr+.gff \
    $ODIR/${CHR}_sgp+.gff    \
  > $ODIR/all_${CHR}.gff
#
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{Interacting with [[MySQL]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We are going to base our job control system on a set of [[MySQL]] tables. Here we are setting up the main database, in the following subsections we are defining the database tables and the scripts to handle data within them.

<<MySQL: Creating Database Report>>=
#
# Creating mysql DataBase (root)
#
shell>  mysql -h monstre1 -u root -p   (u:user, p:passwd)
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 772 to server version: 3.23.36

Type 'help;' or '\h' for help. Type '\c' to clear the buffer

mysql> CREATE DATABASE db_Hsapiens;
Query OK, 1 row affected (0.06 sec)

mysql> show databases;
+-----------------+
| Database        |
+-----------------+
| admin_db        |
| db_Hsapiens     |
| db_SPtest       |
| ensembl_generic |
| horde           |
| mysql           |
| ontology_db     |
| popper          |
| smartie         |
| test            |
| texbiblio_db    |
| web_db          |
+-----------------+
12 rows in set (0.01 sec)

# Accession allowed only from monstre
mysql> GRANT ALL on db_Hsapiens.* TO genome@localhost IDENTIFIED BY "xxxx" ;
Query OK, 0 rows affected (0.10 sec)
# Access from anywhere in IMIM domain
mysql> GRANT ALL on db_Hsapiens.* TO "genome"@"%.imim.es" IDENTIFIED BY "xxxx" ;
Query OK, 0 rows affected (0.10 sec)
#
# Accessing to mysql DataBase (user)
#
shell>  mysql -h monstre1 -u genome -p db_Hsapiens 
#
@ 

\subsubsctn{[[db_Hsapiens.sql]]: Building database tables in [[MySQL]]}

<<MySQL: Setting up Tables>>=
/* Setting working database */
USE db_Hsapiens ;

/* Sequence related tables */
CREATE TABLE tb_chromosome
(
  id          CHAR(2)      NOT NULL,
  code        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  version     VARCHAR(50),
  descr       TEXT
);
CREATE TABLE tb_sequence
(
  id          VARCHAR(25)  NOT NULL,
  code        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  chr         INT UNSIGNED NOT NULL,
  length      INT UNSIGNED NOT NULL,
  version     CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  composition VARCHAR(150) NOT NULL,
  descr       TEXT
);

/* Process related tables */
CREATE TABLE tb_job
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT,
  path    VARCHAR(100) NOT NULL,
  jxid    VARCHAR(25)  NOT NULL
);
CREATE TABLE tb_step
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  job     INT UNSIGNED NOT NULL,
  version VARCHAR(40), /* which program and its version is being run */
  descr   TEXT,
  path    VARCHAR(100) NOT NULL,
  sxid    VARCHAR(25)  NOT NULL,
  idir    VARCHAR(200) NOT NULL,
  odir    VARCHAR(200) NOT NULL,
  edir    VARCHAR(200) NOT NULL,
  script  TEXT         NOT NULL
);

/* Execution related tables */
CREATE TABLE tb_status
(
  id      VARCHAR(10)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT,
  color   VARCHAR(30)  NOT NULL
);
CREATE TABLE tb_exec
(
  status       INT UNSIGNED NOT NULL,
  chr_seq      INT UNSIGNED NOT NULL,
  job_step     INT UNSIGNED NOT NULL,
  exec_pid     INT UNSIGNED NOT NULL,
  exec_date    CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  host         VARCHAR(15)  NOT NULL,
  user         VARCHAR(15)  NOT NULL,
  stdout       TEXT,
  stderr       TEXT
);

/* EOF */
@
<<tangling: mySQL scripts>>=
#
# MySQL tables description for db_Hsapiens
echo "# --> \$MySQLPAR/db_Hsapiens.sql" 1>&2 ;
notangle -R'MySQL: Setting up Tables' $WORK/$nwfile.nw | \
    cpif $MySQLPAR/db_Hsapiens.sql;
#
@ 
 

\subsubsctn{[[db_Hsapiens_in.pm]]: Initialitation files}

<<MySQL: initialization file for Perl scripts>>=
#
# db_Hsapiens_in.pm
#
#   setting user access to db_Hsapiens mySQL database
#
<<Version Control Id Tag>>
#
package db_Hsapiens_in;
use strict;
use vars qw( @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION
             $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw( $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );
# @@EXPORT_OK = qw( );
# %EXPORT_TAGS = ();

$mySQL_db   = 'db_Hsapiens';
$mySQL_host = 'monstre1.imim.es';
$mySQL_user = 'genome';
$mySQL_pswd = ''; # use vi to introduce the pswd for this user!!!

1;
@
<<BASH Variables: Perl>>=
#
PERL5OPT="-I$BBIN/libperl" ;
export PERL5OPT;
#
@ 


This file was tangled the first time, since then it is under version control and edited by hand...

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files
# 
# notangle -R'MySQL: initialization file for Perl scripts' \
#     $WORK/$nwfile.nw | cpif $MySQLPAR/db_Hsapiens_in.pm ;
# chmod 660 $MySQLPAR/db_Hsapiens_in.pm ;
#
@ 

The following files will serve to load rows on different tables with [[admin_db_Hsapiens.pm]].

<<MySQL: adm file - chrs>>=
#
# chrs.tbl
#
#   chromosome table
#
<<Version Control Id Tag>>
#
# Setting global version (must start with '#># ')
#
#># Golden Path 20010806
#
# Record Format:
#   <chr_id> <version> <description>
# where:
#       <version> == . --> global version
#   <description> == . --> undef
 1 . .
 2 . .
 3 . .
 4 . .
 5 . .
 6 . .
 7 . .
 8 . .
 9 . .
10 . .
11 . .
12 . .
13 . .
14 . .
15 . .
16 . .
17 . .
18 . .
19 . .
20 . .
21 . .
22 . .
 X . .
 Y . .
#
NA . .
UL . .
# UN . .
#
@  %%% MySQL: adm file - chrs

<<MySQL: adm file - seqs>>=
#
# seqs.tbl
#
#   sequences for each chromosome
#
<<Version Control Id Tag>>
#
# Record Format:
#   <chr_id> <sequence_id> <length> <file_modifying_date> <description>
# where:
#   <file_modifying_date> is in YYYYMMDDhhmmss format
#   <description> == . --> undef
# 
@  %%% MySQL: adm file - seqs

<<MySQL: adm file - jobs>>=
#
# jobs.tbl
#
#   main process id table
#
<<Version Control Id Tag>>
#
<<JOBheader: Sequence Analysis>>
<<JOBheader: Running GENEID standard>>
<<JOBheader: HsapGPa x MmusPHa WUTBLASTX>>
<<JOBheader: SGP with HSAPgpa x MMUSpha homology>>
<<JOBheader: Visualizing Results with Apollo>>
@  %%% MySQL: adm file - jobs

<<MySQL: adm file - steps>>=
#
# steps.tbl
#
#   process step (executable scripts) id table
#
<<Version Control Id Tag>>
#
@  %%% MySQL: adm file - steps
 
<<MySQL: adm file - status>>=
#
# status.tbl
#
#   program execution status table
#
<<Version Control Id Tag>>
#
# Record format:
#   <process_ID> <color_name>
#   <description-line_0>
#    ...
#   <description-line_n>
#   // # this is the new record separator
#
TODO     lightblue
Process was not started yet... 
//
RUNNING  steelblue
Current step is being executed at this moment...
//
DONE     seagreen
This step has finished without errors...
//
CHECK    orange
Process reported warnings...
Verify its execution log but following steps are going to be run...
//
KILLED   salmon
Program execution was interrupted by user... 
Following steps are being skipped...
//
DIED     red
An error ocurred when running this step...
Please, check error report that has been produced...
//
SKIPPED  gold
This step has been skipped due to a unfinished previous step... 
Please, check previous steps of the current job...
//
N/A      lightgrey
Job status is Not Available at this moment...
Just wait to the next update round to see if connection problem persist...
//
@  %%% MySQL: adm file - status

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files 
( echo "###"; echo "### PARAMETER FILES FOR H.sapiens..."; echo "###" ) 1>&2 ; 
for n in chrs jobs steps status;
  do { 
       echo "# --> \$MySQLPAR/$n.tbl" 1>&2 ;
       notangle -R"MySQL: adm file - $n" \
           $WORK/$nwfile.nw | cpif $MySQLPAR/$n.tbl ;
     }; 
  done;
# seqs.tbl is produced by initialization script on sequence analysis section
echo "# --> \$MySQLPAR/seqs.tbl" 1>&2 ;
{ notangle -R'MySQL: adm file - seqs' $WORK/$nwfile.nw ; 
  cat $HUMUS/seqid_list ; } | cpif $MySQLPAR/seqs.tbl ;
#
@ 

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/local/bin/perl -w
# This is perl, version 5.6.1 built for i386-linux
#
<<Version Control Id Tag>>
#
@ 

<<PERL strict pragma + info>>=
use strict;
#
my $PVER = sprintf("v%vd",$^V);
my $DATE = localtime;
my ($USER,$HOST);
if (defined($ENV{USER})) {
    $USER = $ENV{USER};
} else {
    chomp($USER = `whoami`);
};
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
my $host = $HOST; ###
#
@

<<Global Constants - Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@ %def $T $F


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    my $flg = shift || 0;
    push @Timer, (new Benchmark);
    # partial time 
    $flg || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % $_cntN) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % $_cntN) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Global Vars - Counter>>=
my ($n,$c,$_cntN); # counter, char and width (for &counter function)
@ %def $n $c $_cntN


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%MessageList]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($MessageList{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also requires a hash variable '[[%ErrorList]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($ErrorList{ shift @_ }, @_) }
@

\subsctn{AWK scripts}

<<GAWK shebang>>=
#!/usr/bin/gawk -f
# GNU Awk 3.0.4
<<Version Control Id Tag>>
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
@ 

<<BASH script start>>=
<<BASH shebang>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: 20010806GPaHsap-20011109SCphuMmus_lib.nw,v 1.3 2002-05-09 12:49:58 jabril Exp $
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following examples show what instructions are needed:

<<examples of tangling commands>>=
# showing line numbering comments in program
notangle -L -R"humus" $WORK/$nwfile.nw | \
   perl -ne '$.>1 && print' | cpif $BIN/humus ;
is_exec $BIN/humus ;
# reformating program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/humus ;
# html pretty-printing program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/humus.html ;
#
@ 

\begin{comment}
\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling programs>>=
echo "# TANGLING PERL MODULES:" 1>&2 ;
<<tangling: perl modules>>
echo "# TANGLING mySQL PERL SCRIPTS:" 1>&2 ;
<<tangling: mySQL perl scripts>>
echo "# TANGLING PERL SCRIPTS:" 1>&2 ;
<<tangling: perl scripts>>
echo "# TANGLING PERL TK SCRIPTS:" 1>&2 ;
<<tangling: perl Tk scripts>>
@ 
\end{comment}

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling param files>>=
echo "# TANGLING MySQL SCRIPTS:" 1>&2 ;
<<tangling: mySQL scripts>>
echo "# TANGLING MySQL PARAM FILES:" 1>&2 ;
<<tangling: mySQL param>>
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | \
    cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH script start>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH script start>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$


\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<tangling shell variables>>=
# 
# BASH Environment Variables
echo "# Running notangle on $nwfile.nw: .bash_VARS" 1>&2 ;
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
echo "# Running notangle on $nwfile.nw: .project_VARS" 1>&2 ;
notangle -R'BASH Project Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.project_VARS ;
# source $WORK/.bash_VARS ;
#
@

<<BASH Environment Variables>>=
#
# Setting Global Variables
# WORK is set by "setcwd"
WBIN="$WORK/bin" ;
WPARAM="$BIN/param" ;
WSRC="$WORK/src" ; # where to put the distributable files
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
# nwfile="humus" ;
nwfile="20010806GPaHsap-20011109SCphuMmus_lib" ;
export WBIN WPARAM WSRC DOCS DATA TEST nwfile ;
#
source $WORK/.project_VARS ;
@ 

<<BASH Project Variables>>=
#
umask 002 ;
#
BASE="/projects" ;
HBASE="$BASE/H.sapiens" ;
MBASE="$BASE/M.musculus" ;
export BASE HBASE MBASE ;
#
# Make these "six" vars independent from script (maybe join them with %HOSTS)
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806" ; HSAPSTR="20010806.UCSCgp" ; 
HSEQ="$HSAP/chromosomes" ; 
HSEQMSK="$HSAP/chromFaMasked" ; 
MMUS="/seq/genomes/M.musculus/sanger_phusion_20011109" ; # 
MMUSID="20011109" ; MMUSSTR="20011109.SCphu" ;
# MSEQ="$MMUS/" ; ????
# MSEQMSK="$MMUS/" ; ????
# 
FTPTBX="$HUMUS/.ftp/PankajAgarwal/20020111.tbx-20010806UCSCgp-20011109SCphusion" ;
FTPTBXID="20020111" ;
#
export HSAP HSAPID HSAPSTR HSEQ HSEQMSK \
       MMUS MMUSID MMUSSTR MSEQ MSEQMSK FTPTBX FTPTBXID ;
#
HUMUS="$HBASE/$HSAPSTR" ;
MUSHU="$MBASE/$MMUSSTR" ;
BBIN="/usr/local/molbio/share/sgp" ;
BIN="$BBIN/bin" ;
MySQLPAR="$BBIN/mySQL" ;
LIBPERL="$BBIN/libperl" ;
LIBSTEP="$BBIN/libstep" ;
SRC="$BBIN/src" ;
# TMP="$BBIN/tmp" ; # this is a read only system....
TMP="$HUMUS/tmp" ;
export HUMUS MUSHU BBIN BIN MySQLPAR LIBPERL LIBSTEP SRC TMP ;
#
<<BASH Variables: Perl>>
#
<<BASH Basic Shell Functions>>
<<BASH Functions: Handling large directories>>
<<BASH Functions: Get Gene Number from GENEID Output>>
#
# MkDirs $BASE/H.sapiens $HUMUS $HUMUS/bin $TMP $BASE/M.musculus $MUSHU ;
#
@ 

<<BASH Basic Shell Functions>>=
#
# BASIC Shell Functions
#
function TheEnd ()
{
  #
  # USAGE: TheEnd <STATUS_KEY>
  # PSRF is Process Status Reporter File
  if [ "$PSRF" ] ;
  then
     SCODE=`( $BIN/exit.pl $1 | tee $PSRF ) 2> /dev/null` ;
  else
     SCODE=3 ; # UNAVAILABLE
  fi ;
  exit $SCODE ;
}
#
function MkDirs ()
{
  #
  # USAGE: MkDirs <path_list>
  #
  for name in "$@" ;
    do {
         if [ -d "$name" ] ;
         then 
           echo "### Directory Already Exist: $name" 1>&2 ;
         elif mkdir $name 2> /dev/null ;
           then
             echo "### Making New Directory   : $name" 1>&2 ;
         else
           echo "### CANNOT Create Directory: $name" 1>&2 ; 
           TheEnd NONEWDIR ; 
         fi ;
      } ;
    done ;
}
#
function is_exec ()
{
  #
  # USAGE: is_exec <filename_0>...<filename_N>
  for file in $@ ;
    do {
         if [ -x $file ] ;
         then
           echo "#    Script $file has execute permissions ..." 1>&2 ;
         else
           echo "#    Setting execute permissions for $file ..." 1>&2 ;
           chmod a+x $file 2> /dev/null ;
         fi ;
      } ;
    done ;
}
#
function CheckFile ()
{
  #
  # USAGE: CheckFile <MODE(RWAE)> <filename_0>...<filename_N>
  mode="$1" ; shift ;
  case $mode in
    R|r) tst="-r" ; err="NOREADFILE"   ; msg="readable"  ;;
    W|w) tst="-w" ; err="NOWRITEFILE"  ; msg="writeable" ;;
    A|a) tst="-w" ; err="NOAPPENDFILE" ; msg="writeable" ;;
      *) tst="-e" ; err="NOFILE"       ; msg="found"     ;;
  esac; 
  for file in "$@" ;
    do {
      if [ -f $file -a $tst $file ] ;
         then
           echo "#    $file IS $msg ..." 1>&2 ;
         else
           echo "#    $file IS NOT $msg ..." 1>&2 ;
           TheEnd $err ;
         fi ;
      } ;
    done ;
}
@

<<BASH Functions: Handling large directories>>=
#
function mega ()
{
  #
  # USAGE: mega "<command> [<cmd_params>]" <input_dir> <pattern> [<output_dir>]
  # EXAMPLES:
  #           mega "mv -v" $IDIR "^chr2_" $ODIR/ori # moves all chr2_* files
  #           mega "ls -a" $IDIR "^[^.]*"           # lists all files (not .*)
  M_CMD="$1" ;
  I_DIR=`echo $2 | sed 's/\/$//'` ;
  X_PAT="$3" ;
  [ "$4" ] && O_DIR=`echo $4 | sed 's/\/$//'` || O_DIR='' ;
  ls -1 $I_DIR | egrep $X_PAT - | while read n ;
    do {
         [ "$O_DIR" ] && T_DIR="$O_DIR/$n" || T_DIR='' ;
         $M_CMD $I_DIR/$n $T_DIR ;
       } ;
    done;
}
#
@ 

<<BASH Functions: Get Gene Number from GENEID Output>>=
#
# Counting gene number found in geneid output
function get_geneid_genes ()
{
  #
  # USAGE: get_geneid_genes geneid_out.gff > gene_list.rpt
  #
  # ($1 ~ /^\#/ && $2 ~ /^Gene$/ ) { print $0 } 
  gawk '($0 !~ /^[ \t]*$/ && $1 !~ /^\#/) {
      genes[$9]++;
      if (genes[$9]>1) {
        min[$9] = $4<min[$9] ? $4 : min[$9] ;
        max[$9] = $5>max[$9] ? $5 : max[$9] ;
      } else {
        min[$9] = $4 ;
        max[$9] = $5 ;
        strand[$9] = $7;
      };
      len[$9]+=$5-$4+1
    }
    END {
      for (n in genes) {
        print n, min[n], max[n], strand[n], len[n],genes[n];
      };
    }
  ' $1 | sort +1n +2n -3 - ;
}
#
@


\subsctn{Extracting code blocks for all the scripts}

Remember to set WORK variable at the very beggining, moving into the corresponding "[[/WORK/PATH/.../]]" directory and executing [[setcwd]] (a shell function that sets [[$WORK]] and sources [[.bash_VARS]]).

<<tangling>>=
#
# tangling all .*_VARS
notangle -R'tangling shell variables' $WORK/$nwfile.nw | bash ;
source $WORK/.bash_VARS ;
cp -v $WORK/.project_VARS $HUMUS/bin/.project_VARS;
#
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
is_exec $WORK/nw2tex $WORK/ltx;
#
# tangling all param files
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling param files' $WORK/$nwfile.nw ; } | bash ;
#
# tangling all scripts
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling programs'    $WORK/$nwfile.nw ; } | bash ;
#
# tangling all steps
{ cat $WORK/.bash_VARS ;
  notangle -R'JOB COLLECTOR'        $WORK/$nwfile.nw ; } | bash ;
#
# updating LaTeX documents
$WORK/nw2tex ; $WORK/ltx ;
@ 


<<HIDE: >>=
pushd $TMP;
RM $TMP/.[eo]*/*;
$BIN/stepper.pl --debug 2> $TMP/.err/_ALL.err 1> $TMP/.out/_ALL.out
#
ipcs -s | grep jabril | gawk '{print $2}' | while read n; do ipcrm sem $n; done;
ipcs -m | grep jabril | gawk '{print $2}' | while read n; do ipcrm shm $n; done;
#
$BIN/viewstatustbl.pl | enscript -1C -Gjf Courier5 -M A4
#
# The following lines contains paths corresponding to a newer release, so they must be changed accordingly.
#
# homology results quick summary
( for n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; [ "$N" != "UN" ] && ( echo '################################################### CHR '$n' #####'; perl -ne '/^\#\s+[cT+-]/o && print' $HUMUS/chr${N}/tblastx/20020425/hsp/chr${n}.report $HUMUS/chr${N}/tblastx/20020425/sr/chr${n}.report $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/hsp-sr/chr${n}.report ); } ; done ; for  n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; { echo '########################################## CHR '$n'_random #####'; perl -ne '/^\#\s+[cT+-]/o && print' $HUMUS/chr${N}/tblastx/20020425/hsp/chr${n}_random.report $HUMUS/chr${N}/tblastx/20020425/sr/chr${n}_random.report $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/hsp-sr/chr${n}_random.report; }; } ; done ) 2>&1 | prtcode ;
# gene-pred results quick summary
( for n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; { [ "$N" != "UN" ] && ( echo '################################################### CHR '$n' #####'; echo '### GENEID'; tail -20 $HUMUS/chr${N}/geneid/20011222/logs/chr${n}.geneid | egrep 'TOTAL:|Error:|segmentation fault'; head -4 $HUMUS/chr${N}/geneid/20011222/out/chr${n} ; echo '### SGP'; tail -20 $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/logs/chr${n}.sgp | egrep 'TOTAL:|Error:|segmentation fault'; head -4 $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/out/chr${n} ); }; echo ''; } ; done ; for  n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; { echo '########################################## CHR '$n'_random #####'; echo '### GENEID'; tail -20 $HUMUS/chr${N}/geneid/20011222/logs/chr${n}_random.geneid | egrep 'TOTAL:|Error:|segmentation fault'; head -4 $HUMUS/chr${N}/geneid/20011222/out/chr${n}_random ; echo '### SGP'; tail -20 $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/logs/chr${n}_random.sgp | egrep 'TOTAL:|Error:|segmentation fault'; head -4 $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/out/chr${n}_random; }; echo ''; } ; done ) 2>&1 | prtcode ;
#
### GENE NUMBER
HUMUS="/projects/H.sapiens/20010806.UCSCgp"
# refseq
gawk '{print $1,$2}' $HUMUS/seqid_list | while read CHR SEQ; do { grep -v '^#' $HUMUS/chr$CHR/annotation/20010806/refseq/$SEQ.report | gawk 'BEGIN{ chr=ARGV[1]; ARGV[1]=""; }{ printf "%12s %8d\n", chr, $1 }' "$SEQ" - ; }; done > $HUMUS/evaluations/refseq_Phusion.genes_by_seq ;
( echo "### NUMBER OF REAL GENES ###"; echo "###-> REFSEQ from Hsap UCSC-GoldenPath assembly (20010806)"; gawk 'BEGIN{ printf "\n%12s %8s\n\n", "CHR_SEQNAME","#Genes","Score" }'; gawk '$1!~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs TOTAL\n\n", "",g; }' $HUMUS/evaluations/refseq_Phusion.genes_by_seq; gawk '$1~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs_RANDOM TOTAL\n\n", "",g; }' $HUMUS/evaluations/refseq_Phusion.genes_by_seq ) | gawk '$0~/TOTAL$/ { g+=$1 } { print $0 } END{ printf "%12s %8d  GRAND TOTAL\n", "",g; }' > $HUMUS/evaluations/refseq_Phusion.genes_by_seq.report ;
# ensembl
gawk '{print $1,$2}' $HUMUS/seqid_list | while read CHR SEQ; do { grep -v '^#' $HUMUS/chr$CHR/annotation/20010806/ensembl/$SEQ.report | gawk 'BEGIN{ chr=ARGV[1]; ARGV[1]=""; }{ printf "%12s %8d\n", chr, $1 }' "$SEQ" - ; }; done > $HUMUS/evaluations/ensembl_Phusion.genes_by_seq ;
( echo "### NUMBER OF REAL GENES ###"; echo "###-> ENSEMBL from Hsap UCSC-GoldenPath assembly (20010806)"; gawk 'BEGIN{ printf "\n%12s %8s\n\n", "CHR_SEQNAME","#Genes","Score" }'; gawk '$1!~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs TOTAL\n\n", "",g; }' $HUMUS/evaluations/ensembl_Phusion.genes_by_seq; gawk '$1~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs_RANDOM TOTAL\n\n", "",g; }' $HUMUS/evaluations/ensembl_Phusion.genes_by_seq ) | gawk '$0~/TOTAL$/ { g+=$1 } { print $0 } END{ printf "%12s %8d  GRAND TOTAL\n", "",g; }' > $HUMUS/evaluations/ensembl_Phusion.genes_by_seq.report ;
# genscan
gawk '{print $1,$2}' $HUMUS/seqid_list | while read CHR SEQ; do { grep -v '^#' $HUMUS/chr$CHR/annotation/20010806/genscan/$SEQ.report | gawk 'BEGIN{ chr=ARGV[1]; ARGV[1]=""; }{ printf "%12s %8d\n", chr, $1 }' "$SEQ" - ; }; done > $HUMUS/evaluations/genscan_Phusion.genes_by_seq ;
( echo "### NUMBER OF PREDICTED GENES ###"; echo "###-> GENSCAN from Hsap UCSC-GoldenPath assembly (20010806)"; gawk 'BEGIN{ printf "\n%12s %8s\n\n", "CHR_SEQNAME","#Genes","Score" }'; gawk '$1!~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs TOTAL\n\n", "",g; }' $HUMUS/evaluations/genscan_Phusion.genes_by_seq; gawk '$1~/random$/ { g+=$2; print $0 }END{ printf "%12s %8d  CHRs_RANDOM TOTAL\n\n", "",g; }' $HUMUS/evaluations/genscan_Phusion.genes_by_seq ) | gawk '$0~/TOTAL$/ { g+=$1 } { print $0 } END{ printf "%12s %8d  GRAND TOTAL\n", "",g; }' > $HUMUS/evaluations/genscan_Phusion.genes_by_seq.report ;
# geneid
gawk '{print $1,$2}' $HUMUS/seqid_list | while read CHR SEQ; do { head -4 $HUMUS/chr$CHR/geneid/20020225/out/$SEQ | tail -1 | gawk 'BEGIN{ chr=ARGV[1]; ARGV[1]=""; }{ printf "%12s %8d %12.3f\n", chr,$5,$9; }' "$SEQ" ; }; done > $HUMUS/evaluations/geneid_Phusion.genes_by_seq ;
( echo "# NUMBER OF PREDICTED GENES ###"; echo "###-> GENEID on Hsap UCSC-GoldenPath assembly (20010806)"; gawk 'BEGIN{ printf "\n%12s %8s %12s\n\n", "CHR_SEQNAME","#Genes","Score" }'; gawk '$1!~/random$/ { g+=$2; s+=$3; print $0 }END{ printf "%12s %8d %12.3f  CHRs TOTAL\n\n", "",g,s; }' $HUMUS/evaluations/geneid_Phusion.genes_by_seq; gawk '$1~/random$/ { g+=$2; s+=$3; print $0 }END{ printf "%12s %8d %12.3f  CHRs_RANDOM TOTAL\n\n", "",g,s; }' $HUMUS/evaluations/geneid_Phusion.genes_by_seq ) | gawk '$0~/TOTAL$/ { g+=$1; s+=$2 } { print $0 } END{ printf "%12s %8d %12.3f  GRAND TOTAL\n", "",g,s; }' > $HUMUS/evaluations/geneid_Phusion.genes_by_seq.report ;
# sgp
gawk '{print $1,$2}' $HUMUS/seqid_list | while read CHR SEQ; do { head -4 $HUMUS/chr$CHR/sgp/20020225/out/$SEQ | tail -1 | gawk 'BEGIN{ chr=ARGV[1]; ARGV[1]=""; }{ printf "%12s %8d %12.3f\n", chr,$5,$9; }' "$SEQ" ; }; done > $HUMUS/evaluations/sgp_Phusion.genes_by_seq ;
( echo "### NUMBER OF PREDICTED GENES ###"; echo "###-> SGP on Hsap UCSC-GoldenPath assembly (20010806)"; echo "###        + Mmus SC Phusion assembly (20011106)"; gawk 'BEGIN{ printf "\n%12s %8s %12s\n\n", "CHR_SEQNAME","#Genes","Score" }'; gawk '$1!~/random$/ { g+=$2; s+=$3; print $0 }END{ printf "%12s %8d %12.3f  CHRs TOTAL\n\n", "",g,s; }' $HUMUS/evaluations/sgp_Phusion.genes_by_seq; gawk '$1~/random$/ { g+=$2; s+=$3; print $0 }END{ printf "%12s %8d %12.3f  CHRs_RANDOM TOTAL\n\n", "",g,s; }' $HUMUS/evaluations/sgp_Phusion.genes_by_seq ) | gawk '$0~/TOTAL$/ { g+=$1; s+=$2 } { print $0 } END{ printf "%12s %8d %12.3f  GRAND TOTAL\n", "",g,s; }' > $HUMUS/evaluations/sgp_Phusion.genes_by_seq.report ;
# summarizing
( cat $HUMUS/evaluations/refseq_Phusion.genes_by_seq.report; echo ""; echo "";  echo ""; cat $HUMUS/evaluations/ensembl_Phusion.genes_by_seq.report ; echo ""; echo "";  echo ""; cat $HUMUS/evaluations/genscan_Phusion.genes_by_seq.report ; echo ""; echo "";  echo ""; cat $HUMUS/evaluations/geneid_Phusion.genes_by_seq.report; echo ""; echo "";  echo ""; cat $HUMUS/evaluations/sgp_Phusion.genes_by_seq.report ) > $HUMUS/evaluations/ALL_Phusion.genes_by_seq.report ;
#
enscript --columns=3 -Gjf Courier5 -M A4 $HUMUS/evaluations/ALL_Phusion.genes_by_seq.report ;
#
perl -ne 'BEGIN{ $prog="???"; print STDOUT "PROG CLASS SEQ GENES\n"; } next if /^\s+$/o; /^\#\#\#->\s+(.*?)\s+/o && ($prog=$1, next); next if /^\#/o; next unless /^\s*chr/; chomp; $_ =~ s/^\s+//o; @f=split /\s+/og; $type="ASSEMBLED"; $f[0] =~ s/_random$//o && ($type="RANDOM"); printf STDOUT "%s %s %s %s\n", $prog,$type,@f[0,1];' $HUMUS/evaluations/ALL_Phusion.genes_by_seq.report > $HUMUS/evaluations/r-plots/ALL_Phusion.genes_by_seq.tbl # | gawk '{ tots[$1]+=$4 }END{for (i in tots) print i"->"tots[i] }' 
#
function splittbls ()
{
perl -ne 'BEGIN{ $cls=shift @ARGV; } next unless $.>1; chomp; @f = split /\s+/o, $_; next unless ($f[1] eq $cls); $seq=$f[2]; $prg=$f[0]; defined($hprg{$prg}) || do { push @prog, $prg }; $hprg{$prg}++; defined($hseq{$seq}) || do { push @seqs, $seq }; $hseq{$seq}++; $genes{$seq}{$prg}=$f[3]; END{ $fmt=("\%-10s" x (scalar(@prog)+1))."\n"; printf STDOUT $fmt,"CHR",@prog; for ($n=0;$n<scalar(@seqs);$n++) { $s=$seqs[$n]; @tt=(); for ($p=0;$p<scalar(@prog);$p++) { push @tt, $genes{$s}{$prog[$p]}; }; printf STDOUT $fmt, $seqs[$n],@tt;} }' "$@"
}
splittbls "ASSEMBLED" $HUMUS/evaluations/r-plots/ALL_Phusion.genes_by_seq.tbl > $HUMUS/evaluations/r-plots/ALL_Phusion.genes_by_seq_ASM.tbl 
splittbls "RANDOM" $HUMUS/evaluations/r-plots/ALL_Phusion.genes_by_seq.tbl > $HUMUS/evaluations/r-plots/ALL_Phusion.genes_by_seq_RND.tbl 
#
# drawing histograms with R
def.par <- par()# save default, for resetting...
plot.new()
A <- read.table("/projects/H.sapiens/20010806.UCSCgp/evaluations/r-plots/ALL_Phusion.genes_by_seq_ASM.tbl", header = TRUE, row.names=1, as.is = FALSE, na.strings = "nan")
R <- read.table("/projects/H.sapiens/20010806.UCSCgp/evaluations/r-plots/ALL_Phusion.genes_by_seq_RND.tbl", header = TRUE, row.names=1, as.is = FALSE, na.strings = "nan")

postscript(file="/projects/H.sapiens/20010806.UCSCgp/evaluations/r-plots/ALL_Phusion.genes_by_seq.ps", paper="a4", horizontal=TRUE) 
# op <- par(mfrow=c(2,1)) # another way to produce a table of figures
nf <- layout(matrix(c(1,1,1,0,2,0),2,3,byrow=TRUE), widths=c(lcm(6.25),lcm(12.5),lcm(6.25),lcm(6.25),lcm(12.5),lcm(6.25)), heights=c(lcm(10.5),lcm(8.5)), respect=TRUE)
# layout.show(nf)
par(ps = 8, bg = "white", bty = "o", font = 2, font.axis = 1, cex.lab = 2, las = 2, mar = c(cm(0.75),cm(0.75),cm(0.75),cm(0.75)), mgp = c(3.25,1.5,0), adj = 0.5)
# mgp: The margin line for the axis title, axis labels and axis line. The default is c(3, 1, 0)
barplot(t(A), beside = TRUE, col = rainbow(5), ylim = c(0, 9900))
title(ylab="Number of Genes", adj = 0.5, font = 3, cex.lab = 3.5)
text(65, 9500, "H.sapiens Golden Path Assembly", font = 2, adj = 0.5, cex = 5)
text(65, 8800, "( 8 Aug, 2001 )", font = 2, adj = 0.5, cex = 3.5)
text(65, 7500, "Assembled Chromosomes", font = 2, adj = 0.5, cex = 4)
legend(102, 7250, colnames(A), col = rainbow(5), cex = 2, pch = 16)
#
barplot(t(R), beside = TRUE, col = rainbow(5), ylim = c(0, 1000))
title(ylab="Number of Genes", adj = 0.5, font = 3, cex.lab = 3.5)
text(38.5, 950, "Random Fragments", font = 2, adj = 0.5, cex = 4)
legend(4, 850, colnames(R), col = rainbow(5), cex = 2, pch = 16)
# par(op) # another way to produce a table of figures
dev.off()# closing PostScript device
par(def.par)#- reset to default
#
# gene-pred evaluation quick summary
# source $WORK/.bash_VARS ; $BIN/stepper.pl --step HSAP_GP_ANNOTATION:HSAP_GP_REFSEQ,HSAP_GP_ENSEMBL,HSAP_GP_GENSCAN,HSAP_GP_GENSCAN_EVAL --step HSAPgpa_MMUSpha_WUTBLASTX:EVALUATING_SRs --step GENEID_STD:GENEID_EVALUATION --step SGP_HSAPgpa_MMUSpha_TBX:SGP_EVALUATION  > $HUMUS/tmp/.err/_ALL_eval_t.err  2>&1 ;
#
egrep 'Error:|segmentation fault' $HUMUS/chr*/annotation/20011222/genscan/eval/chr*.genscan_*.[fr]?? ; egrep 'Error:|segmentation fault' $HUMUS/chr*/tblastx/20020425/eval/chr*.sr_*.[fr]?? ; egrep 'Error:|segmentation fault' $HUMUS/chr*/geneid/20011222/eval/chr*.geneid_*.[fr]?? ; egrep 'Error:|segmentation fault' $HUMUS/chr*/sgp/20011222.UCSCgp-20020411.MGSCv3/eval/chr*.sgp_*.[fr]?? ;
#
( for  n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; { [ "$N" != "UN" ] && ( echo '################################################### CHR '$n' #####'; echo '### GENSCAN'; cat $HUMUS/chr${N}/annotation/20011222/genscan/eval/chr${n}.summary ; echo '### SRs'; cat $HUMUS/chr${N}/tblastx/20020425/eval/chr${n}.summary ; echo '### GENEID';  cat $HUMUS/chr${N}/geneid/20011222/eval/chr${n}.summary ; echo '### SGP';  cat $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/eval/chr${n}.summary ); };  echo ''; } ; done ; for  n in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y Un ; do { N=`echo $n | tr [:lower:] [:upper:]`; { echo '################################################### CHR '$n'_random #####'; echo '### GENSCAN'; cat $HUMUS/chr${N}/annotation/20011222/genscan/eval/chr${n}_random.summary ; echo '### SRs'; cat $HUMUS/chr${N}/tblastx/20020425/eval/chr${n}_random.summary ; echo '### GENEID';  cat $HUMUS/chr${N}/geneid/20011222/eval/chr${n}_random.summary ; echo '### SGP';  cat $HUMUS/chr${N}/sgp/20011222.UCSCgp-20020411.MGSCv3/eval/chr${n}_random.summary; };  echo ''; } ; done ) 2>&1  > $HUMUS/evaluations/EVAL.summary ;
$BIN/process_eval.pl    $HUMUS/evaluations/EVAL.summary > $HUMUS/evaluations/EVAL_prog.summary ;
$BIN/process_eval.pl -t $HUMUS/evaluations/EVAL.summary > $HUMUS/evaluations/EVAL_test.summary ;
enscript -1rC -Gjf Courier5 -M A4 $HUMUS/evaluations/EVAL.summary ;
enscript -1rC -Gjf Courier5 -M A4 $HUMUS/evaluations/EVAL_prog.summary ;
enscript -1rC -Gjf Courier5 -M A4 $HUMUS/evaluations/EVAL_test.summary ;
#
#
# All files containing final stats were copied to /projects/H.sapiens/tmp/stats 
@ 

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  n <- 10
%  g <- gl(n, 100, n * 100)
%  x <- rnorm(n * 100) + sqrt(codes(g)) 
%  boxplot(split(x, g), col = "lavender", notch = TRUE)
%  title(main = "Notched Boxplots", xlab = "Group", font.main = 4,
%    font.lab = 1)
%  par(bg = "white")
%  n <- 100
%  x <- c(0, cumsum(rnorm(n)))
%  y <- c(0, cumsum(rnorm(n)))
%  xx <- c(0:n, n:0)
%  yy <- c(x, rev(y))
