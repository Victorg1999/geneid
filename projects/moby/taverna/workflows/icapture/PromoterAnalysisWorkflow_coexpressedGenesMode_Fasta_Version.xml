<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:P9SFJBEMDF9" author="Arnaud Kerhornou - akerhornou@imim.es" title="Promoter sequence of coexpressed genes analysis. This version takes FASTA sequences">The input is a set of upstream sequences in FASTA format.

It will be running MatScan to get a set of maps of putative binding sites (Transfac v6.4). Then these maps will be compared pair-by-pair by meta-alignment software. A score matrix is generated. This matrix will be used to cluster sequences using neighbour-joining clustering algorithm. finally a pretty picture (png format) is generated.

The output is:
* a set of upstream sequences in FASTA format
* a set of MatScan maps in GFF format
* a set of Meta-Alignment output (Meta-alignment specific format)
* a score matrix,
* a sequence clustering tree in newick format
* a cluster tree picture in PNG format.</s:workflowdescription>
  <s:processor name="identifier" boring="true">
    <s:stringconstant>id</s:stringconstant>
  </s:processor>
  <s:processor name="parse_moby_meta">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_matscan">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_tree">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_matrix">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="Decode_base64_to_byte">
    <s:local>org.embl.ebi.escience.scuflworkers.java.DecodeBase64</s:local>
  </s:processor>
  <s:processor name="Create_moby_data">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.CreateMobyData</s:local>
  </s:processor>
  <s:processor name="inbTreeView">
    <s:description>Viewer for Newick Trees (PNG image)</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>inbTreeView</s:serviceName>
      <s:authorityName>bioinfo.ochoa.fib.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="inbHierarchicalCluster">
    <s:description>Hierarchical clustering server for gene expression patterns</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>inbHierarchicalCluster</s:serviceName>
      <s:authorityName>bioinfo.ochoa.fib.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="generateScoreMatrix">
    <s:description>Compute similarity data, such as meta-alignment output, to produce a sequence similarity score matrix.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>generateScoreMatrix</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="fromFASTAtoDNASequenceCollection">
    <s:description>Converts a FASTA object into a collection of DNASequence moby objects</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>fromFASTAtoDNASequenceCollection</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMultiMetaAlignment">
    <s:description>Promoter regions analysis program. runMultiMetaAlignment runs Meta-alignment on a multiple mode, receiving a collection of maps, making pairs of them and, foreach pair, it produces alignments of sequences of TF binding sites. It returns the predictions in 'Meta-alignment' format. Use runMatScanGFF to produce the input GFF files</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>runMultiMetaAlignment</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMatScanGFFCollection">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. You can search for example the Transfac database, but also MEME or jaspar matrices. This service only accepts a collection of DNASequence objects and returns a collection of GFF objects (one GFF object for each DNASequence). If you want to give MatScan output to Meta-alignment program, you MUST use the 'log-likelihood matrix' mode.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFFCollection</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="add_MatScan_Threshold">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:S47NT5ONQ165" author="" title="" />
        <s:processor name="CombineMoby">
          <s:beanshell>
            <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(MobyA));
InputSource Source2 = new InputSource(new StringReader(MobyB));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document doc2=db.parse(Source2);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
NodeList nodelist2an = doc2.getElementsByTagName("moby:Simple");
NodeList nodelist2a = doc2.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
NodeList nodelist2bn = doc2.getElementsByTagName("moby:Collection");
NodeList nodelist2b = doc2.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");
NodeList nodelist2cn = doc2.getElementsByTagName("moby:Parameter");
NodeList nodelist2c = doc2.getElementsByTagName("Parameter");

// We will iterate over these lists
NodeList[] globalS={
	nodelist1an,
	nodelist1a,
	nodelist2an,
	nodelist2a
};

NodeList[] globalC={
	nodelist1bn,
	nodelist1b,
	nodelist2bn,
	nodelist2b,
	nodelist1cn,
	nodelist1c,
	nodelist2cn,
	nodelist2c
};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

// We are skipping over Collected Simples
for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalS[gi].getLength();i&lt;maxi;i++) {
		Node found=globalS[gi].item(i);
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalC[gi].getLength();i&lt;maxi;i++) {
		Node found=globalC[gi].item(i);
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

CombinedMOBY = OutObj;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/xml'">MobyA</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/xml'">MobyB</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/xml'">CombinedMOBY</s:beanshelloutput>
            </s:beanshelloutputlist>
          </s:beanshell>
        </s:processor>
        <s:processor name="CreateMOBYSecondary">
          <s:beanshell>
            <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;moby:Parameter moby:articleName=''&gt;&lt;moby:Value&gt;EMPTY&lt;/moby:Value&gt;&lt;/moby:Parameter&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";

DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource SourceSkel = new InputSource(new StringReader(skel));

Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:Parameter");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

comienzo.setAttribute("articleName",articleName);
// As the skeleton already contains a &lt;moby:Value&gt; with a TEXT_NODE,
// and it is its only child, we are going to reuse it!
comienzo.getFirstChild().getFirstChild().setNodeValue(value);

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

MobySecondary = OutObj;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">value</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/xml'">MobySecondary</s:beanshelloutput>
            </s:beanshelloutputlist>
          </s:beanshell>
        </s:processor>
        <s:processor name="ThresholdArticleName" boring="true">
          <s:stringconstant>threshold</s:stringconstant>
        </s:processor>
        <s:link source="MobyA" sink="CombineMoby:MobyA" />
        <s:link source="ThresholdArticleName:value" sink="CreateMOBYSecondary:articleName" />
        <s:link source="threshold" sink="CreateMOBYSecondary:value" />
        <s:link source="CombineMoby:CombinedMOBY" sink="MobyOutput" />
        <s:link source="CreateMOBYSecondary:MobySecondary" sink="CombineMoby:MobyB" />
        <s:source name="MobyA" />
        <s:source name="threshold" />
        <s:sink name="MobyOutput" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:link source="MatScan_Threshold" sink="add_MatScan_Threshold:threshold" />
  <s:link source="fasta_sequences" sink="Create_moby_data:stringvalue" />
  <s:link source="namespace" sink="Create_moby_data:namespace" />
  <s:link source="Create_moby_data:mobydata" sink="fromFASTAtoDNASequenceCollection:input" />
  <s:link source="add_MatScan_Threshold:MobyOutput" sink="runMatScanGFFCollection:DNASequence(Collection - 'upstream_sequences')" />
  <s:link source="fromFASTAtoDNASequenceCollection:DNASequence(Collection - 'sequences')" sink="add_MatScan_Threshold:MobyA" />
  <s:link source="parse_moby_tree:value" sink="Decode_base64_to_byte:base64" />
  <s:link source="runMatScanGFFCollection:GFF(Collection - 'matscan_predictions')" sink="runMultiMetaAlignment:GFF(Collection - 'maps')" />
  <s:link source="runMatScanGFFCollection:output" sink="parse_moby_matscan:mobydata" />
  <s:link source="runMultiMetaAlignment:output" sink="parse_moby_meta:mobydata" />
  <s:link source="runMultiMetaAlignment:text-formatted(Collection - 'meta_predictions')" sink="generateScoreMatrix:text-formatted(Collection - 'similarity_results')" />
  <s:link source="Decode_base64_to_byte:bytes" sink="Moby_Tree_png" />
  <s:link source="generateScoreMatrix:output" sink="inbHierarchicalCluster:input" />
  <s:link source="generateScoreMatrix:output" sink="parse_moby_matrix:mobydata" />
  <s:link source="identifier:value" sink="Create_moby_data:id" />
  <s:link source="inbHierarchicalCluster:Clustering(_ANON_)" sink="Moby_Newick" />
  <s:link source="inbHierarchicalCluster:output" sink="inbTreeView:input" />
  <s:link source="inbTreeView:b64_Encoded_PNG(_ANON_)" sink="parse_moby_tree:mobydata" />
  <s:link source="parse_moby_matrix:value" sink="Moby_Matrix" />
  <s:link source="parse_moby_matscan:value" sink="Moby_MatScan" />
  <s:link source="parse_moby_meta:value" sink="Moby_Meta" />
  <s:source name="namespace" />
  <s:source name="fasta_sequences" />
  <s:source name="MatScan_Threshold" />
  <s:sink name="Moby_Matrix" />
  <s:sink name="Moby_Meta" />
  <s:sink name="Moby_MatScan" />
  <s:sink name="Moby_Newick" />
  <s:sink name="Moby_Tree_png">
    <s:metadata>
      <s:mimeTypes>
        <s:mimeType>image/*</s:mimeType>
      </s:mimeTypes>
    </s:metadata>
  </s:sink>
</s:scufl>


