#!/bin/sh
######################################################################
#                               gff2ps                               #
######################################################################
#
#     Converting GFF files to PostScript.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 01.03.1999
# Last Update:
#         $Id: gff2ps,v 1.33 1999-08-02 19:42:49 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
# ( ./gff2ps -vC mygffcustomfile -- samples/data.gff > samples/.ps ) > & samples/report.
#
#

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
T_start=` time | gawk '{ split($0,ty," "); print ty[3] }' `
PRG_DIR="/home/jabril/PostScript/07_GFF2PS"
CMDLine=$0" "$*
# 
# Defining Default Values...
Defaults () {
 # 
 # Constants: 
  PROGRAM="gff2ps"
  GAWK_PROG="gff2ps.awk"
  VERSION="v0.9b"
  REVISION='$Revision: 1.33 $'
  DATERELEASE='$Date: 1999-08-02 19:42:49 $'
  PSPROGRAM="PostScript Output from gff2ps"
  AUTHOR="Josep Francesc ABRIL FERRANDO"
  EMAIL="jabril@imim.es"
  MAIL="%                  Dept. Informatica Medica
%          Institut Municipal d'Investigacio Medica
%                   C./ Doctor Aiguader 80
%                  08003 - BARCELONA (SPAIN)"
  USAGE=$PROGRAM" [-h][-H <option>] gff_file"
  COLORS="       black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white 
    verydarkseagreen | darkseagreen | seagreen | lightseagreen | verylightseagreen 
          verydarkgreen | darkgreen | green | lightgreen | verylightgreen 
 verydarklimegreen | darklimegreen | limegreen | lightlimegreen | verylightlimegreen 
      verydarkmagenta | darkmagenta | magenta | lightmagenta | verylightmagenta 
      verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue 
             verydarkblue | darkblue | blue | lightblue | verylightblue 
            verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan 
        verydarkviolet | darkviolet | violet | lightviolet | verylightviolet 
               verydarkred | darkred | red | lightred | verylightred 
        verydarkorange | darkorange | orange | lightorange | verylightorange 
        verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow 
           verydarkbrown | darkbrown | brown | lightbrown | verylightbrown"

 # 
 # Default User-Defined Options: 
  CFDIR=`pwd`;
  if [ $GFFDIR ]
    then
      if [ -d "$GFFDIR" ]                  ###### Environment variable for working directory.
        then
          CFDIR="$GFFDIR";
        fi
    fi
  bgcolor="white";
  fgcolor="black";
  v01=0; n01="load_customfile";
  v02=""; n02="customfile_name";
  if [ $GFF_CUSTOM_FILE ]         ###### Environment variable for default custom file name.
    then
      v03="$CFDIR/$GFF_CUSTOM_FILE";
    else
      v03="$CFDIR/.gff2psrc";
    fi
    n03="customfile_name_default";
  v04=0; n04="exist_default_customfile";
  v04_1=0; n04_1="create_default_customfile";
  v05=0; n05="print_report";
  v06="Landscape"; n06="page_orientation";
  v07="a4"; n07="page_size";
  v08=1; n08="page_number";
  v09=1; n09="blocks_x_page";
  v10=0; n10="nucleotides_x_line";
  v11=1; n11="show_blocks_top-bottom";
  v12="a4,595,842"; n12="page_bbox";
  v13=10; n13="major_tickmarks_num";
  v14=-1; n14="major_tickmarks_nucleotides";
  v15=10; n15="minor_tickmarks_num";
  v16=-1; n16="minor_tickmarks_nucleotides";
  v17="false"; n17="show_positions";
  v18_s='*'; v18_e='*'; n18="zoom";
  v19="FGcolor"; n19="foreground_color";
  v20="BGcolor"; n20="background_color";
  v21="default"; n21="header_style";
  v22="on"; n22="show_page_numbers";
  v23="on"; n23="show_date";
  v24="on"; n24="show_time";
  v25="default"; n25="title";
  v26="default"; n26="subtitle";
  v27="on"; n27="strand_show_forward";
  v28="on"; n28="strand_show_reverse";
  v29="on"; n29="strand_show_independent";
  v30="blue";   n30="frame0_color";
  v31="red";    n31="frame1_color";
  v32="green";  n32="frame2_color";
  v33="orange"; n33="frame_unknown_color";
# Layout Properties
  c01="1cm"; m01="margin_left"
  c02="1cm"; m02="margin_right"
  c03="1cm"; m03="margin_upper"
  c04="1cm"; m04="margin_bottom"
  c05="0.25cm"; m05="default_scale_width"
  c06="1cm";    m06="default_track_width"
  c07="0.25cm";    m07="default_track_spacing_width"
  c08="0.25cm"; m08="default_block_spacing_width"
  c09=1; m09="show_inner_scale"
  c10=1; m10="show_outer_scale"
  c11="default"; m11="header_style"
  # c11="boxed"; m11="header_style"
  c12="default"; m12="block_style"
  # c12="boxed"; m12="block_style"
  #
  # c20=$c05;   m20="text_color"
  # c21="none"; m21="label"
} # End of Defaults

#  
# Default ColorDefinition:
#
colorDef () { # still not defined seagreen and limegreen (now same as green)
cat <<'@@@COLORS@@@'
% black+grey+white
black               0.00 0.00 0.00 1.00
verydarkgrey        0.00 0.00 0.00 0.90
darkgrey            0.00 0.00 0.00 0.75
grey                0.00 0.00 0.00 0.50
lightgrey           0.00 0.00 0.00 0.25
verylightgrey       0.00 0.00 0.00 0.10
white               0.00 0.00 0.00 0.00
% magenta
verydarkmagenta     0.00 1.00 0.00 0.50
darkmagenta         0.00 1.00 0.00 0.25
magenta             0.00 1.00 0.00 0.00
lightmagenta        0.00 0.50 0.00 0.00
verylightmagenta    0.00 0.25 0.00 0.00
% violet
verydarkviolet      0.40 0.80 0.20 0.00
darkviolet          0.45 0.85 0.00 0.00
violet              0.30 0.60 0.00 0.00
lightviolet         0.15 0.55 0.00 0.00
verylightviolet     0.05 0.45 0.00 0.00
% blue
verydarkblue        1.00 1.00 0.00 0.25
darkblue            1.00 1.00 0.00 0.00
blue                0.85 0.85 0.00 0.00
lightblue           0.70 0.70 0.00 0.00
verylightblue       0.50 0.50 0.00 0.00
% skyblue
verydarkskyblue     0.95 0.15 0.00 0.40
darkskyblue         1.00 0.25 0.00 0.15
skyblue             1.00 0.25 0.00 0.00
lightskyblue        0.80 0.20 0.10 0.00
verylightskyblue    0.60 0.15 0.15 0.00
% cyan
verydarkcyan        1.00 0.00 0.00 0.50
darkcyan            1.00 0.00 0.00 0.25
cyan                1.00 0.00 0.00 0.00
lightcyan           0.50 0.00 0.00 0.00
verylightcyan       0.25 0.00 0.00 0.00
% seagreen
verydarkseagreen    0.65 0.00 0.95 0.40
darkseagreen        0.90 0.00 0.90 0.10
seagreen            1.00 0.00 1.00 0.00
lightseagreen       0.50 0.00 1.00 0.00
verylightseagreen   0.25 0.00 0.75 0.00
% green
verydarkgreen       0.65 0.00 0.95 0.40
darkgreen           0.90 0.00 0.90 0.10
green               1.00 0.00 1.00 0.00
lightgreen          0.50 0.00 1.00 0.00
verylightgreen      0.25 0.00 0.75 0.00
% limegreen
verydarklimegreen   0.65 0.00 0.95 0.40
darklimegreen       0.90 0.00 0.90 0.10
limegreen           1.00 0.00 1.00 0.00
lightlimegreen      0.50 0.00 1.00 0.00
verylightlimegreen  0.25 0.00 0.75 0.00
% yellow
verydarkyellow      0.00 0.00 1.00 0.30
darkyellow          0.00 0.00 1.00 0.10
yellow              0.00 0.00 1.00 0.00
lightyellow         0.00 0.00 0.50 0.00
verylightyellow     0.00 0.00 0.25 0.00
% orange
verydarkorange      0.00 0.60 1.00 0.00
darkorange          0.00 0.55 0.90 0.00
orange              0.00 0.50 0.70 0.00
lightorange         0.00 0.30 0.85 0.00
verylightorange     0.00 0.30 0.55 0.00
% red
verydarkred         0.00 0.90 0.90 0.30
darkred             0.00 0.80 0.90 0.10
red                 0.00 1.00 1.00 0.00
lightred            0.05 0.80 0.90 0.00
verylightred        0.15 0.40 0.60 0.00
% brown
verydarkbrown       0.00 0.85 1.00 0.70
darkbrown           0.00 0.75 1.00 0.60
brown               0.00 0.70 1.00 0.40
lightbrown          0.30 0.60 0.70 0.00
verylightbrown      0.15 0.45 0.55 0.00
@@@COLORS@@@
} # End of colorDef

#  
# Default PageSizes:
#
pagesizes () {  # Size_name Portrait_minor-axes:X Portrait_major-axes:Y
cat <<'@@@PAGESIZES@@@'
a0         2384 3370
a1         1684 2384
a2         1190 1684
a3          842 1190
a4          595  842
a5          420  595
a6          297  420
a7          210  297
a8          148  210
a9          105  148
a10          73  105
b0         2920 4127
b1         2064 2920
b2         1460 2064
b3         1032 1460
b4          729 1032
b5          516  729
b6          363  516
b7          258  363
b8          181  258
b9          127  181
b10          91  127
10x14       720 1008
executive   540  720
folio       612  936
ledger     1224  792
legal       612 1008
letter      612  792
quarto      610  780
statement   396  612
tabloid     792 1224
userdefined 595 2384
@@@PAGESIZES@@@
} # End of pagesizes

##############################################################
################### SHELL MAIN FUNCTIONS #####################
#
# Defining Help...
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo ""
  echo "NAME           $PROGRAM"
  echo "VERSION        $VERSION"
  echo ""
  echo "Creation DATE: $SHCREATION"
  echo "Last REVISION: $SHREVISION"
  echo ""
  echo "SYNOPSIS"
  echo ""
  echo "      $USAGE"
  echo ""
  echo "DESCRIPTION"
  echo ""
  echo "       This program draws color-filled DotPlots"
  echo "       from files with gff-formatted data fields."
  echo "   "
  echo ""
  echo "OPTIONS"
  echo ""
  echo "     -h  Shows this help."
  echo "     -H <option> Shows only help for the especified option."
  echo "     -v Verbose mode, a report is sent to standard error."
  echo "     -s <page_size> Useful for modifying the page size (default is a4)."
  echo "     -P <\#> Sets how many pages are needed to split your output (default is one)."
  echo "     -p Switches page orientation to Portrait (default is Landscape)."
  echo "     -B <\#> Sets blocks per page (default is one)."
  echo "     -b Blocks from left to right and from top to bottom (default is top to bottom first)."
  echo "     -N <\#> Sets nucleotides per line (default is the largest sequence position from input gff-files)."
  echo "     -S <\#> Zoom first nucleotide (default is sequence origin)."
  echo "     -E <\#> Zoom last nucleotide (default is sequence length)."
  echo "     -n Switch off labels for element positions." 
  echo "     -L Switch off Header (Title area)."
  echo "     -l Does not show page numbering."
  echo "     -O Does not show date."
  echo "     -o Does not show time."
  echo "     -T <title_string> Defining title (default is input gff filename)."
  echo "     -t <subtitle_string> Defining subtitle (default is none)."
  echo "     -w or -f Switch off displaying forward-strand(Watson) elements."
  echo "     -c or -r Switch off displaying reverse-strand(Crick) elements."
  echo "     -i Switch off displaying strand-independent elements."
  echo "     -G <color_name> Sets color for FOREGROUND (default is black)."
  echo "     -g <color_name> Sets color for BACKGROUND (default is white)."
  echo "     -0 <color_name> Sets color for frame \"0\" (default is blue)."
  echo "     -1 <color_name> Sets color for frame \"1\" (default is red)."
  echo "     -2 <color_name> Sets color for frame \"2\" (default is green)."
  echo "     -3 <color_name> Sets color for frame \".\" (default is orange)."
  echo "     -M <\#> Number of major tickmarks per line (default 10)."
  echo "     -m <\#> Number of minor tickmarks between major tickmarks (default 10)."
  echo "     -K <\#> Major tickmarks scale in nucleotides, default is nucleotide length for lines divided by major tickmarks number (see option -T)."
  echo "     -k <\#> Minor tickmarks scale in nucleotides default is major tickmarks size divided by minor tickmarks number (see option -t)."
  echo "     -d Write (or rewrite if exist) default customfile \"$v03\"."
  echo "     -D <default_custom_filename> Create a new default customfile with the given filename."
  echo "     -C <custom_filename>  Load given custom file and append to default custom file (.gff2psrc)."
  echo ""
  echo "ENVIRONMENT VARIABLES"
  echo ""
  echo "     You can specify the $PROGRAM path where it can find the default files with the shell variable GFFDIR."
  echo "     You can also define the default custom filename you will like with the variable GFF_CUSTOM_FILE, program default filename for custom file is \".gff2psrc\"."
  echo ""
  echo "COMMENTS"
  echo ""
  echo "  * Colors Defined are:"
  echo ""
  echo "$COLORS"
  echo ""
  echo "BUGS"
  echo ""
  echo "  Please, report bugs to:"
  echo "       $AUTHOR"
  echo "       e-mail: $EMAIL"
  echo "       Mail  : "
  gawk 'BEGIN{tt=ARGV[1];ARGV[1]="";gsub("\%\%","",tt);printf tt;print}' "$MAIL"
  echo ""
 return 0
} # End of Help

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1 
 echo ""
 return 0
} # End of ShowHelpLine

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing PostScript Prolog (Constants,Variables and Functions)...
MAINPSHEADER () {
gawk 'BEGIN{ 
 # Find actual date...
 "date" | getline d;
 split(d,dt," ");
 date = dt[3] "." dt[2] "." dt[6] " " substr(dt[4],1,5);
 # Finding logged user...
 "whoami" | getline usr;
 # Printing PostScript Header...
 bg=  "%%\!PS-Adobe-3.0\n";
 bg=bg"%%%%Title: %s\n";
 bg=bg"%%%%Creator: %s\n";
 bg=bg"%%%%Version: %s\n";
 bg=bg"%%%%CreationDate: %s\n";
 bg=bg"%%%%For: %s\n";
 bg=bg"%%%%Pages: (atend)\n";
 bg=bg"%%%%Orientation: %s\n";
 bg=bg"%%%%BoundingBox: 0 0 %s %s\n";
 bg=bg"%%%%EndComments\n%%\n";
 bg=bg"%% Author : %s\n";
 bg=bg"%% e-mail : %s\n";
 bg=bg"%% Mail Adress:\n%s\n%%\n";
 if (ARGV[1]!~"##dflt##") title=ARGV[1];
 else title="gff-format to PostScript";
 split(ARGV[9],bbary,",");
 printf bg, title, ARGV[2], ARGV[3], date, usr, ARGV[8], bbary[2], bbary[3], ARGV[4], ARGV[5], ARGV[6];
 printf "%% ------------------------------------------------------------------------\n";
 printf "%%                     %s\n",ARGV[7];
 printf "%% ------------------------------------------------------------------------\n";
 for (i=1;i<=9;i++) ARGV[i]="";
}' "##dflt##" "$PROGRAM" "$VERSION" "$AUTHOR" "$EMAIL" "$MAIL" "$PSPROGRAM" "$v06" "$v12"

cat <<'@@@EndProlog@@@'
% 
%    $Id: gff2ps,v 1.33 1999-08-02 19:42:49 jabril Exp $
% 
% 
%        Converting GFF files to PostScript plots.
%
%        Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                    Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%%BeginProlog
%
%%BeginProcSet: ShortNames 1.0 0
/tflg false def % test flag
/flgcrd true def % credits flag
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/in { 72    mul } bdf
%%EndProcSet:   ShortNames 1.0 0
%
%%BeginProcSet: Constants 1.0 0
% Printing Offset
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
@@@EndProlog@@@

colorDef | gawk 'BEGIN{ i=0 }
 { if ($1!="%") { count[i++]=$1; C[$1]=$2; M[$1]=$3; Y[$1]=$4; K[$1]=$5 } }
 END {
  printf "%% Fixed Color Variables (CMYK)\n";
  printf "/colordict %s dict def colordict begin %% %s colors + 28 definitions\n", (i+28), i;
  for (j=0;j<i;j++) { n=count[j]; printf "/%-20s { %-4s %-4s %-4s %-4s } def\n", n,C[n],M[n],Y[n],K[n] }
  printf "end %% colordict\n" }' -
 
pagesizes | gawk 'BEGIN{ i=0 }
 { if ($1!="%") { count[i++]=$1; X[$1]=$2; Y[$1]=$3 } }
 END{ 
  printf "%%  Paper Sizes  (in points)\n";
  printf "/pagedict %s dict def pagedict begin %% %s sizes defined\n", (i+1), i;
  for (j=0;j<i;j++) printf "/pg%-12s { %4s %4s } def\n", count[j], X[count[j]], Y[count[j]];
  printf "end %% pagedict\n%%%%EndProcSet:   Constants 1.0 0\n" }' -

} #### End of MAINPSHEADER function #### 

#
# Printing Main PostScript Routines...
MAINPSPROCS () { 
cat <<'@@@MAINProcs@@@'
%%EndProcSet:   Setting_Vars 1.0 0
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
% Defining page-elements layout.
/XSTitl pglim pop XOriTitl 2 mul sub def
/XSBlck pglim pop def
/is1tck LnFwd 0 gt LnBth 0 gt and LnFwd 0 gt LnRvs 0 gt and or LnBth 0 gt LnRvs 0 gt and or def
/is2tck LnBth 0 gt LnFwd 0 gt LnRvs 0 gt and and def % true if must plot two tickmark lines
/YSBlck { pglim exch pop FlgTitl { YSTitl YOriTitl add NBlck } { 0 NBlck 1 sub } ifelse BlckSp mul add sub NBlck div } def
/YS2Blck { pglim exch pop FlgTitl { YSTitl YOriTitl add NBlck } { 0 NBlck 1 sub } ifelse BlckSp mul add sub NBlck div FlgOS { TkMrkW 4 mul sub } if FlgIS { is1tck { TkMrkW 2 mul } if is2tck { TkMrkW 2 mul add } if sub } if } def
/XOriBlck 0 def
/YOriBlck { FlgTitl { YOriTitl YSTitl add BlckSp add } { 0 } ifelse } def
/XSPlot { XSBlck FLftLbl { XLftLbl sub } if FRgtLbl { XRgtLbl sub } if } def
/XOriPlot { XOriBlck FLftLbl { XLftLbl add } if } def
/Xscale XSPlot MaxNuclPage div def
/YSLine YS2Blck LnTot div def
/tracksize tracksize YSLine mul def
/spcrsize spcrsize YSLine mul def
/YSFwd LnFwd YSLine mul def
/YSBth LnBth YSLine mul def
/YSRvs LnRvs YSLine mul def
% /YSTck LnTck YSLine mul def
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/msg { print (\n) print flush } bdf
/F { scale } bdf
/T { translate } bdf
/S { gsave } bdf
/R { grestore } bdf
/m { moveto } bdf
/rm { rmoveto } bdf
/l { lineto } bdf
/rl { rlineto } bdf
/K { stroke } bdf
/scmyk { setcmykcolor } bdf
/slw { setlinewidth } bdf
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/ChkLimits { 3 copy pop 5 2 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or { pop false } { true } ifelse } def 
/nucdif { 2 copy exch sub } bdf
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
%/strh { S newpath 0 0 m false charpath flattenpath pathbbox exch pop exch sub exch pop R } bdf
/chrh { S newpath 0 0 m false charpath flattenpath pathbbox exch pop 3 -1 roll pop R } bdf
/strh { 2 dict begin /lly 0.0 def /ury 0.0 def { ( ) dup 0 4 -1 roll put chrh dup ury gt { /ury xdf } { pop } ifelse dup lly lt { /lly xdf } { pop } ifelse } forall ury end } bdf % lly add end } bdf
% /desc { 2 dict begin /lly 0.0 def /ury 0.0 def { ( ) dup 0 4 -1 roll put chrh pop dup lly lt { /lly xdf } { pop } ifelse } forall lly end } bdf
/stringheight  { S newpath 0 0 m (0) false charpath flattenpath pathbbox exch pop exch sub exch pop 0.95 mul R } bdf
/ct { S 0 T sfont scmyk dup stringwidth pop 2 div neg stringheight 2 div neg m show R } bdf
% X Y angle string valign halign fnt color ttxt
 % valign : tv (top)  cv (middle) bv (bottom)
 % halign : lh (left) ch (center) rh (right)
/ttxt { S scmyk sfont 8 dict begin /h xdf /v xdf /lbl xdf /angle xdf /y xdf /x xdf /hs lbl stringwidth pop neg def /vs lbl strh neg def x y T angle rotate h (rh) eq { hs } { h (ch) eq { hs 2 div } { 0 } ifelse } ifelse v (tv) eq { vs } { v (cv) eq { vs 2 div } { 0 } ifelse } ifelse m lbl show end R } bdf
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: painting_functions 1.0 0
/dotted { [ 1 ] 0 setdash } def
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll m l l l closepath } bdf
/scolor { colordict exch get exec scmyk } bdf
%
colordict begin % adding definitions and functions
 /lup { /ku xdf /yu xdf /mu xdf /cu xdf } bdf
 /lmd { /km xdf /ym xdf /mm xdf /cm xdf } bdf
 /ldn { /kd xdf /yd xdf /md xdf /cd xdf } bdf
 /load2col { lup ldn /dk ku kd sub def /dy yu yd sub def /dm mu md sub def /dc cu cd sub def } bdf
 /load3col { lup lmd ldn /uk ku km sub def /uy yu ym sub def /um mu mm sub def /uc cu cm sub def /dk km kd sub def /dy ym yd sub def /dm mm md sub def /dc cm cd sub def } bdf
 /col2 { 2 dict begin /p xdf /pcd { p mul add } bdf cd dc pcd md dm pcd yd dy pcd kd dk pcd scmyk end } bdf
 /col3 { 3 dict begin /p xdf /pcd { p 2 mul mul add } bdf /pcu { p 0.5 sub 2 mul mul add } bdf p 0.5 le { cd dc pcd md dm pcd yd dy pcd kd dk pcd } { cm uc pcu mm um pcu ym uy pcu km uk pcu } ifelse scmyk end } bdf
 /rainbow { 1 dict begin /p xdf p 0.1 le { p 0.2 div 0.5 add 1 0 0 scmyk } { p 0.4 le { 1 1 p 0.1 sub 0.3 div sub 0 0 scmyk } { p 0.6 le { 1 0 p 0.4 sub 0.2 div 0 scmyk } { p 0.8 le { 1 p 0.6 sub 0.2 div sub 0 1 0  scmyk } { 0 p 0.8 sub 0.2 div 1 0 scmyk } ifelse } ifelse } ifelse } ifelse end } bdf
end % colordict
%%EndProcSet:   painting_functions 1.0 0
%
%%BeginProcSet: header_functions 1.0 0
%
headerdict begin
 /ttfsz { YSTitl 0.65 mul } def
 /stfsz { YSTitl 0.35 mul } def
 /xtfsz { YSTitl 0.25 mul } def
 /ttlong { Title stringwidth pop SubTitle stringwidth pop 2 copy gt { pop } { exch pop } ifelse 2 div } bdf
 % /xtpsz { xtfsz 2 div } def
 /ttfnt { ttfsz /Helvetica-Bold FGcolor } def
 /stfnt { stfsz /Helvetica      FGcolor } def
 /dtfnt { xtfsz /Times-Roman    FGcolor } def
 /tmfnt { xtfsz /Times-Roman    FGcolor } def
 /pgfnt { xtfsz /Times-Roman    FGcolor } def
 /Header { S XOriTitl YOriTitl YSTitl add T 1 -1 F ShwTBx { S 0 0 XSTitl YSTitl bbox FGcolor scmyk K R } if ShwTt Title () ne and { 0.25 cm ttlong add 0 0 Title (tv) (ch) ttfnt ttxt } if ShwST SubTitle () ne and { 0.25 cm ttlong add YSTitl 0 SubTitle (bv) (ch) stfnt ttxt } if ShwTime { XSTitl 4.5 sub xtfsz 0 Sdate (tv) (rh) tmfnt ttxt } if ShwDate { XSTitl 4.5 sub YSTitl 2 div 0 Stime (cv) (rh) dtfnt ttxt } if Shwp_num { XSTitl 4.5 sub YSTitl xtfsz sub 0 PageNumber (bv) (rh) pgfnt ttxt } if R } bdf
end
%
/s_credits { S 1 dict begin /fs_cd 12 def pglim 1 cm add T 1 -1 F 0 0 0 (This poster has been obtained with gff2ps. You can get free last version at \042http:\/\/www1.imim.es/\176jabril/\042. Copyright      1999 by Josep F. Abril & Roderic Guigo) (cv) (rh) fs_cd /Times-Roman FGcolor ttxt S fs_cd /Times-Roman sfont (   1999 by Josep F. Abril & Roderic Guigo) stringwidth pop neg R 0 0 (\343) (cv) (ch) fs_cd /Symbol FGcolor ttxt end R } bdf
%
%%EndProcSet:   header_functions 1.0 0
%
%%BeginProcSet: tickmarks 1.4 0
% Rule.ps ---> rules and scales
/tmdct 22 dict def tmdct begin
 /ShowGrid 0 def % 0 - none : 1 - MinTicks : 2 - MaxTicks : 3 - Both
 /Gridup true def /Griddn true def /flgup true def
 /TkMrkHW TkMrkW  2 div def
 /TkMrkDW TkMrkW 10 div def
 /TkFont { TkMrkHW /Helvetica } def
 /MaxWidthT { S MaxNuclPage 10 string cvs TkFont sfont stringwidth pop 2 mul R } bdf
 /CheckCloser { 3 copy pop MaxWidthT sub 3 1 roll MaxWidthT add 3 1 roll dup dup 5 1 roll 3 1 roll lt 3 1 roll gt or 4 1 roll 3 copy dup 3 1 roll ne 3 1 roll ne and 5 -1 roll and { pop false } { true } ifelse } bdf
 /ctextick { S TkFont sfont dup stringheight 2 div exch stringwidth pop 2 Xscm div neg Xscm exch 2 copy neg T 2 mul exch 2 mul neg exch S 0 0 bbox BGcolor scmyk S tflg { FGcolor scmyk } if 2 slw K R fill R 0 0 m FGcolor scmyk show R } bdf
 /bltextick { S TkFont sfont dup stringwidth pop 2 Xscm div neg Xscm TkMrkHW 2 copy flgup { TkMrkDW add T } { 2 mul T 1 -1 F } ifelse exch 2 mul neg exch S 0 0 bbox BGcolor scmyk S tflg { FGcolor scmyk } if 2 slw K R fill R 0 0 m FGcolor scmyk show R } bdf
 /tonormtick { 0 eq { dup dup 0 ne { MinTick mod } if sub exch dup dup 0 ne { MinTick mod } if sub exch } { dup dup 0 ne { MaxTick mod } if sub exch dup dup 0 ne { MaxTick mod } if sub exch } ifelse } bdf
 /Mkg { 0 0 m l FGcolor scmyk dotted K } bdf
 /MkVGrid { S slw Gridup flgup not { not } if { 0 up Mkg } if Griddn flgup not { not } if { 0 down neg Mkg } if  R } bdf
 /MkAtick { slw 0 TkMrkHW neg m 0 TkMrkHW l FGcolor scmyk K } bdf
 /MkBtick { S dup Xscm 0 T ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if 1 MkAtick CheckCloser { 10 string cvs ctextick } if R } bdf
 /MkCtick { slw 0 0 m 0 TkMrkHW 3 -1 roll { TkMrkDW sub } if l FGcolor scmyk K } bdf
 /MkDtick { S dup Xscm 0 T CheckCloser { 10 string cvs bltextick } if ShowGrid 2 eq ShowGrid 3 eq or { 0.25 MkVGrid } if false 1 MkCtick R } bdf
 /baseline { S Xscm TkMrkDW m Xscm TkMrkDW l TkMrkDW 2 mul slw FGcolor scmyk K R } bdf
 /r { /Gridup true def /Griddn true def /flgup true def 0 exch TkMrkHW add T S 0 T 1 -1 F 5 { 2 copy } repeat pop neg Xscm 0 T 0 tonormtick MinTick exch { ChkLimits { S Xscm 0 T 0.25 MkAtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if R } if } for 1 tonormtick MaxTick exch { ChkLimits { MkBtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkBtick } { pop } ifelse } repeat R } bdf
 /x { 6 { 2 copy } repeat pop neg Xscm 0 T baseline 0 tonormtick MinTick exch { ChkLimits { S Xscm 0 T true 0.25 MkCtick ShowGrid 1 eq ShowGrid 3 eq or { 0 MkVGrid } if R } if } for 1 tonormtick MaxTick exch { ChkLimits { MkDtick } if } for 2 { dup dup 0 ne { MaxTick mod } if 0 ne { MkDtick } { pop } ifelse } repeat } bdf 
 /s { /Gridup false def /Griddn true def /flgup true def 0 exch TkMrkW add T S 0 T 1 -1 F x R } bdf
 /z { /Gridup true def /Griddn false def /flgup false def 0 exch T S 0 T 1 1 F x R } bdf
end % tmdct
%%EndProcSet:   tickmarks 1.4 0
%
%%BeginProcSet: objects 1.1 0
/shpdct 110 dict def shpdct begin
 /mtrx matrix def
 /LY { Yscl 0.5 mul } bdf
%
% X Y angle string valign halign fnt color ttxt
% functions for vectors-like data-sets
 /rt { tracksize strnd (.) eq { 0.975 mul } { 0.50 mul } ifelse } bdf
 /vst 250 string def
 % /clrproc colordict begin white black load2col /col2 load end def
 /clrselc { cvx exec dup 2 eq { pop load2col /clrproc /col2 load def } { dup 3 eq { pop load3col /clrproc /col3 load def } { dup 0 eq { pop white black load2col /clrproc /col2 load def } { dup 4 eq { 5 { pop } repeat /clrproc /rainbow load def } { 1 eq { white 8 4 roll load2col /clrproc /col2 load def } if } ifelse } ifelse } ifelse } ifelse } bdf % no end for closing dict because grdct must be closed by calling function
% /ov { S shpdct begin exch Xscm exch T { currentfile token { exec } { exit } ifelse } loop end R } bdf
% /v { S Xscm dup vtoffset sub exch vtoffset add 0 m 0 l clrproc exec K R } bdf
 /v { clrproc v_s 0 m v_e 0 l K /v_s v_s vstp add def /v_e v_e vstp add def } bdf
 /GetVtVar { /v_cmod xdf /v_end xdf /v_ori xdf colordict begin v_cmod clrselc rt slw } bdf
% /vt { S /VStp xdf /VWdw xdf /vstp VWdw Xscm def /v_s 0 def /v_e vstp def GetVtVar S v_ori VWdw gt { v_ori VStp 2 div sub Xscm 0 T } { VWdw 2 div VStp 2 div sub Xscm 0 T } ifelse { currentfile vst readline pop { { token { cvx exec v } { exit } ifelse } loop } stopped { exit } if } loop (Vector Loop finished...) msg R end R } bdf
 /vt { S /VStp xdf /VWdw xdf /vstp VWdw Xscm def GetVtVar /v_ini v_ori VWdw gt { v_ori VStp 2 div sub Xscm } { v_ori VWdw v_ori sub 2 div VStp 2 div sub add Xscm } ifelse def /v_s v_ini def /v_e v_ini vstp add def S { currentfile vst readline pop { { token { cvx exec v } { exit } ifelse } loop } stopped { exit } if } loop R end R } bdf % (Vector Loop finished...) msg 
 /vp { S GetVtVar v_ori 0 T { currentfile } bind loop (Position-Vector Loop finished...) msg R } bdf
%
% Functions for Shapes......
 /getfrcol { dup (.) eq { pop frmN } { dup 0 eq { pop frm0 } { dup 1 eq { pop frm1 } { 2 eq { frm2 } if } ifelse } ifelse } ifelse } bdf
 /cmdln { S 0 m sqdif 2 div neg 0 rl scmyk K R } bdf
 /lnfill { S Yscl slw sqdif cmdln sqdif 2 div cmdln R } bdf
 /frmfill { frm getfrcol rmd getfrcol lnfill } bdf
 /rnbfill { 1 dict begin S /incr sqdif 100 div def 0 incr sqdif { dup dup incr add 0 exch 0 m l dup 0 gt { sqdif div } if rainbow Yscl slw K } for R end } bdf 
 /setcolmod { cmod cvx exec dup 1 eq { pop scmyk fill } { dup 2 eq { pop lnfill } { dup 5 eq { 5 { pop } repeat frmfill } { dup 4 eq { 5 { pop } repeat rnbfill } { 0 eq { BGcolor scmyk fill } if } ifelse } ifelse } ifelse } ifelse } bdf
 /ShFsz { TkMrkW dup GpFsz 2 div gt { pop GpFsz 4 div } { 2 div } ifelse } bdf
 /ShFont { ShFsz /Helvetica } bdf 
 /postk { S 0 0 m 0 LY 0.55 mul rl 0.75 setgray 0 slw K R } bdf
 /shwpos { S Flgspos { seqori LY ScV 0 eq { 0.55 mul neg } if T sqend sqdif sqori 0 2 { S 0 T postk 10 string cvs 0 0 S strnd (-) ne { 1 -1 F 45 } { -45 } ifelse 4 -1 roll strnd (-) eq { (tv) } { (bv) } ifelse (lh) ShFont FGcolor ttxt R R } repeat } if R } bdf
% *V align:  0 center : 1 baseline : -1 reverse
 /frs { S 0.25 slw strnd (-) eq { -1 1 F } if FtV 0 eq { 0 LY sc mul 2 div neg T } { FtV -1 eq { 1 -1 F } if } ifelse colordict begin /svmtrix mtrx currentmatrix def { p_s cvx exec scmyk } stopped not { S K R clip setcolmod } if newpath end R } bdf % (Filling clipping path...) msg 
 /GetVar { /ftlbl xdf /FtV xdf /p_s xdf /cmod xdf /sc xdf /rmd xdf /frm xdf CKL nucdif /sqdif exch Xscm def /sqend xdf /seqend sqend Xscm def /sqori xdf /seqori sqori Xscm def pop /fflbl ftlbl () eq { false } { true } ifelse def /p_strk true def } bdf
 /p { S GetVar shwpos strnd (-) eq { seqend } { seqori } ifelse 0 T frs R } bdf
% Shapes......
 /cpt { sqdif LY sc mul F m { l } repeat closepath svmtrix setmatrix } bdf
 /cptc { sqdif LY sc mul F arc closepath svmtrix setmatrix } bdf
 /lft { sqdif 0 T -1 1 F } bdf
 % /cpb { fshp } bdf 
 /no_shp { stop } bdf
 /line   { 0 0 m sqdif 0 l LY sc mul slw } bdf
 /box    { 1.0 0.0 1.0 1.0 0.0 1.0 3 0.0 0.0 cpt } bdf
 /fcir   { 0.5 0.5 0.5 0 360 cptc } bdf
 /hcir   { 0.5 0.5 0.5 0 180 cptc } bdf
 /frhead { 0.75 0.0 0.75 -0.1 0.755 -0.1 1.0 0.5 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 8 0.0 0.0 cpt } bdf
 /flhead { lft frhead } bdf
 /hrhead { 1.0 0.0 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 5 0.0 0.0 cpt } bdf
 /hlhead { lft hrhead } bdf
 /frend  { 1.0 0.0 1.0 1.0 0.0 1.0 0.0 0.995 0.25 0.5 0.0 0.005 6 0.0 0.0 cpt } bdf
 /flend  { lft frend } bdf
 /hrend  { 1.0 0.0 1.0 1.0 0.0 1.0 0.0 0.995 4 0.25 0.0 cpt } bdf
 /hlend  { lft hrend } bdf
 /frsgl  { 0.75 0.0 0.75 -0.1 0.755 -0.1 1.0 0.5 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 0.0 0.995 0.25 0.5 0.0 0.005 11 0.0 0.0 cpt } bdf
 /flsgl  { lft frsgl } bdf
 /hrsgl  { 1.0 0.0 0.755 1.1 0.75 1.1 0.75 1.0 0.0 1.0 0.0 0.995 6 0.25 0.0 cpt } bdf
 /hlsgl  { lft hrsgl } bdf
 /frtgl  { 0.0 0.0 0.0 1.0 1.0 0.505 3 1.0 0.495 cpt } bdf
 /fltgl  { lft frtgl } bdf
 /hrtgl  { 0.0 0.0 0.0 1.0 2 1.0 0.0 cpt } bdf
 /hltgl  { lft hrtgl } bdf
 /fdmd   { 0.0 0.5 0.5 1.0 1.0 0.5 3 0.5 0.0 cpt } bdf
 /hdmd   { 1.0 0.0 0.5 1.0 2 0.0 0.0 cpt } bdf
 /fdtgl  { 0.0 1.0 1.0 1.0 2 0.5 0.0 cpt } bdf
%
 /prmx {  S newpath
          1.0   -0.8  0.5   -0.8  0.5   -0.25 m l l
          FGcolor scmyk 0.1 slw K 
          1.0   -0.8  0.75  -0.60 0.75  -1.0  3  1.0   -0.8 cpt
          0.01 slw S K R fill R } bdf
 /hprm {  1.0    0.0  1.0   -0.25 0.0 0.25 3 0.0 0.0 cpt prmx } bdf
 /fprm {  0.0    0.25 1.0    0.25 1.0   -0.25 3  0.0 -0.25 cpt prmx } bdf
% ......Shapes
%
% Group functions...
% /ctr { S 0 T sfont scmyk dup stringwidth pop 2 div neg stringheight strnd (-) eq { 2 div } { 1.25 mul neg } ifelse m show R } bdf
 /g_score 0.5 def
 /GpFsz { Yscl 0.5 mul 8 lt { Yscl 0.25 mul } { 8 } ifelse } def
 /GpFont { GpFsz /Helvetica } bdf
 /gshp { 0 gp_st gp_nd 0 0 g_score gcmod g_shape GpV grlbl p } bdf
 /gp_no { 4 { pop } repeat } bdf
 /gp_ln { scmyk 0.125 slw 0 0 m grdif 0 l K } bdf
 /gp_dt { dotted gp_ln } bdf
 /gp_bk { scmyk 0.25 slw 1 dict begin /tl grdif 2 div def 0 0 m S 0 -1 rl K R tl 0 rl S 0 1 rl K R tl 0 rl S 0 -1 rl K R K end } bdf
 /gp_raw { scmyk 0.25 slw strnd (-) eq { grdif 0 T -1 1 F } if 1 dict begin /tl grdif 0.05 mul def tl 0 m tl neg dup S 1 rl K R S -1 rl K R grdif tl sub 0 l S tl neg 1 rl 0 -2 rl tl 1 rl S fill R K R K end } bdf
 /gp_law { grdif 0 T -1 1 F gp_raw } bdf
 /CkGPL { dup GpFsz 2 div lt { pop GpFsz 0.55 mul } if } bdf
 /gln { S colordict begin g_line cvx exec end R } bdf
 /shgl { S grori Yscl ScV 0 eq { 0.25 mul } { 0.75 mul } ifelse T gln S grdif 2 div Yscl 0.25 mul 2 div CkGPL T strnd (-) ne { 1 -1 F } if ScV 1 eq { 1 -1 F } if Flgglbl { 0 0 0 grlbl (cv) (ch) GpFont FGcolor ttxt } if R R } bdf 
 /GetGVar { /grlbl xdf /g_line xdf /GpV xdf /g_shape xdf /gcmod xdf CKL nucdif /grdif exch Xscm def /gp_nd xdf /grend gp_nd Xscm def /gp_st xdf /grori gp_st Xscm def /Flgglbl grlbl () eq { false } { true } ifelse def } bdf
 % /g_end { end exit } bdf 
end % shpdct
%%EndProcSet:   objects 1.1 0
%
%%BeginProcSet: blocks 1.0 0
/blckdct 38 dict def blckdct begin
 /gst 250 string def
 /XLL { blckori MaxTick sub } bdf
 /XLR { blckend MaxTick add } bdf
 /CKL { 2 { dup XLL lt { pop XLL } { dup XLR gt { pop XLR } if } ifelse exch } repeat } bdf
% 
% Group Functions
 /gp { S shpdct begin GetGVar shgl gshp { currentfile token pop { exec } stopped { exit } if } loop end R } bdf % (Group Loop finished...) msg
%
% Source Functions.
 /ScFsz { Yscl 0.75 mul dup 10 gt { pop 10 } if } def
 /ScFont { ScFsz /Courier } bdf 
 /sc_no { 4 { pop } repeat } bdf
 /sc_ln { scmyk 0 slw 0 0 m XSPlot 0 l K } bdf
 /sc_dt { dotted sc_ln } bdf
 /sln { S colordict begin s_line cvx exec end R } bdf
 /sbc { -10 Yscl 2 mul neg XSPlot 10 add Yscl 1.5 mul bbox clip newpath } bdf % S K R
 /sbb { S 0 0 XSPlot Yscl bbox FlgScBx { 1 slw FGcolor scmyk K } { newpath } ifelse R sbc } bdf
 /shsll { S XLftLbl 2 div neg Yscl 2 div T strnd (-) ne { 1 -1 F } if  FLftLbl { Flgslbl { 0 0 0 srclbl (cv) (ch) ScFont FGcolor ttxt } if } if R } bdf
 /shsrl { S XSPlot XRgtLbl 2 div add Yscl 2 div T strnd (-) ne { 1 -1 F } if  FRgtLbl { Flgslbl { 0 0 0 srclbl (cv) (ch) ScFont FGcolor ttxt } if } if R } bdf
 /GetSVar { /srclbl xdf /s_line xdf /strnd xdf /FlgScBx xdf /spacer exch spcrsize mul def /Yscl exch tracksize mul def /ScV xdf /Flgslbl srclbl () eq { false } { true } ifelse def strnd (.) eq { /Y Y spacer 2 div add def } { strnd (-) eq { /Y Y Yscl spacer add add def } if } ifelse } bdf
 /source { S GetSVar XOriPlot Y T strnd (-) eq { 1 -1 F } if shsrl shsll sbb S ScV 0 eq { 0 Yscl 2 div T } { ScV 1 eq { 0 Yscl T 1 -1 F } if } ifelse sln S blckori Xscm neg 0 T } bdf
 /s_end { R R R strnd (.) eq { /Y Y Yscl add spacer 2 div add def } { strnd (+) eq { /Y Y Yscl spacer add add def } if } ifelse } bdf
%
% Block Functions.
 % /tckszH tracksize 2 div def
 /YBori TkMrkW 2 mul def
 /GetBVar { /blcknum exch 1 sub def /blckend xdf /blckori xdf /YB YOriBlck YSBlck blcknum mul add BlckSp blcknum mul add def } bdf
 /kbb { XOriBlck 5 sub -2 XSBlck 10 add YSBlck 2 add bbox FlgBkBx { 1 slw FGcolor scmyk K } { newpath } ifelse } bdf
 /tm { S tmdct begin /ShowGrid xdf exec end R } bdf
 /shwtck { YSFwd 0 gt YSFwd 0 eq YSBth 0 gt and or { /down YSFwd TkMrkW 1.5 mul add def } { /down 0 def } ifelse YSRvs 0 gt YSRvs 0 eq YSBth 0 gt and or { /up YSRvs TkMrkW 1.5 mul add def } { /up 0 def } ifelse FlgOS { blckori blckend XOriPlot 0 {s} 2 tm blckori blckend XOriPlot YSBlck TkMrkW sub {z} 2 tm } if is1tck FlgIS and { blckori blckend XOriPlot TkMrkW 3 mul YSFwd 0 gt { YSFwd add } { YSBth add } ifelse {r} 0 tm } if is2tck FlgIS and { blckori blckend XOriPlot TkMrkW 5 mul YSFwd add YSBth add {r} 0 tm } if } bdf
 /ChangeStrand {  /Y Y TkMrkW 2 mul add def } bdf
 /b_end { R end } bdf
end
%%EndProcSet:   blocks 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/block { blckdct begin GetBVar S 0 YB T kbb shwtck /Y YBori def } bdf
%
%%EndProcSet:   main_function_calls 1.0 0
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 slw
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
@@@MAINProcs@@@
} #### End of MAINPSPROCS function

##############################################################
##################### SHELL FUNCTIONS ########################
#
# Testing parameters passed by User: Colors.
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (color!~/^BG(color)?$|^FG(color)?$|^black$|^white$|^(very)?(light|dark)?(grey|(sea|lime)?green|(sky)?blue|cyan|violet|magenta|red|orange|yellow|brown)$/) {
      printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2"
      printf "              Default \" ARGV[2] \" is asigned to this option.\n" | "cat 1>&2"
      printf "              You can choose one of this colors:\n" | "cat 1>&2"
      print ARGV[3] | "cat 1>&2"
      print "" | "cat 1>&2"
      color=ARGV[2]
      }
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=""
    }' $1 $2 "$COLORS"
  return 0
} # End of CheckColor

#
# Testing parameters passed by User: Integer Numbers.
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ]
    then echo "1"; return 0
    else 
      echo "<<<<ERROR>>>> \" $1 \" is not an integer value." 1>&2
      echo "              You must especify an integer value to -$W_OPTION" 1>&2
      echo "              Program will take value from defaults..." 1>&2
      echo "" 1>&2
      echo "0";return 1
    fi
  return 1
} # End of CheckInt

#
# Testing parameters passed by User: Page Sizes.
chkpagesize () {
  pagesizes | gawk 'BEGIN{
    pg=ARGV[1]; ARGV[1]=""; ec=0 }
    { if (pg==$1) { ec=1; ps=sprintf("%s,%s,%s",$1,$2,$3) } }
    END{ if (ec) { print ps }
         else { print "a4,595,842" } }' $1 -
  return 0
} # End of chkpagesize

#
# Testing if exist a File.
ExistCustomfile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Report: Default Custom File does not exist." 1>&2
      return 0
    else echo "1" # exist_default_customfile
      echo "Warning: Default Custom File exist." 1>&2
      echo "          Custom_Filename: $1" 1>&2
      return 1
    fi
} # End of ExistCustomfile

ExistFile () {
  if [ ! -f "$1" ]
    then echo "0"
      echo "Warning: File "$1" is empty or does not exist." 1>&2
      return 1
    else echo "1" # exist_file
      echo "Report: File "$1" exist, included as a gff file." 1>&2
      return 0
    fi
} # End of ExistFile

###################################################################
################## MAIN GFF2PS SHELL SCRIPT #######################
###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
###################################################################

Defaults

#
# Checking if default custom file exists
#  else switch on flag to create.
echo "" 1>&2
echo "Report: You have typed the following command line:" 1>&2
echo "" 1>&2
echo $CMDLine 1>&2
echo "" 1>&2

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
npar=$#;
if [ $npar -eq 0 ] 
  then
    echo; echo $USAGE; echo; exit 1
  fi

#
# Asking for Help, output it to screen. 
case $1 in
  -h) Help; exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $npar -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac

#
# Processing all options and parameters passed to program.
while getopts :dD:C:vs:pP:B:bS:E:N:nT:t:G:g:LlOowfcri0:1:2:3:M:m:K:k:Hh W_OPTION
  do
    case $W_OPTION in
      H|h) Help; exit 2;;
      d) v04_1=1;;                    # create_default_customfile (.gff2psrc) or rewrite
      D) v04_1=1;                     # create_default_customfile or rename_it if exist
         v03="$CFDIR/$OPTARG";;
      C) if [ ! -f $CFDIR/$OPTARG ];    # load_customfile customfile_name
           then v01=0;
             echo "Error: Custom File $OPTARG does not exist...Not Loaded." 1>&2 ;
           else v01=1;
	         echo "Report: Adding $OPTARG Custom File to Default Custom File." 1>&2 ;
             v02="$CFDIR/$OPTARG";
           fi;;
      v) v05=1;;                        # print_report
      s) v07=$OPTARG;                   # page_bbox
         v12=`chkpagesize $v07`;;  
      p) v06="Portrait";;               # page_orientation
      P) if [ `CheckInt $OPTARG` ]
           then
             v08=$OPTARG;
           fi;;                  # page_number
      B) if [ `CheckInt $OPTARG` ]
           then
             v09=$OPTARG;
           fi;;                  # blocks_x_page
      b) v11=0;;                      # show_blocks_top-bottom
      S) if [ `CheckInt $OPTARG` ]
           then
             v18_s=$OPTARG;
           fi;;                  # zoom_begin
      E) if [ `CheckInt $OPTARG` ]
           then
             v18_e=$OPTARG;
           fi;;                  # zoom_end
      N) if [ `CheckInt $OPTARG` ]
           then
             v10=$OPTARG;
           fi;;                  # nucleotides_x_line
      n) v17="true";;           # show_positions
      G) v19=`CheckColor $OPTARG $fgcolor`;;    # foreground_color
      g) v20=`CheckColor $OPTARG $bgcolor`;;    # background_color
      L) v21="none";;          # header_style
      l) v22="off";;           # show_page_numbers
      O) v23="off";;           # show_date
      o) v24="off";;           # show_time
      T) v25=$OPTARG;;        # title
      t) v26=$OPTARG;;        # subtitle
      w|f) v27="off";;        # strand_show_forward
      c|r) v28="off";;        # strand_show_reverse
      i) v29="off";;          # strand_show_independent
      0) v30=`CheckColor $OPTARG $fgcolor`;;  # frame0_color
      1) v31=`CheckColor $OPTARG $fgcolor`;;  # frame1_color
      2) v32=`CheckColor $OPTARG $fgcolor`;;  # frame2_color
      3) v33=`CheckColor $OPTARG $fgcolor`;;  # frame_unknown_color
      M) if [ `CheckInt $OPTARG` ]
           then
             v13=$OPTARG;
           fi;;                  # major_tickmarks_num
      m) if [ `CheckInt $OPTARG` ]
           then
             v15=$OPTARG;
           fi;;                  # minor_tickmarks_num
      K) if [ `CheckInt $OPTARG` ]
           then
             v14=$OPTARG;
           fi;;                  # major_tickmarks_nucleotides
      k) if [ `CheckInt $OPTARG` ]
           then
             v16=$OPTARG;
           fi;;                  # minor_tickmarks_nucleotides
       :) ShowHelpLine $1; exit 2;;
      \?) ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts
# Done GetOpts

#
# Shifting all options tested before,
# without removing files passed to shell...
 incr=1
 while [ $OPTIND -gt $incr ]
   do shift; incr=`expr $incr + 1`; done

 GFF_INPUT_FILES=""; ck=0; hmf=0;
if [ $npar -ge $OPTIND ]
 then
 for files in $@
   do
     if [ `ExistFile ./$files` ]  # $CFDIR/
       then 
         if [ $ck -eq 1 ] 
           then
              GFF_INPUT_FILES=$GFF_INPUT_FILES" "
           fi
         GFF_INPUT_FILES=$GFF_INPUT_FILES./$files;  # $CFDIR/
         shift; ck=1;
         hmf=`expr $hmf + 1`;
       fi;
   done;
 fi
 if [ $hmf -eq 0 ]
   then
     echo "WARNING: You have not passed any gff_file to program, it will create an empty page..." 1>&2;
     if [ "$v18_e" = '*' ] 
       then
         v18_e=1000;
       fi;
   fi;

#
# Defining PLOToptions STRING for GNU awk programs.
 v04=`ExistCustomfile "$v03"`
 v18="$v18_s..$v18_e"
   P="BACKGROUND_COLOR:="$bgcolor"::FOREGROUND_COLOR:="$fgcolor"::"$n04_1":="$v04_1"::"
 P=$P$n01":="$v01"::"$n02":="$v02"::"$n03":="$v03"::"$n04":="$v04"::"$n05":="$v05"::"
 P=$P$n06":="$v06"::"$n07":="$v07"::"$n08":="$v08"::"$n09":="$v09"::"$n10":="$v10"::"
 P=$P$n11":="$v11"::"$n12":="$v12"::"$n13":="$v13"::"$n14":="$v14"::"$n15":="$v15"::"
 P=$P$n16":="$v16"::"$n17":="$v17"::"$n18":="$v18"::"$n19":="$v19"::"$n20":="$v20"::"
 P=$P$n21":="$v21"::"$n22":="$v22"::"$n23":="$v23"::"$n24":="$v24"::"$n25":="$v25"::"
 P=$P$n26":="$v26"::"$n27":="$v27"::"$n28":="$v28"::"$n29":="$v29"::"$n30":="$v30"::"
 P=$P$n31":="$v31"::"$n32":="$v32"::"$n33":="$v33"::"
 P=$P$m01":="$c01"::"$m02":="$c02"::"$m03":="$c03"::"$m04":="$c04"::"$m05":="$c05"::"
 P=$P$m06":="$c06"::"$m07":="$c07"::"$m08":="$c08"::"$m09":="$c09"::"$m10":="$c10"::"
 P=$P$m11":="$c11"::"$m12":="$c12"::"
 P=$P"DCF:=$CFDIR/.gff2psrc::InputFNs:="$GFF_INPUT_FILES
 PLOToptions=$P
 if [ $v05 -eq 1 ]
   then
     echo "" 1>&2
     echo "********************************************" 1>&2
     echo ">>>>> Option String Passed to Program <<<<<<" 1>&2
     echo "********************************************" 1>&2
     echo "" 1>&2
     echo $PLOToptions 1>&2
     echo "" 1>&2
   fi

#
# Printing PostScript HEADER.
MAINPSHEADER

#
# MAIN GFF2APLOT PROGRAM:
#   Processing gff files and converting to PostScript.
(echo "$PLOToptions"; MAINPSPROCS) |
gawk -F'\t' -f $PRG_DIR/$GAWK_PROG - $GFF_INPUT_FILES
#### Main GFF2APLOT GNU awk Program DONE ####

#
##################### EOF #####################
T_end=` time | gawk '{ split($0,ty," "); print ty[3] }' `
gawk 'BEGIN{
  t1=ARGV[1];t2=ARGV[2];ARGV[1]=ARGV[2]="";
  split(t1,tt1,":");split(t2,tt2,":");
  printf "\n###################\nGFF2PS Execution Time\n###################\n" | "cat 1>&2";
  printf "> Program started  at: %s\n",t1 | "cat 1>&2"; 
  printf "> Program finished at: %s\n",t2 | "cat 1>&2";
  if (tt2[3]<tt1[3]) { s=(tt2[3]+60)-tt1[3]; am=1 }
    else { s=tt2[3]-tt1[3]; am=0 };
  if (tt2[2]<(tt1[2]-am)) { m=(tt2[2]+60)-tt1[2]-am; ah=1 }
    else { m=tt2[2]-tt1[2]-am; ah=0 };
  h=tt2[1]-tt1[1]-ah;
  printf ">>>>>> Execution time: %s:%s:%s\n",h,m,s | "cat 1>&2";
  printf "\n###################\n" | "cat 1>&2";
  }' $T_start $T_end
exit 0
