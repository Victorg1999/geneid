% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: sim2gff.nw,v 1.3 2003-02-28 17:24:52 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}
%
<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
  \item[$\triangleright$] [\textit{Section}~\ref{#2}, 
                           \textit{page}~\pageref{#2}]\\ {#1}
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Bioinformatics Research Lab}}
\def\progname{blat2gff.pl}
\def\tit{\textsc{\progname}}
%
\def\mtjabril{
 \htmladdnormallink{\texttt{jabril@imim.es}}
                   {MAILTO:jabril@imim.es?subject=[sim2gff]}
 } % def mtjabril
\def\mttwiehe{
 \htmladdnormallink{\texttt{twiehe@zedat.fu-berlin.de}}
                   {MAILTO:twiehe@zedat.fu-berlin.de?subject=[sim2gff]}
 } % def mtjabril
%
\def\authorslist{
 Thomas Wiehe {\mdseries\small\dotfill \mtjabril } \\
 Josep F. Abril {\mdseries\small\dotfill \mtjabril } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Wiehe, T; Abril, JF % Other authors here...
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
Converting SIM output to GFF
 } % def progdesc 
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\def\tit{\textsc{\progname}}
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\tit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
@ 
<<HIDE: new LaTeX definitions>>=
@ 
<<HIDE: new defs TODO>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\begin{bfseries}
\begin{large}
\newlength{\lttbl}\setlength{\lttbl}{0.25\linewidth}
\newlength{\rttbl}\setlength{\rttbl}{0.70\linewidth}
%\fbox{
%\vskip 2ex
\begin{tabular}{>{\scshape}r@{\quad}l}
\rule{\lttbl}{0pt} & \rule{\rttbl}{0pt} \\[2ex]
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
Program Name: & {\Huge\progname}                       \\[3ex]
\multicolumn{2}{c}{\rule[0.5ex]{0.95\linewidth}{2pt}}\\[2ex]
      Author: & {\Large
                 \begin{minipage}[t]{0.95\rttbl}
                 \authorslist
                 \end{minipage}}                       \\[2ex]
     License: & {\license}                             \\[2ex]
 Last Update: & {\today}                               \\[2ex]
 Description: & {\large\mdseries
                 \begin{minipage}[t]{0.95\rttbl}
                 \progdesc
                 \end{minipage}}                       \\[2ex]
\\
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
\end{tabular}
%} % fbox
\end{large}
\end{bfseries}
\end{center}

\vfill

\begin{raggedleft}
\showaffiliation
\end{raggedleft}

\end{titlepage} %'

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: sim2gff.nw,v 1.3 2003-02-28 17:24:52 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{Program description}

\subsctn{Input}


\subsctn{Output}

% \subsctn{Comments}

\subsctn{To Do}

\begin{itemize}
 \input todo.tex
\end{itemize}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Implementation}

<<Program Info>>=
my $PROGRAM = 'sim2gff.pl';
my $VERSION = '1.0';
@ 

<<Program Description>>=
# ##################################################################
# #                          sim2gff.pl                            #
# ##################################################################
# 
#         sim2gff.pl [options] < inputfile > outputfile
#
#       Converts SIM output files to GFF formatted files.
# 
#     Copyright (C) 1999-2003 --         Thomas WIEHE
#                                        Steffi GEBAUER-JUNG
#                                Josep Francesc ABRIL FERRANDO  
@ 

\subsctn{Program outline}

<<sim2gff>>=
<<PERL shebang>>
#
# MODULES
#
<<Use Modules>>
#
# VARIABLES
#
<<Global Vars>>
#
# MAIN LOOP
#
<<Main Loop>>
#
# FUNCTIONS
#
<<Functions>>
@ 

<<Use Modules>>=
use Carp;
use Getopt::Std;
use File::Basename;
@

<<Global Vars>>=
#
use vars qw($opt_r $opt_x $opt_y $opt_H $opt_f $opt_h);
#
my $columns     = 50;
#
my ($simfile,$outfile,$command,$alicount);
my @scorearray;
my $i;
my @tmp = 0;
my %sim;
#*****
my $_array;
my @list;
my ($line,$score,$species1,$species2,
    $method,$strand,$feature,$avlen,
    $nmp,$begin1,$begin2,$end1,$end2,
    $x1frame,$x2frame,$y1frame,$y2frame);
my $flag = "";
my $linemark;
my $lav;
#
@

<<Main Loop>>=
#
# Man page
#
my $MAN = <<MAN;
NAME

     	$PROGRAM $VERSION

    Converts SIM file into GFF formatted records
    (for use with gff2aplot and gff2javaplot).

AVAILABILITY

     	Requires perl 5.002

SYNOPSIS

    	$PROGRAM [-frxyHh] sim_file > gff_file

OPTIONS

     -h         print this help text
     -f		output is written to a file named <sim_file>.gff
     -r		interchange the order of sequences (Seq1 on y-axis, Seq2 on x-axis)
     -x	<name>  specify the species name for species1 (default: "Seq1")
     -y	<name>  specify the species name for species2 (default: "Seq2")
     -H 	use the fasta file headers for species labels

EXIT STATUS

     The following perl-like exit status are returned:

     0        Error
     1        Successful completion
 
AUTHOR(S)

     Thomas Wiehe  (twiehe\@imb-jena.de)

CHANGES

     30.04.1999	Steffi Gebauer-Jung (steffi\@imb-jena.de)
     - output strand according new gff format as "+" or "-" instead of 0 or 1	

ACKNOWLEDGMENTS

MAN
#
getopts('frx:y:Hh') && ! defined($opt_h) && $#ARGV==0 || croak($MAN);
$simfile = shift;
#
sub max(){
	my $a = shift;
	my $b = shift;

	if($a>$b){
		return $a;
	}else{
		return $b;
	}
}
#
##count the number of alignments:
#
$command = sprintf("more %s | grep \"a\ {\" | wc -l |",$simfile);
open(PRG,"$command")||croak(sprintf("Cannot count alignments (ERRMSG = %s)\n",$!));
while(<PRG>){
	if(/\b[0-9]+/){
		$alicount = (split)[0];
	}
}
close(PRG);
#
##sort the encountered score values and store in array scorearray:
#
$command = sprintf("more %s | grep \"\ \ s\ \" | ",$simfile);
open(PRG,"$command")||croak(sprintf("Cannot sort alignment scores (ERRMSG = %s)\n",$!));
$i=0;
while(<PRG>){
	if(/\bs\ [0-9]+/){
	 chomp;
	 $i++;
         $tmp[$i] = (split)[1];
	} 
}
close(PRG);
@scorearray = sort { $a <=> $b } @tmp;
#
-e $simfile                    
    	or croak(sprintf("Cannot find %s file (ERRMSG = %s)",$simfile,$!));
open(SIMFILE,"< $simfile")     
    	or croak(sprintf("Cannot open %s file for reading (ERRMSG = %s)",$simfile,$!));
if(defined($opt_f)){
 #@tmp = split(".sim",$simfile);
 #$outfile = sprintf("%s%s",(split(/\//,$tmp[0]))[-1],".gff");
 $outfile = sprintf("%s%s",(split(/\//,$simfile))[-1],".gff");
 open(STDOUT,"> $outfile")
      or croak(sprintf("Cannot open %s file for writing (ERRMSG = %s)",$outfile,$!));
}
$lav=0;
$line=0;
$linemark=0;
printf STDOUT ("## Alignments from sim file %s\n",$simfile);
while(<SIMFILE>){
 chomp;
 $line++;
 if(/^\#\:lav/){
 	$lav++;
 }
 if(/^d\ \{/){	
     $linemark=$line;
     $flag="d";
 }
 if ($line==$linemark+1 && $flag=~"d") {
        @list=split(/\"/,$_);
	@list=split(/\ /,$list[1]);
	@list=split(/\//,$list[0]);
	$method=$list[-1];
	#printf("method: %s\n",$method);
 }
 $species1="Seq1";
 $species2="Seq2";
 if(defined($opt_x)){
   $species1=$opt_x;
 }
 if(defined($opt_y)){
   $species2=$opt_y;
 }
 if(defined($opt_H)){
     if(/^h\ \{/){
      $linemark=$line;
      $flag="h";
     }
     if ($line==$linemark+1 && $flag=~"h") {
        @list=split(/>|\ |\.+/,$_);
	$species1=$list[1];
	#printf("species1: %s\n",$species1);
     }
     if ($line==$linemark+2 && $flag=~"h") {
        @list=split(/>|\ |\.+/,$_);
	$species2=$list[1];
     }
 }
 if(/^s\ \{/){
     $linemark=$line;
     $flag="s";
 }
 if ($line==$linemark+1 && ($flag =~ "s")) {
       @list=split;
       $x1frame=$list[1];
       $x2frame=$list[2];
       #printf("x1: %d\n",$x1frame);
 }
 if ($line==$linemark+2 && ($flag =~ "s")) {
       @list=split;
       $y1frame=$list[1];
       $y2frame=$list[2];
       $feature = "seqbounds";
       if(!defined($opt_r)){
        printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s\n",
                  uc($species1),uc($species2),uc($method),$feature,$x1frame,$y1frame,
                  $x2frame,$y2frame,"0.0","+","0","0","##");
       }else{
        printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s\n",
                  uc($species2),uc($species1),uc($method),$feature,$y1frame,$x1frame,
                  $y2frame,$x2frame,"0.0","+","0","0","##");
       }
 }
 if(/^a\ \{/) {
 	$flag="a";
        $nmp=0.0;
 }
 if($flag=~"a"){
	    if ( /^(\s*)s/ ) {
	     @list = split;
	     $score = $list[1];
	     $i=0;
	     while($score!=$scorearray[$i]){$i++;}
	     $feature=sprintf("\:%.1f",&max(1.-($alicount-$i)/10.,0.4));
	     $score .= $feature;
	     $feature = "align";
	    }
	    if ( /^(\s*)b/ ) {
             @list = split;
             $begin1 = $list[1];
	     $begin2 = $list[2];
            }
	    if ( /^(\s*)e/ ) {
             @list = split;
             $end1 = $list[1];
             $end2 = $list[2];
	     $avlen = (abs($end1-$begin1+1)+abs($end2-$begin2+1))/2.;
            }
            if ( /^(\s*)l/ ) {
                @list = split;
		if(($list[1]>$list[3]&&$list[2]<=$list[4])||($list[1]<=$list[3]&&$list[2]>$list[4])||$lav==2){
			$strand="-"; #"reverse alignment"
		}else{
			$strand="+"; #"regular alignment"
		}
		$nmp += abs($list[3]-$list[1]+1.)*$list[5]/($avlen*100.);
		if($lav==1){
		 if(!defined($opt_r)){
		  printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s%.3f\n",
		   uc($species1),uc($species2),uc($method),$feature,$list[1],$list[2],
		   $list[3],$list[4],$list[5]/100.,$strand,"0",$score,"## cumulative nmp: ",$nmp); #slot "frame" is not used
		 }else{
		  printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s%.3f\n",
		   uc($species2),uc($species1),uc($method),$feature,$list[2],$list[1],
		   $list[4],$list[3],$list[5]/100.,$strand,"0",$score,"##cumulative nmp: ",$nmp); #slot "frame" is not used
		 }
		}
		if($lav==2){
		 if(!defined($opt_r)){
		  printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s%.3f\n",
		   uc($species1),uc($species2),uc($method),$feature,$list[1],$y1frame+$y2frame-$list[2],
		   $list[3],$y1frame+$y2frame-$list[4],$list[5]/100.,$strand,"0",$score,"## cumulative nmp: ",$nmp); #slot "frame" is not used
		 }else{
		  printf STDOUT ("%s:%s\t%s\t%9s\t%9d:%-9d\t%9d:%-9d\t%.3f\t%s\t%d\t%s\t%s%.3f\n",
		   uc($species2),uc($species1),uc($method),$feature,$y1frame+$y2frame-$list[2],$list[1],
		   $y1frame+$y2frame-$list[4],$list[3],$list[5]/100.,$strand,"0",$score,"##cumulative nmp: ",$nmp); #slot "frame" is not used
		 }
		}
            }
	    if ( /^\}/ ) {
	    	$flag="";
	    }	    
 }
}
close(STDOUT)
        or croak(sprintf("Cannot close %s file (ERRMSG = %s)",$outfile,$!));	
exit(0);
@

<<Functions>>=
@

\begin{comment}
%% \label{todo:AAA}
%%%%<HIDE: new defs TODO>>=
%% \def\todoAAA{This is a first draft of the {\progname}.} % todoAAA
%% @
%%%%<HIDE: TODO>>=
%% \todoitem{\todoAAA}{todo:AAA}
%% @
%% \todo{
%%  \item \todoAAA
%%  } % todo
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{empty appendix section}

\subsctn{empty appendix subsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
#
<<Program Description>>
#
<<GNU License>>
#
<<Version Control Id Tag>>
#
use strict;
#
<<Program Info>>
my $DATE = localtime;
my $USER = defined($ENV{USER}) ? $ENV{USER} : 'Child Process';
my $host = `hostname`;
chomp($host);
#
@

<<Global Constants - Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@ %def $T $F


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.

<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Global Vars - Counter>>=
my ($n,$c); # counter and char (for &counter function)
@ %def $n $c


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%MessageList]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($MessageList{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also requires a hash variable '[[%ErrorList]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($ErrorList{ shift @_ }, @_) }
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: sim2gff.nw,v 1.3 2003-02-28 17:24:52 jabril Exp $
@ 

\subsctn{GNU General Public License}

<<GNU License>>=
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# ##################################################################
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"sim2gff" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' | cpif $BIN/$nwfile.test.pl ;
chmod a+x $BIN/$nwfile.pl ;
@ 

<<tangling>>=
# reformating program with perltidy
notangle -R"sim2gff" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/$nwfile.pl ;
# html pretty-printing program with perltidy
notangle -R"sim2gff" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/$nwfile.html ;
#
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
chmod a+x $WORK/nw2tex $WORK/ltx;
@ 

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH shebang>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
#
# Setting Global Variables
# WORK is now set via setcwd
BIN="$WORK/bin" ;
PARAM="$BIN/param" ;
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
nwfile="sim2gff" ;
export WORK BIN PARAM DOCS DATA nwfile ;
#
@ 

<<tangling>>=
# 
# BASH Environment Variables
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
source $WORK/.bash_VARS ;
#
@

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
