% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% $Id: gff2aplot.nw,v 1.28 2001-12-07 18:38:50 jabril Exp $
%
\usepackage{noweb}
% noweb options
\noweboptions{smallcode,shortxref}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %
%
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
%\usepackage{colortbl}
\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
\usepackage{dcolumn}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
%\usepackage{fancyheadings}
%\usepackage{fancybox}
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
\usepackage{verbatim}
%\usepackage{version}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}
 
\input defs.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\ \vfill
%%\begin{center}
%%\textbf{\Huge A perl development for {\prog}}\\[5ex]
%%
%%\textbf{\Large Josep F. Abril}\raisebox{0.85ex}{\footnotesize$\,\dag$}\\[5ex]
%%
%%\textbf{\large --- \today ---}\\[10ex]
%%
%%\begin{abstract}
%%\begin{center}
%%\parbox{0.75\linewidth}{
%%I am trying to improve some aspects of the {\prog} utility that may be hard to solve in its old [[GNUawk]] format. Taking advantage of some capabilities of [[Perl]], such implemented quicksort sorting algorithm and the posibility of building complex data structures, will make the program faster and easier to maintain. Using [[noweb]] I pretend to improve the overall design and to open the code to other developers.
%%} % parbox
%%\end{center}
%%\end{abstract}\vskip 5ex
%%{\large$<$ \verb$Id: gff2aplot.nw,v 1.28 2001-12-07 18:38:50 jabril Exp $$>$ }
%%
%%\vfill
%%
%%\begin{flushright}
%%\scalebox{0.9 1}{\Large\textsl{\textbf{Genome Informatics Research Lab}}}\\
%%Grup de Recerca en Infom\`atica Biom\`edica\\
%%Institut Municipal d'Investigaci\'o M\`edica\\
%%Universitat Pompeu Fabra\\[2ex]
%%\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: \mtjabril}\\
%%\end{flushright}
%%\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

<<HIDE: LaTeX aplot new definitions>>=
%%%%% Colors for gff2ps
\input tables/AplotColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\subsubsubsctn}[1]{\paragraph{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\pa}[1]{{\footnotesize\textsf{$<$\textsl{#1}$>$}}}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
\item[$\triangleright$] [\textit{Section}~\ref{#2}, \textit{page}~\pageref{#2}]\\
              #1
} % newcommand todoitem
<<HIDE: new LaTeX commands>>
 
%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es}}
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\prog{\textsc{\textbf{gff2aplot}}}
\def\gps{\textsc{\textbf{gff2ps}}}
\def\gft{\textsc{\textbf{gfftools}}}
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
\def\eoline{$\backslash\backslash$}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\progname{gff2aplot.pl}
\def\tit{\textsc{\progname}}
%
\def\mtjabril{
 \htmladdnormallink{\texttt{jabril@imim.es}}
                   {MAILTO:jabril@imim.es?subject=[gff2aplot]}
 } % def mtjabril
\def\mttwiehe{
 \htmladdnormallink{\texttt{twiehe@ice.mpg.de}}
                   {MAILTO:twiehe@ice.mpg.de?subject=[gff2aplot]}
 } % def mttwiehe
\def\mtrguigo{
 \htmladdnormallink{\texttt{rguigo@imim.es}}
                   {MAILTO:rguigo@imim.es?subject=[gff2aplot]}
 } % def mtrguigo
%
\def\authorslist{
 Josep F. Abril   {\mdseries\small\dotfill \mtjabril } \\
 Thomas   Wiehe   {\mdseries\small\dotfill \mttwiehe } \\
 Roderic  Guig\'o {\mdseries\small\dotfill \mtrguigo } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF; Wiehe, T; Guig\'o, R % Other authors here...
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
{\prog} is a tool to visualize the alignment of two genomic sequences together with their annotations. Input to the program are single or multiple files in General Feature Format (GFF). Output is in PostScript format so the program serves to generate scalable print-quality images for comparative genomics sequence analysis.
 } % def progdesc 
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

@

<<HIDE: new LaTeX pstricks>>=
@
<<HIDE: new LaTeX definitions>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\begin{bfseries}
\begin{large}
\newlength{\lttbl}\setlength{\lttbl}{0.25\linewidth}
\newlength{\rttbl}\setlength{\rttbl}{0.70\linewidth}
%\fbox{
%\vskip 2ex
\begin{tabular}{>{\scshape}r@{\quad}l}
\rule{\lttbl}{0pt} & \rule{\rttbl}{0pt} \\[2ex]
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
Program Name: & {\Huge\progname}                       \\[3ex]
\multicolumn{2}{c}{\rule[0.5ex]{0.95\linewidth}{2pt}}\\[2ex]
     Authors: & {\Large
                 \begin{minipage}[t]{0.95\rttbl}
                 \authorslist
                 \end{minipage}}                       \\[2ex]
     License: & {\license}                             \\[2ex]
 Last Update: & {\today}                               \\[2ex]
 Description: & {\large\mdseries
                 \begin{minipage}[t]{0.95\rttbl}
                 \progdesc
                 \end{minipage}}                       \\[2ex]
\\
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
\end{tabular}
%} % fbox
\end{large}
\end{bfseries}
\end{center}

\vfill

\begin{raggedleft}
\showaffiliation
\end{raggedleft}

\end{titlepage}

%'%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage

\thispagestyle{empty}

\ % \vfill
% \hrulefill

\newpage
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\textbf{\prog}\hspace{4ex}\thesection.\ #1}} 
\renewcommand{\subsectionmark}[1]{\markboth{}{\textbf{\prog}\hspace{4ex}\thesubsection.\ \textsl{#1}}}

\tableofcontents

\clearpage

\listoftables

\listoffigures

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\label{todo:AAZ}
<<HIDE: new defs TODO>>=
\def\todoAAZ{Cite here Vista, PiP-maker, Dotter and other dotplot tools.} % todoAAZ
@
<<HIDE: TODO>>=
\todoitem{\todoAAZ}{todo:AAZ}
@
\todo{ \item \todoAAZ } % todo

<<HIDE: BiBTeX references>>=
@ 

\subsctn{Project description}

At the first stage of the new {\prog} implementation, we are going to define a simple main loop that performs a serial process, such in the old [[GNUawk]] version. So that, the program will read the input files and parameters defined by user and perform the plots, finishing the job. Once the new version will be operative, we will try to implement an iterative mode and/or a GUI in [[perlTK]].  

\label{todo:AAA}
<<HIDE: new defs TODO>>=
\def\todoAAA{Flow diagram (Serial/Filter mode) for figure~\ref{fig:filtermode}.} % todoAAA
@
<<HIDE: TODO>>=
\todoitem{\todoAAA}{todo:AAA}
@
\todo{ \item \todoAAA } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][6cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[``Filter'' mode of {\prog}.]{\label{fig:filtermode} Input, output and main code blocks are represented in this flowchart for the ``Filter'' mode of {\prog}.}
\end{center}
\end{figure}

\subsctn{Basic goals}

\begin{itemize}
\item I am trying to improve some aspects of the {\prog} utility that may be hard to solve in its old \texttt{GNUawk} format. Taking advantage of some capabilities of \texttt{Perl}, such implemented quicksort sorting algorithm and the posibility of building complex data structures, will make the program faster and easier to maintain, it will be more portable too. 

\item Using {\noweb} I pretend to improve the overall design and to open the code to other developers. From this {\LaTeX} document it should be possible to extract all the scripts and files needed for the current implementation.

\item \ldots 
\end{itemize}

\subsctn{Future extensions}

\begin{itemize}
\item An interactive (using text menus on xterms) mode.

\item A graphical interface (using [[perlTK]] maybe).

\item Web/CGI mode, looping through the interactive mode perhaps.

\item Move some code parts to perl packages, to share them with future implementations of [[gff2ps]]... (if we have time)

\item \ldots
\end{itemize}

\label{todo:AAB}
<<HIDE: new defs TODO>>=
\def\todoAAB{Flow diagram here (Interactive, Graphic and Web/CGI modes) for figure~\ref{fig:othermodes}.} % todoAAB
@
<<HIDE: TODO>>=
\todoitem{\todoAAB}{todo:AAB}
@
\todo{ \item \todoAAB } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Future modes of {\prog}.]{\label{fig:othermodes} Input, output and main code blocks are represented in this flowchart for the ``Interactive'', ``Graphic'' and ``Web/CGI'' versions of {\prog}.}
\end{center}
\end{figure}

\subsctn{TO DO: Unfinished stuff for current release}

\begin{itemize}
 \input todo.tex
\end{itemize}


\newpage

\sctn{Main program definition} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This is the {\prog} program outline:

<<APLOT>>=
<<PERL shebang>>
<<Program Info>>
#
# MODULES
#
<<Use Modules>>
#
# CONSTANTS
#
<<Global Constants>>
#
# VARIABLES
#
<<Global Vars>>
<<UNDEFINED VARS>>
#
# MAIN PROGRAM LOOP
#
<<Main Loop>>
#
# MAIN FUNCTIONS
#
<<Main Routines>>
#
# GENERAL FUNCTIONS
#
<<Common Routines>>
#
# POSTSCRIPT CODE
#
<<PostScript CODE Chunks>>
@ 

\subsctn{The main loop}

This is the main loop for the {\prog} ``Filter'' mode: 

<<Main Loop>>=

  # &set_default_vars;

  %CmdLineVars = ();            # Reseting Command-Line OPTIONS
  &parse_command_line;

  <<Basic common block for gfftools>>
  &make_plot;

  $total_time = &timing($T);
  &header("$PROGRAM HAS FINISHED","Timing: $total_time secs");
  
  &close_logfile();
  exit(0);
@ 

{\gft}, say here {\prog} and {\gps}, share many of the basic procedures, both must parse same format input files, must map the read fields to the customization variables and sort groups and their elements by acceptor site coord. That is the main reason for developing a module containing the definitions of such common functions.

<<Basic common block for gfftools>>=
%CustomVars = ();             # Reseting Customization OPTIONS
&parse_custom_files;

%Vars = ();
&merge_custom_vars;

%GFF_DATA = %ALN_DATA = (); # Reseting DATA
&parse_GFF_files;

&map_vars_data;

&sort_elements;

&set_page_vars;

@

We force that all the variables must be declared before using them and restrict unsafe constructs with'[[use strict]]'. After that we switch on signal trapping.

<<Use Modules>>=
use strict;
use vars qw/
     <<Pre-Declared Vars>>        
    /;
#
<<Trapping signals>>
#
@ 

% Typeglobs set to a referenced scalar forces a constant value for all execution
% They can only be set with 'local' (not 'my'), and must be de-referenced
% (say here $$T and $$F) so it is not woth using them for this little script.

<<Pre-Declared Vars>>=
$T $F $n $c
@

<<Global Constants>>=
($T,$F) = (1,0); # for 'T'rue and 'F'alse
@

Those are the main variables containing customization parameters and input data from GFF records. We split customization variables on three input classes: [[%DefaultVars]] to set default values and their type (what makes easy to check if a variable exists or not and if its given value has the expected format), [[%CmdLineVars]] for those parameters passed on command-line and [[%CustomVars]] which collects vaiables customization from external parameter files. Two temporary variables ([[%Defaults]] to initialize element variables and [[%Vars]] to provide the customization from command-line and parameter files to those element variables) allow us to merge all the information from these three variables and transfer to each GFF element in the GFF data variables ([[%GFF_DATA]] for annotations and [[%ALN_DATA]] for alignments).

<<Pre-Declared Vars>>=
%DefaultVars %CmdLineVars %CustomVars %Defaults %Vars %Order
%GFF_DATA %ALN_DATA
@ 

[[%ALN_DATA]] is set on section~\ref{sec:APLOThsh} (see page~\pageref{sec:APLOThsh}), [[%GFF_DATA]] is set on section~\ref{sec:GFFhsh} (see page~\pageref{sec:GFFhsh}), and [[%Order]] is set on section~\ref{sec:ORDERhsh} (see page~\pageref{sec:ORDERhsh}). 

Some info about the program itself.

<<Pre-Declared Vars>>=
$PROGRAM $VERSION $REVISION $REVISION_DATE $LAST_UPDATE
@ 
<<Global Constants>>=
($PROGRAM,$VERSION,$REVISION,$REVISION_DATE,$LAST_UPDATE) = 
   ( 'gff2aplot','v2.0',
     '$Revision: 1.28 $', #'
     '$Date: 2001-12-07 18:38:50 $', #'
     '$Id: gff2aplot.nw,v 1.28 2001-12-07 18:38:50 jabril Exp $', #'
    );
$REVISION =~ s/\$//og;
$REVISION_DATE =~ s/\$//og;
@  %$

<<UNDEFINED VARS>>=
@

\subsctn{Main function sections}

Main function calls share a similar internal structure: a '[[header]]' reporting which function is running, the '[[code]]' for that function and maybe a '[[closing report]]' summarizing what the function did. After each main function definition, you should find those constants, variables and routines being used by that function.  

<<Main Routines>>=
<<Setting Defaults>>
<<Parsing Command-Line Options>>
<<Parsing Custom Files>>
<<Parsing Input Data>>
<<Sorting Features>>
<<Features Setting>>
<<Layout Settings>>
<<Making PS Figures>>
@

\subsctn{Printing Help}

Here is shown the basic outline being diplayed when user choose the '[[help]]' command-line option. The '[[REQUIRES]]' section summarizes those perl modules used in this program by joining all the comments in this document under '[[<<requires help>>]]' tag. Similar happens to '[[COMMAND-LINE OPTIONS]]', in which the single descriptions for each option (that follows each option '[[Getopts]]' definition) are collected by the '[[<<command-line help>>]]' tag.

<<Main Routines>>=
sub prt_help() {
    open(HELP, "| more") ;
    print HELP <<"+++EndOfHelp+++";
PROGRAM:
                        $PROGRAM - $VERSION

    Converting GFF files for pairwise alignments to PostScript.

USAGE:        $PROGRAM [options] <GFF_files|STDIN>

DESCRIPTION:

    This program draws color-filled alignment plots from GFF
    files for that alignment and two sequences annotations.

REQUIRES:

    <<perl requires help>>

ENVIRONMENT VARIABLES:

    <<environment vars help>>

COMMAND-LINE OPTIONS:

    <<command-line help>>
    <<command-line help custom>>

    <<colors help>>

    <<pages help>>

BUGS:    Report any problem to 'jabril\@imim.es'.

AUTHORS:

            $PROGRAM is under GNU-GPL
         Josep Francesc ABRIL FERRANDO  
                 Thomas WIEHE                   
                Roderic GUIGO SERRA       

            Copyright (C) 1999-2001

+++EndOfHelp+++
    close(HELP);
    exit(1);
} # prt_help
@ %def &prt_help
%$

<<perl requires help>>=
$PROGRAM needs the following Perl modules installed in 
your system, we used those available from the standard 
Perl distribution. Those that are not in the standard 
distribution are marked with an '(*)', in such cases 
make sure that you already have downloaded them from 
CPAN (http://www.perl.com/CPAN) and installed.

@ %$

<<command-line help>>=
A double dash on itself "--" signals end of the options
and start of file names (if present). You can use a single
dash "-" as STDIN placeholder. Available options and a
short description are listed here:

<<command-line help prog>>
@


\newpage

\sctn{Variable Definition and Customization} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The functions described in this section process each GFF-record, each custom definition or each command-line options, not only loading the internal variables, also checking for the correctness of the user input in each case.

\label{todo:BBB}
<<HIDE: new defs TODO>>=
\def\todoBBB{Diagram for figure~\ref{fig:customvarstruc}:
Structure of main customization variables and their relationships.} % todoBBB
@
<<HIDE: TODO>>=
\todoitem{\todoBBB}{todo:BBB}
@
\todo{ \item \todoBBB } % todo
\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Structure of main customization variables]{\label{fig:customvarstruc} Structure of main customization variables: [[%DefaultVars]], [[%CmdLineVars]], [[%CustomVars]], [[%Defaults]], [[%Vars]]. Relationships among them and their interaction with [[%GFF_DATA]] and [[%ALN_DATA]] variables which contain data are also shown.}
\end{center}
\end{figure}

\subsctn{Setting customization parameters from defaults} 

The main difference from older versions, besides a cleaner hash structure than the GAWK one, is that we include some customization variables at sequence and strand levels. Almost all the variables are described in section~\ref{sec:customvardesc}, page~\pageref{sec:customvardesc}.

<<Setting Defaults>>=
sub set_default_vars() {
    %DefaultVars = (
        LAYOUT   => {           ## '# L #'
            <<default layout vars values>>
        },					  
        SEQUENCE => {           ## '# Q #'
            <<default sequence vars values>>
        },					  
        SOURCE   => {           ## '# S #'
            <<default source vars values>>
        },					  
        STRAND   => {           ## '# T #'
            <<default strand vars values>>
        },					  
        GROUP    => {           ## '# G #'
            <<default group vars values>>
        },					  
        FEATURE  => {           ## '# F #'
            <<default feature vars values>>
        },
    ); # %DefaultVars
    <<map default vars to defaults working copy>>
    print LOGFILE (Data::Dumper->Dump([ \%DefaultVars ],
                                   [ qw( *DefaultVars ) ]))
        if ($LogFile && $Debug);
} # set_default_vars
@ %def &set_default_vars
% print LOGFILE '>>> %DefaultVars : '.(Dumper(\%DefaultVars))

We also build from this structure, making easier variable maintenance because default value and variable type are edited together in [[%DefaultVars]] (as [[TYPE]]/[[VALUE]] pairs), an auxiliary variable which allows us to load default values into GFF elements.

\label{sec:tmpdefaults}
<<map default vars to defaults working copy>>=
%Defaults = ();
foreach my $sct (keys %DefaultVars) {
    foreach my $vnm (keys %{$DefaultVars{$sct}}) {
        $Defaults{$sct}{$vnm} = $DefaultVars{$sct}{$vnm}{'VALUE'};
	}; # foreach $vnm
}; # foreach $sct
@ 

\subsubsctn{Default customization files}

<<Global Vars>>=
my $Custom_path = defined($ENV{GFF2APLOT_CUSTOMPATH})
                  ? $ENV{GFF2APLOT_CUSTOMPATH} : '.';
my $Custom_file = defined($ENV{GFF2APLOT_CUSTOMFILE})
                  ? $ENV{GFF2APLOT_CUSTOMFILE} : '.gff2aplotrc';
$Custom_path =~ s{/$}{}o; 
@ 

We remove any trailing '[[/]]' from '[[$Custom_path]]' that user could have introduced to avoid any problem with full custom filenames later.

<<environment vars help>>=
    There are two environmental variables that can be set by 
users to their preferences:
 + You can specify the path where $PROGRAM can find the default
  files with the shell variable \"GFF2APLOT_CUSTOMPATH\". Default
  value is the path where you are running $PROGRAM.
 + You can also define the default custom filename you will like
  with the variable \"GFF2APLOT_CUSTOMFILE\", program default
  filename for custom file is \".gff2aplotrc\".
 + Now $PROGRAM does not need to write any temporary file, 
  so that previous versions default temporary directory path
  variable (\"GFF2APLOT_TMP\") is no longer used.
 + Setting those vars in Bourne-shell and C-shell:
   o Using a Bourne-Shell (e.g. bash):
        export GFF2APLOT_CUSTOMPATH=\"path\"
        export GFF2APLOT_CUSTOMFILE=\"file_name\"
   o Using a C-Shell:
        setenv GFF2APLOT_CUSTOMPATH \"path\"
        setenv GFF2APLOT_CUSTOMFILE \"file_name\"
@ %$


\subsctn{Setting customization parameters from command-line} 

'[[GetOptions]]' loads command-line options as key-value pairs in the hash variable '[[%CmdLineVars]]' 
that is reset in '[[<<Main Loop>>]]'. Once parsed all the command-line options what remains in '[[@ARGV]]' is just input filenames (which have to be in GFF format), or '[[STDIN]]' if there is none.

<<Parsing Command-Line Options>>=
sub parse_command_line() {
    <<looking for STDIN>>

    $SIG{__WARN__} = sub { &warn('UNKNOWN_CL_OPTION',$T,$_[0]) };
    GetOptions(
               <<command-line options prog>>
               <<command-line options>>
               <<command-line options custom>>
               <<command-line options with exit>>
               ) || (&warn('CMD_LINE_ERROR',$T), exit(1));
    $SIG{__WARN__} = 'DEFAULT';

    <<open LOGFILE>>

    &header('',"RUNNING $PROGRAM",'',"User: $USER","Date: $DATE");

    &header("SETTING DEFAULTS");
    %DefaultVars = ();
    &set_default_vars;

    &header("CHECKING COMMAND-LINE OPTIONS");
    @data_files = ();
    &set_input_file($cmdln_stdin);
    @ARGV = (); # ensuring that command-line ARGVs array is empty

    &set_custom_files();

    &check_command_line_vars();

    &footer("COMMAND-LINE CHECKED");
} # parse_command_line
@ %def &parse_command_line

As the '[[GetOptions]]' function has a problem, in the way we are using here to preserve backwards compatibility, when we want to use a single dash as a way to tell the program that '[[STDIN]]' must be read in the given order (when input filenames are also given and we would load input from a pipe after/before a given file). We show the warnings printed by the program when '[[--]]' is missing or missplaced in the table~\ref{tbl:STDINhandle}.

\begin{table}[!t]
\begin{center}
\begin{small}
\begin{tabular}{|c|}\hline
\begin{minipage}{15cm}
\begin{verbatim}

# CORRECT
> $BIN/gff2aplot -v -T 'Howdy World!' -- - DATA-SAMPLE.gff 
> $BIN/gff2aplot -v -T 'Howdy World!' -- DATA-SAMPLE.gff -

# WRONG???
> $BIN/gff2aplot -v -T 'Howdy World!' DATA-SAMPLE.gff -
> $BIN/gff2aplot -v -T 'Howdy World!' - DATA-SAMPLE.gff
> $BIN/gff2aplot -v -T 'Howdy World!' - -- tests/DATA-SAMPLE.gff

# COMMON MESSAGE when WRONG
### WARNING ### Error trapped while processing command-line:
                substr outside of string at lib/Getopt/Long.pm
                  (autosplit into lib/auto/Getopt/Long/FindOption.al)
                line >NNNNN<
### WARNING ### Error trapped while processing command-line:
                Use of uninitialized value at lib/Getopt/Long.pm
                  (autosplit into lib/auto/Getopt/Long/FindOption.al) 
                line >NNNNN<
### WARNING ### Error trapped while processing command-line:
                Unknown option:

\end{verbatim}
% $
\end{minipage}\\\hline
\end{tabular}
\end{small}
\caption[Fixing [[GetOptions]] for using '[[-]]' as '[[STDIN]]' mark.]{\label{tbl:STDINhandle} Errors reported when using '[[-]]' as '[[STDIN]]' mark and fixed width [[<<looking for STDIN>>]].}
\end{center}
\end{table}

To avoid such errors, we capture the single dash when present in the command-line arguments list. 

'[[$cmdln_stdin]]' will be used by '[[&set_input_file]]' function to include the '[[STDIN]]' in the correct ordering.\label{sec:stdinfix}

<<looking for STDIN>>=
my $cmdln_stdin = undef;
for (my $a = 0; $a <= $#ARGV; $a++) { 
    next unless $ARGV[$a] =~ /^-$/o;
    $cmdln_stdin = $a - $#ARGV;
    splice(@ARGV,$a,1);
};    
@ 

The following two code chunks define what to do if reports are sent to a file which is set in '[[$logs_filename]]'.

<<open LOGFILE>>=
CHKLOG:
  (defined($logs_filename)) && do {
      open(LOGFILE,"> ".$logs_filename) ||
          (&warn('FILE_NO_OPEN',$T,$logs_filename),last CHKLOG);
      $LogFile = 1;
  };
@

<<Common Routines>>=
sub close_logfile() { close(LOGFILE) if $LogFile };
@ %def &close_logfile

<<Use Modules>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
@ 

<<perl requires help>>=
"Getopt::Long" - processing command-line options.
@

See '[[man Getopt::Long]]' for further info about this package.

<<Global Vars>>=
my ($Debug,$Verbose,$Quiet,$LogFile,$logs_filename) = ($F,$F,$F,$F,undef);
@ 

<<warnings - parsing command-line options>>=
UNKNOWN_CL_OPTION =>
  $Warn."Error trapped while processing command-line:\n".(" "x16)."\%s\n",
CMD_LINE_ERROR =>
  $spl.$spw." Please, check your command-line options!!!\n".$Error."\n".
  $spw." ".("."x12)." Type \"$PROGRAM -h\" for help.\n".$spl,
@

\subsubsctn{Special command-line options (forcing exit from program)}

The first command-line checking looks for those options exiting the program: '[[help]]' and '[[version]]'. Both need to output to screen without any other message/warning being displayed at the same time.

<<command-line options with exit>>=
"version"   => \&prt_version, 
"h|help|?"  => \&prt_help,
@ 
<<command-line help prog>>=
-h, --help   Shows this help.
--version    Shows current version and exits.
@
<<DESC command-line options>>=
ORD: 1
OPT: h
LNG: help
SDE: Shows this help.
LDE:
Shows command-line help.
###EOR###
ORD: 2
LNG: version
SDE: Shows current version and exits.
LDE:
Shows current program version and exits.
###EOR###
@ 


<<Parsing Command-Line Options>>=
sub prt_version() {
    my $comment = $Messages{'SHOW_VERSION'};
    $comment = sprintf($comment,$PROGRAM,$VERSION);
    &prt_to_stderr($comment);
    exit(1);
} # prt_version
@ %def &prt_version

<<messages - parsing command-line options>>=
SHOW_VERSION =>
  $sp."### \%s -- \%s\n".$sp,
@

\subsubsctn{Testing command-line input filenames}

<<Parsing Command-Line Options>>=
sub set_input_file() {
    my $stdin_flg = $F;
    <<STDIN backwards compatibility>>
    &report("CHECKING_FILENAMES");
  FILECHK: foreach my $test_file (@ARGV) {
        $test_file ne '-' && do {
            -e $test_file || do {
                &warn('FILE_NO_OPEN',$T,$test_file);
                next FILECHK;
            };
            &report('READING_FILE',$test_file);
            push @data_files, $test_file;
            next FILECHK;
        };
        $stdin_flg = $T;
        push @data_files, '-';
	}; # foreach
    scalar(@data_files) == 0 && do {
        push @data_files, '-';
        $stdin_flg = $T;
    };
    $stdin_flg && &report('READING_STDIN');
} # set_input_file
@ %def &set_input_file

<<Global Vars>>=
my (@data_files,$file);
@ 

<<warnings - input/output>>=
FILE_NO_OPEN =>
  $spl.$Warn."Cannot Open Current file \"\%s\" . Not used !!!\n".$spl,
@

<<messages - input/output>>=
CHECKING_FILENAMES =>
  $sp."### Validating INPUT FILENAMES\n".$sp,
READING_FILE =>
  "###---> \"\%s\" exists, including as Input File.\n",
READING_STDIN =>
  "###---> Including GFF records from standard input.\n",  
@

Here is the fix for the explained in section~\ref{sec:stdinfix} on page~\pageref{sec:stdinfix} ([[<<looking for STDIN>>]] code).

<<STDIN backwards compatibility>>=
my $chk_stdin = shift @_;
my $t = scalar(@ARGV);
defined($chk_stdin) && do {
    abs($chk_stdin) > $t && ($chk_stdin = -$t);
	$chk_stdin > 0  && ($chk_stdin = 0 );
    $t += $chk_stdin;
    splice(@ARGV,$t,0,'-');
};
@

\subsubsctn{Verifying command-line settings}

<<HIDE: DONE>>=
\doneitem{20011023}{Implement [[&check_command_line_vars]] to verify if settings from command-line are OK.}
@

As we reset [[%CmdLineVars]] in main loop we do not need to take care for those key-value pairs that were not defined by [[GetOptions]] function. We will check for two kinds of command-line variables, those having a specific command-line option (and related to [[LAYOUT]] variables) and those that define a feature-specific variable (for GFF-features, groups, sequences and so on). Last ones are validated and set in the following section. Therefore, if layout variables are provided on command-line by this way, they have precedence over the corresponding layout pre-defined command-line option. 

<<Parsing Command-Line Options>>=
sub check_command_line_vars() {
    &report("CHECKING_CMDLN_VARS");
    &command_line_for_layout();
    defined($CmdLineVars{VARS}) &&
        &command_line_for_vars();
    &footer("COMMAND-LINE OPTIONS CHECKED");
} # check_command_line_vars
@ %def &check_command_line_vars

<<messages - input/output>>=
CHECKING_CMDLN_VARS =>
  $sp."### Checking COMMAND-LINE Settings\n".$sp,
@ 

Here we take advantage of the [[&varscheck]] function, that was created to validate input from [[&parse_custom_files]], and that is described in section~\ref{sec:paramvalid}, page~\pageref{sec:paramvalid}.

<<Parsing Command-Line Options>>=
sub command_line_for_layout() {
    $n = 0;
    foreach my $cvar (keys %{ $CmdLineVars{LAYOUT} }) {
        my @cary = ('LAYOUT',$cvar,$CmdLineVars{LAYOUT}{$cvar});
        $c = &varscheck($F,'LAYOUT',\@cary,\%CmdLineVars) ? '.' : $noCV;
        &counter(++$n,$c);
	}; # foreach $cvar
    &counter_end($n,$c);
} # command_line_for_layout
@ %def &command_line_for_layout

\subsubsctn{Loading GFF elements custom variables from command-line}

<<HIDE: DONE>>=
\doneitem{20011023}{
Parsing and loading command-line options having structure like:\\
\centerline{[[--feature feature_name::variable_name=value]]}
}
@

<<Parsing Command-Line Options>>=
sub command_line_for_vars() {
    $n = 0;   
    foreach my $calias ( qw/ L Q S T G F / ) {
        my ($cvar,$cflg);
        $cvar = $VarKeys{$calias};
        $cflg = ($calias ne 'L') ? $T : $F;
        defined($CmdLineVars{VARS}{$cvar}) && do {
            foreach my $ccv (@{ $CmdLineVars{VARS}{$cvar} }) {
                my @clin = ();
              TWOTHREE: {
                  $cflg && do {
			      	  $ccv =~ /^(.*?):{2}(.*?)={1}(.*?)$/o &&
                              (@clin = ($1,$2,$3));
			      	  last TWOTHREE;
			      };
                  $ccv =~ /^(.*?)={1}(.*?)$/o && (@clin = ($cvar,$1,$2));
		        }; # TWOTHREE
                $c = &varscheck($cflg,$cvar,\@clin,\%CmdLineVars)
                     ? $calias : $noCV;
                &counter(++$n,$c);
            }; # foreach $ccv
        }; # $CmdLineVars{VARS}{$cvar}
	}; # foreach $calias
    &counter_end($n,$c);
} # command_line_for_vars
@ %def &command_line_for_vars

<<command-line options custom>>=
"layout-var=s@"   => \@{ $CmdLineVars{VARS}{LAYOUT} },
"sequence-var=s@" => \@{ $CmdLineVars{VARS}{SEQUENCE} },
"source-var=s@"   => \@{ $CmdLineVars{VARS}{SOURCE} },
"strand-var=s@"   => \@{ $CmdLineVars{VARS}{STRAND} },
"group-var=s@"    => \@{ $CmdLineVars{VARS}{GROUP} },
"feature-var=s@"  => \@{ $CmdLineVars{VARS}{FEATURE} },
@ 
<<command-line help custom>>=
  --layout-var '<variable=value>'
--sequence-var '<sequence::variable=value>'
  --source-var '<source::variable=value>'
  --strand-var '<strand::variable=value>' 
   --group-var '<group::variable=value>'
 --feature-var '<feature::variable=value>'
         Loading a feature/group/strand/source/sequence/layout
         customization variable from command-line. You can set
         several variables by repeating any of these options, 
         i.e.:
               ... --feature-var cds::shape=box \
                   --feature-var cds::feature_color=blue ... 
@
<<HIDE: command-line latex short custom>>=
\rw{-\/-feature-var '\pr{feature::variable=value}'}
  {Set a feature customization variable from command-line.}
\rw{-\/-group-var '\pr{group::variable=value}'}
  {Set a group customization variable from command-line.}
\rw{-\/-strand-var '\pr{strand::variable=value}'}
  {Set a strand customization variable from command-line.}
\rw{-\/-source-var '\pr{source::variable=value}'}
  {Set a source customization variable from command-line.}
\rw{-\/-sequence-var '\pr{sequence::variable=value}'}
  {Set a sequence customization variable from command-line.}
\rw{-\/-layout-var '\pr{variable=value}'}
  {Set a layout customization variable from command-line.}
@ 
<<HIDE: command-line latex custom>>=
\clmitem{-\/-feature-var '\pr{feature::variable=value}'}
Loading a customization variable for a GFF feature element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-group-var '\pr{group::variable=value}'}
Loading a customization variable for a GFF group element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-strand-var '\pr{strand::variable=value}'}
Loading a customization variable for a GFF strand element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-source-var '\pr{source::variable=value}'}
Loading a customization variable for a GFF source element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-sequence-var '\pr{sequence::variable=value}'}
Loading a customization variable for a GFF sequence element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-layout-var '\pr{variable=value}'}
Loading a customization variable for page layout from command-line. % '\pr{custom\_file}'. 
@

\subsctn{Setting customization parameters from files} 

Here we define the command-line option for loading customization files. Setting '[[C|custom-filename=s@]]' allows us to pass more than one custom file within the same command-line. Must be noted that latest file customization variables will override the previous ones.

<<command-line options custom>>=
"C|custom-filename=s@"  => \@custom_files,
@ 
<<command-line help custom>>=
-C, --custom-filename <filename>
      Loading customization parameters from a given file (if 
      default \".gff2aplotrc\" exists is loaded before it).
@
% If ORD is not defined then description is placed at the end of the description files.
<<DESC command-line options>>=
ORD: 
OPT: C
LNG: custom-filename
PAR: <filename>
SDE: Read customization parameters from file.
LDE:
Loading customization parameters from <filename>. Now you can load 
several customization files by passing this option several times. The 
precedence is the input order in the command-line, so, for the common 
definitions, the last |custom_file| will override previous |custom_files| 
settings. If default customization file "\texttt{.gff2aplotrc}" does exist,
it is the first customization that is loaded by the program.
###EOR###
@ 


\subsubsctn{Testing whether custom-files exist}

Customization parameters cannot be set from '[[STDIN]]'. What program does first of all, is to look whether default custom file does exist or not ([[$Custom_file]] was set from environment variable if [[GFF2APLOT_CUSTOMFILE]] was defined on the current shell). But we are taking advantage of the fact that we also have to check existence of the command-line custom files (if given), so we insert as first element of the array the default custom file to the variable '[[@custom_files]]' and then we check all its elements with the same function. We look for these files in current path and if they are not found in '[[$Custom_path]]'.

<<Parsing Custom Files>>=
sub set_custom_files() {
	unshift @custom_files, $Custom_file;
    my @files = ();
    &report("CHECKING_CUSTOM_NAMES");
  MLOOP: foreach my $test_file (@custom_files) {
      FILECHK: {
        -e $test_file && last FILECHK;
        ($test_file =~ m{/}og || $Custom_path eq '.') || do {
            my $tmpfl = $test_file;
			$test_file = "$Custom_path/$test_file";
            &report('READING_FROM_PATH',$tmpfl,$test_file);
            -e $test_file && last FILECHK;
        };
        scalar(@custom_files) == 1 && do {
            &report('NO_CUSTOM_FILES',$T);
            last MLOOP;
		};
        &warn('FILE_NO_OPEN',$T,$test_file);
        next MLOOP;
	  }; # FILECHK
        &report('READING_CUSTOM_FILE',$test_file);
        push @files, $test_file;
	}; # MLOOP: foreach
	@custom_files = @files;
} # set_custom_files
@ %def &set_custom_files

<<Global Vars>>=
my @custom_files = ();
@ 

<<messages - input/output>>=
CHECKING_CUSTOM_NAMES =>
  $sp."### Validating CUSTOM FILENAMES\n".$sp,
READING_FROM_PATH =>
  "###---> Custom File NOT FOUND in local path: \"\%s\"\n".
  "###     Trying to find in \"GFF2APLOT_CUSTOMPATH\": \"\%s\"\n",
READING_CUSTOM_FILE =>
  "###---> \"\%s\" exists, including as Custom File.\n",
NO_CUSTOM_FILES =>
  "###---> NO CUSTOM FILES found. Using program DEFAULTS.\n",
@

\subsubsctn{Parsing customization files}

Layout variables are defined as two fields, variable name and value, while the other variables require three fields, a feature to which is set the variable to the given value. To validate input records, '[[$var_flag]]' boolean will determine whether a two fields or a three fields record we currently are going to process. '[[&varscheck]]' function not only checks the customization parameters for correctness but also loads '[[%CustomVars]]' hash.

<<Parsing Custom Files>>=
sub parse_custom_files() {
    &header("READING CUSTOM FILES");
  MAIN: {
      scalar(@custom_files) == 0 && do {
          &report('NO_CUSTOM_FOUND',$file);
		  last MAIN;
	  };
    LOAD: foreach $file (@custom_files) {
        open(THIS,"< $file") ||
            ( &warn('FILE_NO_OPEN',$T,$file), next LOAD);
        &report('READ_CUSTOM_FILE',$file);
        ($n,$c) = (0,undef);
        while (<THIS>) {
            my (@line,$main,$_c,$_v,$v_flag);
		    /^\#/o && do {
                /^\# ([LQSTGF]) \#/o && do { 
                     $_c = $1; $c = '*';
                     $v_flag = ($_c ne 'L') ? $T : $F;
                     $_v = $VarKeys{$_c};
                     next;
                };
				$c = '.'; next;
            };
            ($c = '.', next) if /^\s*$/o;
            chomp;
            ($main,undef) = split /\b\s+\#/o;
          TWOTHREE: {
              $v_flag && do {
				  $main =~ /^(.*?):{2}(.*?)={1}(.*?)$/o &&
                           (@line = ($1,$2,$3));
				  last TWOTHREE;
			  };
              $main =~ /^(.*?)={1}(.*?)$/o && (@line = ($_v,$1,$2));
		  }; # TWOTHREE
            $c = &varscheck($v_flag,$_v,\@line,\%CustomVars) ? $_c : $noCV;
        } continue {
            &counter(++$n,$c);
        }; # WHILE
        &counter_end($n,$c);
        close(THIS);
    }; # LOAD
  }; # MAIN
    print LOGFILE (Data::Dumper->Dump([ \%CustomVars ],
                                   [ qw( *CustomVars ) ]))
        if ($LogFile && $Debug);
    &footer("CUSTOM FILES LOADED");
} # parse_custom_files
@ %def &parse_custom_files
% print LOGFILE '>>> \%CustomVars : '.(Dumper(\%CustomVars))

\begin{table}[!t]
\begin{center}
\begin{tabular}{cc}
\fbox{
\begin{tabular}[b]{c>{\bfseries}c}
\textbf{Record TYPE} & \textbf{Symbol} \\
Empty record            & . \\
Comment                 & . \\
Header (\# [LQSTGF] \#) & * \\
Layout Vars             & L \\
Sequence Vars           & Q \\
Source Vars             & S \\
Strand Vars             & T \\
Group Vars              & G \\
Feature Vars            & F \\
Unknown                 & ? \\
\end{tabular}
} %fbox
&
\parbox[b]{0.4\linewidth}{
\caption[Symbols used to report record type from custom files]{\label{tbl:CFkeysXreport} Symbols used to report record type when parsing customization files (and [[STDERR]] verbose mode is enabled with '[[-v]]' switch).}
} % parbox
\\
\end{tabular}
\end{center}
\end{table}

<<Pre-Declared Vars>>=
%VarKeys $noCV
@ 
<<Global Constants>>=
$noCV = '?';
%VarKeys = (
    L => 'LAYOUT',
    Q => 'SEQUENCE',
    S => 'SOURCE',
    T => 'STRAND',
    G => 'GROUP',
    F => 'FEATURE',
    );
@ 

<<messages - parsing custom files>>=
READ_CUSTOM_FILE => 
  $sp."### Reading Customization Parameters from \"\%s\"\n".$sp,
NO_CUSTOM_FOUND =>
  $sp."### NO CUSTOM FILES found: Using program DEFAULTS.\n".$sp,
@

\label{todo:BGA}
<<HIDE: new defs TODO>>=
\def\todoBGA{Include an ``XTRA'' section to custom files for ``markup'' shapes definition (box, circle, label, and so on).} % todoBGA
@
<<HIDE: TODO>>=
\todoitem{\todoBGA}{todo:BGA}
@
\todo{ \item \todoBGA } % todo


\subsubsctn{Validating customization parameters} 
\label{sec:paramvalid}

'[[$rec]]' is a reference to an array that contains three elements: feature, variable and value. First we check if variable name is defined in , then we check if the given value matches the variable type. After that we analyse the feature element, testing if it is a regular expression or not. We have slightly modified ths function to be able to process input from [[&parse_custom_files]] and [[&check_command_line_vars]], we pass by reference the main hash variable that must be loaded with the data being parsed ([[%CustomVars]] and [[%CmdLineVars]] respectively).

<<Parsing Custom Files>>=
sub varscheck() {
    my ($flag,$class,$rec,$varec) = @_;
    defined($DefaultVars{$class}) || 
        (&warn('SECTION_NOT_DEF',$F),return $F);
	my $_var = \%{$DefaultVars{$class}};
    defined($$rec[2]) || return $F;
    defined($_var->{$$rec[1]}) || 
        (&warn('VAR_NOT_DEFINED',$F,$class,$$rec[1]),return $F);
    &checkvarvalues($_var->{$$rec[1]}{'TYPE'},\$$rec[2],$$rec[1]) || return $F;
    $flag && do {
        my @tmpary = ();
        defined(@{ $varec->{$class}{$$rec[1]} }) || do {
            @{ $varec->{$class}{$$rec[1]} } = ();
        };
        @tmpary = &find_regexp($$rec[0]);
        (shift @tmpary) || return $F;
        push @{ $varec->{$class}{$$rec[1]} }, 
             ( @tmpary, $$rec[2] );
        return $T;
	};
    $varec->{$class}{$$rec[1]} = $$rec[2];
    return $T;
} # varscheck
@ %def &varscheck

\label{sec:DATAtriadarray}
For the same variable name, say here [[ $$rec[1] ]], we will have more than one setting (for the same element or not). This requirement force us to save element-value pairs (and a third field which tells us if element contains a regular expression that must not to be matched or not). The array will preserve the input ordering of each new setting for the same variable. We want this behaviour, as the global definitions must precede specific ones in the custom files. 

<<warnings - parsing custom files>>=
SECTION_NOT_DEF =>
  $Warn."You probably forgot a section header, unable to parse this record.\n",
VAR_NOT_DEFINED =>
  $Warn."\%s variable not defined: \"\%s\" .\n",
@

Different data requires different value tests, another function of those tests is to normalize when needed variable values to fixed internal values, so this will avoid later checkings or functions for reformating them and writing functions
will be simplest.

<<Parsing Custom Files>>=
sub checkvarvalues() {
	my ($_test,$_val,$_var) = @_;
    my $_t = lc($$_val);
    defined($TESTS{$_test}) || do {
        &warn('VARTYPE_NOT_DEFINED',$T,$_test,$_var);
        return $F;
    }; # !defined($TESTS->{$_test})
    return $TESTS{$_test}->($_val,$_var,$_t);
} # checkvarvalues
@ %def &checkvarvalues

<<warnings - parsing custom files>>=
VARTYPE_NOT_DEFINED =>
  $Error."Variable type \"\%s\" not defined,\n".
  $spw."  could not check value for \"\%s\".\n",
@

The following hash keys serve as references to annonymous functions, each one defining a single test for the variable value passed by reference and modifying it if needed. [[%Fonts]] is set on section~\ref{sec:FontsHsh} (page~\pageref{sec:FontsHsh}), [[%COLORS]] is set on section~\ref{sec:ColorsHsh} (page~\pageref{sec:ColorsHsh}), [[%FORMATS]] is set on section~\ref{sec:FormatsHsh} (page~\pageref{sec:FormatsHsh}), [[%Messages]] is set on section~\ref{sec:MessagesHsh} (page~\pageref{sec:MessagesHsh}) and [[%UNITS]] is set on section~\ref{sec:UnitsHsh} (page~\pageref{sec:UnitsHsh}).

<<Pre-Declared Vars>>=
%TESTS %Fonts %COLORS $colors %FORMATS $formats %Messages %UNITS
@ 
<<Global Vars>>=
%TESTS = (
    <<variable value checking>>
    );
@ 

\subsctn{Deciphering element fields}

If an [[element]] appears not to be a regular expression we transform it
to '[[^element$]]' before returning it. [[$not_flg]] and [[$id_flg]]
will be set to a true value in case that input string contains a
'[[!]]' as first character ([[!element]],[[!/regexp/]], [[!/regexp/@id]] and
[[!*]]) and that an ID is given ([[element@id]], [[/regexp/@id]] and
[[!/regexp/@id]]), respectively. Both flags will be helpful to
determine what test we have to perform in order to know if we have to
set the variable value for a GFF element (see
section~\ref{sec:mapcustoms}, page~\pageref{sec:mapcustoms}). For
[[$id_flg]], the true value will consist on the feature identifier, so
that we do not need to introduce a new field in the array.

<<Parsing Custom Files>>=
sub find_regexp() {
    my $string = $_[0];
    my ($isOK_flg,$not_flg,$id_flg,$tmpstr,$tmpid);
    $isOK_flg = $T;
    $not_flg = $F;
    $id_flg = undef;
    $string =~ s{^!}{}o && ($not_flg = $T); # not_regexp is true
    $string =~ s{(\\@)$}{@@}o; # scaping trailing '@' (if element ends with) 
    $string = &escape_input($string);
    ($tmpstr, $tmpid) = (undef, undef);
    ( reverse($string) =~ m{^([^\/@]*?)(?:@){1}(.*)$}o ) && do {
        $tmpstr = reverse($2);
        $tmpid  = reverse($1);
    }; # reverse($string)
    (defined($tmpid)  && $tmpid  ne "") && ($id_flg = $tmpid);
    (defined($tmpstr) && $tmpstr ne "") || do {
        $string eq '@' && ($isOK_flg = $F);
        $tmpstr = $string;
    }; # (defined($tmpstr) && $tmpstr ne "")
  REGEXPS: {
      <<does string contain a regular expression>>
    }; # REGEXPS
    $isOK_flg && do {
        eval { "" =~ m{$string}; } || do {
            $isOK_flg = $F;
        }; # check if final regexp string is OK
    }; # $isOK_flg
    $isOK_flg || do {
        &warn('BAD_REGEXP',$F,"$string");
        $string = "";
    }; # NOT $isOK_flg
    return ($isOK_flg, $not_flg, $id_flg, $string);
} # find_regexp
@ %def &find_regexp

<<warnings - parsing custom files>>=
BAD_REGEXP =>
  $Warn."Ill-formed regular expression found in custom file:\n".
  $spw." ---> \%s <---\n",
@

Two steps are needed for parsing element fields. We must ensure first
that there is an [[@id]] feature delimiter in the element field and,
after removing that delimiter, check if we have a regular expression
or not. The easiest way to extract any trailing 'id' substring from
element field is using a sexeger, a reversed regular expression
\footnote{Further information on sexeger (reversed regexes) can be
found at \url|http://www.perl.com/pub/2001/05/01/expressions.html| and
\url|http://www.pobox.com/~japhy/|.}

<<does string contain a regular expression>>=
$tmpstr eq '*' && do {
    $string = '^.*$'; #'
    last REGEXPS;
}; # $string eq '*'
$tmpstr =~ m{^/(.*)/$}o && do {    
    ($string, $isOK_flg) = &eval_regexp($1);
    last REGEXPS;
}; # $tmpstr is a regexp
# ($tmpstr =~ m{^/.*[^/]$}o || $tmpstr =~ m{^[^/].*/$}o) && do {
#     $isOK_flg = $F;  
#     last REGEXPS;
# }; # $tmpstr is a bad defined regexp
$string = '^'.(quotemeta($tmpstr)).'$'; #' 
@ 

<<Parsing Custom Files>>=
sub eval_regexp() {
    my $str = $_[0];
    my $flag;
    eval { "" =~ m{$str}; $flag = $T; } || ($flag = $F);
    return ($str, $flag);
} # eval_regexp
@ %def &eval_regexp

From a list of possible tainted shell metacharacters, \\[1ex]
\centerline{[[ ; < > * | & $ ! ? # ( ) [ ] { } : ` ' " \ ]]}\vskip 0.5ex
% # @_ =~ s/([;<>\*\|`&\$!?#\(\)\[\]\{\}:'"\\])/\\$1/g;
we quote those that are not going to be used as regular expression metacharacters, \\[1ex]
\centerline{[[ ; < > & ! { } ` ' " ]]}\vskip 0.5ex % "'`
to avoid security issues. This will make a CGI developed on {\prog} a little bit more secure because the user cannot send something like:\\[1ex]
\centerline{\shortstack{[[//; `/bin/rm -rf`;//]]\ \ \ ,\\[[/ @{[ system('mail user@server /etc/passwd') ]} /]]\ \ \ or\\[[/ ${ \( exec('chmod -R 0777 /root') ) } /]]}} %$

<<Parsing Custom Files>>=
sub escape_input() {
    my $var = $_[0];
    $var =~ s{([;,<>&!\{\}`'"])}{\\$1}g; #"'`
    return $var;
} # escape_input
@ %def &escape_input


\subsctn{Customization variable values validation}

This section is dedicated to those test we need to ensure that customization variables contain acceptable values, so we do not need to check them later in the program. Table~\ref{tbl:varformats} summarizes the variable types defined for customization parameters.

\begin{table}[!t]
\begin{center}
\fbox{
\begin{tabular}{cl}
[[BOOLEAN]]  & A true/false variable.\\
[[ALPHA]]    & A string set as '[[ [a-zA-Z][a-zA-Z_0-9]* ]]'.\\
[[STRING]]   & A free text character string.\\
[[NATURAL]]  & A positive integer (nor decimals neither sign).\\
[[INTEGER]]  & Positive or negative integers.\\
[[FLOAT]]    & Numbers with decimal values (subset of reals).\\
[[REAL]]     & Any real number (including scientific notation).\\
[[COLOR]]    & Available colors are defined in '[[%COLORS]]' hash.\\
[[FONT]]     & A {\ps} font from those defined in '[[%Fonts]]' hash.\\
[[BBOX]]     & '[[<width>,<height>]]' pair (in [[PS_UNIT]] units).\\
[[PAGE]]     & Page sizes are set in '[[%FORMATS]]' variable.\\
[[SEQ_UNIT]] & A numeric value with nucleotide units (Gb, Mb, Kb or bases).\\
[[PS_UNIT]]  & A numeric value with {\ps} units (pt, cm, mm or in).\\
[[RANGE]]    & A '[[lower-limit..upper-limit]]' numeric pair.\\
[[PSRANGE]]  & A '[[lower-limit..upper-limit]]' {\ps} lengths pair.\\
[[SEQRANGE]] & A '[[lower-limit..upper-limit]]' sequence coords pair.\\
\end{tabular}
} % fbox
\caption[Customization parameters available formats]{\label{tbl:varformats} Parameter available formats we are going to use for customization variables checking.}
\end{center}
\end{table}
 
<<HIDE: DONE>>=
\doneitem{20011107}{Maybe [[UNITS]] instead of [[FONT_SZ]] will have broader applicability.}
@

\label{todo:BBE}
<<HIDE: new defs TODO>>=
\def\todoBBE{
More format variables need to be defined, such as: [[SHAPES]] from a shapes array, [[LINES]]/[[LINESTYLES]] (none, dotted, dashed, solid/default), [[GROUP-BRACKETS]] (bracket, arrow, half-arrow, dotted-bracket --with vertical dotted lines at both ends like conecting to baseline--).
} % todoBBE
@
<<HIDE: TODO>>=
\todoitem{\todoBBE}{todo:BBE}
@
\todo{
 \item \todoBBE
 } % todo

\subsubsctn{Handling sequence and {\ps} units}

Here we define the annonymous functions that will provide units exchange to points ({\ps} units) or nucleotides (sequence units).
\label{sec:UnitsHsh}

<<Global Vars>>=
%UNITS = (
    <<units exchange functions>>
    );
@

<<Pre-Declared Vars>>=
$kilo $mega $giga $cm2pt $mm2pt $in2pt
@

Those units are used in layout/font-size lengths setting:

<<Global Constants>>=
($cm2pt,$mm2pt,$in2pt) = (28.35,2.835,72);
@ 
<<units exchange functions>>=
"pt"  => sub ($) { return $_[0] },
"mm"  => sub ($) { return $_[0] * $mm2pt },
"cm"  => sub ($) { return $_[0] * $cm2pt },
"in"  => sub ($) { return $_[0] * $in2pt },
@ 

Those allow to recover base-pair nucleotide coords for sequence related calculations:

<<Global Constants>>=
($kilo,$mega,$giga) = (10**3,10**6,10**9);
@
<<units exchange functions>>=
"bp"  => sub ($) { return $_[0] },
"kbp" => sub ($) { return $_[0] * $kilo },
"mbp" => sub ($) { return $_[0] * $mega },
"gbp" => sub ($) { return $_[0] * $giga },
@

As you can note, we have defined a function to convert from gigabases, but at this moment {\ps} can only handle numbers smaller than $2.1*10^9$ and {\prog} is not ready to workaround that. [[pt]] and [[bp]] have been introduced for consistency, so the functions using those units can be more general and avoid to check special cases, then whole program code will be simpler.

Finally, we need a simple function to recover the corresponding value for a given reference to an array which contain coords (as they are outputed by the test functions as a two elements array containing position and unit, in this order). This will simplify the code a little bit (as in section~\ref{sec:LAYOUTsec}). 

<<Common Routines>>=
sub get_units() { return $UNITS{$_[0]->[1]}->($_[0]->[0]); }
@ %def &get_units

\subsubsctn{Checking boolean variables}

We define as 'BOOLEAN' those variables used as flags or switches, which can hold only a binary value such ON/OFF. Booleans are NOT case sensitive.

<<variable value checking>>=
BOOLEAN => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      $_l =~ /^(1|on|t(rue)|y(es))$/o  && ($$_v = $T, return $T);
      $_l =~ /^(0|off|f(alse)|n(o))$/o && ($$_v = $F, return $T);
      &warn('NOT_A_BOOLEAN',$F,$_n);
      return $F;
  },
@ %def {BOOLEAN}

<<warnings - parsing custom files>>=
NOT_A_BOOLEAN =>
  $Warn."\"\%s\" variable requires a boolean value:\n".
  $spw."     (ON/OFF, 1/0, TRUE/FALSE, YES/NO)\n",
@

We also need a small function returning a 'true'/'false' string value to convert those booleans variables to {\ps} format.

<<Common Routines>>=
sub tobool() { return ( $_[0] ? 'true' : 'false' ); }
@ %def &tobool


\subsubsctn{Alphanumeric values}

Although {\ps} allows object ``names'' consisting in any character, except delimiters and white space, string, we are going to restrict user-defined ``names'' to a string that must start with a letter and may contain letters, numbers and underscores.

<<variable value checking>>=
ALPHA => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[a-zA-Z][a-zA-Z_0-9]*$/o && return $T;
      &warn('NOT_ALPHA',$F,$_n);
      return $F;
  },
@ %def {ALPHA}

<<warnings - parsing custom files>>=
NOT_ALPHA =>
  $Warn."\"\%s\" variable parameter must fit \"[a-zA-Z][a-zA-Z_0-9]*\"...\n",
@

\subsubsctn{Protecting reserved characters in strings}

Having a 'STRING' implies to replace/protect those characters that will produce indesirable effects in {\ps} code (such unbalanced parentheses). No error is reported for strings because they are assumed to be free text. Line returns can be forced using '[[\n]]'.

<<variable value checking>>=
STRING => sub { # Value
      my ($_v,undef,undef) = @_;
      defined($$_v) && do {
          $$_v =~ s{[\\]}{\\134}og;
          $$_v =~ s{[\(]}{\\050}og;
          $$_v =~ s{[\)]}{\\051}og;
      }; 
      return $T;
  },
@ %def {STRING}

<<Common Routines>>=
sub tostring() {
    (defined($_[0]) && $_[0] ne '') || return '()';
    $_[0] =~ s{[\(]}{\\050}og;
    $_[0] =~ s{[\)]}{\\051}og;
    return '('.$_[0].')';
}; # tostring
@ %def &tostring

\label{todo:BBG}
<<HIDE: new defs TODO>>=
\def\todoBBG{
Remember to check for some of the strings values such: '++none++', '++sequence++', and so on.
} % todoBBG
@
<<HIDE: TODO>>=
\todoitem{\todoBBG}{todo:BBG}
@
\todo{ \item \todoBBG } % todo


\subsubsctn{Validating numbers}

The following tests look for four different number types.

<<variable value checking>>=
NATURAL => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^\d+$/o && return $T;
      &warn('NOT_A_NATURAL',$F,$_n);
      return $F;
  },
INTEGER => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[+-]?\d+$/o && return $T;
      &warn('NOT_AN_INTEGER',$F,$_n);
      return $F;
  },
FLOAT => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[+-]?(?:\d+(?:\.\d*)?|\.\d+)$/o && return $T;
      &warn('NOT_A_FLOAT',$F,$_n);
      return $F;
  },
REAL => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/o && return $T;
      &warn('NOT_A_REAL',$F,$_n);
      return $F;
  },
@ %def {NATURAL} {INTEGER} {FLOAT} {REAL}

<<warnings - parsing custom files>>=
NOT_A_NATURAL =>
  $Warn."\"\%s\" variable is not a positive integer.\n",
NOT_AN_INTEGER =>
  $Warn."\"\%s\" variable is NOT an integer.\n",
NOT_A_FLOAT =>
  $Warn."\"\%s\" variable is NOT a decimal number.\n",
NOT_A_REAL =>
  $Warn."\"\%s\" variable is NOT a real number (with exponent).\n",
@ %$

\subsubsctn{Looking for color names}

Available colors are shown in section~\ref{sec:CMYKcolordef}, page~\pageref{sec:CMYKcolordef}. Here we check that customization input colors match those defined colors, including 'background' and 'foreground' colors. Color names are NOT case sensitive.

<<variable value checking>>=
COLOR => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      $_l =~ /^b(ack)?g(round)?(color)?/o &&
          ($$_v = 'bg', return $T);
      $_l =~ /^f(ore)?g(round)?(color)?/o &&
          ($$_v = 'fg', return $T);
      defined($COLORS{$_l}) && ($$_v = $_l, return $T);
      &warn('NOT_A_COLOR',$F,$_l,$_n);
      return $F;
  },
@ %def {COLOR}

<<HIDE: DONE>>=
\doneitem{20011107}{Set fg/bg multiple strings to a single color name such fgcolor/bgcolor for later use in the whole program (PS code too).}
@

<<warnings - parsing custom files>>=
NOT_A_COLOR =>
  $Warn."\"\%s\" color not defined in \"\%s\" variable.\n",
@


\subsubsctn{Checking for available fonts and font-sizes}

Font names must be in first capital letter format for {\ps}. 

<<variable value checking>>=
FONT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      defined($Fonts{$_l}) && 
          ($$_v = $Fonts{$_l}, return $T);
      &warn('NOT_A_FONT',$F,$$_v,$_n);
      return $F;
  },
@ %def {FONT}

<<warnings - parsing custom files>>=
NOT_A_FONT =>
  $Warn."Sorry, \"\%s\" font is not defined for \"\%s\".\n",
@

We provide three basic fonts that are standard in most {\ps} devices (a serif, a sans-serif and a monospaced font), and four series for each one (an upright ``normal'', an italic/oblique, a bold, and a bold italic/oblique series). 
\label{sec:FontsHsh}

<<Global Vars>>=
%Fonts = (
    # serif
    times                   => '/Times-Roman',
    'times-roman'           => '/Times-Roman',
    'times-italic'          => '/Times-Italic',
    'times-bold'            => '/Times-Bold',
    'times-bolditalic'      => '/Times-BoldItalic',
    # sans serif
    helvetica               => '/Helvetica',
    'helvetica-oblique'     => '/Helvetica-Oblique',
    'helvetica-bold'        => '/Helvetica-Bold',
    'helvetica-boldoblique' => '/Helvetica-BoldOblique',
    # monospaced
    courier                 => '/Courier',
    'courier-oblique'       => '/Courier-Oblique',
    'courier-bold'          => '/Courier-Bold',
    'courier-boldoblique'   => '/Courier-BoldOblique',
    );
@ 

Font sizes can be given in points, centimeters or inches. If no units are provided, then we asume points, but always must be possitive values (look at '[[PS_UNIT]]' test definition).

<<HIDE: DONE>>=
\doneitem{20011107}{Assign the proper PS unit multiplier. Functions to convert to points/cm/inches, and a hash variable to reformat the values: [[%units]] ([[$units{pt} = ""; $units{cm} = " cm"; $units{mm} = " mm"; $units{in} = " in"]]).
It has been solved by returning a two elements array having the numeric value and the corresponding unit (setting to some default if it is not given).}
\doneitem{20011107}{Can we do the same for SEQ_UNIT ? (section~\ref{sec:DNABASE}).}
@


\subsubsctn{Verifying page-sizes}

A new page bounding-box can be passed through command-line or customization file, we process that case here.

<<variable value checking>>=
BBOX => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my @it = ();
      @it = split /,/og, $_l;
      scalar(@it) != 2 && do {
          &warn('BBOX_NOTOK',$F,$_n,$_l,$_n);
          return $F;
      }; # not enough params
      $TESTS{PS_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      $TESTS{PS_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      $$_v = [ 'userdef', @it ];
      return $T;
  },
@ %def {BBOX}

<<warnings - parsing custom files>>=
BBOX_NOTOK =>
  $Warn."CANNOT understand \"\%s\" set as \"\%s\" ...\n".
  $spw." Format must be: \"\%s=<width>,<height>\" \n",
@ 

Available page sizes are shown in section~\ref{sec:PAGEdef}, page~\pageref{sec:PAGEdef}.

<<variable value checking>>=
PAGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;            
	  defined($FORMATS{$_l}) && ($$_v = $_l, return $T);
      &warn('NOT_A_PAGE',$F,$_l,$$_v);
      return $F;
  },
@ %def {PAGE}

<<warnings - parsing custom files>>=
NOT_A_PAGE =>
  $Warn."\"\%s\" page-size is not defined for \"\%s\" variable.\n",
@

\subsubsctn{Nucleotide coords}

Those numbers relative to DNA positions may be given in bases, kilobases, megabases or gigabases, being last three ones a way to avoid any mistake when a big coord with lots of zeroes is provided. If no units are provided, then we asume bases.

\label{sec:DNABASE}
<<variable value checking>>=
SEQ_UNIT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my $q = undef;
      $_l =~ /^\.$|^\s*$/o && do {
          &warn('NOT_A_NUMBER',$F,$_n);
          return $F;
      };
      $_l =~ s/(?:\.)?
               (?:(g(?:iga)?|m(?:ega)?|k(?:ilo)?)?
               b(?:ase)?
               (?:p(?:air)?)?
               (?:s)?)$
              //ox && ($q = $1);
      defined($q) || do {
          $_l =~ /[^\d]+$/o && do {
               &warn('NOT_A_DNAUNIT',$F,$_n,$$_v);
               return $F;
          };
          $q = '';
      };
      $TESTS{FLOAT}->(\$_l,$_n,$_l) || return $F;
      ($q,undef) = split //o,$q,2;
      $q .= 'bp';
      $$_v = [ $_l, $q ];
      return $T;
  },
@ %def {SEQ_UNIT}

<<warnings - parsing custom files>>=
NOT_A_NUMBER =>
  $Warn."\"\%s\" variable needs a number (with or without units).\n",
NOT_A_DNAUNIT =>
  $Warn."\"\%s\" variable requires nucleotide units.\n".
  $spw." \"\%s\" is not valid (units must be in Gb, Mb, Kb, or bases).\n",
@


\subsubsctn{{\ps} coords}

Those numbers relative to plot positions and font sizes may be given in points, centimeters, milimeters or inches. If no units are provided, then we asume points.

\label{sec:PSCOORDS}

<<variable value checking>>=
PS_UNIT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my $q = undef;
      $_l =~ /^\.$|^\s*$/o && do {
          &warn('NOT_A_NUMBER',$F,$_n);
          return $F;
      };
      PSLEN: {
          $_l =~ s/m(eter(s)?)?$//o && do {
              $_l =~ s/(\.)?c(enti)?$//o   && ($q = 'cm', last PSLEN);
              $_l =~ s/(\.)?m(ili)?$//o    && ($q = 'mm', last PSLEN);
              last PSLEN;
          };
          $_l =~ s/(\.)?in(ch(es)?)?$//o   && ($q = 'in', last PSLEN);
          $_l =~ s/(\.)?(pt|point(s)?)$//o && ($q = 'pt');
      }; # PSLEN
      defined($q) || do {
          $_l =~ /[^\d]+$/o && do {
               &warn('NOT_A_PSUNIT',$F,$_n,$$_v);
               return $F;
          };
          $q = 'pt';
      };
      $TESTS{FLOAT}->(\$_l,$_n,$_l) || return $F;
      $$_v = [ $_l, $q ];
      return $T;
  },
@ %def {PS_UNIT}

<<warnings - parsing custom files>>=
NOT_A_PSUNIT =>
  $Warn."\"\%s\" variable requires PostScript units.\n".
  $spw." \"\%s\" is not valid (units must be in points, cm, mm, or inches).\n",
@


\subsubsctn{Accepting numeric ranges}

A range is a lower/upper limits pair for a given variable. One of the limits, or both, can be an asterisk ('*'), which means that the default value must be used. The result of the range related functions is an array containing two subarrays, one for the start and one for the end, having both two items within, a coord/position and a unit. We can schemmatize that as follows:

\centerline{[[ @output = ( [ start, unit ],  [ end, unit ] ) ]]} 

<<HIDE: DONE>>=
\doneitem{20011107}{Here we must check something like '*..*'.}
@

<<variable value checking>>=
RANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{FLOAT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{FLOAT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {RANGE}

<<variable value checking>>=
PSRANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{PS_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{PS_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {PSRANGE}

<<variable value checking>>=
SEQRANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{SEQ_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{SEQ_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {SEQRANGE}

<<splitting ranges - common code>>=
my @it = ();
@@it = split /\.\./og, $_l;
scalar(@it) != 2 && do {
    &warn('RANGE_NOTOK',$F,$_n,$$_v,$_n);
    return $F;
}; # not enough params
@ 

<<HIDE: test>>=
perl -e 'use Data::Dumper; 
  local $Data::Dumper::Purity = 0;
  local $Data::Dumper::Deepcopy = 1;
  @it = ( "*", [ 1, "cm" ] );
  print Dumper(\@it);
  %hash = ( key1 => "+" );
  print Dumper(\%hash);
  $ref = \$hash{key1};
  $$ref = [ $it[0] eq "*" ? undef : [ @{ $it[0] } ] , [ @{ $it[1] } ], $$ref ];
  print Dumper(\%hash);' 
@ 

If any of the coords was defined with the willcard character '[[*]]', we return an undefined array element where it is needed, so this will make tests easier later.  

<<splitting ranges result - common code>>=
$$_v = [ 
     $it[0] eq '*' ? undef : [ @{ $it[0] } ],
     $it[1] eq '*' ? undef : [ @{ $it[1] } ]
    ];
return $T;
@

<<warnings - parsing custom files>>=
RANGE_NOTOK =>
  $Warn."CANNOT understand \"\%s\" set as \"\%s\" ...\n".
  $spw." Format must be: \"\%s=<lower-value>..<upper-value>\" \n",
@ 

\subsubsctn{Plot features}

<<variable value checking>>=
RIBBON => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      defined($$_v) && do {
          return $$_v;
      };
      return undef;
  },
@ %def {RIBBON}

\newpage

\sctn{Customization Variables Description} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\label{sec:customvardesc}
% \subsctn{Command-line options}

<<HIDE: DONE>>=
\doneitem{20011031}{
Write a script to produce easier the appendix/descriptions tables for the manual from the options code chunks. Transforming to a fixed record formats like:\\
\shortstack[l]{ORDER: ....\\OPTION: ....\\DEFAULTS: ....\\PARAMS: ....\\ SHORT DESC: .... (for the appendix table)\\ LONG DESC: .... (for the description table)}
}
@ 
\label{todo:DDB}
<<HIDE: new defs TODO>>=
\def\todoDDB{
Set the final options/variables/parameters for the whole section.
} % todoDDB
@
<<HIDE: TODO>>=
\todoitem{\todoDDB}{todo:DDB}
@
\todo{ \item \todoDDB } % todo

\subsctn{Reporting program execution}

Two options are used for reporting how program is running. By default no messages are shown to standard error, only errors. One reports to a log file defined by user and the other shows the messages to standard error, both can be activated at the same time. A third one is needed to disable STDERR warnings.

<<command-line options prog>>=
"v|verbose"   => \$Verbose,
@ 
<<command-line help prog>>=
-v, --verbose
      Verbose mode, a full report is sent to standard error 
      (default is set to showing only WARNINGS).
@
<<DESC command-line options>>=
ORD: 3
OPT: v
LNG: verbose
SDE: Verbose mode, a full report is sent to standard error.
LDE:
By default, warnings and errors are sent to standard error. This option 
switches on process reporting messages to appear on standard error too.
###EOR###
@ 


<<command-line options prog>>=
"V|logs-filename=s"  => \$logs_filename,  # Print_Report -> LogFile
@ 
<<command-line help prog>>=
-V, --logs-filename  <filename>
      Report is written to a log file.
@
<<DESC command-line options>>=
ORD: 4
OPT: V
LNG: logs-filename
PAR: <filename>
SDE: Report is written to a log file.
LDE:
If is possible to open <filename> then such file will contain 
all the messages and warnings produced by the program even though they 
were disabled from standard error with [quiet] option.
###EOR###
@ 

<<command-line options prog>>=
"q|quiet"   => \$Quiet,
@
<<command-line help prog>>=
-q, --quiet
      Quiet mode, do not show any message/warning
      to standard error (reporting only ERRORS).
@
<<DESC command-line options>>=
ORD: 5
OPT: q
LNG: quiet
SDE: Quiet mode, messages/warnings disabled (only ERRORS shown).
LDE:
This option disables any message or warning from standard error. It does not 
disable error report because such errors are pointing a problem which can 
make {\prog} produce unexpected results. Solve the cause of such problems 
before continuing to run the program in a silent mode. 
###EOR###
@ 


\subsctn{Layout variables}

\subsubsctn{Page definition}

We do not provide a '[[format_name]]' parameter for [[page_bbox]] variable and related options because if users define a name that already was defined as a function name in the {\ps} code, plot will crash without an obvious error.

<<default layout vars values>>=
# PAGE definition
page_bbox                  => { TYPE => 'BBOX'   , VALUE => undef   },
@ %def {page_bbox}
<<command-line options>>=
"P|page-bbox"   => \$CmdLineVars{LAYOUT}{"page_bbox"},
@ 
<<command-line help>>=
-P, --page-bbox  <width,height>
      Setting a user-defined page size, <width> and
      <height> are set to points if no unit is given,
      you can use pt, mm, cm or in. This option overrides ANY
      'page-size' definition (from command-line or custom file).
@
<<DESC command-line options>>=
ORD: 6
OPT: P
LNG: page-bbox
PAR: <width,height>
EQV: [page_bbox]=<width,height>
SDE: Defining arbitrary page formats.
LDE: 
This option allows users to define an arbitrary page format, by
defining the width and height for that page ({\prog} assigns 
automatically a format name for this new page dimensions). 
See [page_bbox] customization variable on page~\pageref{sec:pagebbox} 
(section~\ref{sec:pagebbox}) for further info on this command-line option.
It overrides any [page-size] command-line option (and any related variable 
passed through custom files). <width> and <height> are set to points 
if no unit is given, now you can use pt, mm, cm or in.
###EOR###
@
<<DESC custom file variables>>=
ORD: 1
SEC: LAYOUT
SUB: PageLayout
OPT: page_bbox
PAR: <width,height>
SDE: Defining arbitrary page formats. Overrides any setting for [page_size].
LDE:
\label{sec:pagebbox}
This variable allows users to define an arbitrary page format, by
defining the width and height for that page ({\prog} assigns 
automatically a format name for this new page dimensions). 
Do not include this variable in your custom files if you are
using standard page sizes which can be set using [page_size], because
[page_bbox] overrides any further page definition by that variable. If
the variable is not set, default value forces the use of any settings
given for [page_size]. <width> and <height> are set to points if no unit is
given, now you can also use points, milimeters, centimeters or inches (pt, 
mm, cm or in, respectively). See table~\ref{tbl:PageSizes} for a reference
on already defined page sizes and their dimensions.
###EOR###
@ 

<<default layout vars values>>=
page_size                  => { TYPE => 'PAGE'   , VALUE => 'a4'    },
@ %def {page_size}
<<command-line options>>=
"p|page-size"   => \$CmdLineVars{LAYOUT}{"page_size"},
@ 
<<command-line help>>=
-p, --page-size  <format_name>
      Setting a page size among pre-defined ones
      (see below for a list of available page formats).
@
<<DESC command-line options>>=
ORD: 7
OPT: p
LNG: page-size
PAR: <format_name>
EQV: [page_size]=<format_name>
SDE: Setting a page size (see table~\ref{tbl:PageSizes}).
LDE:
<format_name> is a pre-defined page format from table~\ref{tbl:PageSizes}. 
By default is set to |a4|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 2
SEC: LAYOUT
SUB: PageLayout
OPT: page_size
DEF: |a4|
PAR: <format_name>
SDE: Sets a standard page size, available format names are listed in table~\ref{tbl:PageSizes}.
LDE:
Setting a standard page size, available values for <format_name> are 
listed in table~\ref{tbl:PageSizes}. Page width and height values are 
coded for most common paper formats.
###EOR###
@ 

\subsubsctn{Page margins}

<<default layout vars values>>=
# Page MARGINS
margin_left                => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_right               => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_top                 => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_bottom              => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
@ %def {margin_left} {margin_right} {margin_top} {margin_bottom}
<<command-line options>>=
"margin-left=s"         => \$CmdLineVars{LAYOUT}{"margin_left"},
"margin-right=s"        => \$CmdLineVars{LAYOUT}{"margin_right"},
"margin-top=s"          => \$CmdLineVars{LAYOUT}{"margin_top"},
"margin-bottom=s"       => \$CmdLineVars{LAYOUT}{"margin_bottom"},
@ 
<<command-line help>>=
--margin-left   <length>
--margin-right  <length>
--margin-top    <length>
--margin-bottom <length>
      Setting each page margin to <length>. If no units are provided,
      points are assumed, you can use points, milimeters, centimeters
      or inches (pt, mm, cm or in, respectively).
@
<<DESC command-line options>>=
ORD: 8
LNG: margin-left
PAR: <length>
EQV: [margin_left]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 3
SEC: LAYOUT
SUB: PageLayout
OPT: margin_left
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 9
LNG: margin-right
PAR: <length>
EQV: [margin_right]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 4
SEC: LAYOUT
SUB: PageLayout
OPT: margin_right
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 10
LNG: margin-top
PAR: <length>
EQV: [margin_top]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 5
SEC: LAYOUT
SUB: PageLayout
OPT: margin_top
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 11
LNG: margin-bottom
PAR: <length>
EQV: [margin_bottom]=<length>
SDE: Setting page margins (default is 1cm each).
LDE: 
You can set page margin with those four variables. <length> can be given in 
points, milimeters, centimeters or inches (pt, mm, cm or in, respectively),
but is set to points if no units are provided.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 6
SEC: LAYOUT
SUB: PageLayout
OPT: margin_bottom
DEF: |1cm|
PAR: <length>
SDE: Setting page margins (default is 1cm each).
LDE: 
You can set page margin with those four variables. <length> can be given in 
points, milimeters, centimeters or inches (pt, mm, cm or in, respectively),
but is set to points if no units are provided.
###EOR###
@ 

\subsubsctn{Page colors}

<<default layout vars values>>=
# Page COLORS			  
background_color           => { TYPE => 'COLOR'  , VALUE => 'white' },
@ %def {background_color}
<<command-line options>>=
"B|background-color=s"  => \$CmdLineVars{LAYOUT}{"background_color"}, # BACKGROUND_COLOR
@ 
<<command-line help>>=
-B, --background-color  <color>    Background color.
@
<<DESC command-line options>>=
ORD: 12
OPT: B
LNG: background-color
PAR: <color>
EQV: [background_color]=<color>
SDE: Setting background color for the page (default is |white|).
LDE: JOIN-NEXT
###EOR###
@ 
% This option sets background color for the page ---say here filling color 
% for whole page---. Available colors are listed on table~\ref{tbl:CMYKcolor},
% default value is |white|.
<<DESC custom file variables>>=
ORD: 7
SEC: LAYOUT
SUB: PageLayout
OPT: background_color
DEF: |white|
PAR: <color>
SDE: Setting background color for the page. Available colors are listed on table~\ref{tbl:CMYKcolor}.
LDE: JOIN-NEXT
###EOR###
@ 

<<default layout vars values>>=
foreground_color           => { TYPE => 'COLOR'  , VALUE => 'black' },
@ %def {foreground_color}
<<command-line options>>=
"F|foreground-color=s"  => \$CmdLineVars{LAYOUT}{"foreground_color"}, # FOREGROUND_COLOR
@ 
<<command-line help>>=
-F, --foreground-color  <color>    Foreground color.
@
<<DESC command-line options>>=
ORD: 13
OPT: F
LNG: foreground-color
PAR: <color>
EQV: [foreground_color]=<color>
SDE: Setting foreground color for the page (default is |black|).
LDE:
You can change background ---say here page filling--- and foreground 
---say here text, outlines and tickmarks--- color for the page. 
Available colors are defined on table~\ref{tbl:CMYKcolor},
default values are |white| and |black|, for background and foreground 
respectively.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 8
SEC: LAYOUT
SUB: PageLayout
OPT: foreground_color
DEF: |black|
PAR: <color>
SDE: Setting foreground color for the page. Find available colors on table~\ref{tbl:CMYKcolor}.
LDE:
These two customization variables accept any <color> from those listed on 
table~\ref{tbl:CMYKcolor}. Default values are |white| and |black| for 
[background_color] and [foreground_color] respectively. These two variables 
also set the aliases [BGcolor] and [FGcolor], so that you can use |bgcolor| and
|bg|, or |fgcolor| and |fg|, to set any other color-related variable with the
same colors you are defining as background/foreground colors.
###EOR###
@ 

\subsubsctn{Figure labels}

<<default layout vars values>>=
# GLOBAL Labels			  
show_title                 => { TYPE => 'BOOLEAN', VALUE => $T     },
title                      => { TYPE => 'STRING' , VALUE => undef  }, # T
@ %def {show_title} {title}
<<command-line options>>=
"T|title=s"  => \$CmdLineVars{LAYOUT}{"title"}, # TITLE
@ 
<<command-line help>>=
-T, --title <string>   Definning plot title.
@
<<DESC command-line options>>=
ORD: 14
OPT: T 
LNG: title
PAR: <string>
EQV: [title]=<string>
SDE: Setting figure title to <string>.
LDE: 
Setting the main title to <string>
for the current figure, by default showing |align_name|
in the form of |sequence1_name| x |sequence2_name|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 9
SEC: LAYOUT
SUB: Labels
OPT: title
PAR: <string>
SDE: Setting figure title to <string>.
LDE: 
[title] sets the main title to <string>
for the current figure, by default showing |align_name|
in the form of |sequence1_name| x |sequence2_name|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 10
SEC: LAYOUT
SUB: Labels
OPT: show_title
DEF: |on|
PAR: <boolean>
SDE: Switching on/off title from plot.
LDE: 
[show_title] switches on/off displaying the figure title. 
If you do not want to visualize the default title you can set this
variable to |off|, but you are not able to reuse the area of plot 
where title appears (set [title_fontsize] to |0| if you want to remove
that area from plot).
###EOR###
@ 
<<default layout vars values>>=
title_font                 => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
title_fontsize             => { TYPE => 'PS_UNIT', VALUE => [ 24, 'pt' ]  },
@ %def {title_font} {title_fontsize}
<<DESC custom file variables>>=
ORD: 11
SEC: LAYOUT
SUB: Labels
OPT: title_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets title font, see available fonts at~\ref{tbl:fontnames}.
LDE: 
###EOR###
ORD: 12
SEC: LAYOUT
SUB: Labels
OPT: title_fontsize
DEF: |24pt|
PAR: <length>
SDE: Sets title fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets title fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [title_fontsize] to |0| forces {\prog} to remove
title area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_subtitle              => { TYPE => 'BOOLEAN', VALUE => $T     },
subtitle                   => { TYPE => 'STRING' , VALUE => undef  }, # ST
@ %def {show_subtitle} {subtitle}
<<command-line options>>=
"t|subtitle=s"  => \$CmdLineVars{LAYOUT}{"subtitle"}, # SUBTITLE
@ 
<<command-line help>>=
-t, --subtitle <string>   Definning plot subtitle.
@
<<DESC command-line options>>=
ORD: 15
OPT: t 
LNG: subtitle
PAR: <string>
EQV: [subtitle]=<string>
SDE: Setting subtitle to <string>.
LDE: 
Setting <string> as the current figure subtitle, by default an empty string.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 13
SEC: LAYOUT
SUB: Labels
OPT: subtitle
PAR: <string>
SDE: Setting subtitle to <string>.
LDE: 
[subtitle] sets the current figure subtitle to <string>, by default
it is defined as an empty string.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 14
SEC: LAYOUT
SUB: Labels
OPT: show_subtitle
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_subtitle] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
subtitle_font              => { TYPE => 'FONT'   , VALUE => 'helvetica'   },
subtitle_fontsize          => { TYPE => 'PS_UNIT', VALUE => [ 16, 'pt' ]  },
@ %def {subtitle_font} {subtitle_fontsize}
<<DESC custom file variables>>=
ORD: 15
SEC: LAYOUT
SUB: Labels
OPT: subtitle_font
DEF: |helvetica|
PAR: <font>
SDE: Sets subtitle font, see available fonts at~\ref{tbl:fontnames}.
LDE: 
###EOR###
ORD: 16
SEC: LAYOUT
SUB: Labels
OPT: subtitle_fontsize
DEF: |16pt|
PAR: <length>
SDE: Sets subtitle fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets subtitle fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_x_label               => { TYPE => 'BOOLEAN', VALUE => $T     },
x_label                    => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_x_label} {x_label}
<<command-line options>>=
"X|x-label=s"  => \$CmdLineVars{LAYOUT}{"x-axis_label"}, # X-Axis_LABEL
@ 
<<command-line help>>=
-X, --x-label <string>   Defining X-axis label.
@
<<DESC command-line options>>=
ORD: 16
OPT: X 
LNG: x-label
PAR: <string>
EQV: [x_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 17
SEC: LAYOUT
SUB: Labels
OPT: x_label
PAR: <string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 18
SEC: LAYOUT
SUB: Labels
OPT: show_x_label
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_x_label] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
x_label_font               => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
x_label_fontsize           => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {x_label_font} {x_label_fontsize}
<<DESC custom file variables>>=
ORD: 19
SEC: LAYOUT
SUB: Labels
OPT: x_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets X-label font, see available fonts at~\ref{tbl:fontnames}.
LDE: 

###EOR###
ORD: 20
SEC: LAYOUT
SUB: Labels
OPT: x_label_fontsize
DEF: |12pt|
PAR: <length>
SDE: Sets X-label fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets X-label fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_y_label              => { TYPE => 'BOOLEAN', VALUE => $T     },
y_label                   => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_y_sequence_label} {y_sequence_label}
<<command-line options>>=
"Y|y-label=s"  => \$CmdLineVars{LAYOUT}{"y-axis_label"}, # Y-Axis_LABEL
@ 
<<command-line help>>=
-Y, --y-label <Y-Label>   Defining Y-axis label.
@
<<DESC command-line options>>=
ORD: 17
OPT: Y
LNG: y-label
PAR: <string>
EQV: [y_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 21
SEC: LAYOUT
SUB: Labels
OPT: y_label
PAR: <string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 22
SEC: LAYOUT
SUB: Labels
OPT: show_y_label
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_x_label] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
y_label_font               => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
y_label_fontsize           => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {y_label_font} {y_label_fontsize}
<<DESC custom file variables>>=
ORD: 23
SEC: LAYOUT
SUB: Labels
OPT: y_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets Y-label font, see available fonts at~\ref{tbl:fontnames}.
LDE: 

###EOR###
ORD: 24
SEC: LAYOUT
SUB: Labels
OPT: y_label_fontsize
DEF: |12pt|
PAR: <length>
SDE: Sets Y-label fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets Y-label fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_percent_box_label     => { TYPE => 'BOOLEAN', VALUE => $T     },
percent_box_label          => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_percent_box_label} {percent_box_label}
<<command-line options>>=
"L|percent-box-label=s"  => \$CmdLineVars{LAYOUT}{"percent_box_label"},
@ 
<<command-line help>>=
-L, --percent-box-label <string>   Defining percent-box label.
@
<<DESC command-line options>>=
ORD: 18
OPT: L
LNG: percent-box-label
PAR: <string>
EQV: [percent_box_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 25
SEC: LAYOUT
SUB: Labels
OPT: show_percent_box_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 26
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
percent_box_label_font     => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
percent_box_label_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {percent_box_label_font} {percent_box_label_fontsize}
<<DESC custom file variables>>=
ORD: 27
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets percent-box main label font.
LDE:

###EOR###
ORD: 28
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets percent-box main label fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_percent_box_sublabel  => { TYPE => 'BOOLEAN', VALUE => $T     },
percent_box_sublabel       => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_percent_box_sublabel} {percent_box_sublabel}
<<DESC custom file variables>>=
ORD: 29
SEC: LAYOUT
SUB: Labels
OPT: show_percent_box_sublabel
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 30
SEC: LAYOUT
SUB: Labels
OPT: percent_box_sublabel
DEF: 
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
percent_box_sublabel_font     => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
percent_box_sublabel_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {percent_box_sublabel_font} {percent_box_sublabel_fontsize}
<<DESC custom file variables>>=
ORD: 31
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets percent-box sublabel font.
LDE:

###EOR###
ORD: 32
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets percent-box sublabel fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_extra_box_label       => { TYPE => 'BOOLEAN', VALUE => $T     },
extra_box_label            => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_extra_box_label} {extra_box_label}
<<command-line options>>=
"l|extra-box-label=s"  => \$CmdLineVars{LAYOUT}{"extra_box_label"},
@ 
<<command-line help>>=
-l, --extra-box-label <XBox-Label>   Definning Extra-Box Label.
@
<<DESC command-line options>>=
ORD: 19
OPT: l
LNG: extra-box-label
PAR: <string>
EQV: [extra_box_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 33
SEC: LAYOUT
SUB: Labels
OPT: show_extra_box_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 34
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
extra_box_label_font       => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
extra_box_label_fontsize   => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {extra_box_label_font} {extra_box_label_fontsize}
<<DESC custom file variables>>=
ORD: 35
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets extra-box main label font.
LDE:

###EOR###
ORD: 36
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets extra-box main label fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_extra_box_sublabel    => { TYPE => 'BOOLEAN', VALUE => $T     },
extra_box_sublabel         => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_extra_box_sublabel} {extra_box_sublabel}
<<DESC custom file variables>>=
ORD: 37
SEC: LAYOUT
SUB: Labels
OPT: show_extra_box_sublabel
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 38
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
extra_box_sublabel_font     => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
extra_box_sublabel_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {extra_box_sublabel_font} {extra_box_sublabel_fontsize}
<<DESC custom file variables>>=
ORD: 39
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets extra-box sublabel font.
LDE:

###EOR###
ORD: 40
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets extra-box sublabel fontsize.
LDE:

###EOR###
@ 


\subsubsctn{Zoom in, zoom out}

The following variables define the boundary/clipping coordinates for each sequence, so you can select a region to be displayed in the {\ps} output.

<<default layout vars values>>=
x_sequence_coords          => { TYPE => 'SEQRANGE', VALUE => undef  },
x_sequence_start           => { TYPE => 'SEQ_UNIT', VALUE => undef  },
x_sequence_end             => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {x_sequence_coords} {x_sequence_start} {x_sequence_end}
<<command-line options>>=
"x|x-sequence-coords=s" => \$CmdLineVars{LAYOUT}{"x_sequence_coords"},
"S|start-x-sequence=i"  => \$CmdLineVars{LAYOUT}{"x_sequence_start"}, # SEQUENCE1_ORIGIN # Zoom_SEQUENCE1_ORIGIN
"E|end-x-sequence=i"    => \$CmdLineVars{LAYOUT}{"x_sequence_end"}, # SEQUENCE1_END    # Zoom_SEQUENCE1_END
@ 
<<command-line help>>=
-x, --x-sequence-coords <pos..pos> 
-S, --start-x-sequence <pos>  Sets X-sequence first nucleotide.
-E, --end-x-sequence <pos>    Sets X-sequence last nucleotide.
@
<<DESC command-line options>>=
ORD: 61
OPT: x
LNG: x-sequence-coords
PAR: <pos..pos>
EQV: [x_sequence_coords]=<pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 62
OPT: S
LNG: start-x-sequence
PAR: <pos>
EQV: [x_sequence_start]=<pos>
SDE: 
LDE: 

###EOR###
ORD: 63
OPT: E
LNG: end-x-sequence
PAR: <pos>
EQV: [x_sequence_end]=<pos>
SDE: 
LDE: 

###EOR###
@ 

[[x_sequence_coords]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 61
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_coords
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 62
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 63
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@
 

<<default layout vars values>>=
y_sequence_coords          => { TYPE => 'SEQRANGE', VALUE => undef  },
y_sequence_start           => { TYPE => 'SEQ_UNIT', VALUE => undef  },
y_sequence_end             => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {y_sequence_coords} {y_sequence_start} {y_sequence_end}
<<command-line options>>=
"y|y-sequence-coords=s" => \$CmdLineVars{LAYOUT}{"y_sequence_coords"},
"s|start-y-sequence=i"  => \$CmdLineVars{LAYOUT}{"y_sequence_start"}, # SEQUENCE2_ORIGIN # Zoom_SEQUENCE2_ORIGIN
"e|end-y-sequence=i"    => \$CmdLineVars{LAYOUT}{"y_sequence_end"}, # SEQUENCE2_END    # Zoom_SEQUENCE2_END
@ 
<<command-line help>>=
-y, --y-sequence-coords <pos..pos> 
-s, --start-y-sequence <pos>  Sets Y-sequence first nucleotide.
-e, --end-y-sequence <pos>    Sets Y-sequence last nucleotide.
@
<<DESC command-line options>>=
ORD: 64
OPT: y
LNG: y-sequence-coords
PAR: <pos..pos>
EQV: [y_sequence_coords]=<pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 65
OPT: s
LNG: start-y-sequence
PAR: <pos>
EQV: [y_sequence_start]=<pos>
SDE: 
LDE: 

###EOR###
ORD: 66
OPT: e
LNG: end-y-sequence
PAR: <pos>
EQV: [y_sequence_end]=<pos>
SDE: 
LDE: 

###EOR###
@ 

[[y_sequence_coords]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 64
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_coords
DEF: |*..*|
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 65
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 66
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
x_sequence_zoom            => { TYPE => 'SEQRANGE', VALUE => undef  },
x_sequence_zoom_start      => { TYPE => 'SEQ_UNIT', VALUE => undef  },
x_sequence_zoom_end        => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {x_sequence_zoom} {x_sequence_zoom_start} {x_sequence_zoom_end}
<<command-line options>>=
"x-sequence-zoom=s"         => \$CmdLineVars{LAYOUT}{"x_sequence_zoom"},
@ 
<<command-line help>>=
--x-sequence-zoom <pos..pos> 
@
<<DESC command-line options>>=
ORD: 67
LNG: x-sequence-zoom
PAR: <pos..pos>
EQV: [x_sequence_zoom]=<pos..pos>
SDE: 
LDE: 

###EOR###
@
% CLO-ORD 69

[[x_sequence_zoom]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 67
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 68
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 69
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
y_sequence_zoom            => { TYPE => 'SEQRANGE', VALUE => undef  },
y_sequence_zoom_start      => { TYPE => 'SEQ_UNIT', VALUE => undef  },
y_sequence_zoom_end        => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {y_sequence_zoom} {y_sequence_zoom_start} {y_sequence_zoom_end}
<<command-line options>>=
"y-sequence-zoom=s"         => \$CmdLineVars{LAYOUT}{"y_sequence_zoom"},
@ 
<<command-line help>>=
--y-sequence-zoom <pos..pos> 
@
<<DESC command-line options>>=
ORD: 70
LNG: y-sequence-zoom
PAR: <pos..pos>
EQV: [y_sequence_zoom]=<pos..pos>
SDE: 
LDE: 

###EOR###
@ 

[[y_sequence_zoom]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]).

<<DESC custom file variables>>=
ORD: 70
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 71
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 72
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
zoom                       => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_area                  => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_marks                 => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_area_mark_width       => { TYPE => 'PS_UNIT', VALUE => [ 2, 'pt' ]  },
zoom_area_mark_color       => { TYPE => 'COLOR'  , VALUE => 'lightred' },
zoom_area_fill_color       => { TYPE => 'COLOR'  , VALUE => undef  },
@ %def {zoom} {zoom_area} {zoom_marks} {zoom_area_mark_color}
<<command-line options>>=
"Z|zoom"                 => \$CmdLineVars{LAYOUT}{"zoom"},
"z|zoom-area"            => \$CmdLineVars{LAYOUT}{"zoom_area"},
@ 
<<command-line help>>=
-Z, --zoom [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ]
               This option zooms an area you have selected
               with -S,-E,-s,-e (all 4 are optional).
-z, --zoom-area [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ]
               This option marks a zoom area on your plot,
               but does not make a zoom.
@
<<DESC command-line options>>=
ORD: 73
OPT: Z
LNG: zoom
EQV: [zoom]=|on|
SDE: 
LDE: 

###EOR###
ORD: 74
OPT: z
LNG: zoom-area
EQV: [zoom_area]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 73
SEC: LAYOUT
SUB: Zoom
OPT: zoom
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 74
SEC: LAYOUT
SUB: Zoom
OPT: zoom-area
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 75
SEC: LAYOUT
SUB: Zoom
OPT: zoom_marks
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 77
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_mark_width
DEF: |2pt|
PAR: <length>
SDE: 
LDE: 

###EOR###
ORD: 78
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_mark_color
DEF: |lightred|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 78
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_fill_color
PAR: <color>
SDE: 
LDE: 

###EOR###
@


\subsubsctn{The aplot layout}

<<default layout vars values>>=
alignment_name            => { TYPE => 'STRING', VALUE => undef     },
x_sequence_name           => { TYPE => 'STRING', VALUE => undef     },
y_sequence_name           => { TYPE => 'STRING', VALUE => undef     },
@ %def {alignment_name} {x_sequence_name} {y_sequence_name}
<<command-line options>>=
"A|alignment-name=s"   => \$CmdLineVars{LAYOUT}{"alignment_name"}, # Align_NAME
"N|x-sequence-name=s"  => \$CmdLineVars{LAYOUT}{"x_sequence_name"}, # X-Sequence_NAME
"n|y-sequence-name=s"  => \$CmdLineVars{LAYOUT}{"y_sequence_name"}, # Y-Sequence_NAME
@ 
<<command-line help>>=
-A, --alignment-name <SeqXName:SeqYName>
     Defining which alignment is going to be plotted 
     if you have more than one alignment in your gff input.
-N, --x-sequence-name <SeqXName>
     Defining which sequence is going to be plotted at X-axis.
-n, --y-sequence-name <SeqYName>
     Defining which sequence is going to be plotted at Y-axis.
@
<<DESC command-line options>>=
ORD: 80
OPT: A
LNG: alignment-name
PAR: <seqXname:seqYname>
EQV: [alignment_name]=<seqXname:seqYname>
SDE: Selects <seqXname:seqYname> alignment.
LDE: 
When you are providing several alignments from input, you can select which one
to be plotted. By default program uses first alignment found in the input 
stream if [x_sequence_name] and [y_sequence_name] were also not defined, else
it will try combining those variables if they are set by user or relying on 
their default values. See [alignment_name] customization variable description
on section~\ref{sec:seqXseqY}, page~\pageref{sec:seqXseqY}, for further info.
It is also explained there but remember that you should take care of unexpected
side effects when setting different sequence names to this command-line option
and its siblings, [x-sequence-name] and [y_sequence_name], if you set one of 
them in a custom file and the others on command-line or viceversa.
###EOR###
ORD: 81
OPT: N
LNG: x-sequence-name
PAR: <seqXname>
EQV: [x_sequence_name]=<seqXname>
SDE: Selects which sequence to plot on X-axis.
LDE: 
You can choose the sequence that is going to be drawn along X-axis, or what
is equivalent, which annotation will appear on that axis. See [alignment-name] 
description to know more about these variables.
###EOR###
ORD: 82
OPT: n
LNG: y-sequence-name
PAR: <seqYname>
EQV: [y_sequence_name]=<seqYname>
SDE: Selects which sequence to plot on Y-axis.
LDE: 
Here you will define which sequence is drawn on Y-axis. Take a look to 
[alignment-name] to get more info about the interactions between these variables.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 80
SEC: LAYOUT
SUB: Aplot
OPT: alignment_name
PAR: <seqXname:seqYname>
SDE: Selects <seqXname:seqYname> alignment (useful when input contain many alignments).
LDE: 
\label{sec:seqXseqY}
When you are providing several alignments from input, you can select which one
to be plotted. By default program uses first alignment found in the input 
stream if [x_sequence_name] and [y_sequence_name] were also not defined, else
it will try combining those variables if they are set by user or relying on 
their default values. The precedence of those variables is the following:
\centerline{<seqXname:seqYname> $\gg$ <seqXname>:<seqYname> $\gg$ <defaults>}
Where <seqXname>:<seqYname> stands for the combination of the values set for
[x_sequence_name] and [y_sequence_name] variables.
If you set [alignment_name] and <seqXname:seqYname> is not found in the list
of read alignments, program tries to find the reverse, <seqYname:seqXname>, 
else no alignment will be drawn. \\
Remember that if you set this variable on 
command-line and the other two in a customization file or viceversa, you will 
get a plot in which sequence annotation along the axes does not correlate to
the alignment shown, so that make sure that you are using all three in a 
coordinated way (although you are looking for that uncorrelated effect, but 
then it will be your fault, do not blame on {\prog}). This can seem a drawback,
but think that it will be very useful if you are parsing GFF input and the 
alignment name was set with different sequence names: say here you have |SeqA|
and |SeqB|, and the alignment sequence name from filtered output after running
those sequences through your alignment program was set to |my_a:my_b| instead
of |SeqA:SeqB|, so you do not have to reformat the GFF records for the 
alignment or the annotation. Following with that example, if nothing else is 
defined, |SeqA| will be drawn on X-axis and |SeqB| on Y-axis. If happens that
|my_a:my_b| (neither in case you already have |SeqA:SeqB|) does not appear on
GFF input, but program finds an alignment named as |my_b:my_a|, then 
annotations will swap on axes, having |SeqA| along Y-axis and |SeqB| on X-axis.
###EOR###
ORD: 81
SEC: LAYOUT
SUB: Aplot
OPT: x_sequence_name
PAR: <seqXname>
SDE: Selects which sequence annotation is going to be plotted on X-axis.
LDE: 
We define which sequence annotation is going to be drawn on X-axis,
having two or more sequences from GFF input.
By default, the program will use the first sequence id from that input (unless
 you have set something different on [alignment_name] or from command-line).
<seqXname> will be the same as <seqYname> (but then you must define both 
variables, [x_sequence_name] and [y_sequence_name]), this is useful when 
comparing a sequence against itself to find repeated elements, but take care 
not doing that when you are trying to compare different sequences because the 
program cannot guess that you do not want to do that.
###EOR###
ORD: 82
SEC: LAYOUT
SUB: Aplot
OPT: y_sequence_name
PAR: <seqYname>
SDE: Selects which sequence annotation is going to be plotted on Y-axis.
LDE: 
This variable allows you to define which sequence is going to be drawn along
the Y-axis. Take a look to [alignment_name] and [x_sequence_name] variables 
descriptions for a deeper explanation of their settings and behaviour. 
###EOR###
@


<<default layout vars values>>=
aplot_xy_same_length       => { TYPE => 'BOOLEAN', VALUE => $T     },
aplot_xy_scale             => { TYPE => 'FLOAT',   VALUE => undef  },
@ %def {aplot_xy_same_length} {aplot_xy_scale}
<<command-line options>>=
"r|aplot-xy-noteq"     => sub { $CmdLineVars{LAYOUT}{"aplot_xy_same_length"} = $F },
"R|aplot-xy-scale=f"   => \$CmdLineVars{LAYOUT}{"aplot_xy_scale"}, 
@ 
<<command-line help>>=
-r, --aplot-xy-noteq
      By default X and Y axes have same length, this option 
      disables such behaviour, so X and Y sequence will have
      axes-lengths proportional to their nucleotide lengths.
-R, --xy-axes-scale  <X/Y ratio>
      This option allows to set a different scale between X
      and Y axes lengths (by default is '1'). Below 1 values
      make Y larger than X, and larger than 1 result in getting
      X larger than Y. # Must be explained better.
@ 
<<DESC command-line options>>=
ORD: 83
OPT: r
LNG: aplot-xy-noteq
EQV: [aplot_xy_same_length]=|off|
SDE: 
LDE: 

###EOR###
ORD: 84
OPT: R
LNG: xy-axes-scale
PAR: <X/Y ratio>
EQV: [aplot_xy_scale]=<X/Y ratio>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 83
SEC: LAYOUT
SUB: Aplot
OPT: aplot_xy_same_length
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 84
SEC: LAYOUT
SUB: Aplot
OPT: aplot_xy_scale
PAR: <X/Y ratio>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
alignment_scale_width      => { TYPE => 'BOOLEAN', VALUE => $F     },
alignment_scale_color      => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {alignment_scale_width} {alignment_scale_color}
<<command-line options>>=
"W|aln-scale-width"    => \$CmdLineVars{LAYOUT}{"alignment_scale_width"}, # APlotLine_ScaleWidth; APlotLine_GroupScore
"w|aln-scale-color"    => \$CmdLineVars{LAYOUT}{"alignment_scale_color"}, # APlotLine_ScaleGrey; APlotLine_GroupScore
@ 
<<command-line help>>=
-W, --aln-scale-width   Scaling score on width for Aplot lines.
-w, --aln-scale-color   Scaling score on color for Aplot lines.
@
<<DESC command-line options>>=
ORD: 85
OPT: W
LNG: aln-scale-width
EQV: [alignment_scale_width]=|on|
SDE: 
LDE: 

###EOR###
ORD: 86
OPT: w
LNG: aln-scale-color
EQV: [alignment_scale_color]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 85
SEC: LAYOUT
SUB: Aplot
OPT: alignment_scale_width
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 86
SEC: LAYOUT
SUB: Aplot
OPT: alignment_scale_color
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
show_ribbons               => { TYPE => 'BOOLEAN', VALUE => $F     },
ribbons_style              => { TYPE => 'RIBBON',  VALUE => undef  },
show_grid                  => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_ribbons} {show_grid}
<<command-line options>>=
"K|show-ribbons=s"   => \$CmdLineVars{LAYOUT}{"ribbons_style"}, # Show_Ribbons (NLRB)
"G|show-grid"        => \$CmdLineVars{LAYOUT}{"show_grid"}, # Display_GRID
# "g"    => \$CmdLineVars{LAYOUT}{""}, # Display_GRID
@ 
<<command-line help>>=
-K, --show-ribbons <ribbon_type>
      Force Ribbons for all features on axes to be:
         (N)one, (L)ines, (R)ibbons, (B)oth.
-G, --show-grid   Switches 'on' grid (default is 'off').
@
<<DESC command-line options>>=
ORD: 87
OPT: K
LNG: show-ribbons
PAR: <ribbon-type>
EQV: [show_ribbons]=<ribbon-type>
SDE: 
LDE: 

###EOR###
ORD: 88
OPT: G
LNG: show-grid
EQV: [show_grid]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 87
SEC: LAYOUT
SUB: Aplot
OPT: show_ribbons
PAR: <ribbon-type>
SDE: 
LDE: 

###EOR###
ORD: 88
SEC: LAYOUT
SUB: Aplot
OPT: show-grid
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
show_percent_box           => { TYPE => 'BOOLEAN', VALUE => $F     },
show_extra_box             => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_percent_box} {show_extra_box}
<<command-line options>>=
"I|show-percent-box"   => \$CmdLineVars{LAYOUT}{"show_percent_box"}, # Display_PERCENT-BOX
"i|hide-percent-box"   => sub { $CmdLineVars{LAYOUT}{"show_percent_box"} = $F }, # Display_PERCENT-BOX
"O|show-extra-box"     => \$CmdLineVars{LAYOUT}{"show_extra_box"}, # Display_EXTRA-BOX
"o|hide-extra-box"     => sub { $CmdLineVars{LAYOUT}{"show_extra_box"} = $F }, # Display_EXTRA-BOX
@ 
<<command-line help>>=
-I, --show-percent-box
      Switches 'on' Percent box (default is 'off').
-i, --hide-percent-box
      Switches 'off' Percent box (if set to 'on' on custom files).
-O, --show-extra-box
      Switches 'on' Extra box (default is 'off').
-o, --hide-extra-box
      Switches 'off' Extra box (if set to 'on' on custom files).
@
<<DESC command-line options>>=
ORD: 89
OPT: I
LNG: show-percent-box
EQV: [show_percent_box]=|on|
SDE: 
LDE: 

###EOR###
ORD: 90
OPT: i
LNG: hide-percent-box
EQV: [show_percent_box]=|off|
SDE: 
LDE: 

###EOR###
ORD: 91
OPT: O
LNG: show-extra-box
EQV: [show_extra_box]=<on>
SDE: 
LDE: 

###EOR###
ORD: 92
OPT: o
LNG: hide-extra-box
EQV: [show_extra_box]=<off>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 91
SEC: LAYOUT
SUB: Aplot
OPT: show_percent_box
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 92
SEC: LAYOUT
SUB: Aplot
OPT: show_extra_box
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
aplot_box_bgcolor          => { TYPE => 'COLOR'  , VALUE => 'bg'   },
percent_box_bgcolor        => { TYPE => 'COLOR'  , VALUE => 'bg'   },
extra_box_bgcolor          => { TYPE => 'COLOR'  , VALUE => 'bg'   },
@ %def {aplot_box_bgcolor} {percent_box_bgcolor} {extra_box_bgcolor}
<<command-line options>>=
"D|aplot-box-color=s"    => \$CmdLineVars{LAYOUT}{"aplot_box_bgcolor"}, # APlotBox_BqGCOLOR
"d|percent-box-color=s"  => \$CmdLineVars{LAYOUT}{"percent_box_bgcolor"}, # PercentBox_BGCOLOR
"b|extra-box-color=s"    => \$CmdLineVars{LAYOUT}{"extra_box_bgcolor"}, # ExtraBox_BGCOLOR
@ 
<<command-line help>>=
-D, --aplot-box-color <color>   Aplot main box background color.
-d, --percent-box-color <color>   Percent box background color.
-b, --extra-box-color <color>   Extra box background color.
@
<<DESC command-line options>>=
ORD: 93
OPT: D
LNG: aplot-box-color
PAR: <color>
EQV: [aplot_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
ORD: 94
OPT: d
LNG: percent-box-color
PAR: <color>
EQV: [percent_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
ORD: 95
OPT: b
LNG: extra-box-color
PAR: <color>
EQV: [extra_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 93
SEC: LAYOUT
SUB: Aplot
OPT: aplot_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 94
SEC: LAYOUT
SUB: Aplot
OPT: percent_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 95
SEC: LAYOUT
SUB: Aplot
OPT: extra_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
percent_box_height        => { TYPE => 'PS_UNIT'  , VALUE => [ -1, 'pt' ] },
extra_box_height          => { TYPE => 'PS_UNIT'  , VALUE => [ -1, 'pt' ] },
@ %def {percent_box_height} {extra_box_height}
<<DESC custom file variables>>=
ORD: 96
SEC: LAYOUT
SUB: Aplot
OPT: percent_box_height
PAR: <length>
SDE: 
LDE: 

###EOR###
ORD: 97
SEC: LAYOUT
SUB: Aplot
OPT: extra_box_height
PAR: <length>
SDE: 
LDE: 

###EOR###
@

\subsubsctn{Tickmarks customization}

<<default layout vars values>>=
show_tickmark_label        => { TYPE => 'BOOLEAN', VALUE => $T     },
show_only_bottom_ticks     => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_tickmark_label} {show_only_bottom_ticks}
<<DESC custom file variables>>=
ORD: 100
SEC: LAYOUT
SUB: Tickmarks
OPT: show_tickmark_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 101
SEC: LAYOUT
SUB: Tickmarks
OPT: show_only_bottom_ticks
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_aplot_x_ticks         => { TYPE => 'BOOLEAN', VALUE => $T     },
show_aplot_y_ticks         => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_aplot_x_ticks} {show_aplot_y_ticks}
<<DESC custom file variables>>=
ORD: 102
SEC: LAYOUT
SUB: Tickmarks
OPT: show_aplot_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 103
SEC: LAYOUT
SUB: Tickmarks
OPT: show_aplot_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_percent_x_ticks       => { TYPE => 'BOOLEAN', VALUE => $T     },
show_percent_y_ticks       => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_percent_x_ticks} {show_percent_y_ticks}
<<DESC custom file variables>>=
ORD: 104
SEC: LAYOUT
SUB: Tickmarks
OPT: show_percent_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 105
SEC: LAYOUT
SUB: Tickmarks
OPT: show_percent_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_extrabox_x_ticks      => { TYPE => 'BOOLEAN', VALUE => $T     },
show_extrabox_y_ticks      => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_extrabox_x_ticks} {show_extrabox_y_ticks}
<<DESC custom file variables>>=
ORD: 106
SEC: LAYOUT
SUB: Tickmarks
OPT: show_extrabox_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 107
SEC: LAYOUT
SUB: Tickmarks
OPT: show_extrabox_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
aplot_major_tickmark       => { TYPE => 'INTEGER', VALUE => undef  },
aplot_minor_tickmark       => { TYPE => 'INTEGER', VALUE => 5      },
aplot_score_range          => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {aplot_major_tickmark} {aplot_minor_tickmark} {aplot_score_range}
<<DESC custom file variables>>=
ORD: 108
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_major_tickmark
DEF: |2|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 109
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 110
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
percent_major_tickmark     => { TYPE => 'INTEGER', VALUE => 5      },
percent_minor_tickmark     => { TYPE => 'INTEGER', VALUE => 5      },
percent_box_score_range    => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {percent_major_tickmark} {percent_minor_tickmark} {percent_box_score_range}
<<DESC custom file variables>>=
ORD: 111
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_major_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 112
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 113
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_box_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
extra_major_tickmark       => { TYPE => 'INTEGER', VALUE => 2      },
extra_minor_tickmark       => { TYPE => 'INTEGER', VALUE => 5      },
extra_box_score_range      => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {extra_major_tickmark} {extra_minor_tickmark} {extra_box_score_range}
<<DESC custom file variables>>=
ORD: 114
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_major_tickmark
DEF: |2|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 115
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 116
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_box_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
major_tickmark_nucleotide  => { TYPE => 'SEQ_UNIT', VALUE => undef  },
minor_tickmark_nucleotide  => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {major_tickmark_nucleotide} {minor_tickmark_nucleotide}
<<DESC custom file variables>>=
ORD: 117
SEC: LAYOUT
SUB: Tickmarks
OPT: major_tickmark_nucleotide
PAR: <nucleotides>
SDE: 
LDE: 

###EOR###
ORD: 118
SEC: LAYOUT
SUB: Tickmarks
OPT: minor_tickmark_nucleotide
PAR: <nucleotides>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
major_tickmark_score       => { TYPE => 'FLOAT', VALUE => undef  },
minor_tickmark_score       => { TYPE => 'FLOAT', VALUE => undef  },
@ %def {major_tickmark_score} {minor_tickmark_score}
<<DESC custom file variables>>=
ORD: 119
SEC: LAYOUT
SUB: Tickmarks
OPT: major_tickmark_score
PAR: <score-step>
SDE: 
LDE: 

###EOR###
ORD: 120
SEC: LAYOUT
SUB: Tickmarks
OPT: minor_tickmark_score
PAR: <score-step>
SDE: 
LDE: 

###EOR###
@ 


%% 
%% The following variables must be set to undef for layout defaults or not
%% (Depending on what rules out the global layout settings or
%% the feature attributes). % VAR-ORD 41-60 : CLO-ORD 20-60
\subsubsctn{Global settings for features}

<<default layout vars values>>=
show_feature_label         => { TYPE => 'BOOLEAN', VALUE => $F          }, 
feature_label_font         => { TYPE => 'FONT'   , VALUE => 'helvetica' },
feature_label_fontsize     => { TYPE => 'PS_UNIT', VALUE => [ 6, 'pt' ] },
@ %def {show_feature_label} {feature_label_font} {feature_label_fontsize}
<<DESC custom file variables>>=
ORD: 141
SEC: LAYOUT
SUB: Labels
OPT: show_feature_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 142
SEC: LAYOUT
SUB: Labels
OPT: feature_label_font
DEF: |helvetica|
PAR: <font>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 143
SEC: LAYOUT
SUB: Labels
OPT: feature_label_fontsize
DEF: |6pt|
PAR: <length>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
feature_x_label_length     => { TYPE => 'INTEGER', VALUE => undef  },
feature_x_label_angle      => { TYPE => 'DEGREES', VALUE => 0      },
feature_x_label_rotate     => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {feature_x_label_length} {feature_x_label_angle} {feature_x_label_rotate}
<<DESC custom file variables>>=
ORD: 145
SEC: LAYOUT
SUB: Labels
OPT: feature_x_label_length
PAR: <char-length>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 145
SEC: LAYOUT
SUB: Labels
OPT: feature_x_label_angle
DEF: |$0^{\,\circ}$|
PAR: <degrees>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 146
SEC: LAYOUT
SUB: Labels
OPT: feature_x_label_rotate
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
feature_y_label_length     => { TYPE => 'INTEGER', VALUE => undef  },
feature_y_label_angle      => { TYPE => 'INTEGER', VALUE => 0      },
feature_y_label_rotate     => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {feature_y_label_length} {feature_y_label_angle} {feature_y_label_rotate}
<<DESC custom file variables>>=
ORD: 150
SEC: LAYOUT
SUB: Labels
OPT: feature_y_label_length
PAR: <char-length>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 151
SEC: LAYOUT
SUB: Labels
OPT: feature_y_label_angle
DEF: |$0^{\,\circ}$|
PAR: <degrees>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 152
SEC: LAYOUT
SUB: Labels
OPT: feature_y_label_rotate
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@ 


\subsubsctn{Global settings for groups}

<<default layout vars values>>=
show_group_label           => { TYPE => 'BOOLEAN', VALUE => $T          }, 
group_label_font           => { TYPE => 'FONT'   , VALUE => 'helvetica' },
group_label_fontsize       => { TYPE => 'PS_UNIT', VALUE => [ 8, 'pt' ] },
@ %def {show_group_label} {group_label_font} {group_label_fontsize}
<<DESC custom file variables>>=
ORD: 161
SEC: LAYOUT
SUB: Labels
OPT: show_group_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 162
SEC: LAYOUT
SUB: Labels
OPT: group_label_font
DEF: |helvetica|
PAR: <font>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 163
SEC: LAYOUT
SUB: Labels
OPT: group_label_fontsize
DEF: |8pt|
PAR: <length>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
group_x_label_length       => { TYPE => 'INTEGER', VALUE => undef  },
group_x_label_angle        => { TYPE => 'DEGREES', VALUE => 0      },
group_x_label_rotate       => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {group_x_label_length} {group_x_label_angle} {group_x_label_rotate}
<<DESC custom file variables>>=
ORD: 164
SEC: LAYOUT
SUB: Labels
OPT: group_x_label_length
PAR: <char-length>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 165
SEC: LAYOUT
SUB: Labels
OPT: group_x_label_angle
DEF: |$0^{\,\circ}$|
PAR: <degrees>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 166
SEC: LAYOUT
SUB: Labels
OPT: group_x_label_rotate
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
group_y_label_length     => { TYPE => 'INTEGER', VALUE => undef  },
group_y_label_angle      => { TYPE => 'INTEGER', VALUE => 0      },
group_y_label_rotate     => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {group_y_label_length} {group_y_label_angle} {group_y_label_rotate}
<<DESC custom file variables>>=
ORD: 170
SEC: LAYOUT
SUB: Labels
OPT: group_y_label_length
PAR: <char-length>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 171
SEC: LAYOUT
SUB: Labels
OPT: group_y_label_angle
DEF: |$0^{\,\circ}$|
PAR: <degrees>
SDE: 
LDE: JOIN-NEXT
###EOR###
ORD: 172
SEC: LAYOUT
SUB: Labels
OPT: group_y_label_rotate
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@ 


\subsubsctn{Miscellanea}

<<default layout vars values>>=
hide_credits               => { TYPE => 'BOOLEAN', VALUE => $F      },
@ %def {hide_credits}
<<command-line options>>=
"a|hide-credits"   => \$CmdLineVars{LAYOUT}{"hide_credits"}, # Show_Credits
@ 
<<command-line help>>=
-a, --hide-credits
      Switch off $PROGRAM credits line on plot.
@
<<DESC command-line options>>=
ORD: 250
OPT: a
LNG: hide-credits
EQV: [hide_credits]=|on|
SDE: Switch off program credits line on plot.
LDE: 

###EOR###
@
<<DESC custom file variables>>=
ORD: 250
SEC: LAYOUT
SUB: General
OPT: hide_credits
DEF: |off|
PAR: <boolean>
SDE: Switch off program credits line on plot.
LDE: 

###EOR###
@


<<Changes in command-line options>>=
# "i"  => # Page_Orientation
# "F"  => \$CmdLineVars{LAYOUT}{""}, # Function_COLOR;Display_FUNCTION;Display_EXTRA-BOX
# "f"  => \$CmdLineVars{LAYOUT}{""}, # Display_FUNCTION; Display_EXTRA-BOX
# "M"  => \$CmdLineVars{LAYOUT}{""}, # Display_GFF; Display_EXTRA-BOX
# "m"  => \$CmdLineVars{LAYOUT}{""}, # Display_GFF-ReverseOrder; Display_EXTRA-BOX
@


\subsctn{Sequence variables}

<<default sequence vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Source variables}

<<default source vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Strand variables}

<<default strand vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Group variables}

<<default group vars values>>=
show_group_label           => { TYPE => 'BOOLEAN', VALUE => $T     }, 
show_group_rule            => { TYPE => 'BOOLEAN', VALUE => $T     },
show_group_arrow           => { TYPE => 'BOOLEAN', VALUE => $T     },
feature_arrows_color       => { TYPE => 'COLOR'  , VALUE => 'fg'   },
Show_JOINS                 => { TYPE => 'BOOLEAN', VALUE => $T     },
Join_Lines_COLOR           => { TYPE => 'COLOR'  , VALUE => 'fg'   },
@


\subsctn{Feature variables}

<<default feature vars values>>=
Show_HalfHeightBOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
HalfSizeBox_BGCOLOR        => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_FullHeightBOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
FullSizeBox_BGCOLOR        => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_BOX_LABEL             => { TYPE => 'BOOLEAN', VALUE => $T     },
Show_UserDef_BOX_LABEL     => { TYPE => 'BOOLEAN', VALUE => $T     },
Show_RIBBON                => { TYPE => 'BOOLEAN', VALUE => $T     },
Ribbon_BGCOLOR             => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_GFF                   => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_GFF_ReverseOrder      => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_FUNCTION              => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_GroupScore       => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_ScaleWidth       => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_ScaleGrey        => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_SELECTION_BOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
SelectionBox_BGCOLOR       => { TYPE => 'COLOR'  , VALUE => 'grey' },
Function_COLOR             => { TYPE => 'COLOR'  , VALUE => 'red'  },
@

\begin{comment}
## ## 
## XTR (bin): Force those <features> for which XTR is switched ON
##   to be displayed in the third panel, if the Plot Option 
##   "Display_EXTRA-BOX" is switched ON.
## ## 
## Box (FHN): Define the box size (FHN) for <feature>.
## ##
## Line (NLRB): Draw lines across all panels for the <feature>.
## ##
## Join (bin): Switch ON to connect elements of one group with splice symbols.
## ##
## Arrw (bin): Swicth ON to display an arrow that shows the <feature>'s strand.
## ##
## Lbl (bin): Swicth ON to display the <feature>'s label
##   (if it's defined in the .gff file).
## ##
## Color (clr): Fill <Box> with this color.
## ##
## CLine (clr): Fill Line <Ribbons> with this color.
## ##
## Wdth (HND): You can choose among three predefined LineWidths.
## ##
## Layr : Layer where is drawed each feature.
##   You must pass an integer for feature ordering (1..n),
##   put 0 to print the feature always on top. 
\end{comment}

<<Changes in custom Vars>>=
# PERCENT_ORIGIN => "50",
# PERCENT_END => "100",
Align_NAME       \
X_Sequence_NAME   >--> To be defined in SOURCE
Y_Sequence_NAME  /
### FL ## FLAGs ##
### DF ## DEFAULT VALUES ##
### OP ## OPTIONs ##
### FT ## GFF FEATUREs DEFINITION ##
  # FTcounter++,
  # FTindex[""]="",
  # FTputEXTRA[""]=OnOff(""),
  # FTBoxType[""]="",
  # FTLineType[""]="",
  # FTputJoin[""]=OnOff(""),
  # FTputArrow[""]=OnOff(""),
  # FTputLabel[""]=OnOff(""),
  # FTLineWidth[""]="",
  # FTLayer[""]="",
  # FTColor[""]=Var["BACKGROUND_COLOR"],
  # FTRbnColor[""]=Var["BACKGROUND_COLOR"],
@ 

<<Changes in custom Vars>>=
### SP ## Special gff Features ##
  # FTGeneBounds="genebounds", NOT NEEDED NOW !!!
  FTLimits="seqbounds",
  FTAPlot="align",
  FTHighLight="boxit",
  FTRectangle="rectangle",
  FTCircle="circle",
  FTText="text",
  FTExtraFunction="function",
  FTExtraDisplay="est",
@
 

\newpage

\sctn{Reading GFF records} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have to deal with two basic formats, the \textsl{standard} General Feature Format (GFF) and the derived \textsl{aplot} format, the former having two versions with some minor differences at field level. We are going to asume the record formats shown in the table~\ref{tbl:formats} for the input files.


\label{todo:EEA}\label{todo:EEB}
<<HIDE: new defs TODO>>=
\def\todoEEA{
A flow chart of the GFF record parsing process (figure~\ref{fig:parsingGFF}).
} % todoEEA
\def\todoEEB{
Move this section to a perl package: \\ suggesting [[gfftools::parser]].
} % todoEEB
@
<<HIDE: TODO>>=
\todoitem{\todoEEA}{todo:EEA}
\todoitem{\todoEEB}{todo:EEB}
@
\todo{ \item \todoEEA 
       \item \todoEEB } % todo


\begin{figure}[!t]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Flow diagram of the input records parsing.]{\label{fig:parsingGFF} Flow diagram of the input records parsing showing the main function names involved in this process.}
\end{center}
\end{figure}

\begin{table}[!t]
% \newcommand{\m}[1]{\multicolumn{2}{@{}c@{}}{#1}}
\begin{center}\setlength{\fboxsep}{10pt}
\fbox{
\begin{minipage}[c]{0.95\linewidth}
\begin{center}
\footnotesize
\textbf{\normalsize Record Format}\\[1ex]
\pa{seqname} \pa{source} \pa{feature} \pa{start} \pa{end} \pa{score} \pa{strand} \pa{frame} [attributes] [comments]\\[2ex]
\renewcommand{\arraystretch}{1.5}\begin{tabular}{ccc}
\textbf{Field Name} & \textbf{GFF Version 1/Version 2} & \textbf{Aplot format} \\
\pa{seqname} & [[ [^\# ]+ ]]     & \pa{seqname1}:\pa{seqname2} \\
\pa{source}  & [[ [^\# ]+ ]]     & \pa{source}[:\pa{source}]   \\
\pa{feature} & [[ [^\# ]+ ]]     & \pa{feature}[:\pa{feature}] \\
\pa{start}   & [[ [+-]?[0-9]+ ]] & \pa{start1}:\pa{start2}     \\
\pa{end}     & [[ [+-]?[0-9]+ ]] & \pa{end1}:\pa{end2}         \\
\pa{score}   & [[ [+-]?[0-9]*[.]?[0-9]*(e[+-]?[0-9]+)? ]] & \pa{alignment\_score}       \\[-1.5ex]
  (no score) & GFFv1 [[=> 0]] / GFFv2 [[=> .]] & . \\
\pa{strand}  & [[ [+-.] ]]  & \pa{strand1}[:\pa{strand2}] \\
\pa{frame}   & [[ [.012] ]] & \pa{frame1}[:\pa{frame2}]   \\[0.5ex]
\textbf{Field Separator} & GFFv1 [[=> \s+ ]] / GFFv2 [[=> [\t]+ ]] & [[ \s+ ]] \\
\end{tabular}\\[4ex]
\textbf{\normalsize Grouping fields}\\[1ex]
\begin{tabular}{rl}
 \,[attributes]  & \hspace{0.25cm}(\textsl{GFF v1\&v2, APLOT})\\
                 & group\_name [extra\_data]\\
                 & "group\_name" [extra\_data]\\
                 & \pa{tag} "group\_name" [extra\_data]\\[1ex]
 \,[extra\_data] & \\
                 & [\,[\pa{start2} \pa{end2} [\pa{strand2}] [\pa{frame2}]\,]; \pa{tag} \pa{value} [ \ldots ; \pa{tag} \pa{value}]\,]\\[2ex]
 \,[attributes]  & \hspace{0.25cm}(\textsl{APLOT old format})\\
                 & group\_name:element\_name [extra\_data]\\[1ex]
 \,[extra\_data] & \hspace{0.25cm}(\textsl{APLOT old format})\\
                 & [\,; \pa{tag} \pa{value} [ \ldots [ ; \pa{tag} \pa{value}]\,]\,]\\
\end{tabular}\\[4ex]
\textbf{\normalsize Other definitions}\\[1ex]
\begin{tabular}{rl}
 \,[comments]    & [[# Whatever extra information about this record...]] \\
\end{tabular}
\end{center}
\end{minipage}
} %fbox
\caption{\label{tbl:formats} Input records format definition for {\prog}.}
\end{center}
\end{table}


Function '[[&parse_GFF_files]]' is only a wrapper for reporting the parsing process over GFF records. The main function call is '[[&fieldscheck]]',which processes each GFF record and loads the values in its fields to the corresponding data structure. Although that, the wrapper checks if there are enough fields (8 required at least) and removes also any comment from the input record, assuming that a white space or a tab followed by a '[[#]]' (as shown in this regular expression: '[[ /\s+\#/ ]]') is a comment mark, from there to the end of line everything is ignored.

<<Parsing Input Data>>=
sub parse_GFF_files() {
    &header("PARSING INPUT GFF RECORDS");
  LOAD: foreach $file (@data_files) {
      open(THIS,"< $file") ||
          (&warn('FILE_NO_OPEN',$T,$file), next LOAD);
      $file eq '-' && ($file = 'STANDARD INPUT');
      &report('READ_GFF_FILE',$file);
      ($n,$c) = (0,undef);
      while (<THIS>) {
          my (@line,$main);
          ($c = '.', next) if /^\#/o;
          ($c = '.', next) if /^\s*$/o;
          chomp;
          # $c = $noGFF;
          ($main,undef) = split /\s+\#/o;
          @line = split /\s+/o, $main, 9;        
          scalar(@line) < 8 &&
              (&warn('NOT_ENOUGH_FIELDS',$F,$file,$n,join(" ",@line)), next);
          $c = &GFF_format(&fieldscheck(\@line));
      } continue {
          &counter(++$n,$c);
      }; # WHILE
      &counter_end($n,$c);
      close(THIS);
  }; # LOAD
    print LOGFILE (Data::Dumper->Dump([ \%GFF_DATA, \%ALN_DATA  ],
                                   [ qw( *GFF_DATA   *ALN_DATA ) ]))
        if ($LogFile && $Debug);
    &footer("DATA LOADED");
} # sub parse_GFF
@ %def &parse_GFF
%$ print LOGFILE '>>> \%GFF_DATA : '.(Dumper(\%GFF_DATA))


We define the following constants, used to report which format was found in the current read record (See table~\ref{tbl:DTkeysXreport}).

\begin{table}[!t]
\begin{center}
\begin{tabular}{cc}
\fbox{
\begin{tabular}[b]{c>{\bfseries}c}
\textbf{Record TYPE} & \textbf{Symbol} \\
Empty record        & . \\
Comment             & . \\
GFF (grouped)       & X \\
GFF (ungrouped)     & x \\
GFF (alignment)     & A \\
GFF (vector)        & V \\
APLOT (grouped)     & O \\
APLOT (ungrouped)   & o \\
Unknown             & ? \\
\end{tabular}
} %fbox
&
\parbox[b]{0.4\linewidth}{
\caption[Symbols used to report record type from data files]{\label{tbl:DTkeysXreport} Symbols used to report record type when parsing input GFF files (and [[STDERR]] verbose mode is enabled with '[[-v]]' switch).}
} % parbox
\\
\end{tabular}
\end{center}
\end{table}

<<Pre-Declared Vars>>=
$GFF $GFF_NOGP $VECTOR $ALIGN $APLOT $APLOT_NOGP $noGFF
@ 
<<Global Constants>>=
($GFF,$GFF_NOGP,$VECTOR,$ALIGN,
    $APLOT,$APLOT_NOGP,$noGFF) =
    qw/ X x V A O o ? /;
@ 

<<warnings - parsing GFF files>>=
NOT_ENOUGH_FIELDS =>
  $Warn."Not enough fields in file \"\%s\", line \%s :\n\t\%s\n",
@ 

<<messages - parsing GFF files>>=
READ_GFF_FILE => 
  $sp."### Reading GFF records from \"\%s\"\n".$sp,
@

We set the character being printed in the parsing status output.

<<Parsing Input Data>>=
sub GFF_format() {
    my $gff = $_[0];
    # return "x" if $GFF == $version1;
    return $GFF        if $gff eq $GFF;        # $version2
    return $GFF_NOGP   if $gff eq $GFF_NOGP;   # $version2 (ungrouped)
    return $VECTOR     if $gff eq $VECTOR;     # VECTOR: GFFv2 particular case 
    return $ALIGN      if $gff eq $ALIGN;      # ALIGN: GFFv2 particular case
    return $APLOT      if $gff eq $APLOT;      # Old aplot format (with colons)
    return $APLOT_NOGP if $gff eq $APLOT_NOGP; # Old aplot format (ungrouped)
    return $noGFF;
} # GFF_format
@ %def &GFF_format
%$

Here we decide to parse records as they are in GFF or in APLOT format. '[[load_gff]]' and '[[load_aplot]]' do the field error checking and load the program variables '[[%GFF_DATA]]' and '[[%ALN_DATA]]'. Those variables are reset in '[[<<Main Loop>>]]'.

<<Parsing Input Data>>=
sub fieldscheck() {
    my ($list) = @_;
    my ($seqname,$start,$end) = @$list[0,3,4]; 
                              # ($list->[0],$list->[3],$list->[4]);
    (&fcolon($seqname) && &fcolon($start) && &fcolon($end)) && do {
        return &load_aplot($list);
    };
    return &load_gff($list);
} # fieldscheck
@ %def &fieldscheck

For historical reasons the program can work with APLOT format (see Table~\ref{tbl:formats}). Initial field checking determines whether the record being processed is under that alignment GFF-like format, by determining that first, fourth and fifth fields contain a colon char. Then we assume we are under APLOT format.

<<Parsing Input Data>>=
sub fcolon() { return ($_[0] =~ /^.+:.+$/o ? $T : $F) }
@ %def &fcolon

\subsctn{Validating fields}

The following functions checks whether some of the input GFF fields are well defined. They return '[[True]]' ('[[$T]]') if no error found and '[[False]]' ('[[$F]]') when input fields are wrong. The returned value forces '[[&load_aplot]]' or '[[&load_gff]]' functions to skip the records having format errors.

Here we test that '\pa{start}' field must be lower or equal than '\pa{end}':

\label{func:checkcoords}
<<Parsing Input Data>>=
sub check_coords() { # ((ori,end)_1,...,(ori,end)_n)
    my @ary = @_;
    for (my $j=0; $j<=$#ary; $j+=2) {
        $ary[$j] > $ary[$j+1] && do {
            &warn('ORI_GREATER_END',$F,$ary[$j],$ary[$j+1],$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_coords
@ %def &check_coords

<<warnings - parsing GFF files>>=
ORI_GREATER_END =>
  $Warn."Start greater than end \"\%s > \%s\" in file \"\%s\" line \"\%s\".\n", 
@

'\pa{strand}' field must contain only '+', '-' or '.' (for records having no strand).

<<Parsing Input Data>>=
sub check_strand() { # (str_1,...,srt_n)
    foreach my $str (@_) {
        $str !~ /[+-.]/o && do {
            &warn('STRAND_MISMATCH',$F,$str,$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_strand
@ %def &check_strand

<<warnings - parsing GFF files>>=
STRAND_MISMATCH =>
  $Warn." Strand mismatch definition \"\%s\" in file \"\%s\" line \"\%s\".\n",
@ 

Same happens to '\pa{frame}', which only '0', '1', '2' or '.' (for those records having no frame) values are allowed.

<<Parsing Input Data>>=
sub check_frame() { # (frm_1,...,frm_n)
    foreach my $frm (@_) {
        $frm !~ /[.012]/o && do {
            &warn('FRAME_MISMATCH',$F,$frm,$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_frame
@ %def &check_frame

<<warnings - parsing GFF files>>=
FRAME_MISMATCH =>
  $Warn." Frame mismatch definition \"\%s\" in file \"\%s\" line \"\%s\".\n",
@ 


\subsctn{Parsing standard GFF format}
\label{sec:parseGFF}

'[[&check_gff_fields]]' will call to the '[[&add_gff_record]]' which loads the new record if everything is OK into '[[%GFF_DATA]]' (see section~\ref{sec:GFFhsh}, page~\pageref{sec:GFFhsh}). The first parameter for '[[&load_grouping]]' function is set to 'True' for GFF grouping definition ('False' is for APLOT grouping definition, see section~\ref{sec:parseAPLOT}). 

<<Parsing Input Data>>=
sub load_gff() { # if errors found > return $noGFF
    my ($list) = @_ ;
    my $w_gff;
    ($seqname,$source,$feature,$start,$end,
     $score,$strand,$frame) = @$list[0,1,2,3,4,5,6,7];
    $w_gff = &load_grouping($T,$list->[8]);
    &check_gff_fields($w_gff) || ($w_gff=$noGFF);
    return $w_gff;
} # load_gff
@ %def &load_gff

<<Global Vars>>=
my ($seqname,$source,$feature,$start,
    $end,$score,$strand,$frame); # GFF temporary vars
@

\subsubsctn{Checking fields and accepting GFF records}

<<Parsing Input Data>>=
sub check_gff_fields() {
    &check_coords($start,$end) || (return $F);
    &check_strand($strand) || (return $F);
    &check_frame($frame) || (return $F);
    &add_gff_record($_[0]);
    return $T; 
} # check_gff_fields
@ %def &check_gff_fields

\begin{table}[!t]
\begin{center}
\input tables/DataStructure_GFF.tex
\caption[GFF internal data structure for {\prog}]{\label{tbl:gffdata} GFF internal data structure for {\prog}. The topmost hash corresponds to '[[%GFF_DATA]]', the others are anonymous lists/hashes expanding from it.}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<HIDE: GFF DATA STRUCTURE>>= 
% DataStructure_GFF.tex
 \newcommand{\arry}[1]{@[\:#1\:]}
 \newcommand{\hash}[1]{\%\{\:#1\:\}}
 \newcommand{\aryrow}[3]{\mbox{#1}_#2 & \Rightarrow & \arry{\arry{\mbox{Counters}}_#2,\:\hash{\mbox{Properties}}_#2,\:\hash{\mbox{#3}}_#2},}
 \newcommand{\aryrowb}[3]{\mbox{#1}_#2 & \Rightarrow & \arry{\arry{\mbox{Counters}}_#2,\:\hash{\mbox{Properties}}_#2,\:\arry{\mbox{#3}}_#2},}
 \newcommand{\tbl}[2]{  
  \% \left\{
  \begin{array}{ccc}
   \aryrow{#1}{0}{#2} \\ 
       & \vdots &     \\
   \aryrow{#1}{n}{#2}  
  \end{array}
  \right\}
  } % \tbl
 \newcommand{\tblb}[2]{  
  \% \left\{
  \begin{array}{ccc}
   \aryrowb{#1}{0}{#2} \\ 
       & \vdots &      \\
   \aryrowb{#1}{n}{#2}  
  \end{array}
  \right\}
 } % \tbl
 \newcommand{\connect}[3]{
   \put(#1,#2){
    \put(0,0){\line(0,-1){0.5}}
    \put(0,-0.5){\line(-1,0){#3}\vector(-1,-2){0.35}}
   } % put
  } % connect
 %
\fbox{
\begin{minipage}[t]{0.975\linewidth}
\unitlength1cm
\begin{picture}(14,19.5)
 \put(7,17.0){\makebox(2,14)[b]{$\tbl{SEQUENCE}{SOURCES}$}}
 \connect{12.75}{16.95}{9.25}
 \put(7,14.0){\makebox(2,14)[b]{$\tbl{SOURCE}{STRANDS}$}}
 \connect{12.50}{13.95}{9.0}
 \put(7,11.0){\makebox(2,14)[b]{$\tbl{STRAND}{GROUPS}$}}
 \connect{12.50}{10.95}{9.0}
 \put(7, 8.0){\makebox(2,14)[b]{$\tblb{GROUP}{ELEMENTS}$}}
 \connect{12.40}{7.95}{9.4}
 \put(7, 5.0){\makebox(2,14)[b]{
   $ @\left[ \begin{array}{c}
   \arry{\mbox{Type},\:\hash{\mbox{Properties}},\:\mbox{GFF-Feature},\:\mbox{ID},\:\mbox{Start},\:\mbox{End},\:\mbox{Score},\:\mbox{Frame}}_0 \\
   \hfill \vdots \hfill \vdots \hfill \vdots \hfill \vdots \hfill \qquad \\
   \arry{\mbox{Type},\:\hash{\mbox{Properties}},\:\mbox{GFF-Feature},\:\mbox{ID},\:\mbox{Start},\:\mbox{End},\:\mbox{Score},\:\mbox{Frame}}_n \\
   \end{array} \right] $
  } % makebox
 } % put
 \put(2,3.75){\line(1,0){12}}
 \put(7,0.5){ \makebox(2,14)[b]{
$ \begin{array}{r@{\quad=\quad}l}
\arry{\mbox{COUNTERS}} & 
(\:\mbox{Order \#},\:\mbox{Elements \#},\:\mbox{Start},\:\mbox{End}\:) \\[2.5ex]
\hash{\mbox{PROPERTIES}} & 
\left\{
 \begin{array}{ccc}
  \mbox{VAR\_NAME}_0 & \Rightarrow & \backslash\mbox{\$VALUE}_0 \\ 
                     &    \vdots   &  \\
  \mbox{VAR\_NAME}_k & \Rightarrow & \backslash\mbox{\$VALUE}_k
 \end{array}
\right\}
\end{array} $ 
  } % makebox
 } % put
\end{picture}
\end{minipage}
} % fbox
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsctn{Parsing APLOT format}
\label{sec:parseAPLOT}

'[[&check_aplot_fields]]' will call to the '[[&add_aplot_record]]' which loads the new record if everything is OK into '[[%ALN_DATA]]' (see section~\ref{sec:APLOThsh}, page~\pageref{sec:APLOThsh}). The first parameter for '[[&load_grouping]]' function is set to 'False' is for APLOT grouping definition ('True' for GFF grouping definition, see section~\ref{sec:parseGFF}). To optimize feature search later, now [[&remove_colon]] can return undefined values; so that, we have to check if [[$strand_2]] and [[$frame_2]] are defined or not, to set the corresponding equivalence, but we do not do the same for [[$source_2]] and [[$feature_2]] (see [[<<select GFF or ALN settings>>]] code chunk to see what we do now when these last two vars were not defined).

<<Parsing Input Data>>=
sub load_aplot() { # if errors found > return $noGFF
    my ($list) = @_;
    my $w_gff;
    ($seqname_1,$seqname_2,$source_1,$source_2,$feature_1,$feature_2,
     $start_1,$start_2,$end_1,$end_2,
     $strand_1,$strand_2,$frame_1,$frame_2) = 
     &remove_colon(@$list[0,1,2,3,4,6,7]);
    defined($strand_2) || ($strand_2 = $strand_1);
    defined($frame_2)  || ($frame_2  = $frame_1 );
    ($score_1,$score_2) = ($list->[5], undef);
    $w_gff = &load_grouping($F,$list->[8]);
    &check_aplot_fields($w_gff) || ($w_gff=$noGFF);
    return $w_gff;
} # load_aplot
@ %def &load_aplot
%$

We reserve [[$score_2]] for other scores than can be passed, we may have bit-scores in '[[score]]' field (so [[$score_1]] will be set to that) and alignment-scores in a tag-value pair found in extra data from grouping fields (we will use them to set [[$score_2]]), or viceversa. Although that could happen, we initialize [[$score_2]] to an undefined value.

<<Global Vars>>=
my ($seqname_1,$seqname_2,
    $source_1,$source_2,$feature_1,$feature_2,
    $start_1,$start_2,$end_1,$end_2,$score_1,$score_2,
    $strand_1,$strand_2,$frame_1,$frame_2); # APLOT temporary vars
my ($tag,$group,$group_id,$label,
    $group_gff_counter,$group_aplot_counter); # GROUPING temporary vars
@ 

\begin{table}[!t]
\begin{center}
\fbox{
\begin{tabular}{c@{\qquad}c}
Strand
\(
\quad\Rightarrow\quad
\left\{
\begin{array}{c@{\quad\Rightarrow\quad}c}
\mbox{[[+]]} & \mbox{[[+:+]]}\\
\mbox{[[-]]} & \mbox{[[-:-]]}\\
\mbox{[[.]]} & \mbox{[[.:.]]}\\
\end{array}
\right.
\)
 &
Frame
\(
\quad\Rightarrow\quad
\left\{
\begin{array}{c@{\quad\Rightarrow\quad}c}
\mbox{[[2]]} & \mbox{[[2:2]]}\\
\mbox{[[1]]} & \mbox{[[1:1]]}\\
\mbox{[[0]]} & \mbox{[[0:0]]}\\
\mbox{[[.]]} & \mbox{[[.:.]]}\\
\end{array}
\right.
\)
 \\
\end{tabular}
} % fbox
\parbox{0.75\linewidth}{
\caption[Retrieving second element when missing in old APLOT format]{\label{tbl:missingfields} For {\prog} old format, when in a '\pa{element1}:\pa{element2}' field pair the second element is missing, second is set to first element.}
} % parbox
\end{center}
\end{table}

When checking for colons, we assume that any element defined without colons is equal to the same value repeated twice (see Table~\ref{tbl:missingfields}). 

<<Parsing Input Data>>=
sub remove_colon() {
    my @ary_out = ();
    my ($a,$b) = (undef,undef);
	foreach my $fld (@_) {
		($a,$b) = split /:/o, $fld, 2;
		push @ary_out, (
            (defined($a) ? $a : '.'  ),
            (defined($b) ? $b : undef)
            );
	};
	return @ary_out;
} # remove_colon
@ %def &remove_colon
%$

\subsubsctn{Checking fields and accepting APLOT records}

If records are OK, then we can append a new record to the variable defined for APLOT records (so called as '[[%ALN_DATA]]' in table~\ref{tbl:alndata}, page~\pageref{tbl:alndata}). \label{sec:APLOThsh}

<<Parsing Input Data>>=
sub check_aplot_fields() {
    &check_coords($start_1,$end_1,$start_2,$end_2) || (return $F);
    &check_strand($strand_1,$strand_2) || (return $F);
    &check_frame($frame_1,$frame_2) || (return $F);
    &add_gff_record($_[0]);
    return $T; 
} # check_aplot_fields
@ %def &check_aplot_fields

\begin{table}[!t]
\begin{center}
% \input tables/DataStructure_ALN.tex
\caption[Internal data structure to store alignments]{\label{tbl:alndata} Alignment data structure, so called '[[%ALN_DATA]]', has same structure as '[[%GFF_DATA]]' shown in table~\ref{tbl:gffdata}. Here we only show the small differences between them.}
\end{center}
\end{table}

\label{todo:ELA}
<<HIDE: new defs TODO>>=
\def\todoELA{
DATA STRUCTURE for [[%ALN_DATA]] was defined:
Include a figure if differs from [[%GFF_DATA]] definition (table~\ref{tbl:alndata}).
} % todoELA
@
<<HIDE: TODO>>=
\todoitem{\todoELA}{todo:ELA}
@
\todo{ \item \todoELA } % todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<HIDE: ALN DATA STRUCTURE>>= 
% DataStructure_ALN.tex
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsctn{Loading records to GFF/ALN hashes}

<<HIDE: DONE>>=
\doneitem{20011113}{Append a new record to the variable defined for APLOT records.}
@

Once fields checking is done, we proceed to load the data structure defined for the GFF records or for the ALIGNMENT ones, we have merged the loading functions for both record types in the current version because they shared many common structures. 

In the first case we have to add the new record into '[[%GFF_DATA]]' hash, the outline of the inner structure of that variable is shown in table~\ref{tbl:gffdata}, page~\pageref{tbl:gffdata}. \label{sec:GFFhsh}
On the other hand, ALIGMENT records need a pre-processing of some of the fields before being ready to fill '[[%ALN_DATA]]' hash, table~\ref{tbl:alndata} in page~\pageref{tbl:alndata} summarizes the differences between this record type and the GFF one. \label{sec:ALNhsh}

<<Parsing Input Data>>=
sub add_gff_record() {
    my $_gff = $_[0];
    my ($VarName,$Counter,$Type,$isaln,$myfunc,$t);
    <<select GFF or ALN settings>>
    &load_var($seqname,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = (
        \%{$VarName->{$seqname}[$_element]},
        \$$VarName{$seqname}[$_counter][$_elemNum],
        'SOURCE' );
    &load_var($source,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = ( 
        \%{$VarName->{$source}[$_element]},
        \$$VarName{$source}[$_counter][$_elemNum],
        'STRAND' );
    &load_var($strand,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = (
        \%{$VarName->{$strand}[$_element]},
        \$$VarName{$strand}[$_counter][$_elemNum],
        'GROUP' );
    &load_var($group,$VarName,$Counter,$Type,$myfunc);
    <<adding new feature elements>>
    return;
} # add_gff_record
@ %def &add_gff_record

If the standard GFF alignment format is found, we process those records as if they were aplot records, so that we have to set all the variables required to fill such data structure. We solve that by setting the same variables when loading those standard GFF alignment records as we do when loading aplot records, then they can share the same processes that are switched on by [[$isaln]].
% ('[[&add_aplot_record]]' is described in section~\ref{func:loadalnvar}, page~\pageref{func:loadalnvar})

<<select GFF or ALN settings>>=
$isaln = ($_gff =~ /$ALIGN|$APLOT|$APLOT_NOGP/o) ? $T : $F;
ISALN: {
    $isaln && do {
        $myfunc = \&load_aln_var;
        ($VarName,$Counter,$Type) = (
            \%ALN_DATA,
            \$aln_COUNT,
            'SEQUENCE' );
        $seqname = join(":", $seqname_1, $seqname_2);
        $source  = defined($source_2)
                   ? join(":", $source_1, $source_2)
                   : $source_1;
        $strand  = $strand_1.$strand_2;
        $feature = defined($feature_2) 
                   ? join(":", $feature_1, $feature_2)
                   : $feature_1;
        last ISALN;
    }; # $isaln
    $myfunc = \&load_gff_var;
    ($VarName,$Counter,$Type) = (
        \%GFF_DATA,
        \$seq_COUNT,
        'SEQUENCE' );
}; # ISALN
@ 

First we load the plain GFF attributes for a given record, when such record is defining a vector we add a new element to the feature anonymous array. That element is a list of the scores provided by the '[[&load_GFF_vector]]' function defined in section~\ref{sec:loadvector}, page~\pageref{sec:loadvector}.

<<adding new feature elements>>=
LDALN: {
    $isaln && do {
        push @{$VarName->{$group}[$_element]},
            [
              'A',       # Type == ALIGNMENT
        	  {},        # Properties hash, now empty
              $feature,  # GFF feature (3rd field)
              $label,    # Record ID if exist, order# otherwise
              $start_1, $end_1, $score_1, $frame_1,
              $start_2, $end_2, $score_2, $frame_2,
            ];
        last LDALN;
    }; # $isaln
    my $first_fld = ($_gff eq $VECTOR) ? 'V' : 'G';
    push @{$VarName->{$group}[$_element]},
        [
          $first_fld,      # Type == plain GFF or vector
    	  {},              # Properties hash, now empty
          $feature,        # GFF feature (3rd field)
          $label,          # Record ID if exist, order# otherwise
          $start, $end, $score, $frame,
        ];
    $_gff eq $VECTOR && do {
    	@{$VarName->{$group}[$_element][8]} = [ @vect_ary ];
    };
}; # LDALN
$t = ++$VarName->{$group}[$_counter][$_elemNum];
&set_var_defaults('FEATURE',
                  \%{$VarName->{$group}[$_element][($t-1)][$_prop]});
@ 

We declare here auxiliary variables containing the array indexes used in the anonymous arrays defined within the main variables containing all the GFF data ([[%GFF_DATA]], that was declared in section~\ref{sec:GFFhsh}, page~\pageref{sec:GFFhsh}), and the alignment data ([[%ALN_DATA]], that was declared in section~\ref{sec:APLOThsh}, page~\pageref{sec:APLOThsh}).

<<Pre-Declared Vars>>=
$aln_COUNT $seq_COUNT
$_counter $_prop $_element
$_order $_elemNum $_ori $_end $_flw $_glw
        $_mnsco $_mxsco $_nori $_nend
$_fttype $_ftprop $_ftname $_ftid
         $_ftori  $_ftend  $_ftsco  $_ftfrm
         $_ftnori $_ftnend $_ftnsco $_ftnfrm
@ 

<<Global Vars>>=
($_counter,$_prop,$_element) = (0..2);
($_order,$_elemNum,$_ori,$_end,
 $_mnsco,$_mxsco,$_flw,$_glw,$_nori,$_nend) = (0..9);
($_fttype,$_ftprop,$_ftname,$_ftid,
 $_ftori, $_ftend, $_ftsco, $_ftfrm,
 $_ftnori,$_ftnend,$_ftnsco,$_ftnfrm) = (0..11);
@ 

<<Parsing Input Data>>=
sub load_var() {
    my ($_value,$_var,$_cnt,$_type,$_frf) = @_;
	defined($$_var{$_value}) || do {
		$$_var{$_value}[$_counter] = &$_frf(++$$_cnt);
		&set_var_defaults($_type,\%{$$_var{$_value}[$_prop]});
	};
	return;
} # load_var
@ %def &load_var
%$

\label{func:loadgffvar} \label{func:loadalnvar}
<<Parsing Input Data>>=
sub load_gff_var() { return [ $_[0], (0) x 7 ]; }
sub load_aln_var() { return [ $_[0], (0) x 9 ]; }
@ %def &load_gff_var &load_aln_var

We initialize properties for each new element as references to '[[%DefaultVars]]' given level corresponding values. 

<<Parsing Input Data>>=
sub set_var_defaults() {
    my ($sect,$varhash) = @_;
    <<P.I.D: set reference to all properties>>
	return;
} # set_var_defaults
@ %def &set_var_defaults

We can set default properties of GFF elements in two ways: making a reference to the default properties hash for that element, as shown in the [[<<P.I.D: set reference to all properties>>]], or reference each variable from the properties hash to a new key, as described in [[<<P.I.D: set reference for each property>>]].

\label{sec:DATAdefaultvars}
<<P.I.D: set reference to all properties>>=
# $$varhash = \%{$Defaults{$sect}};
@

<<P.I.D: set reference for each property>>=
foreach my $nm (keys %{$DefaultVars{$sect}}) {
    $$varhash{$nm} = \$DefaultVars{$sect}{$nm}{'VALUE'};
}; # foreach $nm
@

We choose the first approach, and we will replace the hash reference by the keys with references to defaults if needed when setting variables from custom parameters for a given GFF element (see section~\ref{sec:mapcustoms}, page~\pageref{sec:mapcustoms}). That choice will save memory used by the elements properties if user does not customize any of the element properties, but requires a temporary default variable (due to the special structure of the [[%DefaultVars]] hash which contains not only default variable values but also variable type), named [[%Defaults]] and defined in section~\ref{sec:tmpdefaults}, page~\pageref{sec:tmpdefaults}.


\subsctn{Parsing grouping attributes}

'[[GFF_CHOICE]]' block sets some variables depending on the record format, standard GFF or APLOT GFF-like. Once we have the attribute string from the GFF/APLOT record, we first check if it is empty, then we split by semicolons which will have or not white spaces or tabs before and/or after, as shown in this regular expression:\\
\centerline{'[[/\b\s*;\s*\b/]]'}\\
This will define tag-value pairs (and maybe some extra fields).  

<<Parsing Input Data>>=
sub load_grouping() {
    my ($_type,$attributes) = @_;
    my ($grp_string,$grp_counter,$grp_GP,$grp_NOGP,$grp_tag);
  GFF_CHOICE: {
    $_type && do { 
        $grp_string = "$seqname\_$source\_$strand";
        $grp_counter = ++$group_gff_counter;
        $grp_GP = $GFF;
        $grp_NOGP = $GFF_NOGP;
        $grp_tag = '';
        last GFF_CHOICE;
    };
    $grp_string = "$seqname_1\_$seqname_2\_$source_1\_$strand_1$strand_2";
    $grp_counter = ++$group_aplot_counter;
    $grp_GP = $APLOT;
    $grp_NOGP = $APLOT_NOGP;
    $grp_tag = $Vars{LAYOUT}{align_tag}; # %SOURCE is a temporary hash name
  };
    $label = $group_id = $grp_counter;
    defined($attributes) || do {
        $group = "$grp_string\_$group_id";
	    return $grp_NOGP;
    };
    my @grouping_list = ();
    @grouping_list = split /\b\s*;\s*\b/o, $attributes;
	<<parse grouping attributes>>
	<<parse other attributes>>
    return $grp_GP;
} # load_grouping
@ %def &load_grouping

We may find four basic grouping field structures (detailed in Table~\ref{tbl:formats}) within the first element of '[[@grouping_list]]'. We check first for double-quotes in the first or second field within that element. If second field is double-quoted, the first field is set as 'Tag' and the quoted as 'Value', else 'Tag' is set to default value (empty string for GFF records and 'target' for APLOT GFF-like ones) and 'Value' is set with the first field. Then we are looking in GFF grouping attributes for extra fields defining start, end, strand and frame (all related to the second sequence); in APLOT GFF-like format, those values are deprecated (because they must be defined in the first eight fields following the first sequence values and a colon as shown in table~\ref{tbl:formats}). 

<<parse grouping attributes>>=
my $grp_flag = 0;
my @new_group = ();
my $groupregexp = '^(.*?)(?:"(.+?)"(?:\s+\b(.*))?)?$'; #'
my $group_string = shift @grouping_list;
($group_string =~ /$groupregexp/o) && 
    (@new_group = ($1,$2,$3));
$new_group[0] =~ s/\b\s*$//o;
$new_group[0] || do {  # type 2 attributes
    $grp_flag = 1;
    $new_group[0] = $grp_tag;
};
$new_group[1] || do {  # type 1 attributes
    $grp_flag = 1;
    $new_group[1] = $new_group[0];
    $new_group[0] = $grp_tag;
};
($tag,$group) = (lc($new_group[0]),$new_group[1]);
# Here looking for colon field separator in aplot GFF-like grouping
($grp_flag && $group =~ /^(.*?):(.*?)$/o) && (($group,$label) = ($1,$2));
@ %$

Here we look for other attribute fields, those defining coords for the target sequence match in standard GFF format and those defining a scoring vector, both formats are explained more in detail in the following two subsections.

<<parse other attributes>>=
$_type && do { # GFF grouping
    $tag =~ /$Vars{LAYOUT}{align_tag}/ && do {
        &load_GFF_align;
        return $ALIGN;
    }; 
    $tag =~ /$Vars{LAYOUT}{vector_tag}/ && do {
        &load_GFF_vector;
        return $VECTOR;
	};
};
@ 

We are interested in finding 'id' tag, that defines the label for a single record, this is implemented in the '[[&load_GFF_align]]' and '[[&load_GFF_vector]]'functions but has to be parsed in plain GFF records.

<<parse other attributes>>=
scalar(@grouping_list) > 0 && do{ 
    foreach my $element (@grouping_list) {
        ($element =~ /$groupregexp/o) && (@new_group = ($1,$2,$3));
        lc($new_group[0]) =~ /$Vars{LAYOUT}{label_tag}/ && do {
            $label = $new_group[1];
            $label eq "" && do {
                (undef,$label,undef) = split /\s+/og, $new_group[0];
            };
        };
    };
};
@

\subsubsctn{Layout variables involved in grouping tags}

<<default layout vars values>>=
align_tag                  => { TYPE => 'ALPHA', VALUE => 'target'   },
vector_tag                 => { TYPE => 'ALPHA', VALUE => 'vector'   },
label_tag                  => { TYPE => 'ALPHA', VALUE => 'id'       },
@ %def {align_tag} {vector_tag} {label_tag}
<<DESC custom file variables>>=
ORD: 240
SEC: LAYOUT
SUB: General
OPT: align_tag
DEF: |target|
PAR: <tag>
SDE: 
LDE: 
[align_tag] holds the specific tag (for a grouping Tag-Value pair) to detect 
those GFF records coding for alignment data and having the following group 
structure:\\%{1ex%} \n\
\centerline{
 \shortstack%{r%}{align_tag "group_name" <seq2_start> <seq2_end> 
   %{ ; Strand <seq2_strand> \eoline\\\,%{ ; Frame <seq2_frame> %{ ; 
        E_value <score> %}\,%}\,%}\hspace{3ex}
  }
 }\\%{0.75ex%} \n\
so the program can recover the coords for the target sequence from the 
grouping fields. Remember that tags are not case-sensitive. 
###EOR###
ORD: 241
SEC: LAYOUT
SUB: General
OPT: vector_tag
DEF: |vector|
PAR: <tag>
SDE: 
LDE: 
[vector_tag] sets the specific tag (for a grouping Tag-Value pair) to detect 
scoring vector GFF records, which have the following group structure:
\\%{1ex%} \n\
\centerline{
 \shortstack%{r%}{vector_tag "group_name" <vector_type> %{ ;
   Window <window_length> \eoline\\\, %{ ; Step <step_length> %}\,%} ;
   Scores <score$%-0$> ... <score$%-n$>\hspace{3ex}
  }
  }\\%{0.75ex%} \n\
so the program can parse the list of single scores from the grouping fields. 
Remember that tags are not case-sensitive.
###EOR###
ORD: 242
SEC: LAYOUT
SUB: General
OPT: label_tag
DEF: |id|
PAR: <tag>
SDE: 
LDE: 
[label_tag] sets the specific tag (for a grouping Tag-Value pair) that allows 
to identify a single record. The program looks for the grouping Tag-Value pair 
for which the tag matches [label_tag] and takes <value> as the specific record 
label. You must have an attribute like this within the grouping attribute list:
\\%{0.75ex%} \n\
\centerline{
  \ldots ; label_tag "element_label" %{ ; \ldots %}
  }\\%{0.5ex%} \n\
Using this attribute makes easy to set specific properties for one or more 
elements. Remember that tags are not case-sensitive.
###EOR###
@


The following record formats share the field structure of a GFF standard record, but there are special tags in the grouping fields containing data that will be used by {\prog}. Both formats require a fixed tag string (by default 'Vector' for the scoring vectors and 'Target' for the alignment data), which can be redefined by users from custom files.

<<HIDE: DONE>>=
\doneitem{20011113}{[[%SOURCE]] is a \textbf{provisional varname} that must be replaced by the corresponding [[$DefaultVars{LAYOUT}]], [[$CustomVars{LAYOUT}]] or [[$CmdLineVars{LAYOUT}]]. Those 'LAYOUT' variables must be set before reading GFF input files because some settings are used by parser functions.}
@

\subsubsctn{Parsing alignment records}

\label{todo:ERA}
<<HIDE: new defs TODO>>=
\def\todoERA{
Parsing alignment records:\\
\centerline{[[aln_tag "value" target_ori target_end target_frame target_strand (...)]]}
} % todoERA
@
<<HIDE: TODO>>=
\todoitem{\todoERA}{todo:ERA}
@
\todo{ \item \todoERA } % todo

<<Parsing Input Data>>=
sub load_GFF_align() {

} # load_GFF_align
@ %def &load_GFF_align

\subsubsctn{Parsing scoring vectors} \label{sec:loadvector}

\label{todo:EVA}
<<HIDE: new defs TODO>>=
\def\todoEVA{
Parsing scoring vectors:\\
\centerline{[[vector_tag "value" vector_type; step value; window value; scores sco ... sco]]}
} % todoEVA
@
<<HIDE: TODO>>=
\todoitem{\todoEVA}{todo:EVA}
@
\todo{ \item \todoEVA } % todo

<<Parsing Input Data>>=
sub load_GFF_vector() {
	@vect_ary = ();
} # load_GFF_vector
@ %def &load_GFF_vector

<<Global Vars>>=
my @vect_ary;
@ 


\newpage

\sctn{Mapping custom features to figure elements} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<HIDE: DONE>>=
\doneitem{20011113}{Set variable mapping for [[%ALN_DATA]] elements.}
@

\subsctn{Mapping customization variables to working variable}

We define here [[&merge_custom_vars]] to combine customization
parameters from [[%CmdLineVars]] and [[%CustomVars]] into [[%Vars]]
before start parsing GFF input files. The main reason to do this
variable mapping at this point is that there are some LAYOUT variables
that are used when parsing the GFF records (basically
[[align_tag]],[[vector_tag]] and [[label_tag]]). Another reason is
that from now on, we only have to take care of a single variable,
which summarizes all the settings from different inputs, say here the
program built-in defaults, the custom files and the command-line
options. The values set on command-line override those from custom
files and those set from custom files override defaults. We are going
to concatenate each element-value pairs for each variable (not for the
layout variables but for all the rest), so that we will have a
variable name reference linked to a list of element-value pairs, which
will be used when mapping those values for a given element in the data
variables. When loading variables, defaults are set to [[%Defaults]]
(see section~\ref{sec:DATAdefaultvars},
page~\pageref{sec:DATAdefaultvars}), so we only take care here of
those values that are redefined by user (we do not use [[%DefaultVars]] because we already checked variable values and [[%Defaults]] variable has a simpler structure than it).

<<Features Setting>>=
sub merge_custom_vars() {
    &header("MAPPING CUSTOMIZATION INPUTS TO MAIN VARS");
    <<setting layout variables>>
    <<setting non-layout variables>>
    print LOGFILE (Data::Dumper->Dump([ \%Vars ],
                                   [ qw( *Vars ) ]))
        if ($LogFile && $Debug);
    &footer("VALUES SET for MAIN VARS");
} # merge_custom_vars
@ %def &merge_custom_vars

Layout variables are simpler than the rest, they are defined as a key-value pair, so that mapping is straightforward.

<<setting layout variables>>=
foreach my $var_name (keys %{ $Defaults{LAYOUT} }) {
    defined($CmdLineVars{LAYOUT}{$var_name}) && do {
        $Vars{LAYOUT}{$var_name} = $CmdLineVars{LAYOUT}{$var_name};
        next;
    };
    defined($CustomVars{LAYOUT}{$var_name}) && do {
        $Vars{LAYOUT}{$var_name} = $CustomVars{LAYOUT}{$var_name};
        next;
    };
    $Vars{LAYOUT}{$var_name} = $Defaults{LAYOUT}{$var_name};
}; # foreach $var_name
@ 

For the rest of variable classes (SEQUENCE, SOURCE, STRAND, GROUP and
FEATURE), which are defined as an element-key-value triad, we can have
more than one element and with a different value settings, for each
key (say here variable name). We store that information in a list. We
know that every three values of the list we have a variable definition
for a given element and if it is a negation or not (i.e., see
section~\ref{sec:DATAtriadarray}, page~\pageref{sec:DATAtriadarray},
for its definition in [[%CustomVars]]). The structure of that subset
of the list is squetched here:\\

\centerline{\ldots , 'negate regexp flag', 'element regular expression', 'variable value' , \ldots}

<<setting non-layout variables>>=
foreach my $_sec (keys %Defaults) {
    $_sec eq 'LAYOUT' && next; # skip layout variables
    foreach my $_var (keys %{$Defaults{$_sec}}) {
        defined($CustomVars{$_sec}{$_var}) && do {
            push @{ $Vars{$_sec}{$_var} }, @{ $CustomVars{$_sec}{$_var} };
        }; # defined($CustomVars{$_sec}{$_var})
        defined($CmdLineVars{$_sec}{$_var}) && do {
            push @{ $Vars{$_sec}{$_var} }, @{ $CmdLineVars{$_sec}{$_var} };
        }; # defined($CustomVars{$_sec}{$_var})        
	}; # foreach $vnm
}; # foreach $sct
@ 

Here we load the custom files definitions before the command-line ones, because for those variables in [[%Vars]] ordering is important, and later definitions in the array will override previous ones. 

\subsctn{Mapping customization to GFF elements}

Once we have set the variables from different sources as we did in the previous section, and once we loaded the GFF data from input files, we have to assign the corresponding settings to each GFF element. Defaults were already set as a reference to [[%Defaults]] hash (see section~\ref{sec:DATAdefaultvars}, page~\pageref{sec:DATAdefaultvars}). Perhaps this will be the most time consuming function of the program as we have to traverse all the variables for each class (if they are set in [[%Vars]], which will save much of that time if they are not defined) throught all the GFF elements.
\label{sec:mapcustoms}

<<Features Setting>>=
sub map_vars_data() {
    &header("SETTING CUSTOM VALUES TO GFF ELEMENTS");
    foreach my $v_sec (keys %Vars) {
        $v_sec eq 'LAYOUT' && next; # skip layout variables
        foreach my $v_var (keys %{$Vars{$v_sec}}) {
            my @v_values = @{ $Vars{$v_sec}{$v_var} };
            for (my $foo = 0; $foo < $#v_values; $foo+=4) {
                my @tl = @v_values[$foo..($foo + 3)];
                &map_vars_to_GFF(\%GFF_DATA,$v_sec,$v_var,@tl);
                &map_vars_to_GFF(\%ALN_DATA,$v_sec,$v_var,@tl);
            }; # for $foo
	    }; # foreach $vnm
    }; # foreach $sct
    print LOGFILE (Data::Dumper->Dump([ \%GFF_DATA, \%ALN_DATA ], 
                                   [ qw( *GFF_DATA   *ALN_DATA ) ]))
        if ($LogFile && $Debug);
    &footer("VALUES SET for GFF ELEMENTS");
} # map_vars_data
@ %def &map_vars_data

We have to set the properties hash corresponding to the GFF elements present in the current section (say here SEQUENCE, SOURCE, STRAND, GROUP or FEATURE). To do that we have to define a reference to that anonymous hash and also retrieve the element string ([[$element]]) to check if it match to the regular expression ([[$reg_exp]]) which determines if the variable of that element is re-assigned to the current value ([[$the_value]]).

<<Features Setting>>=
sub map_vars_to_GFF() {
    my ($mainref,  $v_sec,   $v_var,
        $neg_flg, $id_flg, $reg_exp, $the_value, $name_test) = @_;
    $name_test = $neg_flg ? \&match_regexp_neg : \&match_regexp;
    foreach my $seq (keys %{ $mainref }) {
        my $seq_ref = \@{ $mainref->{$seq} };
        $v_sec eq 'SEQUENCE' && do {
            &does_feat_match($name_test,$seq,$reg_exp,$seq_ref,
                             $_prop,$v_sec,$v_var,$the_value);
            next;
        };
        <<set reference to GFF data: SOURCES>>
    }; # foreach my $seq
    return;
} # map_vars_to_GFF
@ %def &map_vars_to_GFF

<<set reference to GFF data: SOURCES>>=
foreach my $src (keys %{ $seq_ref->[$_element] }) {
    my $src_ref = \@{ $seq_ref->[$_element]{$src} };
    $v_sec eq 'SOURCE' && do {
        &does_feat_match($name_test,$src,$reg_exp,$src_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: STRANDS>>
}; # foreach my $src
@ 

<<set reference to GFF data: STRANDS>>=
foreach my $str (keys %{ $src_ref->[$_element] }) {
    my $str_ref = \@{ $src_ref->[$_element]{$str} };
    $v_sec eq 'STRAND' && do {
        &does_feat_match($name_test,$str,$reg_exp,$str_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: GROUPS>>
}; # foreach my $str
@ 

<<set reference to GFF data: GROUPS>>=
foreach my $grp (keys %{ $str_ref->[$_element] }) {
    my $grp_ref = \@{ $str_ref->[$_element]{$grp} };
    $v_sec eq 'GROUP' && do {
        &does_feat_match($name_test,$grp,$reg_exp,$grp_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: FEATURES>>
}; # foreach my $grp
@ 

<<set reference to GFF data: FEATURES>>=
foreach my $feat (0..$#{ $grp_ref->[$_element] }) {
    my ($feat_ref, $ft_name, $ft_id, $ft_vars);
    $feat_ref = \@{ $grp_ref->[$_element][$feat] };
    ($ft_name, $ft_id) = ($feat_ref->[$_ftname],$feat_ref->[$_ftid]);
    # check ID
    defined($id_flg) && do {
        $ft_id =~ /^$id_flg$/o && do {
            &does_feat_match($name_test,$ft_name,$reg_exp,$feat_ref,
                             $_ftprop,$v_sec,$v_var,$the_value);
        }; # $ft_id =~ /^$id_flg$/o
        next;
    }; # $id_flg ne $NULL
    # check regexp
    &does_feat_match($name_test,$ft_name,$reg_exp,$feat_ref,
                     $_ftprop,$v_sec,$v_var,$the_value);
}; # foreach my $feat
@

<<Features Setting>>=
sub does_feat_match() {
    my ($thetest,$name,$rexp,$gffref,$prop,$sct,$var,$value) = @_;
    &$thetest($name,$rexp) && do {
        (ref($gffref->[$prop]) eq 'REF') &&
            &set_all_defaults($gffref, $sct);
        $gffref->[$prop]{$var} = $value;
    };
} # does_feat_match
@ %def &does_feat_match

The following two functions are checking if a GFF element match or not a given regular expression (minimal expression consists in a GFF element string). They return a true/flase result that decides if a variable is set or not for a given GFF element.

<<Features Setting>>=
sub match_regexp() {
    $_[0] =~ /$_[1]/o && return $T;
    return $F;
} # match_regexp
sub match_regexp_neg() {
    $_[0] !~ /$_[1]/o && return $T;
    return $F;
} # match_regexp_neg
@ %def &match_regexp &match_regexp_neg

<<Features Setting>>=
sub set_all_defaults() {
    my ($the_hash,$the_sec) = @_;
    $the_hash->[$_prop] = ();
    foreach my $vnm (keys %{$Defaults{$the_sec}}) {
        $the_hash->[$_prop]{$vnm} = \$Defaults{$the_sec}{$vnm};
    }; # foreach $nm
} # set_all_defaults
@ %def &set_all_defaults


\newpage

\sctn{Sorting GFF features} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We need to sort the GFF elements by acceptor, it is more or less easy to sort them because they were defined in [[%GFF_DATA]] or [[%ALN_DATA]]
as arrays (it is implemented with the [[map]]/[[sort]]/[[map]] technique as it can be appreciated in [[<<sorting group elements>>]] code chunk). But we also need to sort groups by their coordinates and to sort sequences and sources by their input order (as they were read from input file I mean). This will be difficult to do on the original hashes because coords and order were placed in a subarray for a given group/source/sequence key name (that key point to an anonymous array containing that counters as you can see in table~\ref{tbl:gffdata}, page~\pageref{tbl:gffdata}). As we are looking for the GFF elements that belong to a group, which is related to a given strand of a source within a sequence, we can build an auxiliary variable that holds the proper ordering at each level as we go deep in the [[%GFF_DATA]]/[[%ALN_DATA]] variables hierarchy.
At the same time we can fill the [[$_ori]] and [[$_end]] fields we left set to zero for the counters array in [[&load_gff_var]] (see function definition in page~\pageref{func:loadgffvar}).

Something that really boost the ordering, if we compare to the old [[gawk]] version of {\prog}, is that we are performing the sort only on those groups that have more that one element, and that we are also ordering short sets of GFF elements instead of sorting the whole input records first and then sorting the groups we found in those records (also GFF records were ordered by an insertion sort algorithm when being loaded). Finally, we take advantage of the perl references pointing to different parts of complex data structures, so we are using ``less'' temporary variables and, indirectly, we are going to use ``less'' memory.

<<HIDE: DONE>>=
\doneitem{20011120}{Set ordering for [[%ALN_DATA]].}
@

\subsctn{Main sorting function}

<<Sorting Features>>=
sub sort_elements() {
    &header("SORTING ELEMENTS BY ACCEPTOR (START)");
    %Order = ();
    # sorting %GFF_DATA contents 
    scalar(%GFF_DATA) && do {
        &report('SORT_GFF','*- ','ANNOTATION DATA');
        &sort_elements_loop(\%GFF_DATA,'GFF');
    }; # scalar(%GFF_DATA) > 0
    # sorting %ALN_DATA contents 
    scalar(%ALN_DATA) && do {
        &report('SORT_GFF','*- ','ALIGNMENT DATA');
        &sort_elements_loop(\%ALN_DATA,'ALN');
    }; # scalar(%ALN_DATA) > 0
    print LOGFILE (Data::Dumper->Dump([ \%Order, \%GFF_DATA, \%ALN_DATA ],
                                   [ qw( *Order   *GFF_DATA   *ALN_DATA ) ]))
        if ($LogFile && $Debug);
    &footer("ELEMENTS SORTED");
} # sort_elements
@ %def &sort_elements

We will take advantage of the fact that we are moving through all the data structures, to find minimum and maximum values for features, including start and end coordinates (twice if we are looking to alignment data), min/max scores, and length of longest label.

<<Sorting Features>>=
sub sort_elements_loop() {
    my ($s_ref,$ktr) = @_;
    my ($v_max,$v_min,$w_max,$w_min,$s_max,$s_min,$l_max,$L_max,$aflg);
    my $sq_ord = \@{ $Order{$ktr} } ; 
    # my @tt_coords = ();
    $aflg = $ktr eq 'ALN' ? $T : $F;
    @{ $sq_ord } = ();
    foreach my $s_seq (keys %{ $s_ref }) {
        <<sorting sequences>>
    }; # foreach $s_seq
    &sort_by_inputorder($sq_ord);
    return;
} #sort_elements_loop
@ %def &sort_elements_loop

Once we get into [[&sort_elements]] function we initialize the arrays within the [[%Order]] hash as we are requiring them. \label{sec:ORDERhsh}

<<messages - sorting GFF data>>=
SORT_GFF => "\%sSorting \%s\n",
@

\subsctn{Descending from sequences to groups}

<<sorting sequences>>=
&report('SORT_SEQ','|  *- ',$s_seq);
my @sc_coords = ();
push @{ $sq_ord },
        [ $s_seq,
          $s_ref->{$s_seq}[$_counter][$_order],
          () ];
my $sc_ord = \@{ $sq_ord->[ $#{$sq_ord} ][2] };
my $ss_ref = \%{ $s_ref->{$s_seq}[$_element] };
foreach my $s_src (keys %{ $ss_ref }) {
    <<sorting sources>>
}; # foreach $s_src
&sort_by_inputorder($sc_ord);
<<set sequence elements boundaries>>
@ 

<<sorting sources>>=
&report('SORT_SRC',(('|  ' x 2).'*- '),$s_src);
my @sr_coords = ();
push @{ $sc_ord },
        [ $s_src,
          $ss_ref->{$s_src}[$_counter][$_order],
          () ];
my $sr_ord = \@{ $sc_ord->[ $#{$sc_ord} ][2] };
my $sc_ref = \%{ $ss_ref->{$s_src}[$_element] };
foreach my $s_str (keys %{ $sc_ref }) {
    <<sorting GFF groups>>
}; # foreach $s_str
<<set source elements boundaries>>
@

<<messages - sorting GFF data>>=
SORT_SEQ => "\%sSequence: \%s\n",
SORT_SRC => "\%sSource: \%s\n",
@ 

\subsctn{Sorting features for groups}

<<sorting GFF groups>>=
&report('SORT_STR',(('|  ' x 3).'*- '),$s_str);
my @ft_coords = ();
push @{ $sr_ord },
        [ $s_str,
          # $sc_ref->{$s_str}[$_counter][$_order],
          () ]; # if uncomment '$sc_ref' set next to [2] instead of [1].
my $st_ord = \@{ $sr_ord->[ $#{$sr_ord} ][1] };
my $sr_ref = \%{ $sc_ref->{$s_str}[$_element] };
<<set forward/reverse sorting function>>
my $s_elem;
foreach my $s_grp (keys %{ $sr_ref }) {
    <<sorting group elements>>
}; # foreach $s_grp
<<sorting group coords by acceptor>>
@ 

<<messages - sorting GFF data>>=
SORT_STR => "\%sStrand: \%s\n",
@

The main difference between this piece of code and the previous three ones is that we also find the boundaries of the groups here ([[$v_min]]/[[$v_max]] variables). This make possible to sort them and to know the first and the last coords that we can find in a strand/source/sequence. It also allows us to retrieve the minimum and maximum for scores, start and end coordinates of the target sequence on alignment records, and feature/group labels longest string lengths (as we are doing in the last lines of the following piece of code, and in the next one [[<<sorting group coords by acceptor>>]]). \label{sec:setlabellengths}

<<sorting group elements>>=
&report('SORT_GRP',(('|  ' x 4).'*- '),$s_grp);
my $sg_ref = \@{ $sr_ref->{$s_grp}[$_element] };
$s_elem = $sr_ref->{$s_grp}[$_counter][$_elemNum];
$s_elem > 1 && do {
    @{ $sg_ref } = map { $_->[2] }
                   sort { &$sortfunct }
                   map { [ $_->[$_ftori],
                           $_->[$_ftend],
                           $_ ] } @{ $sg_ref }; # maps start,end,arrayelement
}; # $s_elem > 1
# @ft_coords = ( map { $_->[$_ftori], $_->[$_ftend] } @{ $sg_ref } );
$v_min = &min(map { $_->[$_ftori] } @{ $sg_ref });
$v_max = &max(map { $_->[$_ftend] } @{ $sg_ref });
$sr_ref->{$s_grp}[$_counter][$_ori] = $v_min;
$sr_ref->{$s_grp}[$_counter][$_end] = $v_max;
@ft_coords = ( map { $_->[$_ftsco] } @{ $sg_ref } );
$s_min = &min(@ft_coords);
$s_max = &max(@ft_coords);
$sr_ref->{$s_grp}[$_counter][$_mnsco] = $s_min;
$sr_ref->{$s_grp}[$_counter][$_mxsco] = $s_max;
# @ft_coords = ( map { &max(length($_->[$_ftname]),length($_->[$_ftid])) }
#                   @{ $sg_ref } );
$l_max = &max(map { &max(length($_->[$_ftname]),length($_->[$_ftid])) }
                  @{ $sg_ref });
$sr_ref->{$s_grp}[$_counter][$_flw] = $l_max;
$L_max = length($s_grp);
#
$aflg && do {
    # @ft_coords = ( map { $_->[$_ftnori], $_->[$_ftnend] } @{ $sg_ref } );
    $w_min = &min(map { $_->[$_ftnori] } @{ $sg_ref });
    $w_max = &max(map { $_->[$_ftnend] } @{ $sg_ref });
    $sr_ref->{$s_grp}[$_counter][$_nori] = $w_min;
    $sr_ref->{$s_grp}[$_counter][$_nend] = $w_max;
    push @{ $st_ord },
         [ $s_grp, $v_min, $v_max, $s_min, $s_max,
                   $l_max, $L_max, $w_min, $w_max ];
}; 
$aflg || do {
    push @{ $st_ord },
         [ $s_grp, $v_min, $v_max, $s_min, $s_max, $l_max, $L_max ];
};
#
&report('SORT_FTR',('|  ' x 5),$s_elem);
@

<<messages - sorting GFF data>>=
SORT_GRP => "\%sGroup: \%s\n",
SORT_FTR => "\%s       Sorted \%s elements.\n",
@ 

\subsctn{Sorting groups by coords and upper features by input order}

Here we take advantage of having the group coords in a list of lists ([[@{ $st_ord }]]) instead of having it as a list within a key/value hash of lists. Minimum and maximum values from a group counters array are already the minimum and maximum for all the elements within a group, then we do not need a temporary array to which list all coords or scores (as we did in [[<<sorting group elements>>]]).

<<sorting group coords by acceptor>>=
# @ft_coords = ( map { $_->[1], $_->[2] } @{ $st_ord } );
$v_min = &min(map { $_->[1] } @{ $st_ord });
$v_max = &max(map { $_->[2] } @{ $st_ord });
$sc_ref->{$s_str}[$_counter][$_ori] = $v_min;
$sc_ref->{$s_str}[$_counter][$_end] = $v_max;
# @ft_coords = ( map { $_->[3], $_->[4] } @{ $st_ord } );
$s_min = &min(map { $_->[3] } @{ $st_ord });
$s_max = &max(map { $_->[4] } @{ $st_ord });
$sc_ref->{$s_str}[$_counter][$_mnsco] = $s_min;
$sc_ref->{$s_str}[$_counter][$_mxsco] = $s_max;
# @ft_coords = ( map { $_->[5] } @{ $st_ord } );
$l_max = &max(map { $_->[5] } @{ $st_ord });
$L_max = &max(map { $_->[6] } @{ $st_ord });
$sc_ref->{$s_str}[$_counter][$_flw]   = $l_max;
$sc_ref->{$s_str}[$_counter][$_glw]   = $L_max;
$aflg && do {
    # @ft_coords = ( map { $_->[6], $_->[7] } @{ $st_ord } );
    $w_min = &min(map { $_->[7] } @{ $st_ord });
    $w_max = &max(map { $_->[8] } @{ $st_ord });
    $sc_ref->{$s_str}[$_counter][$_nori] = $w_min;
    $sc_ref->{$s_str}[$_counter][$_nend] = $w_max;
    push @sr_coords,
         [ $v_min, $v_max, $s_min, $s_max, $l_max, $L_max, $w_min, $w_max ];
}; 
# push @sr_coords, $v_min, $v_max;
$aflg || do {
    push @sr_coords,
         [ $v_min, $v_max, $s_min, $s_max, $l_max, $L_max ];
}; 
#
@{ $st_ord } = map { $_->[2] }
               sort { &$sortfunct }
               map { [ $_->[1],
                       $_->[2],
                       $_->[0] ] } @{ $st_ord };
$s_elem = $sc_ref->{$s_str}[$_counter][$_elemNum];
&report('SORT_GPN',('|  ' x 4),$s_elem);
@ 

We reduced the group order subarray just to contain the group names sorted (their coords were saved in the corresponding variable within )

<<messages - sorting GFF data>>=
SORT_GPN => "\%s\`Sorted \%s groups.\n",
@ 

We are going to skip the strand sorting, because the program will process always strands in a fixed order, that is: '+', '.' and '-' (so forward features first, followed by those features that does not have a defined strand, and finally reverse features).

<<set source elements boundaries>>=
# @tt_coords = ( map { $_->[0], $_->[1] } @sr_coords );
$v_min = &min(map { $_->[0] } @sr_coords);
$v_max = &max(map { $_->[1] } @sr_coords);
$ss_ref->{$s_src}[$_counter][$_ori] = $v_min;
$ss_ref->{$s_src}[$_counter][$_end] = $v_max;
# @tt_coords = ( map { $_->[2], $_->[3] } @sr_coords );
$s_min = &min(map { $_->[2] } @sr_coords);
$s_max = &max(map { $_->[3] } @sr_coords);
$ss_ref->{$s_src}[$_counter][$_mnsco] = $s_min;
$ss_ref->{$s_src}[$_counter][$_mxsco] = $s_max;
$l_max = &max(map { $_->[4] } @sr_coords);
$L_max = &max(map { $_->[5] } @sr_coords);
$ss_ref->{$s_src}[$_counter][$_flw]   = $l_max;
$ss_ref->{$s_src}[$_counter][$_glw]   = $L_max;
$aflg && do {
    # @tt_coords = ( map { $_->[5], $_->[6] } @sr_coords );
    $w_min = &min(map { $_->[6] } @sr_coords);
    $w_max = &max(map { $_->[7] } @sr_coords);
    $ss_ref->{$s_src}[$_counter][$_nori] = $w_min;
    $ss_ref->{$s_src}[$_counter][$_nend] = $w_max;
    push @sc_coords,
         [ $v_min, $v_max, $s_min, $s_max, $l_max, $L_max, $w_min, $w_max ];
}; 
# push @sc_coords, $v_min, $v_max;
$aflg || do {
    push @sc_coords,
         [ $v_min, $v_max, $s_min, $s_max, $l_max, $L_max ];
}; 
@ 

We are at the sequence array level again:

<<set sequence elements boundaries>>=
# @tt_coords = ( map { $_->[0], $_->[1] } @sc_coords );
$s_ref ->{$s_seq}[$_counter][$_ori] = &min(map { $_->[0] } @sc_coords);
$s_ref ->{$s_seq}[$_counter][$_end] = &max(map { $_->[1] } @sc_coords);
# @tt_coords = ( map { $_->[2], $_->[3] } @sc_coords );
$s_ref->{$s_seq}[$_counter][$_mnsco] = &min(map { $_->[2] } @sc_coords);
$s_ref->{$s_seq}[$_counter][$_mxsco] = &max(map { $_->[3] } @sc_coords);
$s_ref->{$s_seq}[$_counter][$_flw]   = &max(map { $_->[4] } @sc_coords);
$s_ref->{$s_seq}[$_counter][$_glw]   = &max(map { $_->[5] } @sc_coords);
$aflg && do {
    # @tt_coords = ( map { $_->[5], $_->[6] } @sc_coords );
    $s_ref->{$s_seq}[$_counter][$_nori] = &min(map { $_->[6] } @sc_coords);
    $s_ref->{$s_seq}[$_counter][$_nend] = &max(map { $_->[7] } @sc_coords);
}; 
@ 

<<Sorting Features>>=
sub sort_by_inputorder() {
    my $ref = $_[0];
    @{ $ref } = map { [ $_->[0], $_->[2] ] }
                sort { $a->[1] <=> $b->[1] }
                map { [ $_->[0], $_->[1], $_->[2] ] } @{ $ref };
} # sort_by_inputorder
@ %def &sort_by_inputorder

\subsctn{Sorting forward/reverse strands}

As we are saving feature boundaries always in forward coords (meaning that feature start is always smaller than feature end, this was already checked by [[&check_coords]] which is defined in page~\pageref{func:checkcoords}), we need two sort functions, one for sorting forward features that is slightly different than the one used for sorting reverse ones. The main reason is that we want to avoid feature overlapping upstream (so that an element that ends downstream a previous element but starts within the boundaries of this one do not hide it ), this works from left to right for forward features, but must be done counterclockwise (say here from right to left) on reverse features.

<<Sorting Features>>=
sub sort_forward {
    $a->[0] <=> $b->[0]  # sorting by start
             or
    $b->[1] <=> $a->[1]; # reverse sorting by end if same start
} # sort_forward
#
sub sort_reverse {
    $b->[1] <=> $a->[1] # reverse sorting by end
             or
    $a->[0] <=> $b->[0];  # sorting by start if same end
} # sort_forward
@ %def &sort_forward &sort_forward

We choose between those two functions (both defining which fields to order and the direction --ascending/descending--), assigning by reference to [[$sortfunct]] variable which is de-referenced within the [[sort]] functions.

<<set forward/reverse sorting function>>=
my $sortfunct = ($s_str eq '-') ? \&sort_reverse : \&sort_forward;
@
%$

\newpage

\sctn{Setting page layout variables} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:LAYOUTsec}

From now on, we are going to work internally with {\ps} points lengths. '[[%Vars]]' keys set to '[[_*]]' represent variables that are only visible within the program and cannot be configured by user.

<<Layout Settings>>=
sub set_page_vars() {
    &header("SETTING PAGE LAYOUT");
    my $var = \%{ $Vars{LAYOUT} };
    &set_page_size($var);
    &set_page_axes($var);
    &set_seq_boundaries($var);
    &set_score_boundaries($var);
    &set_tickmark_vars($var);
    &find_prop_ratio($var);
    &set_misc_vars($var);
    &set_page_labels($var);
    &footer("PAGE LAYOUT SET for CURRENT PLOT");
} # set_page_vars
@ %def &set_page_vars

\subsctn{Page dimensions}

We compute the whole page dimensions, width and height, those are the most outer boundaries in the {\ps} figure.  

<<Layout Settings>>=
sub set_page_size() {
    my ($vrf) = @_;
    PSIZES: {
        defined($vrf->{page_bbox}) && do {
            $vrf->{_page_width}  = &get_units(\@{ $vrf->{page_bbox}[1] });
            $vrf->{_page_height} = &get_units(\@{ $vrf->{page_bbox}[2] });
            $FORMATS{$vrf->{page_bbox}[0]} = 
                [ ++$formats, $vrf->{_page_width}, $vrf->{_page_height} ];
            $vrf->{page_size} = $vrf->{page_bbox}[0];
            last PSIZES;
        };
        ($vrf->{_page_width},
         $vrf->{_page_height}) = @{ $FORMATS{$vrf->{page_size}} }[1,2];
    }; # PSIZES
    &report('SETPAGESIZE',$vrf->{page_size},
            "$vrf->{_page_width} x $vrf->{_page_height}");
    return;
} # set_page_size
@ %def &set_page_size {_page_width} {_page_height}

<<messages - input/output>>=
SETPAGESIZE =>
  "###---> Page size set to \"\%s\" ( \%s )...\n",
@

Not sure if the following function will be required, or better to pass values to PS code and compute layout there.

<<HIDE: Layout Settings>>=
#   &set_page_margins($var);
@ 
<<Layout Settings>>=
sub set_page_margins() {
    my ($vrf) = @_;
    $vrf->{_page_margins} = [
        &get_units(\@{ $vrf->{margin_left}[0]   }),
        &get_units(\@{ $vrf->{margin_right}[0]  }),
        &get_units(\@{ $vrf->{margin_top}[0]    }),
        &get_units(\@{ $vrf->{margin_bottom}[0] })
        ];
    $vrf->{_page_clip_width}  = $vrf->{_page_width} - 
         ($vrf->{_page_margins}[0] + $vrf->{_page_margins}[1]); 
    $vrf->{_page_clip_height} = $vrf->{_page_height} - 
         ($vrf->{_page_margins}[2] + $vrf->{_page_margins}[3]); 
    return;
} # set_page_margins
@ %def &set_page_margins {_page_margins} {_page_clip_width} {_page_clip_height}


\subsctn{Choosing which alignment and annotation to show}

Now, we should choose which alignment and which annotations will appear on the plot, by default the first ones read from input files. This process is done in three steps: 

\begin{enumerate}
\item First we should look for customization variables sequence names if defined ([[alignment_name]], [[x_sequence_name]] and [[y_sequence_name]] variables and their corresponding command-line options, see section~\ref{sec:customvardesc} on page~\pageref{sec:customvardesc} for further info).

<<setting axes - step 1>>=
$vrf->{_x_sequence_name} = defined($vrf->{x_sequence_name})
    ? $vrf->{x_sequence_name} : '.+';
$vrf->{_y_sequence_name} = defined($vrf->{y_sequence_name})
    ? $vrf->{y_sequence_name} : '.+';
defined($vrf->{alignment_name}) && do {
    ($vrf->{_x_sequence_name},
     $vrf->{_y_sequence_name}) = 
         split /:/o, $vrf->{alignment_name}, 2;
}; # defined($vrf->{alignment_name})
$vrf->{_alignment_name} = 
    [ $vrf->{_x_sequence_name}, $vrf->{_y_sequence_name} ];
@ %def {_alignment_name}

\item Then we must find if the resulting alignment has been loaded, searching on [[@{$Order{ALN}}]], and setting X and Y sequences accordingly. [[&search_alnname]] will return the final X-Y sequence names by modifying [[@{ $vrf->{_alignment_name} }]]. We do not swap sequence names on [[$vrf->{_alignment_name}]] at [[$vrf->{_swap_aln}]] test because it is already swapped within that function.

<<setting axes - step 2>>=
($vrf->{_plot_aln}, $vrf->{_swap_aln}) = 
    &search_alnname(\@{ $vrf->{_alignment_name} }, \@{ $Order{ALN} });
$vrf->{_swap_aln} && do {
    ($vrf->{x_sequence_name},$vrf->{y_sequence_name}) =
        ($vrf->{y_sequence_name},$vrf->{x_sequence_name});
}; # $vrf->{_swap_aln} 
$vrf->{_plot_aln} && do {
    $vrf->{_x_sequence_name} = defined($vrf->{x_sequence_name})
        ? $vrf->{x_sequence_name} : $vrf->{_alignment_name}[0];
    $vrf->{_y_sequence_name} = defined($vrf->{y_sequence_name})
        ? $vrf->{y_sequence_name} : $vrf->{_alignment_name}[1];
}; # $vrf->{_plot_aln}
@ %def {_plot_aln} {_swap_aln}

\item Finally we grep those X and Y sequences from [[@{$Order{GFF}}]], so we sholud know if they are present there or not. This depends on what we have found in [[@{$Order{ALN}}]] but also on [[$Vars{LAYOUT}{x_sequence_name}]] and [[$Vars{LAYOUT}{y_sequence_name}]] settings.

<<setting axes - step 3>>=
$vrf->{_alignment_name} = join(":", @{ $vrf->{_alignment_name} });
($vrf->{_plot_x_sequence},$vrf->{_x_sequence_name}) =
    &search_seqname($vrf->{_x_sequence_name}, undef, \@{ $Order{GFF} });
($vrf->{_plot_y_sequence},$vrf->{_y_sequence_name}) =
    &search_seqname($vrf->{_y_sequence_name}, $vrf->{_x_sequence_name}, 
                    \@{ $Order{GFF} });
@ %def {_plot_x_sequence} {_plot_y_sequence}
\end{enumerate}

While following those points, we will set also three variables that tell {\prog} if it is worth to plot alignments, x and y sequence ([[_plot_aln]], [[_plot_x_sequence]] and [[_plot_y_sequence]] respectively).

<<Layout Settings>>=
sub set_page_axes() {
    my ($vrf) = @_;
    <<setting axes - step 1>>
    <<setting axes - step 2>>
    <<setting axes - step 3>>
    # ($vrf->{alignment_name} = $vrf->{_alignment_name}) =~ s/$;/ : /o;
    my ($yf,$nf) = ('was found. PLOTTING IT...','NOT found. NOT PLOTTED...');
    &report('SETPAGEAXES',
             ( "ALIGNMENT \"$vrf->{_alignment_name}\" ".
               ( $vrf->{_plot_aln} ? $yf : $nf ).
               ( $vrf->{_swap_aln} ?
                 "\n###     The alignment found makes program".
                          " to swap X-Y annotations..." : "" )
               ),
             ( "X-SEQUENCE \"$vrf->{_x_sequence_name}\" ".
               ( $vrf->{_plot_x_sequence} ? $yf : $nf ) ),
             ( "Y-SEQUENCE \"$vrf->{_y_sequence_name}\" ".
               ( $vrf->{_plot_y_sequence} ? $yf : $nf ) )
            );
    return;
} # set_page_axes
@ %def &set_page_axes

<<messages - input/output>>=
SETPAGEAXES =>
  "###---> Setting plot AXES: \n###     \%s\n###     \%s\n###     \%s\n",
@

We need two auxiliarly functions to grep alignment and sequences names on [[@{$Order{ALN}}]] and [[@{$Order{GFF}}]] respectively. Remember that we are using a colon (':') as joining character between two sequence names (in order to simplify parsing of customization and GFF records, also to cross-interacting among them).
% Remember that '[[$;]]' correspond to '[[SUBSEP]]' in AWK.

<<Layout Settings>>=
sub search_alnname() {
    my ($_ra,$_ro) = @_;
    my ($sq_a,$sq_b,$naln,$nm_a,$nm_b);
    #
    ($sq_a,$sq_b) = @$_ra;
    foreach $naln (@$_ro) {
        ($nm_a,$nm_b) = split /:/o, $naln->[0], 2; 
        ($nm_a =~ /^$sq_a$/ && $nm_b =~ /^$sq_b$/) && do {
            @$_ra = ($nm_a,$nm_b);
            return ($T, $F);
        };
    }; # foreach $naln
    # swapping
    foreach $naln (@$_ro) {
        ($nm_a,$nm_b) = split /:/o, $naln->[0], 2; 
        ($nm_a =~ /^$sq_b$/ && $nm_b =~ /^$sq_a$/) && do {
            @$_ra = ($nm_b,$nm_a);
            return ($T, $T);
        };
    }; # foreach $naln
    #
    return ($F, $F);
} # search_alnname
@ %def &search_alnname

<<Layout Settings>>=
sub search_seqname() {
    my ($sq_a,$sq_b,$_ro) = @_;
    my ($a_found,$naln);
    foreach $naln (@$_ro) {
        ($sq_a eq '.+' && defined($sq_b) && $naln->[0] eq $sq_b) && next;
        $naln->[0] =~ /^$sq_a$/ && do {
            $sq_a = $naln->[0];
            return ($T, $sq_a);
        };
    }; # foreach $naln
    return ($F, undef);
} # search_seqname
@ %def &search_seqname


\subsctn{Getting sequence coords limits to set axes boundaries}

In order to compute coordinates limits that we will need later when calculating tickmarks and other variables, we follow these steps

\begin{enumerate}
\item We must take as defaults the starting and ending coordinates found in the GFF input records. If none is defined, because you have been playing with a not defined alingment or sequences names, program uses 0 as start and 1000 as end so it does not die on an empty plot.

<<setting boundaries - initialize>>=
%tcrds = ();
($a, $x, $y) = (
    $vrf->{_alignment_name}, 
    $vrf->{_x_sequence_name},
    $vrf->{_y_sequence_name}
    );
$vrf->{_plot_aln} && do {
    $rrf = \@{ $ALN_DATA{$a}[$_counter] };
    push @{ $tcrds{xs} }, $rrf->[$_ori] ;
    push @{ $tcrds{xe} }, $rrf->[$_end] ;
    push @{ $tcrds{ys} }, $rrf->[$_nori] ;
    push @{ $tcrds{ye} }, $rrf->[$_nend] ;
};
$vrf->{_plot_x_sequence} && do {
    $rrf = \@{ $GFF_DATA{$x}[$_counter] };
    push @{ $tcrds{xs} }, $rrf->[$_ori] ;
    push @{ $tcrds{xe} }, $rrf->[$_end] ;
};
$vrf->{_plot_y_sequence} && do {
    $rrf = \@{ $GFF_DATA{$y}[$_counter] };
    push @{ $tcrds{ys} }, $rrf->[$_ori] ;
    push @{ $tcrds{ye} }, $rrf->[$_end] ;
};
# print LOGFILE (Data::Dumper->Dump([ \%tcrds ], [ qw( *tcrds ) ]))
#     if ($LogFile && $Debug);
#
$vrf->{_x_start} = [ ( scalar(@{ $tcrds{xs} }) > 0 ?
                         &min(@{ $tcrds{xs} }) :    0 ), 'bp' ];
$vrf->{_x_end}   = [ ( scalar(@{ $tcrds{xe} }) > 0 ? 
                         &max(@{ $tcrds{xe} }) : 1000 ), 'bp' ];
$vrf->{_y_start} = [ ( scalar(@{ $tcrds{ys} }) > 0 ? 
                         &min(@{ $tcrds{ys} }) :    0 ), 'bp' ];
$vrf->{_y_end}   = [ ( scalar(@{ $tcrds{ye} }) > 0 ? 
                         &max(@{ $tcrds{ye} }) : 1000 ), 'bp' ];
#
@ %def {_x_start} {_x_end} {_y_start} {_y_end}

\item Now we look for user defined values, we build an array of possible values for each x and y start-end pairs, leaving an element undefined if the corresponding variable was not set. Then we can recover from those arrays the zoom-area clip, the normal zoom clip and the plot limits.

<<setting boundaries - initialize customs>>=
%tcrds = (
    xs => [
        defined($vrf->{x_sequence_zoom}) ?
                $vrf->{x_sequence_zoom}[0] : undef,
        defined($vrf->{x_sequence_zoom_start}) ?
                $vrf->{x_sequence_zoom_start} : undef,
        defined($vrf->{x_sequence_coords}) ?
                $vrf->{x_sequence_coords}[0] : undef,
        defined($vrf->{x_sequence_start}) ?
                $vrf->{x_sequence_start} : undef,
        $vrf->{_x_start}
        ],
    xe => [
        defined($vrf->{x_sequence_zoom}) ?
                $vrf->{x_sequence_zoom}[1] : undef,
        defined($vrf->{x_sequence_zoom_end}) ?
                $vrf->{x_sequence_zoom_end} : undef,
        defined($vrf->{x_sequence_coords}) ?
                $vrf->{x_sequence_coords}[1] : undef,
        defined($vrf->{x_sequence_end}) ?
                $vrf->{x_sequence_end} : undef,
        $vrf->{_x_end}
        ],
    ys => [
        defined($vrf->{y_sequence_zoom}) ?
                $vrf->{y_sequence_zoom}[0] : undef,
        defined($vrf->{y_sequence_zoom_start}) ?
                $vrf->{y_sequence_zoom_start} : undef,
        defined($vrf->{y_sequence_coords}) ?
                $vrf->{y_sequence_coords}[0] : undef,
        defined($vrf->{y_sequence_start}) ?
                $vrf->{y_sequence_start} : undef,
        $vrf->{_y_start}
        ],
    ye => [
        defined($vrf->{y_sequence_zoom}) ?
                $vrf->{y_sequence_zoom}[1] : undef,
        defined($vrf->{y_sequence_zoom_end}) ?
                $vrf->{y_sequence_zoom_end} : undef,
        defined($vrf->{y_sequence_coords}) ?
                $vrf->{y_sequence_coords}[1] : undef,
        defined($vrf->{y_sequence_end}) ?
                $vrf->{y_sequence_end} : undef,
        $vrf->{_y_end}
        ],
   ); # %tcrds
# print LOGFILE (Data::Dumper->Dump([ \%tcrds ], [ qw( *tcrds ) ]))
#     if ($LogFile && $Debug);
#
$vrf->{_x_start} = &get_units(\@{ $vrf->{_x_start} });
$vrf->{_x_end}   = &get_units(\@{ $vrf->{_x_end} });
$vrf->{_y_start} = &get_units(\@{ $vrf->{_y_start} });
$vrf->{_y_end}   = &get_units(\@{ $vrf->{_y_end} });
@

\item Once sequence defaults has been set, we check if [[zoom_area]] is switched on and, after that, we look for [[zoom]] switch. This will allow users to define a zoom area within an already zoomed plot (that feature was not available on old gawk version of {\prog}). Here we look for the zoom area coords, when they are same than sequence boundaries, [[zoom_area]] flag is disabled but also is [[zoom]] (because there are no sequence coords for any zoom defined by user and this way we can skip the corresponding test that will be unnecessary).
 
<<setting boundaries - is zoom area ON>>=
$vrf->{zoom_area} && do {
  $cc = 0;
  $vrf->{_x_zoomarea_start} = &get_first_coord(\@{ $tcrds{xs} },\$cc);
  $vrf->{_x_zoomarea_end}   = &get_first_coord(\@{ $tcrds{xe} },\$cc);
  $vrf->{_y_zoomarea_start} = &get_first_coord(\@{ $tcrds{ys} },\$cc);
  $vrf->{_y_zoomarea_end}   = &get_first_coord(\@{ $tcrds{ye} },\$cc);
  $cc == 4 && ($vrf->{zoom_area} = $F, $vrf->{zoom} = $F);
}; # zoom_area
@ %def {_x_zoomarea_start} {_x_zoomarea_end} {_y_zoomarea_start} {_y_zoomarea_end}

Here we are looking for the zoom coordinates. If those coords are the same as sequence boundaries the zoom is disabled, else current plot sequence boundaries are set to zoom ones. Also when zoom is out, zoom marks must not be shown although they were switched on by user.

<<setting boundaries - is zoom ON>>=
$vrf->{zoom} && do {
  $cc = 0;
  $vrf->{_x_zoom_start} = &get_first_coord(\@{ $tcrds{xs} },\$cc);
  $vrf->{_x_zoom_end}   = &get_first_coord(\@{ $tcrds{xe} },\$cc);
  $vrf->{_y_zoom_start} = &get_first_coord(\@{ $tcrds{ys} },\$cc);
  $vrf->{_y_zoom_end}   = &get_first_coord(\@{ $tcrds{ye} },\$cc);
  $cc == 4 && ($vrf->{zoom} = $F);
  $vrf->{zoom} && do {
      $vrf->{_x_start} = $vrf->{_x_zoom_start};
      $vrf->{_x_end}   = $vrf->{_x_zoom_end};
      $vrf->{_y_start} = $vrf->{_y_zoom_start};
      $vrf->{_y_end}   = $vrf->{_y_zoom_end};
  }; # zoom...
}; # zoom
$vrf->{zoom} || ($vrf->{zoom_marks} = $F);
@ %def {_x_zoom_start} {_x_zoom_end} {_y_zoom_start} {_y_zoom_end}

We do need an auxiliarly function to decide which is the first defined value starting from left in each [[%tcrds]] subarray:

<<Layout Settings>>=
sub get_first_coord() {
    my ($ary,$cct) = @_;
    my ($thelast,$cur,$tht);
    $thelast = $#{ $ary };
    for ( $cur = 0; $cur < $thelast; $cur++ ) {
        defined($ary->[$cur]) && do {
            ($tht, $ary->[$cur]) = ($ary->[$cur], undef);
            return &get_units(\@$tht);
        }; # defined($ary[$cur])
    }; # for $cur
    $$cct++;
    return &get_units(\@{ $ary->[$thelast] });
} # get_first_coord
@ %def &get_first_coord

\end{enumerate}

So that, the [[&set_seq_boundaries]] function is set as:

<<Layout Settings>>=
sub set_seq_boundaries() {
    my ($vrf) = @_;
    my ($a, $x, $y, $rrf, %tcrds, $cc);
    <<setting boundaries - initialize>>
    <<setting boundaries - initialize customs>>
    <<setting boundaries - is zoom area ON>>
    <<setting boundaries - is zoom ON>>
    &report('PLOTLIMITS', "X : $vrf->{_x_start} to $vrf->{_x_end}",
                          "Y : $vrf->{_y_start} to $vrf->{_y_end}");
    &report(( $vrf->{zoom_area}
             ? ('ONZOOM',
                "X : $vrf->{_x_zoom_start} to $vrf->{_x_zoom_end}",
                "Y : $vrf->{_y_zoom_start} to $vrf->{_y_zoom_end}" )
             : 'NOZOOM' ));
    &report(( $vrf->{zoom_area}
             ? ('ONZOOMAREA',
                "X : $vrf->{_x_zoomarea_start} to $vrf->{_x_zoomarea_end}",
                "Y : $vrf->{_y_zoomarea_start} to $vrf->{_y_zoomarea_end}" )
             : 'NOZOOMAREA' ));
    return;
} # set_seq_boundaries
@ %def &set_seq_boundaries

<<messages - input/output>>=
PLOTLIMITS =>
  "###---> SEQUENCE BOUNDARIES selected for this plot:\n".
  "###      \%s\n###      \%s\n",
ONZOOM =>
  "###---> SEQUENCE ZOOM that has been choosen:\n".
  "###      \%s\n###      \%s\n",
NOZOOM =>
  "###     SEQUENCE ZOOM is not enabled for this plot...\n",
ONZOOMAREA =>
  "###---> ZOOM AREA that is going to be highlighted:\n".
  "###      \%s\n###      \%s\n",
NOZOOMAREA =>
  "###     NO ZOOM AREA was selected for this plot... \n",
@


\subsctn{Getting score limits for alignment and percent box}

We have to find which are the lower and upper scores for the alignment and for the percent box, this will be used by the program to skip the outlayers when drawing the percent box and to fix the score treshold for minimum and maximum alignment features line-width on the aplot box. 

<<Layout Settings>>=
sub set_score_boundaries() {
    my ($vrf) = @_;
    my ($mnsco, $mxsco);
    <<setting score limits: current alignment>>
    <<setting score limits: percent box>>
    &report('PLOTSCORES',
            "ALIGNMENT:   $vrf->{_aln_min_score} to $vrf->{_aln_max_score}",
            "PERCENT box: $vrf->{_pbox_min_score} to $vrf->{_pbox_max_score}");
} # set_score_boundaries
@ %def &set_score_boundaries

<<messages - input/output>>=
PLOTSCORES =>
  "###---> SCORE BOUNDARIES selected for this plot:\n".
  "###      \%s\n###      \%s\n",
@

If [[percent_box_score_range]] was not defined then we look for [[aplot_score_range]] else we use the scores found in the [[%ALN_DATA]] for the corresponding alignment. We get first those minimum and maximum scores for the choosen alignment (once we provided a suitable pair of default values), and then we change the related variables if needed.

<<setting score limits: current alignment>>=
($vrf->{_aln_min_score},$vrf->{_aln_max_score}) = (0,100);
$vrf->{_plot_aln} && do {
    $vrf->{_aln_min_score} =
        $ALN_DATA{$vrf->{_alignment_name}}[$_counter][$_mnsco];
    $vrf->{_aln_max_score} =
        $ALN_DATA{$vrf->{_alignment_name}}[$_counter][$_mxsco];
}; # _plot_aln
defined($vrf->{aplot_score_range}) && do {
    ($mnsco, $mxsco) = @{ $vrf->{aplot_score_range} };
    defined($mnsco) && ($vrf->{_aln_min_score} = $mnsco);
    defined($mxsco) && ($vrf->{_aln_max_score} = $mxsco);
}; # defined($vrf->{aplot_score_range})
@ %def {_aln_min_score} {_aln_max_score}

Having already defined the alignment variables ([[_aln_min_score]] and [[_aln_max_score]]), we take them as defaults for the percent box variables ([[_pbox_min_score]] and [[_pbox_max_score]]), before finding specific values in the corresponding variables.

<<setting score limits: percent box>>=
($vrf->{_pbox_min_score}, $vrf->{_pbox_max_score}) =
     ($vrf->{_aln_min_score}, $vrf->{_aln_max_score});
($vrf->{show_percent_box} && defined($vrf->{percent_box_score_range})) && do {
    ($mnsco, $mxsco) = @{ $vrf->{percent_box_score_range} };
    defined($mnsco) && ($vrf->{_pbox_min_score} = $mnsco);
    defined($mxsco) && ($vrf->{_pbox_max_score} = $mxsco);
}; # show_percent_box
@ %def {_pbox_min_score} {_pbox_max_score}

Here we are implementing how the script is going to set major and minor tickmark steps for scores, although it is included in the following section main function [[&set_tickmark_vars]]. 

<<set tickmarks - percents>>=
$vrf->{_pbox_len} = $vrf->{_pbox_max_score} - $vrf->{_pbox_min_score} + 1;
if ( defined($vrf->{percent_major_tickmark}) && 
    !defined($vrf->{major_tickmark_score}) ) {
    $stplen = 10**( int( &logdec( $vrf->{_pbox_len} ) ) + 1 )
              / $vrf->{percent_major_tickmark};
} else {
    $stplen = 10**( int( &logdec( $vrf->{_pbox_len} ) - 0.175 ) );
};
defined($vrf->{major_tickmark_score}) || do {
    $vrf->{major_tickmark_score} = $stplen;
}; # defined($vrf->{major_tickmark_score})
defined($vrf->{minor_tickmark_score}) || do {
    $vrf->{minor_tickmark_score} = 
        $vrf->{major_tickmark_score} / $vrf->{percent_minor_tickmark};
}; # defined($vrf->{minor_tickmark_score})
@ %def {_pbox_len}


\subsctn{Setting tickmark variables}

<<Layout Settings>>=
sub set_tickmark_vars() {
    my ($vrf) = @_;
    my (@tary,$stplen);
    <<set tickmarks - bottom one>>
    <<set tickmarks - steps for shorter edge>>
    <<set tickmarks - percents>>
    &report('TICKDONE',
        "Major step $vrf->{major_tickmark_nucleotide} - ".
        "Minor step $vrf->{minor_tickmark_nucleotide}",
        "Major step $vrf->{major_tickmark_score} - ".
        "Minor step $vrf->{minor_tickmark_score}");
    return;
} # set_tickmark_vars
@ %def &set_tickmark_vars

<<messages - input/output>>=
TICKDONE =>
  "###---> TICKMARKS were set: \n".
  "###      Nucleotide-Scale: \%s\n###      Score-Scale:      \%s\n",
@

We have to switch on the bottomest scale that appears on plot (it depends on [[show_percent_box]] and [[show_extra_box]]) when [[show_only_bottom_ticks]] is on.

<<set tickmarks - bottom one>>=
$vrf->{show_only_bottom_ticks} && do {
    WHATICK: {
        $vrf->{show_extra_box}   && (@tary = ($F,$F,$T), last WHATICK);
        $vrf->{show_percent_box} && (@tary = ($F,$T,$F), last WHATICK);
        @tary = ($T,$F,$F);
    }; # WHATICK
    ( $vrf->{show_aplot_x_ticks},
      $vrf->{show_percent_x_ticks},
      $vrf->{show_extrabox_x_ticks} ) = @tary;
};
@ 

Now we compute the tickmark steps for the nucleotide scale of the shortest edge (taken as the shortest sequence coords from alignment and or sequence annotations), it is required if user does not define a nucleotide scale (either if she sets major/minor tickmark steps). Major tickmarks steps are now calculated within the perl script, not by {\ps} code, using the following formula:

\[
\begin{array}{rcl}
\mbox{step} & = &
 \mbox{\Large 10}^{
  \left[
    \mathrm{int}( 
      \log_{10}{( \min{ \Delta_{\mathrm{seqX}} , \Delta_{\mathrm{seqY}} )} }
      \;-\; \lambda
    )
  \right]
 } \;, \\[1ex]
\mbox{where} & \quad &
             \Delta_{\mathrm{seq}} = \mathrm{end}_{\mathrm{seq}}
                                   - \mathrm{start}_{\mathrm{seq}} + 1 \;,\\
             & \quad &
             \min{ \Delta_{\mathrm{seqX}} , \Delta_{\mathrm{seqY}} } > 0 \;,\\
             & \quad &
             \mathrm{int}(x) \quad \mbox{is the integer part of} \quad x \;,\\
\mbox{and}   & \quad & 0 < \lambda < 1 \;. \\
\end{array}
\]

We explored several values of $\lambda$ and found that the most appropriate for the current implementation was $\lambda\,=\,0.175$ .

<<set tickmarks - steps for shorter edge>>=
$vrf->{_x_len} = $vrf->{_x_end} - $vrf->{_x_start} + 1;
$vrf->{_y_len} = $vrf->{_y_end} - $vrf->{_y_start} + 1;
if ( defined($vrf->{aplot_major_tickmark}) && 
    !defined($vrf->{major_tickmark_nucleotide}) ) {
    $stplen = 10**( int( &logdec( &min($vrf->{_x_len},$vrf->{_y_len})
                                  ) ) + 1 ) / $vrf->{aplot_major_tickmark};
} else {
    $stplen = 10**( int( &logdec( &min($vrf->{_x_len},$vrf->{_y_len})
                                  ) - 0.175 ) );
};
defined($vrf->{major_tickmark_nucleotide}) || do {
    $vrf->{major_tickmark_nucleotide} = $stplen;
}; # defined($vrf->{major_tickmark_nucleotide})
defined($vrf->{minor_tickmark_nucleotide}) || do {
    $vrf->{minor_tickmark_nucleotide} = 
        $vrf->{major_tickmark_nucleotide} / $vrf->{aplot_minor_tickmark};
}; # defined($vrf->{minor_tickmark_nucleotide})
@ %def {_x_len} {_y_len}

We do not want to use the module [[POSIX]] just to have the logarithm in base 10 as a built-in function when it is so easy to implement with the default natural logarithm implemented in perl, as shown here:
% log_10(x) = ( log_e(x)/log_e(10) );

<<Common Routines>>=
sub logdec() { return (log($_[0])/log(10)); }
@ %def &logdec


\subsctn{Finding X/Y axes proportionality ratio}

We will want to set a fixed X/Y scale ratio (using [[aplot_xy_scale]] layout variable) and we have to set the proper values (or defaults) for the correspoding variables. If user provides a reasonable [[aplot_xy_scale]] value, then we must disable [[aplot_xy_same_length]], else we have to disable the first variable unless user has switched off the second one. We are interested in that case to know how much different are both axes lengths, so we are taking the X and Y axes ratio of their order of magnitude to get a well dimensioned plot (formula is similar to the tickmark step formula we have described in the previous section).

<<Layout Settings>>=
sub find_prop_ratio() {
    my ($vrf) = @_;
    my ($a,$b,$r);
    $a = 10**( int( &logdec( $vrf->{_x_len} ) ) );
    $b = 10**( int( &logdec( $vrf->{_y_len} ) ) );
    $r = $a / $b;
    RATIO: {
        defined($vrf->{aplot_xy_scale}) && do {
            (   $vrf->{aplot_xy_scale} > 0
             && $vrf->{aplot_xy_scale} < 10 * $r
              ) && do {
                $vrf->{aplot_xy_same_length} = $F;
                last RATIO;
            };
        }; # {aplot_xy_scale}
	    $vrf->{aplot_xy_same_length} && do {
            $vrf->{aplot_xy_scale} = -1;
            last RATIO;
        }; # {aplot_xy_same_length}
        $vrf->{aplot_xy_scale} = $r;
    }; # RATIO
    &report('SCALEDONE',
            (($vrf->{aplot_xy_scale} ne -1)
             ? "Current plot has an XY-RATIO of $vrf->{aplot_xy_scale}"
             : "XY-RATIO is not taken into account for this plot"
             ), &tobool($vrf->{aplot_xy_same_length}));
    return;
} # find_prop_ratio
@ %def &find_prop_ratio

<<messages - input/output>>=
SCALEDONE =>
  "###---> X/Y scale settings are: \n###     \%s\n".
  "###     Are X/Y axes going to have same length ? \%s \n",
@

As we are getting the ratio of X-axes divided by X-axes dimensionality, [[aplot_xy_scale]] over 1 correspond to X-axes larger than Y-axes and the opposite for values below 1. This will be useful in the PS code as we are now independent of the nucleotide lengths represented along the axes. 


\subsctn{Misc plot sections variables}

<<Layout Settings>>=
sub set_misc_vars() {
    my ($vrf) = @_;
    my %lbllen;
    <<looking for feature/group label lengths>>
} # set_misc_vars
@ %def &set_misc_vars

Here, we take care if user has set a fixed width for feature and group labels, else it is taken from the main GFF data structure (the corresponding fields, [[$_flw]] and [[$_glw]], were set in section~\ref{sec:setlabellengths} on page~\pageref{sec:setlabellengths}).

<<looking for feature/group label lengths>>=
%lbllen = (
    xfl => $vrf->{feature_x_label_length},
    xgl => $vrf->{group_x_label_length}  ,
    yfl => $vrf->{feature_y_label_length},
    ygl => $vrf->{group_y_label_length}  ,
  );
$vrf->{_plot_x_sequence} && do { 
    defined($lbllen{xfl}) || do {
        $lbllen{xfl} = 
            $GFF_DATA{$vrf->{_x_sequence_name}}[$_counter][$_flw];
    }; # feature_x_label_length
    defined($lbllen{xgl}) || do {
        $lbllen{xgl} = 
            $GFF_DATA{$vrf->{_x_sequence_name}}[$_counter][$_glw];
    }; # group_x_label_length
}; # _plot_x_sequence
$vrf->{_plot_y_sequence} && do { 
    defined($lbllen{yfl}) || do {
        $lbllen{yfl} = 
            $GFF_DATA{$vrf->{_y_sequence_name}}[$_counter][$_flw];
    }; # feature_y_label_length
    defined($lbllen{ygl}) || do {
        $lbllen{ygl} = 
            $GFF_DATA{$vrf->{_y_sequence_name}}[$_counter][$_glw];
    }; # feature_y_label_length
}; # _plot_y_sequence
foreach my $u (keys %lbllen) {
    $lbllen{$u} = (defined($lbllen{$u}) && $lbllen{$u} >= 0) ? $lbllen{$u} : 0;
}; # foreach $u
$vrf->{feature_x_label_length} = $lbllen{xfl};
$vrf->{group_x_label_length}   = $lbllen{xgl};
$vrf->{feature_y_label_length} = $lbllen{yfl};
$vrf->{group_y_label_length}   = $lbllen{ygl};
@ 


\subsctn{Setting whole figure labels}

When setting some of the plot labels, we must check if they are defined or not, but also we use them as warning reporters if any of the main draw elements was not found, say here alignment and/or X/Y sequence annotations.

<<Layout Settings>>=
sub set_page_labels() {
    my ($vrf) = @_;
    defined($vrf->{title})    || do {
        ($vrf->{title} = $vrf->{_alignment_name}) =~ s/:/ x /o;
        $vrf->{_plot_aln} || 
            ($vrf->{subtitle} = 
              'This alignment sequence was not found on GFF input records.\n'.
              '...Please, check your command-line and/or data...');
    };
    defined($vrf->{subtitle}) || ($vrf->{subtitle} = "");
    defined($vrf->{x_label})  || do {
        $vrf->{x_label} = $vrf->{_x_sequence_name};
        $vrf->{_plot_x_sequence} ||
            ($vrf->{x_label} .= " (Annotation NOT FOUND)");
    };
    defined($vrf->{y_label})  || do {
        $vrf->{y_label} = $vrf->{_y_sequence_name};
        $vrf->{_plot_y_sequence} ||
            ($vrf->{y_label} .= " (Annotation NOT FOUND)");
    };
    defined($vrf->{percent_box_label})    ||
        ($vrf->{percent_box_label} = '');
    defined($vrf->{percent_box_sublabel}) ||
        ($vrf->{percent_box_sublabel} = '');
    defined($vrf->{extra_box_label})      ||
        ($vrf->{extra_box_label} = '');
    defined($vrf->{extra_box_sublabel})   ||
        ($vrf->{extra_box_sublabel} = '');
    return;
} # set_page_labels
@ %def &set_page_labels


\newpage

\sctn{Obtaining {\ps} output} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	In this section we are going to implement those perl functions that are processing the data to produce a {\ps} plot (although we are writting some {\ps} code on it too), next section will focus in the {\ps} code that is included literally in those functions and which is really processing our data to get the figure. 

\label{todo:IAA}
<<HIDE: new defs TODO>>=
\def\todoIAA{
Description of Document Structuring Convention (DSC) and sketch PS file structure on figure~\ref{fig:PSdsc}.
} % todoIAA
@
<<HIDE: TODO>>=
\todoitem{\todoIAA}{todo:IAA}
@
\todo{ \item \todoIAA } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][6cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[{\ps} Document Structuring Convention for {\prog} output.]{\label{fig:PSdsc} Document Structuring Convention for {\prog} {\ps} output.}
\end{center}
\end{figure}

<<Making PS Figures>>=
sub make_plot() {
    &header("WRITING POSTSCRIPT TO STDOUT");

    &ps_header;
    &ps_colors;
    &ps_page_formats;
    &ps_variables;
    &ps_main;

    &ps_plot; 

    &ps_trailer;

    &footer("WRITING POSTSCRIPT FINISHED");
} # make_plot
@ %def &make_plot

<<PostScript CODE Chunks>>=
<<PostScript PLOT>>
<<PostScript HEADER>>
<<PostScript COLORS>>
<<PostScript FORMATS>>
<<PostScript VARS>>
<<PostScript MAIN>>
<<Postscript OPEN PAGE>>
<<Postscript CLOSE PAGE>>
<<Postscript TRAILER>>
@

\subsctn{Header comments and constants definition}
 
<<PostScript HEADER>>=
sub ps_header() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++HEADER+++";
%!PS-Adobe-3.0
%%Title: $vr->{title}
%%Creator: $PROGRAM
%%Version: $VERSION
%%CreationDate: $DATE
%%For: $USER
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 $vr->{_page_width} $vr->{_page_height}
%%EndComments
%
<<GNU License PostScript>>
%
% $LAST_UPDATE
%
% Report BUGS to: jabril\@imim.es 
%
%%BeginProlog
%
<<POSTSCRIPT shortnames>>
<<POSTSCRIPT constants>>
<<POSTSCRIPT general functions>>
<<POSTSCRIPT text functions>>
+++HEADER+++
    &report('PSHEADER');
} # ps_header
@ %def &ps_header

<<messages - input/output>>=
PSHEADER =>
  "###---> PostScript Header DONE...\n",
@

\subsctn{Filling up the CMYK colors hash} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CMYKcolordef}

% \subsctn{CMYK color definition}
This is the function that fills up the {\ps} colors array:

<<PostScript COLORS>>=
sub ps_colors() {
    my %tmp = ();
    print STDOUT "%% Fixed Color Variables (CMYK)\n";
    print STDOUT "/colordict ".($colors + 28)." dict D colordict begin %% ".
                 $colors." colors + 28 definitions\n";
    foreach my $key (keys %COLORS) { $tmp{$COLORS{$key}->[0]} = $key };
    for (my $j = 1; $j <= $colors; $j++) { 
        my $name = $tmp{$j};
        my $ref = \$COLORS{$name};
        my $cmyk = "$$ref->[1] $$ref->[2] $$ref->[3] $$ref->[4]";
        print STDOUT "/".(&fill_right($name,20," "))."{ $cmyk } D\n";
        };
    print STDOUT "end %% colordict\n";
    &report('PSCOLORS');
} # ps_colors
@ %def &ps_colors colordict

<<messages - input/output>>=
PSCOLORS =>
  "###---> PostScript Colors Table SET...\n",
@

<<Global Vars>>=
$colors = 0;
%COLORS = (    # [ ColorNUMBER, qw/ CYAN MAGENTA YELLOW BLACK / ]
  <<cmyk colors perl definition>>
  ); # %COLORS
@ %def COLORS

\label{todo:JAA}
<<HIDE: new defs TODO>>=
\def\todoJAA{
Move this section to a perl package: \\ suggesting [[gfftools::PostScript::colors]].
} % todoJAA
@
<<HIDE: TODO>>=
\todoitem{\todoJAA}{todo:JAA}
@
\todo{ \item \todoJAA } % todo

To avoid mistakes when working with three separate files, we define here CMYK color names used by this perl program, then the corresponding chunks are processedby [[colors2tex.pl]] to obtain the definitions {\LaTeX} file ('[[AplotColorDefs.tex]]') and the table summarizing them for the manual ('[[AplotColorTbl.tex]]').See appendix~\ref{sec:COLORprg} on page~\pageref{sec:COLORprg} to look at that script implementation. % outlined in page~\pageref{sec:cmykfiles}.

\label{sec:ColorsHsh}

\subsubsctn{Black and White}

\newcommand{\clrtbl}[5]{\vskip -2.95ex \noindent\hrulefill\cln{#1}\cln{#2}\cln{#3}\cln{#4}\cln{#5}}
\newcommand{\clrtblg}[7]{\vskip -2.95ex \noindent\hrulefill\cln{#1}\cln{#2}\cln{#3}\cln{#4}\cln{#5}\cln{#6}\cln{#7}}

\clrtblg{black}{verydarkgrey}{darkgrey}{grey}{lightgrey}{verylightgrey}{white}

<<cmyk colors perl definition>>=
# black+grey+white
black              => [ ++$colors, qw/ 0.00 0.00 0.00 1.00 / ],
verydarkgrey       => [ ++$colors, qw/ 0.00 0.00 0.00 0.80 / ],
darkgrey           => [ ++$colors, qw/ 0.00 0.00 0.00 0.60 / ],
grey               => [ ++$colors, qw/ 0.00 0.00 0.00 0.40 / ],
lightgrey          => [ ++$colors, qw/ 0.00 0.00 0.00 0.20 / ],
verylightgrey      => [ ++$colors, qw/ 0.00 0.00 0.00 0.10 / ],
white              => [ ++$colors, qw/ 0.00 0.00 0.00 0.00 / ],
@

\subsubsctn{Magenta}

\clrtbl{verydarkmagenta}{darkmagenta}{magenta}{lightmagenta}{verylightmagenta}

<<cmyk colors perl definition>>=
# magenta				  
verydarkmagenta    => [ ++$colors, qw/ 0.00 1.00 0.00 0.30 / ],
darkmagenta        => [ ++$colors, qw/ 0.00 0.80 0.00 0.05 / ],
magenta            => [ ++$colors, qw/ 0.00 0.60 0.00 0.00 / ],
lightmagenta       => [ ++$colors, qw/ 0.00 0.40 0.00 0.00 / ],
verylightmagenta   => [ ++$colors, qw/ 0.00 0.20 0.00 0.00 / ],
@

\subsubsctn{Violet}

\clrtbl{verydarkviolet}{darkviolet}{violet}{lightviolet}{verylightviolet}

<<cmyk colors perl definition>>=
# violet				  
verydarkviolet     => [ ++$colors, qw/ 0.45 0.85 0.00 0.00 / ],
darkviolet         => [ ++$colors, qw/ 0.30 0.65 0.00 0.00 / ],
violet             => [ ++$colors, qw/ 0.22 0.55 0.00 0.00 / ],
lightviolet        => [ ++$colors, qw/ 0.15 0.40 0.00 0.00 / ],
verylightviolet    => [ ++$colors, qw/ 0.10 0.20 0.00 0.00 / ],
@

\subsubsctn{Blue}

\clrtbl{verydarkblue}{darkblue}{blue}{lightblue}{verylightblue}

<<cmyk colors perl definition>>=
# blue				  
verydarkblue       => [ ++$colors, qw/ 1.00 1.00 0.00 0.20 / ],
darkblue           => [ ++$colors, qw/ 0.90 0.90 0.00 0.00 / ],
blue               => [ ++$colors, qw/ 0.75 0.75 0.00 0.00 / ],
lightblue          => [ ++$colors, qw/ 0.50 0.50 0.00 0.00 / ],
verylightblue      => [ ++$colors, qw/ 0.30 0.30 0.00 0.00 / ],
@

\subsubsctn{Skyblue}

\clrtbl{verydarkskyblue}{darkskyblue}{skyblue}{lightskyblue}{verylightskyblue}

<<cmyk colors perl definition>>=
# skyblue				  
verydarkskyblue    => [ ++$colors, qw/ 0.90 0.50 0.00 0.15 / ],
darkskyblue        => [ ++$colors, qw/ 0.75 0.45 0.00 0.00 / ],
skyblue            => [ ++$colors, qw/ 0.60 0.38 0.00 0.00 / ],
lightskyblue       => [ ++$colors, qw/ 0.45 0.25 0.00 0.00 / ],
verylightskyblue   => [ ++$colors, qw/ 0.30 0.15 0.00 0.00 / ],
@

\subsubsctn{Cyan}

\clrtbl{verydarkcyan}{darkcyan}{cyan}{lightcyan}{verylightcyan}

<<cmyk colors perl definition>>=
# cyan				  
verydarkcyan       => [ ++$colors, qw/ 1.00 0.00 0.00 0.10 / ],
darkcyan           => [ ++$colors, qw/ 0.80 0.00 0.00 0.00 / ],
cyan               => [ ++$colors, qw/ 0.60 0.00 0.00 0.00 / ],
lightcyan          => [ ++$colors, qw/ 0.40 0.00 0.00 0.00 / ],
verylightcyan      => [ ++$colors, qw/ 0.20 0.00 0.00 0.00 / ],
@

\subsubsctn{Seagreen}

\clrtbl{verydarkseagreen}{darkseagreen}{seagreen}{lightseagreen}{verylightseagreen}

<<cmyk colors perl definition>>=
# seagreen			  
verydarkseagreen   => [ ++$colors, qw/ 0.75 0.00 0.45 0.00 / ],
darkseagreen       => [ ++$colors, qw/ 0.62 0.00 0.38 0.00 / ],
seagreen           => [ ++$colors, qw/ 0.50 0.00 0.30 0.00 / ],
lightseagreen      => [ ++$colors, qw/ 0.38 0.00 0.22 0.00 / ],
verylightseagreen  => [ ++$colors, qw/ 0.25 0.00 0.15 0.00 / ],
@

\subsubsctn{Green}

\clrtbl{verydarkgreen}{darkgreen}{green}{lightgreen}{verylightgreen}

<<cmyk colors perl definition>>=
# green				  
verydarkgreen      => [ ++$colors, qw/ 1.00 0.00 1.00 0.25 / ],
darkgreen          => [ ++$colors, qw/ 0.80 0.00 0.80 0.00 / ],
green              => [ ++$colors, qw/ 0.60 0.00 0.60 0.00 / ],
lightgreen         => [ ++$colors, qw/ 0.40 0.00 0.40 0.00 / ],
verylightgreen     => [ ++$colors, qw/ 0.20 0.00 0.20 0.00 / ],
@

\subsubsctn{Limegreen}

\clrtbl{verydarklimegreen}{darklimegreen}{limegreen}{lightlimegreen}{verylightlimegreen}

<<cmyk colors perl definition>>=
# limegreen			  
verydarklimegreen  => [ ++$colors, qw/ 0.50 0.00 1.00 0.10 / ],
darklimegreen      => [ ++$colors, qw/ 0.40 0.00 0.95 0.00 / ],
limegreen          => [ ++$colors, qw/ 0.30 0.00 0.80 0.00 / ],
lightlimegreen     => [ ++$colors, qw/ 0.20 0.00 0.65 0.00 / ],
verylightlimegreen => [ ++$colors, qw/ 0.10 0.00 0.50 0.00 / ],
@

\subsubsctn{Yellow}

\clrtbl{verydarkyellow}{darkyellow}{yellow}{lightyellow}{verylightyellow}

<<cmyk colors perl definition>>=
# yellow				  
verydarkyellow     => [ ++$colors, qw/ 0.00 0.00 1.00 0.25 / ],
darkyellow         => [ ++$colors, qw/ 0.00 0.00 1.00 0.10 / ],
yellow             => [ ++$colors, qw/ 0.00 0.00 1.00 0.00 / ],
lightyellow        => [ ++$colors, qw/ 0.00 0.00 0.50 0.00 / ],
verylightyellow    => [ ++$colors, qw/ 0.00 0.00 0.25 0.00 / ],
@

\subsubsctn{Orange}

\clrtbl{verydarkorange}{darkorange}{orange}{lightorange}{verylightorange}

<<cmyk colors perl definition>>=
# orange				  
verydarkorange     => [ ++$colors, qw/ 0.00 0.50 0.80 0.10 / ],
darkorange         => [ ++$colors, qw/ 0.00 0.40 0.80 0.00 / ],
orange             => [ ++$colors, qw/ 0.00 0.30 0.80 0.00 / ],
lightorange        => [ ++$colors, qw/ 0.00 0.20 0.75 0.00 / ],
verylightorange    => [ ++$colors, qw/ 0.00 0.15 0.70 0.00 / ],
@

\subsubsctn{Red}

\clrtbl{verydarkred}{darkred}{red}{lightred}{verylightred}

<<cmyk colors perl definition>>=
# red					  
verydarkred        => [ ++$colors, qw/ 0.00 1.00 1.00 0.15 / ],
darkred            => [ ++$colors, qw/ 0.00 0.80 0.80 0.00 / ],
red                => [ ++$colors, qw/ 0.00 0.60 0.60 0.00 / ],
lightred           => [ ++$colors, qw/ 0.00 0.40 0.40 0.00 / ],
verylightred       => [ ++$colors, qw/ 0.00 0.20 0.20 0.00 / ],
@

\subsubsctn{Brown}

\clrtbl{verydarkbrown}{darkbrown}{brown}{lightbrown}{verylightbrown}

<<cmyk colors perl definition>>=
# brown				  
verydarkbrown      => [ ++$colors, qw/ 0.35 0.85 1.00 0.40 / ],
darkbrown          => [ ++$colors, qw/ 0.30 0.70 1.00 0.35 / ],
brown              => [ ++$colors, qw/ 0.25 0.75 1.00 0.25 / ],
lightbrown         => [ ++$colors, qw/ 0.20 0.60 0.70 0.15 / ],
verylightbrown     => [ ++$colors, qw/ 0.15 0.45 0.55 0.00 / ],
@ 

\subsubsctn{Colors Help}

<<colors help>>=
Those are the colors defined in $PROGRAM:
+ Basic Colors: black white.
+ Variable Colors: 
      grey magenta violet blue skyblue cyan seagreen
         green limegreen yellow orange red brown
  You can get five color shades from Variable Colors with
  \"verydark\", \"dark\", \"light\" and \"verylight\" prefixes,
  as example: 
    verydarkblue, darkblue, blue, lightblue and verylightblue.
@


\subsctn{Filling up the page formats hash} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsctn{Page formats definition}

Now we have to fill the page formats {\ps} array:

\label{sec:PAGEdef}

<<PostScript FORMATS>>=
sub ps_page_formats() {
    my %tmp = ();
    print STDOUT "%% Paper Sizes (in points)\n";
    print STDOUT "/pagedict ".($formats + 2)." dict D pagedict begin %% ".
                 $formats." formats + 2 definitions\n";
    foreach my $key (keys %FORMATS) { $tmp{$FORMATS{$key}->[0]} = $key };
    for (my $j = 1; $j <= $formats; $j++) { 
        my $name = $tmp{$j};
        my $ref = \$FORMATS{$name};
        my $pgsz = &fill_left($$ref->[1],4," ").&fill_left($$ref->[2],5," ");
        print STDOUT "/pg".(&fill_right($name,10," "))."{ $pgsz } D\n";
        };
    print STDOUT "end %% pagedict\n";
    &report('PSFORMATS');
} # ps_page_formats
@ %def &ps_page_formats pagedict

<<messages - input/output>>=
PSFORMATS =>
  "###---> PostScript Page-formats Table SET...\n",
@

<<Global Vars>>=
$formats = 0;
%FORMATS = (   # [ FormatNUMBER, X(short edge), Y(long edge) ]
  <<page sizes perl definition>>
  ); # %FORMATS
@ %def FORMATS


\label{todo:JAB}
<<HIDE: new defs TODO>>=
\def\todoJAB{
Move this section to a perl package: \\ suggesting [[gfftools::PostScript::formats]].
} % todoJAB
@
<<HIDE: TODO>>=
\todoitem{\todoJAB}{todo:JAB}
@
\todo{ \item \todoJAB } % todo


\label{sec:FormatsHsh}

\subsubsctn{ISO standard page sizes: A series}

<<page sizes perl definition>>=
  # A Series
  a0        => [ ++$formats, 2384, 3370 ],
  a1        => [ ++$formats, 1684, 2384 ],
  a2        => [ ++$formats, 1190, 1684 ],
  a3        => [ ++$formats,  842, 1190 ],
  a4        => [ ++$formats,  595,  842 ],
  a5        => [ ++$formats,  420,  595 ],
  a6        => [ ++$formats,  297,  420 ],
  a7        => [ ++$formats,  210,  297 ],
  a8        => [ ++$formats,  148,  210 ],
  a9        => [ ++$formats,  105,  148 ],
  a10       => [ ++$formats,   73,  105 ],
@

\subsubsctn{ISO standard page sizes: B series}

<<page sizes perl definition>>=
  # B Series
  b0        => [ ++$formats, 2920, 4127 ],
  b1        => [ ++$formats, 2064, 2920 ],
  b2        => [ ++$formats, 1460, 2064 ],
  b3        => [ ++$formats, 1032, 1460 ],
  b4        => [ ++$formats,  729, 1032 ],
  b5        => [ ++$formats,  516,  729 ],
  b6        => [ ++$formats,  363,  516 ],
  b7        => [ ++$formats,  258,  363 ],
  b8        => [ ++$formats,  181,  258 ],
  b9        => [ ++$formats,  127,  181 ],
  b10       => [ ++$formats,   91,  127 ],
@

\subsubsctn{US standard page sizes}

<<page sizes perl definition>>=
  # USA Formats
  executive => [ ++$formats,  540,  720 ],
  folio     => [ ++$formats,  612,  936 ],
  legal     => [ ++$formats,  612, 1008 ],
  letter    => [ ++$formats,  612,  792 ],
  quarto    => [ ++$formats,  610,  780 ],
  statement => [ ++$formats,  396,  612 ],
 '10x14'    => [ ++$formats,  720, 1008 ],
  ledger    => [ ++$formats, 1224,  792 ],
  tabloid   => [ ++$formats,  792, 1224 ],
@

\subsubsctn{Page sizes help}

<<pages help>>=
The following page sizes are available: from A0 to A10, 
from B0 to B10, 10x14, executive, folio, ledger, legal, 
letter, quarto, statement and tabloid.
@


\subsctn{Setting up {\ps} variables}

<<HIDE: DONE>>=
\doneitem{20011113}{Setting up PostScript variables}
@

Color and page dictionaries are generated before this chunk from the corresponding {\prog} hashes ([[%COLORS]] and [[%FORMATS]]). Now we are going to set all the variables in the {\ps} code that depend on a [[%Vars{LAYOUT}]] variable.

<<PostScript VARS>>=
sub ps_variables() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++PSVARS+++";
%
%%EndProcSet:   Pseudohash_dicts 1.0 0
%
tflg { (%%% Basic settings and functions were defined %%%) msg } if
%
%%BeginProcSet: Setting_Vars 1.0 0
%
tflg { (%%% Setting variables %%%) msg } if
<<PSVariables - layout>>
<<PSVariables - tickmarks>>
<<PSVariables - labels>>
%
%%EndProcSet:   Setting_Vars 1.0 0
%
+++PSVARS+++
    &report('PSVARS');
} # ps_variables
@ %def &ps_variables

<<messages - input/output>>=
PSVARS =>
  "###---> PostScript Variables SET...\n",
@

\subsubsctn{Setting global boolean flags and page format for figure}

We define here the main {\ps} flags for the plot, in example those related to showing or not main blocks from the final figure, but also the test flag that will help us to debug the {\ps} code by switching on few print outs to check the contents of the {\ps} stack.

<<PSVariables - layout>>=
/H true D     %-> horizontality boolean flag default value
/HT {         %-% switch on horizontality flag
  /H true  D  %-%
} B           %-%
/VT {         %-% switch off horizontality flag
  /H false D  %-%
} B           %-%
%-%
/flgcrd                                  %-> to show credits or not
  @{[ &tobool(! $vr->{hide_credits}) ]}  %-% we must negate hide_credits value
D                                        %-% 
%-%
/flglscape @{[ &tobool($F) ]} D  %-> landscape mode not implemented yet
                                 %-% so that, it is set to false
%-%
/Pb @{[ &tobool($vr->{show_percent_box}) ]} D  %-%
/Qb @{[ &tobool($vr->{show_extra_box}) ]} D    %-%
%-%
/axesb @{[ &tobool($vr->{aplot_xy_same_length}) ]} D  %-%
/XYR   $vr->{aplot_xy_scale} D                        %-%
%-%
/ZM    @{[ &tobool($vr->{zoom_marks}) ]} D            %:%
@ %def H HT VT flgcrd flglscape Pb Qb axesb XYR ZM 

<<PSVariables - layout>>=
%-% getting page format
/Dpage {                %-> Dpage -> page_width page_height
  pagedict begin        %-> recovering from pagedict dictionary
    pg$vr->{page_size}  %->          this page width and height        
    flglscape {         %-> if flglscape is true 
      exch              %->    exchanges width and height
    } if                %->
  end                   %-> close pagedict
} D                     %-%
%-% proportionality constant
/PPC              %->
  pagedict begin  %-> recovering from pagedict dictionary
    pga4          %->   a4 page size
  end             %->
  hip             %-> hypotenuse for a4 page
  Dpage hip       %-> hypotenuse for current page format
  exch            %-> hyp_curr_page hyp_a4_page
  div             %-> ratio between current page format and a4
D                 %-%
%-% Setting credits max height
/Ch               %-> 
   4 pt           %-> min_height
  15 pt           %-> max_height
   4 pt PPC mul   %-> current height (scaled relative to page size)
  clim            %-> 
D                 %:%
@ %def Dpage PPC Ch

<<PSVariables - layout>>=
%-% Margins are XY independent.
/MT @{ $vr->{margin_top} } D     %-% Top margin
/MB @{ $vr->{margin_bottom} } D  %-% Bottom margin
/ML @{ $vr->{margin_left} } D    %-% Left margin
/MR @{ $vr->{margin_right} } D   %:% Right margin
@ %def MT MB ML MR


\subsubsctn{Page main blocks color variables}

<<PSVariables - layout>>=
%-% Background Colors
/bg {                       %-% bg -> c m y k 
  colordict begin           %-> recovering from colordict dictionary
    $vr->{background_color}    %-%            this color cmyk values
  end                       %-% close colordict
} D                         %-% 
/fg {                       %-% fg -> c m y k 
  colordict begin           %->
    $vr->{foreground_color}    %-%
  end                       %-%
} D                         %-% 
/ABc {                      %-% ABc -> c m y k 
  colordict begin           %->
    $vr->{aplot_box_bgcolor}   %-%
  end                       %-%
} D                         %-% 
/PBc {                      %-% PBc -> c m y k 
  colordict begin           %->
    $vr->{percent_box_bgcolor} %-%
  end                       %-%
} D                         %-% 
/QBc {                      %-% QBc -> c m y k 
  colordict begin           %->
    $vr->{extra_box_bgcolor}   %-%
  end                       %-%
} D                         %-% 
@ %def bg fg ABc PBc QBc 

\subsubsctn{Sequence boundaries and tickmarks}

<<PSVariables - layout>>=
%-% plot limits
/XO $vr->{_x_start} D  %-% X-sequence first nucleotide coord
/XE $vr->{_x_end} D    %-% X-sequence last  nucleotide coord
/XD XE XO sub 1 add D  %-%
/YO $vr->{_y_start} D  %-% Y-sequence first nucleotide coord
/YE $vr->{_y_end} D    %-% Y-sequence last  nucleotide coord
/YD YE YO sub 1 add D  %-%
/PO $vr->{_pbox_min_score} D  %-% Percent lower score value
/PE $vr->{_pbox_max_score} D  %-% Percent upper score value
/PD PE PO sub D        %:%
@ %def XO XE XD YO YE YD PO PE PD

% not very useful at this moment but could be interesting
% /PD
%   PE PO sub 
%   PO chktk 
%   PE chktk
%   max
%   10 exch neg exp % if PE=1.0 and PO=0.2   then adds 0.1
%   add             % if PE=1.0 and PO=0.25  then adds 0.01
% D                 % if PE=1.0 and PO=0.255 then adds 0.001

<<PSVariables - layout>>=
%-% boxes heights
/Ph @{ $vr->{percent_box_height} } D  %-% user can define a box height
/Qh @{ $vr->{extra_box_height} } D    %:% but it will always fit page limits 
@ %def Ph Qh

<<PSVariables - tickmarks>>=
%-% tickmark boolean flags
/KGb @{[ &tobool($vr->{show_grid}) ]} D            %-% 
/KLb @{[ &tobool($vr->{show_tickmark_label}) ]} D  %-% tickmark labels == coords
/KAXb @{[ &tobool($vr->{show_aplot_x_ticks}) ]} D    %-% Aplot X ticKmarks flg
/KAYb @{[ &tobool($vr->{show_aplot_y_ticks}) ]} D    %-% Aplot Y ticKmarks flg
/KPXb @{[ &tobool($vr->{show_percent_x_ticks}) ]} D  %-% Percent X ticKmarks flg
/KPYb @{[ &tobool($vr->{show_percent_y_ticks}) ]} D  %-% Percent Y ticKmarks flg
/KQXb @{[ &tobool($vr->{show_extrabox_x_ticks}) ]} D %-% extra-Q X ticKmarks flg
/KQYb @{[ &tobool($vr->{show_extrabox_y_ticks}) ]} D %:% extra-Q X ticKmarks flg
@ %def KGb KLb KAXb KAYb KPXb KPYb KQXb KQYb

<<PSVariables - tickmarks>>=
%-% tickmark start/end and step variables
/KASm $vr->{major_tickmark_nucleotide} D  %-%
/KASn $vr->{minor_tickmark_nucleotide} D  %-%
%-%
/KPSm $vr->{major_tickmark_score} D       %-%
/KPSn $vr->{minor_tickmark_score} D       %-%
%-%
    /maxtck 10 D %-% $vr->{aplot_major_tickmark} D
    /mintck  5 D %-% $vr->{aplot_minor_tickmark} D
    /pctmxt 10 D %-% $vr->{percent_major_tickmark} D
    /pctmnt  5 D %-% $vr->{percent_minor_tickmark} D
  /KQSm 10 D %-% $vr->{extra_major_tickmark_step} D
  /KQSn 10 D %-% $vr->{extra_minor_tickmark_step} D
    /xtrmxt 10 D %-% $vr->{extra_major_tickmark} D
    /xtrmnt  5 D %-% $vr->{extra_minor_tickmark} D
@ %def KASm KASn KPSm KPSn KQSm KQSn

\subsubsctn{Title area variables}

<<PSVariables - labels>>=
%-% Title labels
/TTLb @{[ &tobool($vr->{show_title}) ]} D      %-%
/TTLl @{[ &tostring($vr->{title}) ]} D         %-%
/TTLz @{ $vr->{title_fontsize} } D             %-%
/TTLf { TTLz $Fonts{$vr->{title_font}} } D     %-%
/TTLp    %-% Title spacer
  10 pt  %-%  min_value
  25 pt  %-%  max_value
  TTLz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %-%
/TTlb @{[ &tobool($vr->{show_subtitle}) ]} D   %-%
/TTll @{[ &tostring($vr->{subtitle}) ]} D      %-%
/TTlz @{ $vr->{subtitle_fontsize} } D          %-%
/TTlf { TTlz $Fonts{$vr->{subtitle_font}} } D  %-%
/TTlp    %-% Subtitle spacer
  10 pt  %-%  min_value
  25 pt  %-%  max_value
  TTlz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %:%
@ %def TTLb TTLl TTLz TTLf TTLp TTlb TTll TTlz TTlf TTlp

\subsubsctn{Labeling X/Y sequence axes}

<<PSVariables - labels>>=
%-% annotation labels
/XSLb @{[ &tobool($vr->{show_x_label}) ]} D   %-%
/XSLl @{[ &tostring($vr->{x_label}) ]} D      %-%
/XSLz @{ $vr->{x_label_fontsize} } D          %-%
/XSLf { XSLz $Fonts{$vr->{x_label_font}} } D  %-%
/XSLp    %-% X-sequence label spacer
   5 pt  %-%  min_value
  10 pt  %-%  max_value
  XSLz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %-%
/YSLb @{[ &tobool($vr->{show_y_label}) ]} D   %-%
/YSLl @{[ &tostring($vr->{y_label}) ]} D      %-%
/YSLz @{ $vr->{y_label_fontsize} } D          %-%
/YSLf { YSLz $Fonts{$vr->{y_label_font}} } D  %-%
/YSLp    %-% Y-sequence label spacer
   5 pt  %-%  min_value
  10 pt  %-%  max_value
  YSLz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %:%
@ %def XSLb XSLl XSLz XSLf XSLp YSLb YSLl YSLz YSLf YSLp

\subsubsctn{Labels for percent box}

<<PSVariables - labels>>=
%-% percent box labels
/PBLb @{[ &tobool($vr->{show_percent_box_sublabel}) ]} D  %-%
/PBLl @{[ &tostring($vr->{percent_box_label}) ]} D        %-%
/PBLz @{ $vr->{percent_box_label_fontsize} } D            %-%
/PBLf { PBLz $Fonts{$vr->{percent_box_label_font}} } D    %-%
/PBLp    %-% Percent box label spacer
  10 pt  %-%  min_value
  20 pt  %-%  max_value
  PBLz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %-%
/PBlb @{[ &tobool($vr->{show_percent_box_sublabel}) ]} D  %-%
/PBll @{[ &tostring($vr->{percent_box_sublabel}) ]} D     %-%
/PBlz @{ $vr->{percent_box_sublabel_fontsize} } D         %-%
/PBlf { PBlz $Fonts{$vr->{percent_box_sublabel_font}} } D %-%
/PBlp    %-% Percent box sublabel spacer
  10 pt  %-%  min_value
  20 pt  %-%  max_value
  PBlz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %:%
@ %def PBLb PBLl PBLz PBLf PBLp PBlb PBll PBlz PBlf PBlp

\subsubsctn{Labels for bottom panel}

<<PSVariables - labels>>=
%-% extra box labels
/QBLb @{[ &tobool($vr->{show_extra_box_label}) ]} D   %-%
/QBLl @{[ &tostring($vr->{extra_box_label}) ]} D      %-%
/QBLz @{ $vr->{extra_box_label_fontsize} } D          %-%
/QBLf { QBLz $Fonts{$vr->{extra_box_label_font}} } D  %-%
/QBLp    %-% Extra box label spacer
  10 pt  %-%  min_value
  20 pt  %-%  max_value
  QBLz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %-%
/QBlb @{[ &tobool($vr->{show_extra_box_sublabel}) ]} D   %-%
/QBll @{[ &tostring($vr->{extra_box_sublabel}) ]} D      %-%
/QBlz @{ $vr->{extra_box_sublabel_fontsize} } D          %-%
/QBlf { QBlz $Fonts{$vr->{extra_box_sublabel_font}} } D  %-%
/QBlp    %-% Extra box sublabel spacer
  10 pt  %-%  min_value
  20 pt  %-%  max_value
  QBlz   %-%  current_value
  zlim   %-%  return value within interval or zero
D        %:%
@ %def QBLb QBLl QBLz QBLf QBLp QBlb QBll QBlz QBlf QBlp


\subsubsctn{Labels for annotation features}

<<PSVariables - labels>>=
%-% feature labels: global settings
/FTz @{ $vr->{feature_label_fontsize} } D         %-%
/FTf { FTz $Fonts{$vr->{feature_label_font}} } D  %-%
/FTp                                   %-% feature labels spacing
  FTz 0.25 mul                         %-% (between feature labels
D                                      %-%         and source tier)
%-% feature labels: X-sequence vars
/FTXw                                  %-% max feature label length
  $vr->{feature_x_label_length}        %-%
  FTf glblw                            %-%
D                                      %-%
/FTXa $vr->{feature_x_label_angle} D   %-%
/FTXrb @{[ &tobool($vr->{feature_x_label_rotate}) ]} D  %-%
%-% feature labels: Y-sequence vars
/FTYw                                  %-% max feature label length
  $vr->{feature_y_label_length}        %-%
  FTf glblw                            %-%
D                                      %-%
/FTYa $vr->{feature_y_label_angle} D   %-%
/FTYrb @{[ &tobool($vr->{feature_y_label_rotate}) ]} D  %:%
@ %def FTz FTf FTp FTXw FTXa FTXrb FTYw FTYa FTYrb


\subsubsctn{Labels for annotated groups}

<<PSVariables - labels>>=
%-% group labels: global settings
/GPz @{ $vr->{group_label_fontsize} } D         %-%
/GPf { GPz $Fonts{$vr->{group_label_font}} } D  %-%
/GPp                                 %-% group labels spacing 
  GPz 0.25 mul                       %-% (between feature and group labels)
D                                    %-% 
%-% group labels: X-sequence vars
/GPXw                                %-% max group label length
  $vr->{group_x_label_length}        %-%
  GPf glblw                          %-%
D                                    %-%
/GPXa $vr->{group_x_label_angle} D   %-%
/GPXrb @{[ &tobool($vr->{group_x_label_rotate}) ]} D  %-%
%-% group labels: Y-sequence vars
/GPYw                                %-% max group label length
  $vr->{group_y_label_length}        %-%
  GPf glblw                          %-%
D                                    %-%
/GPYa $vr->{group_y_label_angle} D   %-%
/GPYrb @{[ &tobool($vr->{group_y_label_rotate}) ]} D  %:%
@ %def GPz GPf GPp GPXw GPXa GPXrb GPYw GPYa GPYrb

\subsubsctn{Misc layout variables}

Those vars are not well defined yet.

<<PSVariables - labels>>=
/DRh 10 pt D  %:% source tier height
@ %def DRh

<<PSVariables - labels>>=
/Blw 2 pt D    %-% boxes border line width
/KLz 8 pt D    %-% tickmarks labels font-size
/KLf {            %->
  KLz /Helvetica  %-%
} D               %-% tickmarks labels font
/KWx 1.5 pt D  %-% major tickmarks line width
/KWn           %-> minor tickmarks line width
  KWx 0.1 mul  %->
D              %->
/KHx           %-> major tickmarks height
  KLz 0.75 mul %->
D              %->
/KHn           %-> minor tickmarks height
  KLz 0.50 mul %->
D              %->
/KLp           %-> tickmarks labels spacer (plus drawn marks)
  KLz 1.0 mul  %->
D              %-%
/KLh           %-> tickmarks labels max height
  KLz KLp add  %->
D              %->
/KLw           %-> tickmarks labels max width
  20 KLp add   %->
D              %-%
@ %def KLz KLw KLh KLp

<<PSVariables - labels>>=
% those must be renamed/removed
/X0 XO D
/X1 XE D
/Y0 XO D
/Y1 XE D
/Y 5 cm D
/ZoomON 0 D
/Spacer 1 cm D
/Xmarg 1 cm D
/axesp 1 D
/BBoxX XO D
/BBoxY XE D
/MxFtLBL  1 D % MxFtLBL;
/MxGpLBL  1 D % MxGpLBL;
/putExon  1 D % tmpflag;
/putExLbl 1 D % OnOff(Var["Display_BOX_LABEL"]);
/putGnLbl 1 D % OnOff(Var["Display_GENE_LABEL"]);
@


\subsctn{Main {\ps} functions}

\label{todo:IAC}
<<HIDE: new defs TODO>>=
\def\todoIAC{
Page layout must be redefined (taking into account page size too).
} % todoIAC
@
<<HIDE: TODO>>=
\todoitem{\todoIAC}{todo:IAC}
@
\todo{ \item \todoIAC } % todo

<<PostScript MAIN>>=
sub ps_main() {
    print STDOUT << '+++MAINProcs+++';
<<POSTSCRIPT layout>>
<<POSTSCRIPT aplotdict>>
<<POSTSCRIPT main function calls>>
%
%%EndProlog
%
<<PostScript SETUP>>
%
+++MAINProcs+++
    &report('PSCODE');
} # ps_main
@ %def &ps_main

<<messages - input/output>>=
PSCODE =>
  "###---> PostScript Functions SET...\n",
@

<<PostScript SETUP>>=
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
@


\subsctn{Plotting data into the figure}

We are going to translate data and their settings into {\ps} code, passing those elements to the {\ps} execution stack from where they can be taken as parameters of the built-in {\ps} functions (see section~\ref{sec:PSONLY}, page~\pageref{sec:PSONLY}, to get into the {\ps} functions implementation). {\prog} produces a single page figure, so that [[&ps_plot]] routine has been developed as a linear design.

\label{todo:IAD}
<<HIDE: new defs TODO>>=
\def\todoIAD{
Plotting data into the figure
} % todoIAD
@
<<HIDE: TODO>>=
\todoitem{\todoIAD}{todo:IAD}
@
\todo{ \item \todoIAD } % todo

<<PostScript PLOT>>=
sub ps_plot(){
    &report('PSPLOT');
    #
    &ps_open_page;
    #
    &ps_block_aplot;
    #
    $Vars{LAYOUT}{show_percent_box} && &ps_block_percent;
    #
    $Vars{LAYOUT}{show_extra_box}   && &ps_block_extra;
    #
    &ps_close_page;
    #
    &report('PSPLOTDONE');
} # ps_plot
@ %def &ps_plot

<<messages - input/output>>=
PSPLOT =>
  "###---> Writting PostScript Page:\n",
PSPLOTDONE =>
  "###---> PostScript Page FINISHED...\n",
BLOCKRB =>
  "###     + APLOT-BOX drawing \%s ribbons...\n",
BLOCKXY =>
  "###     + APLOT-BOX drawing \%s annotation...\n",
BLOCKA =>
  "###     + \%s drawing alignment features...\n",
BLOCKFX =>
  "###     + APLOT-BOX extra features from custom files...\n",
BLOCKDONE =>
  "###     + \%s section DONE...\n",
@

\subsubsctn{Producing main aplot box}

<<PostScript PLOT>>=
sub ps_block_aplot() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << '+++MAINProcs+++';
%
%%%%%%%% START NEW PLOT
%
DoInit
DoHeader
%
%%%%%%%% ALIGNMENT PLOT - BOX
%
begindata
+++MAINProcs+++
    # feature ribbons
    $vlr->{show_ribbons} && do {
        $vlr->{_plot_x_sequence} && do { # horizontal
            &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        }; # _plot_x_sequence
        $vlr->{_plot_y_sequence} && do { # vertical
            &ps_plot_ribbons($vlr->{_y_sequence_name},$F);
        }; # _plot_y_sequence
        # nice ribbon lines finishing
        &ps_plot_outlines;
    }; # show_ribbons
    # tag definitions: Box,Join,Arrow,Banner;
    $vlr->{_plot_x_sequence} && do { # horizontal
        &ps_plot_features($vlr->{_x_sequence_name},$T);
    }; # _plot_x_sequence
    $vlr->{_plot_y_sequence} && do { # vertical
        &ps_plot_features($vlr->{_y_sequence_name},$F);
    }; # _plot_y_sequence
    $vlr->{_plot_aln} && do {
        &ps_plot_aln($vlr->{_alignment_name});
    }; # _plot_aln
    $vlr->{_plot_addons} && do {
        &ps_plot_addons; # PLOTREMARKS(seqname,flag)
    }; # _plot_addons
    $vlr->{zoom_area} && do {
        my $kt = defined($vlr->{zoom_area_fill_color}) 
                 ? "$vlr->{zoom_area_fill_color} ".&tobool($T)
                 : &tobool($F);
        printf STDOUT "%s %s %s %s %s %s %s Msquare\n",
            $vlr->{zoom_area_mark_width}, $vlr->{zoom_area_mark_color}, $kt,
            &max($vlr->{_x_zoomarea_start}, $vlr->{_x_start}),
            &min($vlr->{_x_zoomarea_end},   $vlr->{_x_end}),
            &max($vlr->{_y_zoomarea_start}, $vlr->{_y_start}),
            &min($vlr->{_y_zoomarea_end},   $vlr->{_y_end});
    }; # zoom_area
    print STDOUT "\%\nenddata\n\%\n";
    &report('BLOCKDONE','APLOT-BOX  ');
} # ps_block_aplot
@ %def &ps_block_aplot

<<PostScript PLOT>>=
sub ps_plot_ribbons() {
    my ($seq,$flg) = @_;
    my $what = $flg ? 'X-sequence' : 'Y-sequence';
    &report('BLOCKRB',$what);
    print STDOUT "\%\n\%\%\%\% $what Ribbons\n\%\n".
                 ($flg ? 'beginXseq'  : 'beginYseq')."\n"; 


    print STDOUT "endseq\n";
} # ps_plot_ribbons
@ %def &ps_plot_ribbons

<<PostScript PLOT>>=
sub ps_plot_outlines() {

} # ps_plot_outlines
@ %def &ps_plot_outlines

<<PostScript PLOT>>=
sub ps_plot_features() {
    my ($seq,$flg) = @_;
    my $what = $flg ? 'X-sequence' : 'Y-sequence';
    &report('BLOCKXY',$what);
    print STDOUT "\%\n\%\%\%\% DATA ---> $what Annotations\n\%\n".
                 ($flg ? 'beginXseq'  : 'beginYseq')."\n"; 


    print STDOUT "endseq\n";
} # ps_plot_features
@ %def &ps_plot_features

<<PostScript PLOT>>=
sub ps_plot_aln() {
    my ($aln) = @_;
    &report('BLOCKA','APLOT-BOX');
    print STDOUT "\%\n\%\%\%\% DATA ---> Alignment\n\%\nbeginaln\n"; 

 
    print STDOUT "endseq\n";
} # ps_plot_aln
@ %def &ps_plot_aln

<<PostScript PLOT>>=
sub ps_plot_addons() {
    &report('BLOCKFX');
    print STDOUT "\%\n\%\%\%\% Extra features from custom files...\n\%\nbeginaln\n"; 
 

    print STDOUT "endseq\n";
} # ps_plot_addons
@ %def &ps_plot_addons


\subsubsctn{Generating percent box}

% Get the scores limits for the sequence 
% (taking into account $vlr->{percent_box_score_range} )
%
% $vlr->{_aln_lower_sco} $vlr->{_aln_upper_sco}
% $vlr->{_alignment_name}

<<PostScript PLOT>>=
sub ps_block_percent() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++MAINProcs+++";
%
%%%%%%%% MATCHES PERCENT - BOX
%
% lowerpct upperpct
$vlr->{_aln_lower_sco} $vlr->{_aln_upper_sco} beginmatches
%
+++MAINProcs+++
    ($vlr->{show_ribbons} && $vlr->{_plot_x_sequence}) && do { # horizontal
        &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        &ps_plot_outlines;
    }; # show_ribbons && _plot_x_sequence
    print STDOUT "\%\nVT\n\%\npctmarks\n";
    $vlr->{_plot_aln} && do {
        &ps_plot_pctaln($vlr->{_alignment_name});
    }; # _plot_aln
    print STDOUT "\%\nendmatches\n\%\n";
    &report('BLOCKDONE','PERCENT-BOX');
} # ps_block_percent
@ %def &ps_block_percent

<<PostScript PLOT>>=
sub ps_plot_pctaln() {
    my ($aln) = @_;
    print STDOUT "\%\n\%\%\%\% DATA ---> Alignment\n\%\n"; 
    &report('BLOCKA','PERCENT-BOX');
 
} # ps_plot_pctaln
@ %def &ps_plot_pctaln


\subsubsctn{Generating lower panel}

<<PostScript PLOT>>=
sub ps_block_extra() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++MAINProcs+++";
%
%%%%%%%% EXTRA DATA - BOX
%
% numlines
$vlr->{_x_sequence_sources} beginextra % NGROUPS
%
+++MAINProcs+++
    ($vlr->{show_ribbons} && $vlr->{_plot_x_sequence}) && do { # horizontal
        &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        &ps_plot_outlines;
    }; # show_ribbons && _plot_x_sequence

    print STDOUT "\%\nendextra\n\%\n";
    &report('BLOCKDONE','EXTRA-BOX  ');
} # ps_block_extra
@ %def &ps_block_extra


\subsctn{{\ps} code chunks}

\subsubsctn{Page boundaries}

<<Postscript OPEN PAGE>>=
sub ps_open_page() {
    print STDOUT << '+++OPEN+++';
%%Page: 1 1
%%BeginPageSetup
%
% Saving current page settings
/pgsave save D
%
%%EndPageSetup
%
+++OPEN+++
} # ps_open_page
@ %def &ps_open_page

<<Postscript CLOSE PAGE>>=
sub ps_close_page() {
    print STDOUT << '+++CLOSE+++';
%
DoEnd
%
%%%%%%%% PLOT DONE
%
grestoreall
pgsave restore
showpage
%
%%PageEND: 1 1
%
+++CLOSE+++
} # ps_close_page
@ %def &ps_close_page

\subsubsctn{{\ps} end of file}

<<Postscript TRAILER>>=
sub ps_trailer() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++EOF+++";
%%Trailer
%
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 $vr->{_page_width} $vr->{_page_height}
%%EOF
+++EOF+++
} # ps_trailer
@ %def &ps_trailer

\newpage

\sctn{{\ps} main program and routines} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:PSONLY}

This section is mainly focused on the {\ps} functions that are executed on the {\ps} device to produce the figures.
We have implemented a perl script that is used as a [[noweb]] filter (see appendix~\ref{sec:PSnowebfilter}, page~\pageref{sec:PSnowebfilter}), that removes from {\ps} code chunks a special set of comments ('[[%-%]]', '[[%->]]' and '[[%:%]]'). That makes such code more compact within executable {\prog} version, while preserving full readability in this document, as example by showing stack contents for functions and so on.
 
<<HIDE: DONE>>=
\doneitem{20011114}{Enhance PostScript code readability, including special comments that should be stripped out when tangling code, making final PS code more compact while preserving full explanations in this document.}
@


\subsctn{Abbreviated function names}

<<POSTSCRIPT shortnames>>=
%%BeginProcSet: Short_names 1.0 0
%
%-% key definition
/B { bind def } bind def       %-% bind replaces operator names by their values
                               %-% so that the "bound" function executes faster
/X { exch def } B              %-%
/D { def      } B              %-%
%-% graphic state matrix
/S { gsave     } B             %-% temporary saving/restoring 
/R { grestore  } B             %-%   of the current graphics state matrix
/F { scale     } B             %-%
/T { translate } B             %-%
%-% path drawing
/m  { moveto  } B              %-%
/rm { rmoveto } B              %-%
/l  { lineto  } B              %-%
/rl { rlineto } B              %-%
/K  { stroke  } B              %-%
%-% styles
/cmyk { setcmykcolor } B       %-% we are going to use only CMYK colors
/slw  { setlinewidth } B       %-%
/dotted  { [ 1   ] 0 setdash } D  %-% dotted line style: 1 ON 1 OFF, offset=0
/ldotted { [ 1 2 ] 0 setdash } D  %-% dotted line style: 1 ON 2 OFF, offset=0
/dashed  { [ 3 2 ] 0 setdash } D  %:% dashed line style: 3 ON 2 OFF, offset=0
%
%%EndProcSet:   Short_names 1.0 0
%
@


\subsctn{Defining PS constants}

<<POSTSCRIPT constants>>=
%%BeginProcSet: Constants 1.0 0
%
%-% units
/pt   {           } B  %-% points do not need to be transformed
/cm   { 28.35 mul } B  %-% convert centimeters to points
/icm  { 28.35 div } B  %-% invert centimeter scale (points to cm)
/in   { 72    mul } B  %:% convert inches to points
%-% printer offset
/OST 0.25 cm D  %-% offset defines non printable
/OSB 0.25 cm D  %-% paper area for pages (printer outlimits).
/OSL 0.25 cm D  %-%
/OSR 0.25 cm D  %:%
%
%%EndProcSet:   Constants 1.0 0
%
@ %def OST OSB OSL OSR


\subsctn{Reporting {\ps} code execution}

We take advantage of the {\ps} file operators '[[print]]' and '[[flush]]' to report {\ps} code execution and stack contents. '[[print]]' writes a string to the {\ps} interpreter standard output, you can visualize that output if you are using a {\ps} interpreter like [[ghostscript]] not when you are sending the document to the printer. '[[flush]]' causes any buffered characters for the standard output file to be delivered immediately, so we can obtain the output messages produced with '[[print]]' during real-time execution. [[mst]] requires a ``mark'' element as the first element stack, which is provided at the variables definition if [[tflg]] boolean flag is switched on (remember that it depends on [[$Debug]] perl variable settings).

<<PSFunctions - debugging>>=
%-% debugging boolean flags
/vflg false D %-> verbose flag
/tflg @{[ &tobool($Debug) ]} D  %-> test flag
tflg {  %-% if debbuging is on then push the mark object into the execution
  mark  %-%  stack (as the bottomest element) so dumping functions
} if    %:%  can retrieve all elements in that stack to check if they are ok
%-%
%-% msg takes a string from the stack and send it to standard output
/msg {     %-> string msg 
  print    %->  prints the string to stdout
  (\\n)     %->  we append a newline to the string
  print    %->    by printing the newline to stdout
  flush    %-> delivering buffered characters to standard output
} B        %->
%-%
%-% mst takes a string that we use as an identifier, appends all the elements 
%-%   that were found in the stack and send it to standard output
/mst {         %-> mark stack_el.n ... stack_el.0 string mst
  msg          %-%  printing identifier string, so stack is now:
               %-> mark stack_el.n ... stack_el.0
  counttomark  %-%  finding how many elements the stack has, so stack is now:
               %-% mark stack_el.n ... stack_el.0 n
  1 add        %-> mark stack_el.n ... stack_el.0 N (where N = n + 1)
  dup {        %-> mark stack_el.n ... stack_el.0 N N 
               %-%  the duplicated N is used here as times to repeat this loop
    dup        %-> mark stack_el.n ... stack_el.0 N N
    index      %-%  returning the Nth element from stack (starting on top)
               %-> mark stack_el.n ... stack_el.0 N stack_el.N
    20 string  %-> mark stack_el.n ... stack_el.0 N stack_el.N empty_string
    cvs        %-> mark stack_el.n ... stack_el.0 N (stack_el.N)_string
    print      %-%  printing (stack_el.N)_string
    ( )        %-%  printing a white space to distinguish
    print      %-%    each stack element from next one
               %-> mark stack_el.n ... stack_el.0 N
    1 sub      %-> mark stack_el.n ... stack_el.0 N--
  } repeat     %-%  stack is left untouched during the whole repeat loop 
  (\\n)        %->
  print        %->  we append a newline to the stack elements set of strings
  pop          %->  we must remove last value of N (that is -1) from stack
  flush        %->  delivering buffered characters to standard output
} B            %-%
%-% 
%-% msc is useful when we want to print var contents
%-%   because we can push the var names and their values into the stack
%-%   and it clears the stack once it has finished 
/msc {         %-> mark var_name.string.0 var_value.0 ...
  mst          %->   ... var_name.string.n var_value.n string msc 
  counttomark  %-> 
  1 add {      %-> 
    pop        %-> removing all the stack elements, including the "mark"
  } repeat     %-> (but leaving the global "mark" we left if $Debug is on)
} B            %:%  
@ %def tflg msg mst


\subsctn{General function names}

<<POSTSCRIPT general functions>>=
%%BeginProcSet: General_functions 1.0 0
%
<<PSFunctions - debugging>>
<<PSFunctions - bbox>>
<<PSFunctions - obox>>
<<PSFunctions - min max>>
<<PSFunctions - clim zlim>>
<<PSFunctions - hip>>
%
%%EndProcSet:   General_functions 1.0 0
%
@

\begin{figure}[!h]
\begin{center}
\begin{tabular}{c@{}c}
\begin{minipage}[c]{0.65\linewidth}
\begin{center}
\hspace{1cm}
<<PSFunctions - bbox>>=
/bbox {      %-> llx lly urx ury bbox
  %-% vflg { (bbox) msg } if
  4 copy     %-> llx lly urx ury llx lly urx ury
  3 1 roll   %-> llx lly urx ury llx ury lly urx
  exch       %-> llx lly urx ury llx ury urx lly
  6 2 roll   %-> llx lly urx lly urx ury llx ury
  8 -2 roll  %-> urx lly urx ury llx ury llx lly
  m l l l    %->
  closepath  %-> 
} B          %:% function returns a box path
@ %def bbox
\end{center}
\end{minipage}
&
\fbox{
\begin{minipage}[c]{0.3\linewidth}
\begin{center}
\setlength{\unitlength}{0.5cm}
\begin{picture}(6,4.5)\small
 \put(0.5,0.5){\makebox(0,0){(llx,lly)}} \put(0.5,3.5){\makebox(0,0){(llx,ury)}}
 \put(5.5,0.5){\makebox(0,0){(urx,lly)}} \put(5.5,3.5){\makebox(0,0){(urx,ury)}}
 \thinlines
 \put(0.5,1){\vector(0,1){2}}  \put(2,3.5){\vector(1,0){2}}
 \put(5.5,3){\vector(0,-1){2}} \multiput(4,0.5)(-0.25,0){9}{\line(-1,0){0.1}}
\end{picture}
\vskip 1ex
\caption[PS functions: \texttt{bbox}]{\\[1ex]
\parbox{\linewidth}{\hfill\parbox{0.9\linewidth}{PS function [[bbox]], dashed line represents [[closepath]].}}
 } % caption
\end{center}
\end{minipage}
} %fbox
\\
\end{tabular}
\end{center}
\end{figure}

<<PSFunctions - obox>>=
%-% obox draw a box that is enclosing its bounding box
%-%   by displacing half the with of its path outside those limits
/obox {     %-> LLx LLy URx URy lw  obox
  %-% vflg { (obox) msg } if
  2 div     %-> we get half the width, which is the correct offset to add
  dup       %-> LLx LLy URx URy lw lw 
  dup       %-> LLx LLy URx URy lw lw lw
  dup       %-> LLx LLy URx URy lw lw lw lw
  7 1 roll  %-> LLx lw LLy URx URy lw lw lw
  5 1 roll  %-> LLx lw LLy lw URx URy lw lw
  3 1 roll  %-> LLx lw LLy lw URx lw URy lw
  add       %-> LLx lw LLy lw URx lw URy!
  7 1 roll  %-> URy! LLx lw LLy lw URx lw
  add       %-> URy! LLx lw LLy lw
  6 1 roll  %-> URx! URy! LLx lw LLy lw
  sub       %-> URx! URy! LLx lw LLy!
  5 1 roll  %-> LLy! URx! URy! LLx lw
  sub       %-> LLy! URx! URy! LLx!
  4 1 roll  %-> LLx! LLy! URx! URy!
  bbox      %->
} B         %-%
@ %def obox

<<PSFunctions - min max>>=
%-% minimum of two values
/min {    %-> value1 value2 min -> min_value
  %-% vflg { (min) msg } if
  2 copy  %-> value1 value2 value1 value2
  gt {    %-> is value1 greater than value2
    exch  %-> then stack-> value2 value1
  } if    %-> else stack-> value1 value2
  pop     %-> removing top element from stack
} B       %-% returns smaller value
%-% maximum of two values
/max {    %-> value1 value2 max -> max_value
  %-% vflg { (max) msg } if
  2 copy  %-> value1 value2 value1 value2
  lt {    %-> is value1 lower than value2
    exch  %-> then stack-> value2 value1
  } if    %-> else stack-> value1 value2
  pop     %-> removing top element from stack
} B       %:% returns larger value
@ %def min max 

<<PSFunctions - clim zlim>>=
%-% clim returns a value that must fit within an interval
%-%   by clipping off-limits to min or max values 
/clim {      %-> min_value max_value value clim -> new_value
  %-% vflg { (clim) msg } if
  min        %-> min_value min(max_value,value)
  max        %-> max(min_value,min(max_value,value))
} B          %-% min_value <= value <= max_value
%-% zlim computes limits as clim
%-%   but taking into account null values
/zlim {      %-> min_value max_value curr_value zlim -> new_value
  %-% vflg { (zlim) msg } if 
  dup        %-> min_value max_value curr_value curr_value
  0 eq {     %-> if font size is set to zero remove title area
    3 {      %-> 
      pop    %->   empty function stack
    } repeat %-> 
    0        %->   value returned is set to zero
  } {        %-> else
    clim     %->   return value within interval
  } ifelse   %->
} B          %:% (value == 0) OR (min_value <= value <= max_value)
@ %def clim zlim

\vskip 1ex
\begin{tabular}{c@{}c}
\begin{minipage}[c]{0.65\linewidth}
\begin{center}
\hspace{-1cm}
<<PSFunctions - hip>>=
%-% hip returns the hypotenuse given two legs of a right triangle
%-%   by applying Theorem of Pythagoras
/hip {   %-> x-leg y-leg hip -> hypotenuse
  %-% vflg { (hip) msg } if
  dup    %-> x-leg y-leg y-leg
  mul    %-> x-leg y-leg^2
  exch   %-> y-leg^2 x-leg
  dup    %-> y-leg^2 x-leg x-leg
  mul    %-> y-leg^2 x-leg^2
  add    %-> sum_of_squares
  sqrt   %-> square_root of sum_of_squares
} B      %:% 
@ %def hip
\end{center}
\end{minipage}
&
\begin{minipage}[c]{0.35\linewidth}
\begin{center}
\fbox{
$
h \;=\; \sqrt{ \; x^2 + y^2 \; }
$
} %fbox
\end{center}
\end{minipage}
\\
\end{tabular}


\subsctn{Text related functions}

<<POSTSCRIPT text functions>>=
%%BeginProcSet: Text_functions 1.0 0
%
<<PSFunctions - sfnt>>
<<PSFunctions - glblw>>
<<PSFunctions - rtshw>>
<<PSFunctions - ctshw>>
<<PSFunctions - ltshw>>
<<PSFunctions - chrh>>
<<PSFunctions - strh>>
<<PSFunctions - ttshw>>
%
%%EndProcSet:   Text_functions 1.0 0
%
%%BeginProcSet: Pseudohash_dicts 1.0 0
% %-% color and page dictionaries are generated after this chunk
@

<<PSFunctions - sfnt>>=
%-% sfnt is setting current scaled font
/sfnt {      %-> font_size font_name  sfnt
  %-% vflg { (sfnt) msg } if
  findfont   %-> font_size <font>
  exch       %-> <font> font_size
  scalefont  %-> <scaled_font>
  setfont    %-> 
} B          %:%
@ %def sfnt

<<PSFunctions - glblw>>=
%-% glblw returns the length in points of a string having n chars
/glblw {               %-> char_length {font_size font}  glblw
  %-% vflg { (glblw) msg } if
  sfnt                 %-> char_length font_def
  (X) stringwidth pop  %-> getting length for a single char
  mul                  %->   at the given font and fontsize
} B                    %:%
@ %def glblw

<<PSFunctions - rtshw>>=
%-% rtshw shows strings from (x,y) coords to right 
/rtshw {     %-> (string) angle x y font_def c m y k  rtshw
  %-% vflg { (rtshw) msg } if
  S          %->
  cmyk       %-> (string) angle x y font_def
  sfnt       %-> (string) angle x y
  m          %-> (string) angle
  rotate     %-> (string)
  show       %-> 
  R          %-> 
} B          %:%
@ %def rtshw

<<PSFunctions - ctshw>>=
%-% ctshw shows strings centered on (x,y) coords 
/ctshw {        %-> (string) angle x y font_def c m y k  ctshw
  %-% vflg { (ctshw) msg } if
  10 -1 roll    %-> angle x y font_def={fontsize font} c m y k (string)
  dup           %-> angle x y fontsize font c m y k (string) (string)
  11 1 roll     %-> (string) angle x y fontsize font c m y k (string)
  7 -2 roll     %-> (string) angle x y c m y k (string) fontsize font
  2 copy        %-> (string) angle x y c m y k (string) f_size font f_size font
  9 2 roll      %-> (string) angle x y f_size font c m y k (string) f_size font
  S             %->
    sfnt        %->
    stringwidth %->
    pop         %-> (string) angle x y f_size font c m y k string_width
  R             %->
  2 div         %-> (string) angle x y f_size font c m y k string_width/2
  9 -1 roll     %-> (string) angle y f_size font c m y k width/2 x
  exch          %-> (string) angle y f_size font c m y k x width/2
  sub           %-> (string) angle y f_size font c m y k x!
  8 1 roll      %-> (string) angle x! y f_size font c m y k
  rtshw         %->
} B             %:%
@ %def ctshw

% /ctshw { vflg { (ctshw) msg } if 10 -1 roll dup 11 1 roll 7 -2 roll 2 copy 9 2 roll S sfnt stringwidth pop R 2 div H { 9 -1 roll exch sub 8 1 roll } { 8 -1 roll exch sub 7 1 roll } ifelse rtshw } B
% /ltshw { vflg { (ltshw) msg } if 10 -1 roll dup 11 1 roll 7 -2 roll 2 copy 9 2 roll S sfnt stringwidth pop R H { 9 -1 roll exch sub 8 1 roll } { 8 -1 roll exch sub 7 1 roll } ifelse rtshw } B

<<PSFunctions - ltshw>>=
%-% ltshw shows strings from (x,y) coords to left 
/ltshw {        %-> (string) angle x y font_def c m y k  ltshw
  vflg { (ltshw) msg } if  %-%
  10 -1 roll    %-> angle x y font_def={fontsize font} c m y k (string)
  dup           %-> angle x y fontsize font c m y k (string) (string)
  11 1 roll     %-> (string) angle x y fontsize font c m y k (string)
  7 -2 roll     %-> (string) angle x y c m y k (string) fontsize font
  2 copy        %-> (string) angle x y c m y k (string) f_size font f_size font
  9 2 roll      %-> (string) angle x y f_size font c m y k (string) f_size font
  S             %->
    sfnt        %->
    stringwidth %->
    pop         %-> (string) angle x y f_size font c m y k string_width
  R             %->
  9 -1 roll     %-> (string) angle y f_size font c m y k string_width x
  exch          %-> (string) angle y f_size font c m y k x string_width
  sub           %-> (string) angle y f_size font c m y k x!
  8 1 roll      %-> (string) angle x! y f_size font c m y k
  rtshw         %->
} B             %:%
@ %def ltshw

<<PSFunctions - chrh>>=
%-% chrh returns character height for the current font size
/chrh {            %->
  vflg { (chrh) msg } if  %-%
  S                %->
    newpath        %->
    0 0 m          %->
    false charpath %->
    flattenpath    %->
    pathbbox       %->
    exch           %->
    pop            %->
    3 -1 roll      %->
    pop            %->
  R                %->
} B                %:%
@ %def chrh

<<PSFunctions - strh>>=
%-% strh returns whole string total height with the current font size
/strh {         %->
  vflg { (strh) msg } if  %-%
  2 dict begin  %->
    /lly 0.0 D  %->
    /ury 0.0 D  %->
    {     	    %->
      ( )       %->
      dup       %->
      0    	    %->
      4 -1 roll %->
      put       %->
      chrh     	%->
      dup       %->
      ury gt {  %->
        /ury X  %->
      } {       %->
        pop     %->
      } ifelse  %->
      dup       %->
      lly lt {  %->
        /lly X  %->
      } {       %->
        pop     %->
      } ifelse  %->
    } forall    %->
    ury    	    %->
  end           %->
} B             %:%
@ %def strh

<<PSFunctions - ttshw>>=
% X Y angle string valign halign fnt color ttshw
 % valign : tv (top)  cv (middle) bv (bottom)
 % halign : lh (left) ch (center) rh (right)
/ttshw {            %->
  vflg { (ttshw) msg } if  %-%
  S                 %->
    cmyk            %->
    sfnt            %->
    8 dict begin    %->
      /h X          %->
      /v X          %->
      /lbl X        %->
      /angle X      %->
      /y X          %->
      /x X          %->
      /hs           %->
        lbl         %->
        stringwidth %->
        pop         %->
%        neg         %->
        D           %->
      /vs           %->
        lbl         %->
        strh        %->
%        neg         %->
        D           %->
      x y T         %->
      angle rotate  %->
      h (rh) eq {   %->
        hs          %->
      } {           %->
        h (ch) eq { %->
          hs 2 div  %->
        } {         %->
          0         %->
        } ifelse    %->
      } ifelse      %->
      neg           %->
      v (tv) eq {   %->
        vs          %->
      } {           %->
        v (cv) eq { %->
          vs 2 div  %->
        } {         %->
          0         %->
        } ifelse    %->
      } ifelse      %->
      m             %->
      lbl show      %->
    end             %->
  R                 %->
} B                 %:%
@ %def ttshw


\subsctn{Page layout}

In this section we are going to compute in the {\ps} code, the relative amount of plot lengths for each of the main plot blocks (in this case, alignment plot, percent and extra boxes). We start by getting the usable page area:

<<POSTSCRIPT layout>>=
%%BeginProcSet: Page_layout 1.0 0
%
tflg { (%%% Computing page layout %%%) msg } if
%-% checking if margins are within the defined offset
%->% flglscape {
  %-% checking margins for flglscape mode
%->% } {
  %-% checking margins for portrait mode
  /MT MT OST max D  %-%
  /MB MB OSB max D  %-%
  /ML ML OSL max D  %-%
  /MR MR OSR max D  %:%
%->% } ifelse 
%-%
%-% defining pagelimits
/FL {            %-> FL -> usable_width usable_height
  Dpage          %-> page_width page_height
  MT MB add      %->
  flgcrd {       %-> if credits are shown
    Ch add       %->   also remove credits height from available space
  } if           %-> n = (margin_top + margin_bottom [+ credits_height])
  sub            %-> page_width u_hght = (page_height - n)
  exch           %-> u_hght page_width
  ML MR add sub  %-> u_hght u_wdth = (p_width - (margin_left + margin_right))
  exch           %-> u_wdth u_hght
} D              %-% returns u_wdth u_hght
%-% defining coordinates for origin on page
%->% flglscape {
%->% } {
  %-% in portrait mode:
  /FXO ML D  %-% corresponds to upper left corner X
  /FYO       %-% corresponds to upper left corner Y
    Dpage    %-> page_width page_height
    exch     %-> page_height page_width
    pop      %-> page_height
    MT sub   %-> page_height - margin_top
  D          %:%
%->% } ifelse 
tflg { %-%
  mark (Dpage:) Dpage ( PPC:) PPC ( ZM:) ZM (*>*>*>) msc %-%
  mark (bg:) bg ( fg:) fg                   (*>*>*>) msc %-%
  mark ( ABc:) ABc ( PBc:) PBc ( QBc:) QBc  (*>*>*>) msc %-%
  mark (XO:) XO ( XE:) XE ( XD:) XD         (*>*>*>) msc %-%
  mark (YO:) YO ( YE:) YE ( YD:) YD         (*>*>*>) msc %-%
  mark (FL:) FL ( FXO:) FXO ( FYO:) FYO     (*>*>*>) msc %-%
} if %:%
@ %def FL FXO FYO

We also need to know how much space is required for feature and group labels.

<<POSTSCRIPT layout>>=
/FTXh      %-%
 10        %-%
D          %-% feature labels height
/FTYh      %-%
 10        %-%
D          %:% feature labels height
@ %def FTXh FTYh

<<POSTSCRIPT layout>>=
/GPXh      %-%
 10        %-%
D          %-% group labels height
/GPYh      %-%
 10        %-%
D          %:% group labels height
@ %def GPXh GPYh

After that we look how much width the alignment plot may have:

<<POSTSCRIPT layout>>=
/ATX             %-> x-sequence total annotation width
  GPXh GPp add   %-%  add X-seq group label height and spacer
  FTXh FTp add   %-%  add X-seq feature label height and spacer
  add            %-%
  DRh add        %-%  add source tier height
D                %-%
/ATY             %-> y-sequence total annotation width
  GPYh GPp add   %-%  add Y-seq group label height and spacer
  FTYh FTp add   %-%  add Y-seq feature label height and spacer
  add            %-%
  DRh add        %-%  add source tier height
D
@ %def ATX ATY

<<POSTSCRIPT layout>>=
/AXL             %-> left starting position for aplot
  YSLz YSLp add  %-%  add Y-sequence label height and spacer
  ATY add        %-%  add annotation width 
D                %-%
%-%
/AXR             %-> right ending position for aplot
  FL pop         %-%  get available page_width
  KAYb KPYb or   %-% 
  KQYb or {      %-% if ( KAYb || KPYb || KQYb ) then
    KLw KLp add  %-%   substracting tickmark label width and its spacer
    sub          %-%
  } if           %-%
D                %-%
%-%
/AX              %-> getting aplot box max_width
  AXR AXL sub    %-%
D                %:%
tflg { mark (ATX:) ATX ( ATY:) ATY                        %-%
           ( AXL:) AXL ( AXR:) AXR ( AX:) AX (*>*>*>) msc } if
@ %def AXL AXR AX

And we have to calculate how much height the alignment plot has:

<<POSTSCRIPT layout>>=
/AYT             %-> top starting position for aplot-box
  TTLz TTLp add  %-%  add title area  
  TTlz TTlp add  %-% 
  add            %-%  add subtitle area
  XSLz XSLp add  %-% 
  add            %-%  add X-seq label height and spacer
  ATX add        %-%  add annotation width 
D                %-%
%-%
/AYB             %-> although plots will have different heights,
  AYT AX add     %-% aplot origin is always the same, at (AXL,AYB)
D                %-%
%-% 
/AY AX D         %:% aplot max_width and max_height are the same by default
tflg { mark (AYT:) AYT ( AYB:) AYB ( AY:) AY (*>*>*>) msc } if
@ %def AYT AYB AY

We re-scale the X and Y axes for the alignment plot:

<<POSTSCRIPT layout>>=
XYR 0 le {  %-%
  /XYR 1 D  %-% reseting XYR if not defined as 1:1 x/y-ratio
} if        %-%
%-%
axesb not {      %-%
  %-% if not aplot_xy_same_length flag then change previous def
  XYR 1 ge {     %-% 
    %-% if XYR>=1 then X-axes must be larger than Y-axes 
    %-% /AX AX D %-% AX does not change 
    /AY          %-% 
      AY XYR div %-% we set AY = AY / XYR
    D            %-%
  } {            %-%
    %-% else XYR<1 then Y-axes must be larger than X-axes
    %-% /AY AY D %-% AY does not change
    /AX          %-%
      AX XYR mul %-% we set AX = AX / (1 / XYR) = AX * XYR
    D            %-%
  } ifelse       %-%
} if             %:%
tflg { mark (XYR:) XYR ( AX:) AX ( AY:) AY (*>*>*>) msc } if
@

Here, we set up all the Y coords for the percent box:

<<POSTSCRIPT layout>>=
/PYT        %-> percent-box upper coord
  AYB       %-%  starts were ends aplot box
  KLz       %-%  plus tickmark font height
  KAXb {    %-%  if show_aplot_x_ticks
    2 mul   %-%    we must keep twice the space
  } if      %-%    between aplot box and percent box
  add       %-%
D           %-%
%-%
/rspc          %-> remaining bottom free space
  FL exch pop  %-% page usable_height
  PYT sub      %-% remove aplot and headers height
  Pb {         %-% if show_percent_box
    KLz        %-%  plus tickmark font height
    KPXb {     %-%  if show_percent_x_ticks
      2 mul    %-%    we must keep twice the space
    } if       %-%    between percent box and extra box
    sub        %-% 
  } if         %-%
  Qb {         %-% if show_extra_box
    KLz        %-%  plus tickmark font height
    KQXb {     %-%  if show_extrabox_x_ticks
      2 mul    %-%    we must keep twice the space
    } if       %-%    between percent box and extra box
    sub        %-% 
  } if         %-% so we finally get the remaining bottom free space
D              %-%
%-%
/PY  %-> defining height of percent box with the current layout definitions
  Pb {           %-% if show_percent_box
    Ph 0 gt {    %-%   if defined percent_box_height
      2 cm       %-%     min percent box height
      rspc       %-%     remaining space should be the max height
      Qb {       %-%     if show_extra_box
        2 div    %-%       then take as much as half the remaining space
      } if       %-% 
      Ph         %-%     current space
      clim       %-%     returning a value within the interval
    } {          %-%   else !defined
      2.5 cm     %-%     default value is defined as 2.5 cm
    } ifelse     %-%  
  } {            %-%   else !show
    0            %-%     setting to zero (we do not need later)
  } ifelse       %-%  
D                %-%
%-%
/PYB         %-> setting percent-box bottom coord
  PYT PY add %-%  by adding percent-box height
D            %:%  to percent-box upper coord
tflg { mark (axesb:) axesb ( rspc:) rspc     (*>*>*>) msc %-%
       mark (PYT:) PYT ( PYB:) PYB ( PY:) PY (*>*>*>) msc } if
@ %def PYT PYB PY rspc

Now, we focus on the Y coords for the extra box:

<<POSTSCRIPT layout>>=
/QYT         %-> extra-box upper left corner
  PYB        %-%  starts were ends percent box,
             %-%    but here we must check:
  Pb {       %-%  if show_percent_box
    KLz      %-%    plus tickmark font height
    KPXb {   %-%    if show_percent_x_ticks
      2 mul  %-%      we must keep twice the space
    } if     %-%      between aplot box and percent box
    add      %-%
  } if       %-%
D            %-%
%-%
/QY  %-> defining height of extra box with the current layout definitions
  Qb {         %-> if show_extra_box
    rspc       %-%   by default
    Pb {       %-%   we take all the remaining space 
      PY sub   %-%    removing percent box height if shown in plot
    } if       %-%
    Qh 0 gt {  %-%   if defined extra_box_height
      2 cm     %-%     min extra box height
      exch     %-%     retrieve max height (rspc)
      Qh       %-%     current space
      clim     %-%     returning a value within the interval
    } if       %-%
  } {          %-%   else !show
    0          %-%     setting to zero (we do not need later)
  } ifelse     %-%
D              %-%
%-%
/QYB          %-> setting extra-box bottom coord
  QYT QY add  %-%  by adding extra-box height
D             %:%  to extra-box upper coord
tflg { mark (QYT:) QYT ( QYB:) QYB ( QY:) QY (*>*>*>) msc } if
@ %def QYT QYB QY

<<POSTSCRIPT layout>>=
/WBox     0.50 cm D    % TagBox Size
/HWBox WBox 2 div    D
/Warw  WBox 0.75 mul D
/HWarw Warw 2 div    D
%
/ElmFont      { 12 FTLbsc mul /Times-Roman } D
/TagFont      { 14 GPLbsc mul /Times-Roman } D
/TagLabelFont { 16 /Times-Bold  } D
%
/xBDspl  1.8 putExon add putExLbl add putGnLbl add D % 1.25
/xGLDspl 1.0 putExon add putExLbl add D              % 0.85
/xGDspl  0.75 putExon add putExLbl add D
/FBDspl 0.60 D % For example, for mRNA.
%
%%EndProcSet:   Page_Layout 1.0 0
%
@


\subsctn{The APLOT dictionary}

<<POSTSCRIPT aplotdict>>=
%
%%BeginProcSet: Aplot_dict 1.0 0
%
tflg { (%%% Setting aplot dictionary %%%) msg } if
/aplotdict 120 dict D  %-%
  aplotdict begin      %:%
  <<PSFunctions - Xscm Xscme>>
  <<PSFunctions - Yscm Yscme>>
  <<PSFunctions - fmt flt>>
  <<PSFunctions - line>>
  <<PSFunctions - uline>>
  <<PSFunctions - corner>>
  <<PSFunctions - zoomtk>>
  <<PSFunctions - Line>>
  <<PSFunctions - Xline>>
  <<PSFunctions - Bline>>
  <<PSFunctions - Bsquare>>
  <<PSFunctions - Msquare>>
  <<PSFunctions - Mcircle>>
  <<PSFunctions - Join>>
  <<PSFunctions - Arrow>>
  <<PSFunctions - FBox>>
  <<PSFunctions - FTalgn>>
  <<PSFunctions - GPalgn>>
  <<PSFunctions - Box>>
  <<PSFunctions - GDmore>>
  <<PSFunctions - BDmore>>
  <<PSFunctions - GnBanner>>
  <<PSFunctions - SbBanner>>
  <<PSFunctions - Banner>>
  <<PSFunctions - common tick functions>>
  <<PSFunctions - htick>>
  <<PSFunctions - vtick>>
  <<PSFunctions - nucltick>>
  <<PSFunctions - pctmarks>>
  <<POSTSCRIPT main functions>>
end % aplotdict
%
%%EndProcSet:   Aplot_dict 1.0 0
%
@ %def aplotdict tckdict


<<PSFunctions - Xscm Xscme>>=
/Xscm {       %->
  Xscale mul  %->
} B           %->
/Xscme {      %->
  Xscm exch   %->
} B           %:%
@ %def Xscm Xscme

<<PSFunctions - Yscm Yscme>>=
/Yscm {       %->
  Yscale mul  %->
} B           %->
/Yscme {      %->
  Yscm exch   %->
} B           %:%
@ %def Yscm Yscme

<<PSFunctions - fmt flt>>=
/fmt {   %->
  Yscme  %->
  Xscme  %->
  m      %->
} B      %->
/flt {   %->
  Yscme  %->
  Xscme  %->
  l      %->
} B      %:%
@ %def fmt flt

<<PSFunctions - line>>=
/line {  %->
  vflg { (line) msg } if  %-%
  cmyk   %->
  slw    %->
  m      %->
  l      %->
  K      %->
} B      %:%
@ %def line

<<PSFunctions - uline>>=
/uline {         %->
  vflg { (uline) msg } if  %-%
  cmyk           %->
  slw            %->
  m              %->
  S              %->
    H {          %->
      0 -0.1 cm  %->
    } {          %->
      0.1 cm 0   %->
    } ifelse     %->
    rl           %->
    K            %->
  R              %->
  l              %->
  S              %->
    H {          %->
      0 -0.1 cm  %->
    } {          %->
      0.1 cm 0   %->
    } ifelse     %->
    rl           %->
    K            %->
  R              %->
  K              %->
} B              %:%
@ %def uline

<<PSFunctions - corner>>=
/corner {        %-> X Y r s corner
  S              %->
    4 -2 roll    %-> r s X Y
    m            %->         moving corner to its origin
    0 0 0 0      %-> r s 0 0 0 0
    6 4 roll     %-> 0 0 0 0 r s
    dup neg      %-> 0 0 0 0 r s -s
    5 1 roll     %-> 0 0 -s 0 0 r s
    6 1 roll     %-> 0 s 0 -s 0 0 r
    dup neg      %-> 0 s 0 -s 0 0 r -r
    4 1 roll     %-> 0 s 0 -s -r 0 0 r
    exch         %-> 0 s 0 -s -r 0 r 0
    2 {          %->
      rl         %-> going out from (X,Y)
      S          %->
        bg cmyk  %->
        Blw 6 div slw %->
        K        %->
      R          %->
      rl         %-> returning to (X,Y)
      S          %->
        fg cmyk  %->
        Blw slw  %->
        [1 3] 0 setdash %->
        K        %->
      R          %->
    } repeat     %->
  R              %->
} B              %->
@ %def corner

<<PSFunctions - zoomtk>>=
/zoomtk {   %-> LLx LLy URx URy zoomtk
  vflg { (zoomtk) msg } if  %-%
  %-% setting coordinates for all four box corners
  4 copy    %-> LLx LLy URx URy LLx LLy URx URy
  3 1 roll  %-> LLx LLy URx URy LLx URy LLy URx
  exch      %-> LLx LLy URx URy LLx URy URx LLy
  %-% drawing corner marks
  ATX     ATY     corner  %-> corner on URx LLy
  ATX neg ATY neg corner  %-> corner on LLx URy
  ATX     ATY neg corner  %-> corner on URx URy
  ATX neg ATY     corner  %-> corner on LLx LLy
} D         %:%
@ %def zoomtk

<<PSFunctions - Line>>=
%%  x0 y0 x1 y1 lwidth lcolor Line
/Line {  %->
  vflg { (Line) msg } if  %-%
  S  %->
    9 5 roll   %->
    2 {  %->
      Yscm  %->
      4 1 roll  %->
      Xscm  %->
      4 1 roll  %->
    } repeat  %->
    9 4 roll  %->
    line  %->
  R  %->
} B  %:%
@ %def Line

<<PSFunctions - Xline>>=
/Xline {   %->
  vflg { (Xline) msg } if  %-%
  S  %->
    3 1 roll  %->
    Xscme  %->
    Xscme  %->
    3 -1 roll  %->
    Yscm  %->
    xwdt sub  %->
    dup  %->
    3 1 roll  %->
    xwdt  %->
    9 -4 roll  %->
    line  %->
  R  %->
} B  %:%
@ %def Xline

<<PSFunctions - Bline>>=
%% lwidth lcolor bcol ori end Bline
/Bline {  %->
  vflg { (Bline) msg } if  %-%
  S  %->
    H {  %->
      Xscme  %->
      Xscme  %->
      y0 Yscme  %->
      y1 Yscm  %->
      bbox  %->
    } {  %->
      Yscme  %->
      Yscme  %->
      X0 Xscm  %->
      3 1 roll  %->
      X1 Xscme  %->
      bbox  %->
    } ifelse  %->
    S  %->
      cmyk  %->
      fill   %->
    R  %->
    cmyk  %->
    slw  %->
    K  %->
  R  %->
} B  %:%
@ %def Bline

<<PSFunctions - Bsquare>>=
/Bsquare {  %->
  vflg { (Bsquare) msg } if  %-%
  S  %->
    Yscme  %->
    Yscme  %->
    4 2 roll  %->
    Xscme  %->
    Xscme  %->
    4 1 roll  %->
    exch  %->
    bbox   %->
    S  %->
      cmyk  %->
      fill   %->
    R  %->
    cmyk  %->
    slw  %->
    K  %->
  R  %->
} B  %:%
@ %def Bsquare

<<PSFunctions - Msquare>>=
/Msquare {  %->
  vflg { (Msquare) msg } if  %-%
  S  %->
    Yscme  %->
    Yscme  %->
    4 2 roll  %->
    Xscme  %->
    Xscme  %->
    4 1 roll  %->
    exch  %->
    bbox  %->
    cmyk  %->
    slw  %->
    K  %->
  R  %->
} B  %:%
@ %def Msquare

<<PSFunctions - Mcircle>>=
/Mcircle {  %->
  vflg { (Mcircle) msg } if  %-%
  S  %->
    Yscme  %->
    Xscme  %->
    3 -1 roll  %->
    Xscm  %->
    0 360 arc  %->
    closepath  %->
    cmyk  %->
    slw  %->
    K  %->
  R  %->
} B  %:%
@ %def Mcircle

<<PSFunctions - Join>>=
/Join {  %->
  vflg { (Join) msg } if  %-%
  S  %->
    2 copy  %->
    2 copy  %->
    pop  %->
    sub  %->
    2 div  %->
    add  %->
    exch  %->
    H {  %->
      y1 TyWB add  %->
      dup  %->
      dup  %->
      TyWB 0.75 mul  %->
      add  %->
      4 1 roll  %->
      5 1 roll  %->
    } {  %->
      X0 TxWB sub  %->
      dup  %->
      dup  %->
      TxWB 0.75 mul  %->
      sub  %->
      5 1 roll  %->
      6 1 roll  %->
      exch  %->
    } ifelse  %->
    3 {  %->
      Yscme  %->
      Xscme  %->
      6 2 roll  %->
    } repeat  %->
    m  %->
    l  %->
    l  %->
    0.25 slw  %->
    cmyk  %->
    K  %->
  R  %->
} B  %:%
@ %def Join

<<PSFunctions - Arrow>>=
/Arrow {  %->
  vflg { (Arrow) msg } if  %-%
  /acol  %->
    [  %->
      9 -4 roll  %->
    ]  %->
  D  %->
  /acolor {  %->
    acol  %->
    aload  %->
    pop  %->
  } D  %->
  S  %->
    1 eq {  %->
      exch  %->
      /sn {  %->
        1 mul  %->
      } D  %->
    } {  %->
      /sn {  %->
        1 neg  %->
        mul  %->
      } D  %->
    } ifelse  %->
    H {  %->
      Xscm  %->
      dup  %->
      y1 Yscm  %->
      HWBox add  %->
      m  %->
      HWarw  %->
      sn  %->
      HWarw  %->
      rl  %->
      0  %->
      Warw neg  %->
      rl  %->
      HWarw neg  %->
      sn  %->
      HWarw  %->
      rl  %->
      closepath  %->
      S  %->
        acolor cmyk  %->
        fill  %->
      R  %->
      y1 Yscm  %->
      HWBox add  %->
      m  %->
      Xscm  %->
      y1 Yscm  %->
      HWBox add  %->
      l  %->
      acolor cmyk  %->
      1 slw  %->
      K  %->
    } {  %->
      Yscm  %->
      dup  %->
      X0 Xscm  %->
      HWBox sub  %->
      exch  %->
      m  %->
      HWarw neg  %->
      HWarw  %->
      sn  %->
      rl  %->
      Warw 0 rl  %->
      HWarw neg  %->
      HWarw neg  %->
      sn  %->
      rl  %->
      closepath  %->
      S  %->
        acolor cmyk  %->
        fill  %->
      R  %->
      X0 Xscm  %->
      HWBox sub  %->
      exch  %->
      m  %->
      Yscm  %->
      X0 Xscm  %->
      HWBox sub  %->
      exch  %->
      l  %->
      acolor cmyk  %->
      1 slw  %->
      K  %->
    } ifelse  %->
  R  %->
} B  %:%
@ %def Arrow

<<PSFunctions - FBox>>=
/FBox {  %->
  vflg { (FBox) msg } if  %-%
  H {  %->
    Xscme  %->
    Xscme  %->
    y1 Yscme  %->
    y1  %->
    TyWB  %->
    FBDspl mul  %->
    add  %->
    Yscm  %->
    bbox  %->
  } {  %->
    Yscme  %->
    Yscme  %->
    X0 Xscm  %->
    3 1 roll  %->
    X0  %->
    TxWB  %->
    FBDspl mul  %->
    sub  %->
    Xscme  %->
    bbox  %->
  } ifelse  %->
  S  %->
    cmyk  %->
    fill  %->
  R  %->
  fg cmyk  %->
  1 slw  %->
  K  %->
} B  %:%
@ %def FBox

<<PSFunctions - FTalgn>>=
/FTalgn {  %->
  vflg { (FTalgn) msg } if  %-%
  H {  %->
    FTXangle 0 eq {  %->
      (bv) (ch)  %->
    } {  %->
      (cv) (lh)  %->
    } ifelse  %->
  } {  %->
    FTYangle 0 eq {  %->
      (cv) (rh)  %->
    } {  %->
      (bv) (rh)  %->
    } ifelse  %->
  } ifelse  %->
} B  %:%
@ %def FTalgn

<<PSFunctions - GPalgn>>=
/GPalgn {  %->
  vflg { (GPalgn) msg } if  %-%
  H {  %->
    GPXangle 0 eq {  %->
      (bv) (ch)  %->
    } {  %->
      (cv) (lh)  %->
    } ifelse  %->
  } {  %->
    GPYangle 0 eq {  %->
      (cv) (rh)  %->
    } {  %->
      (bv) (rh)  %->
    } ifelse  %->
  } ifelse  %->
} B  %:%
@ %def GPalgn

<<PSFunctions - Box>>=
/Box {  %->
  vflg { (Box) msg } if  %-%
  2 copy  %->
  2 copy  %->
  pop  %->
  sub  %->
  2 div  %->
  add  %->
  7 1 roll  %->
  S  %->
    H {  %->
      Xscme  %->
      Xscme  %->
      y1 Yscme  %->
      y1  %->
      TyWB add  %->
      Yscm  %->
      bbox  %->
    } {  %->
      Yscme  %->
      Yscme  %->
      X0 Xscm  %->
      3 1 roll  %->
      X0  %->
      TxWB sub  %->
      Xscme  %->
      bbox  %->
    } ifelse  %->
    S  %->
      cmyk  %->
      fill  %->
    R  %->
    fg cmyk  %->
    1 slw  %->
    K  %->
    H {  %->
      Xscm  %->
      y1  %->
      TyWB 1.75 mul  %->
      add  %->
      Yscm  %->
      FTXangle  %->
    } {  %->
      Yscm  %->
      X0  %->
      TxWB 1.75 mul  %->
      sub  %->
      Xscme  %->
      FTYangle  %->
    } ifelse  %->
    6 -1 roll  %->
    FTalgn  %->
    8 -2 roll  %->
    fg  %->
    ttshw  %->
  R  %->
} B  %:%
@ %def Box

<<PSFunctions - GDmore>>=
/GDmore {  %->
  vflg { (GDmore) msg } if  %-%
  MxFtLBL  %->
  S  %->
    ElmFont sfnt  %->
    (M) stringwidth  %->
    pop  %->
  R  %->
  mul  %->
  H {  %->
    FTXangle sin  %->
  } {  %->
    FTYangle cos  %->
  } ifelse  %->
  abs  %->
  mul  %->
  ivcm  %->
  add  %->
} B  %:%
@ %def GDmore

<<PSFunctions - BDmore>>=
/BDmore {  %->
  vflg { (BDmore) msg } if  %-%
  MxGpLBL  %->
  S  %->
    TagFont sfnt  %->
    (M) stringwidth  %->
    pop  %->
  R  %->
  mul  %->
  H {  %->
    GPXangle sin  %->
  } {  %->
    GPYangle cos  %->
  } ifelse  %->
  abs  %->
  mul  %->
  ivcm  %->
  add  %->
} B  %:%
@ %def BDmore

<<PSFunctions - GnBanner>>=
/GnBanner{  %->
  vflg { (GnBanner) msg } if  %-%
  S  %->
    1 eq {  %->
      2 copy  %->
      H {  %->
        Xscme  %->
        Xscme  %->
        y1  %->
        TyWB GDspl mul  %->
        add  %->
        dup  %->
        Yscme  %->
        Yscm  %->
        3 1 roll  %->
      } {  %->
        Yscme  %->
        Yscme  %->
        X0  %->
        TxWB GDspl mul  %->
        sub  %->
        dup  %->
        Xscme  %->
        Xscme  %->
        4 1 roll  %->
        exch  %->
      } ifelse  %->
      0.5 fg uline  %->
    } if  %->
    2 copy  %->
    pop  %->
    sub  %->
    2 div  %->
    add  %->
    H {  %->
      Xscm  %->
      y1  %->
      TyWB GLDspl mul  %->
      add  %->
      Yscm  %->
      GPXangle  %->
    } {  %->
      Yscm  %->
      X0  %->
      TxWB GLDspl mul  %->
      sub  %->
      Xscme  %->
      GPYangle  %->
    } ifelse  %->
    6 -1 roll  %->
    GPalgn  %->
    8 -2 roll  %->
    fg  %->
    ttshw  %->
  R  %->
} B  %:%
@ %def GnBanner

<<PSFunctions - SbBanner>>=
/SbBanner {  %->
  vflg { (SbBanner) msg } if  %-%
  S  %->
    H {  %->
      0 X0  %->
      X1 X0 sub  %->
      2 div  %->
      add  %->
      Xscm  %->
      y1  %->
      TyWB  %->
      GDspl  %->
      mul  %->
      add  %->
      Yscm  %->
    } {  %->
      90 X0  %->
      TxWB  %->
      GDspl  %->
      mul  %->
      sub  %->
      Xscm  %->
      y0  %->
      y1 y0 sub  %->
      2 div  %->
      add  %->
      Yscm  %->
    } ifelse  %->
    5 -2 roll  %->
    fg  %->
    ctshw  %->
  R  %->
} B  %:%
@ %def SbBanner

<<PSFunctions - Banner>>=
/Banner {  %->
  vflg { (Banner) msg } if  %-%
  S  %->
    H {  %->
      0  X0  %->
      X1 X0 sub  %->
      2 div  %->
      add  %->
      Xscm  %->
      y1  %->
      TyWB  %->
      BDspl  %->
      mul  %->
      add  %->
      Yscm  %->
    } {  %->
      90 X0  %->
      TxWB  %->
      BDspl  %->
      mul  %->
      sub  %->
      Xscm  %->
      y0  %->
      y1 y0 sub  %->
      2 div  %->
      add  %->
      Yscm  %->
    } ifelse  %->
    5 -2 roll  %->
    fg  %->
    ctshw  %->
  R  %->
} B  %:%
@ %def Banner

<<PSFunctions - common tick functions>>=
%-% we provide a number to this function to find how many  
%-%   decimal digits it has, and chktk function returns that value (ge 0)
/chktk {          %-> number  chktk
  3 dict begin    %-> 
    /pk X         %-> load "number" into a local variable (pk)
    /ck 0 D       %-> initializing counters
    /ek 1 D       %->
    {             %-> begin loop
      ck 5 gt {   %->
        exit      %-> we are not interested in very large decimal numbers
      } if        %-> and we take at least 5 significative digits
                  %-% (also PS code does not support integer numbers 
                  %-%  larger than 2147483647 or smaller than -2147483648,
                  %-%  although it can handle reals in the +-10e+-38 range)
      /ek         %->
        10 ck exp %->
      D           %-> setting exponent factor
      pk ek mul   %-> number.real = number * e-factor
      cvi         %-> number.real is converted to number.integer
      ek div      %-> number! = number.integer / e-factor
      pk eq {     %-> 
        exit      %-> if number == number! then exiting from loop
      } if        %-> ck variable will contain the number of decimals
                  %-% that the original number had 
      /ck         %->
        ck 1 add  %-> increase 1 decimal 
      D           %->
    } loop        %-> end loop
    ck            %-> returning ck contents through stack
  end             %->
} B               %->
%-%
/mymod {          %-> a b  mymod
  %-% vflg { (mymod) msg } if
  2 copy          %-> a b a b
  chktk           %-> a b a bc
  exch            %-> a b bc a
  chktk           %-> a b bc ac
  max             %-> a b f
  dup 0 eq {      %-> a b f f
    pop           %-> a b
    2 {           %->
      cvi exch    %-> here we make sure that we are passing two integers to mod
    } repeat      %->
    mod           %->     when f==0 then we compute the builtin modulus of a/b
                  %-%     because mod function requires that both given
                  %-%     parameters were integers
  } {             %-> a b f
    1 dict begin  %->
      /ff         %-> a b f /ff
        10        %-> a b f /ff 10
        3 -1 roll %-> a b /ff 10 f
        exp       %-> a b /-> /ff = 10^f 
      D           %-> a b
      2 {         %->
        ff mul    %->
        %-%
        round     %-> we are going to compare the nearest integer values
        cvi       %->   of a and b (just to make all tickmarks work fine) 
                  %-% just remember that we are taking into account up to
                  %-%   5 significant digits on the chktk function
        %-%
        exch      %-> a b! -> b! a -> b! a! -> a! b!
      } repeat    %-> now a and b are integers,
      mod         %-> so modulus can return another integer 
      ff div      %-> which we can use to recover the real modulus
    end           %-> of the original two decimal numbers
  } ifelse        %->
} B               %:% returns the a/b modulus via the stack
@ %def chktk mymod

<<PSFunctions - common tick functions>>=
%-% mkgrid prints the grid lines if needed
/mkgrid {      %-> boolean x y  mkgrid 
  %-% vflg { (mkgrid) msg } if
  S            %-> 
    0 0 m      %-> set initial point
    rl         %-> making the tickmark grid line relative from current point
    fg cmyk    %->
    {          %-> if boolean true, then major tickmark
      dashed   %->
      KWn 2 mul slw  %-> linewidth for major tickmarks grid lines
    } {        %-> else minor tickmark
      ldotted  %->
      KWn slw  %-> linewidth for minor tickmarks grid lines
    } ifelse   %-> setting dotted line style
    K          %-> stroke tickmark grid line
  R            %->
} B            %-%
%-% major tickmark lines
/mjrtick {       %-> boolean  mjrtick
  %-% vflg { (mjrtick) msg } if
  S              %->
    0 0 m        %-> set starting point
    {            %-> boolean to choose horizontal or vertical axes
      0 KHx neg  %-> horizontal axes
	} {          %->
      KHx 0      %-> vertical axes
    } ifelse     %->
    rl           %-> make a line of major tickmark heigth
    KWx slw      %-> linewidth for major tickmarks
    fg cmyk      %-> 
    K            %-> stroke tickmark
  R              %->
} B              %-%
%-% minor tickmark lines
/mnrtick {       %-> boolean  mnrtick
  %-% vflg { (mnrtick) msg } if
  S              %->
    0 0 m        %-> set starting point
    {            %-> boolean to choose horizontal or vertical axes
      0 KHn neg  %-> horizontal axes
	} {          %->
      KHn 0      %-> vertical axes
    } ifelse     %->
    rl           %-> make a line of minor tickmark heigth
    KWn slw      %-> linewidth for minor tickmarks
    fg cmyk      %-> 
    K            %-> stroke minor tickmark
  R              %->
} B              %:%
@ %def mkgrid mjrtick mnrtick 


<<PSFunctions - htick>>=
/hticklbl {    %-> coord  ticklbl
  %-% vflg { (hticklbl) msg } if
  S            %->
    10 string  %->
    cvs        %-> converting coord to string
    0          %-> string angle
    0 KLh neg  %-> string angle x y
    KLf fg     %-> string angle x y font color
    ctshw      %->
  R            %->
} B            %-%
%-%
/htickslbl {      %-> coord bool  ticklbl
  %-% vflg { (htickslbl) msg } if
  S               %->
    2 dict begin  %->
      /f X        %-> get bool
      /fdf {      %->
        KLh neg   %-> y
        KLf fg    %-> y font color
      } D         %->
      10 string   %->
      cvs         %-> converting coord to string
      0           %-> string angle
      ZM {        %->
        f {       %->
          KHn neg %-> string angle x (was -4pt, now height of minor tickmark)
          fdf     %-> string angle x y font color
          ltshw   %->
        } {       %->
          KHn     %-> string angle x (was 4pt, now height of minor tickmark)
          fdf     %-> string angle x y font color
          rtshw   %->
        } ifelse  %->
      } {         %->
        0         %-> string angle x
        fdf       %-> string angle x y font color
        ctshw     %->
      } ifelse    %->
    end           %->         
  R               %->
} B               %:%
@ %def hticklbl htickslbl

<<PSFunctions - htick>>=
/htick {                 %-> height xori xend maxtck mintck  htick
  vflg { (htick) msg } if  %-%
  S                      %->
    10 dict begin        %->
      /tmn X             %-> get minor tickmark nucleotide length
      /tmx X             %-> get major tickmark nucleotide length
      /te X              %-> get tickmarks end
      /to X              %-> get tickmarks start
      /yt X              %-> get height
      %-% major tickmarks start and end
      /lxo               %->
        to               %->
        to tmx mymod     %->
        sub              %->
      D                  %->
      /lxe               %->
        tmx              %->
        te tmx mymod     %->
        sub              %->
        te add           %->
      D                  %->
      %-% minor tickmarks start and end
      /lno               %->
        to               %->
        to tmn mymod     %->
        sub              %->
      D                  %->
      /lne               %->
        tmn              %->
        te tmn mymod     %->
        sub              %->
        te add           %->
      D                  %->
      %-% htick already starts at (LLx,LLy) so we do not have to tranlate
      %-% 0 0 T
      %-% Making major tickmarks
      S                  %->
        /cnt             %->
          lxo            %->
        D                %->
        to neg Xscm 0 T  %-> translating to sequence absolute start
        {                %-> begin loop
          cnt te ge {    %->
            exit         %-> if current tick greater than last tick
          } if           %->   then exit from tickmarks loop
          cnt to gt      %->
          cnt te lt      %->
          and {          %-> draw major tickmark if it is within limits
            cnt Xscm     %->
            S            %->
              0 T                 %-> move to (current_coord, 0)
              true mjrtick        %-> draw major tick line (true==horizontal)
              KGb {               %->
                true 0 yt mkgrid  %->
              } if                %-> must show grid ?            
              cnt hticklbl        %-> show tickmark coord
            R            %->
          } if           %->
          /cnt           %-> adding new tickmark to counter
            cnt tmx add  %->
          D              %->
         } loop          %-> end loop
      R                  %->
      %-% Making minor tickmarks
      S                  %->
        /cnt             %->
          lno            %->
        D                %->
        to neg Xscm 0 T  %-> translating to minor tickmark start
        {                %-> begin loop
          cnt te ge {    %->
            exit         %-> if current tick greater than last tick
          } if           %->   then exit from tickmarks loop
          cnt to gt      %->
          cnt te lt      %-> is minor tickmark within limits ?
          and            %->
          cnt tmx mymod  %-> skip minor tickmarks that overlap a major one
          0 eq not       %-> 
          and {          %->   if all above is true draw minor tickmark
            cnt Xscm     %->
            S            %->
              0 T                  %-> move to (current_coord, 0)
              true mnrtick         %-> draw minor tick line (true==horizontal)
              KGb {                %->
                false 0 yt mkgrid  %->
              } if                 %-> must show grid ?
            R            %-> (restoring last moveto)
          } if           %->
          /cnt           %-> adding new tickmark to counter
            cnt tmn add  %->
          D              %->
        } loop           %-> end loop
        %-% Start and end
        S                %->
          to Xscm 0 T    %-> move to sequence start
          true mjrtick   %-> draw major tick line (true==horizontal)
          to false htickslbl  %-> show start tickmark coord
        R                %->
        S                %->
          te Xscm 0 T    %-> move to sequence end 
          true mjrtick   %-> draw major tick line (true==horizontal)
          te true  htickslbl  %-> show end tickmark coord
        R                %->
      R                  %->
    end                  %-> closing tckdict
  R                      %->
} B                      %:%
@ %def htick


<<PSFunctions - vtick>>=
/vticklbl {    %-> coord  ticklbl
  %-% vflg { (hticklbl) msg } if
  S            %->
    10 string  %->
    cvs        %-> converting coord to string
    0          %-> string angle
    KLp        %-> string angle x
    KLz 3 div neg  %-> string angle x y
    KLf fg     %-> string angle x y font color
    rtshw      %->
  R            %->
} B            %-%
%-%
/vtickslbl {      %-> coord bool  ticklbl
  %-% vflg { (htickslbl) msg } if
  S               %->
    3 dict begin  %->
      /f X        %-> get bool
      /p          %-> half the font size
        KLz 3 div %->
      D           %->
      /fdf {      %->
        KLp exch  %-> x _y_
        KLf fg    %-> x _y_ font color
      } D         %->
      10 string   %->
      cvs         %-> converting coord to string
      0           %-> string angle
      ZM {        %->
        f {       %->
          KLz neg %-> string angle y
          fdf     %-> string angle x y font color
        } {       %->
          p       %-> string angle y
          fdf     %-> string angle x y font color
        } ifelse  %->
      } {         %->
        p neg     %-> string angle y (centering vertically ?)
        fdf       %-> string angle x y font color
      } ifelse    %->
      rtshw       %->
    end           %->         
  R               %->
} B               %:%
@ %def vticklbl vtickslbl

<<PSFunctions - vtick>>=
/vtick {                 %-> width xori xend maxtck mintck  vtick
  vflg { (vtick) msg } if  %-%
  S                      %->
    10 dict begin        %->
      /tmn X             %-> get minor tickmark nucleotide length
      /tmx X             %-> get major tickmark nucleotide length
      /te X              %-> get tickmarks end
      /to X              %-> get tickmarks start
      /xt X              %-> get width
      %-% major tickmarks start and end
      /lxo               %->
        to               %->
        to tmx mymod     %->
        sub              %->
      D                  %->
      /lxe               %->
        tmx              %->
        te tmx mymod     %->
        sub              %->
        te add           %->
      D                  %->
      %-% minor tickmarks start and end
      /lno               %->
        to               %->
        to tmn mymod     %->
        sub              %->
      D                  %->
      /lne               %->
        tmn              %->
        te tmn mymod     %->
        sub              %->
        te add           %->
      D                  %->
      %-% as we assume that current point is (LLx,LLy) for the current box
      %-% we must translate coords origin to (LLx,LRy)
      xt 0 T             %->
      %-% Making major tickmarks
      S                  %->
        /cnt             %->
          lxo            %->
        D                %->
        0 to neg Yscm T  %-> translating to sequence absolute start
        {                %-> begin loop
          cnt te ge {    %->
            exit         %-> if current tick greater than last tick
          } if           %->   then exit from tickmarks loop
          cnt to gt      %->
          cnt te lt      %->
          and {          %-> draw major tickmark if it is within limits
            cnt Yscm     %->
            S            %->
              0 exch T            %-> move to (0,current_coord)
              false mjrtick       %-> draw major tick line (false==vertical)
              KGb {               %->
                true xt neg 0     %->
                          mkgrid  %->
              } if                %-> must show grid ?            
              cnt vticklbl        %-> show tickmark coord
            R            %->
          } if           %->
          /cnt           %-> adding new tickmark to counter
            cnt tmx add  %->
          D              %->
         } loop          %-> end loop
        %-% Making minor tickmarks
        /cnt             %->
          lno            %->
        D                %->
        {                %-> begin loop
          cnt te ge {    %->
            exit         %-> if current tick greater than last tick
          } if           %->   then exit from tickmarks loop
          cnt to gt      %->
          cnt te lt      %-> is minor tickmark within limits ?
          and            %->
          cnt tmx mymod  %-> skip minor tickmarks that overlap a major one
          0 eq not       %-> 
          and {          %->   if all above is true draw minor tickmark
            cnt Yscm     %->
            S            %->
              0 exch T             %-> move to (0,current_coord)
              false mnrtick        %-> draw minor tick line (false==vertical)
              KGb {                %->
                false xt neg 0     %->
                           mkgrid  %->
              } if                 %-> must show grid ?
            R            %-> (restoring last moveto)
          } if           %->
          /cnt           %-> adding new tickmark to counter
            cnt tmn add  %->
          D              %->
        } loop           %-> end loop
      R                  %->
      %-% Start and end
      S                  %->
        0 to neg Yscm T  %-> absolute start
        S                %->
          0 to Yscm T    %-> move to sequence start
          false mjrtick  %-> draw major tick line (false==vertical)
          to false vtickslbl  %-> show start tickmark coord
        R                %->
        S                %->
          0 te Yscm T    %-> move to sequence end 
          false mjrtick  %-> draw major tick line (false==vertical)
          te true  vtickslbl  %-> show end tickmark coord
        R                %->
      R                  %->
    end                  %-> closing tckdict
  R                      %->
} B                      %:%
@ %def vtick

<<PSFunctions - nucltick>>=
/nucltick {  %-> height  nucltick
  vflg { (nucltick) msg } if  %-%
  XO XE      %-> X-sequence start and end
  KASm KASn  %-> major and minor tickmarks (in nucleotides)
    htick    %-> when calling htick we are already at (LLx,LLy)
             %-% now PS stack must look like: height start end major minor
} B          %:%
@ %def nucltick

<<PSFunctions - pctmarks>>=
/pctmarks {  %->
  vflg { (pctmarks) msg } if  %-%
  S  %->
  R  %->
} B  %:% 
/pctmarksOLD {  %->
  vflg { (pctmarks) msg } if  %-%
  S  %->
    y0 10 y1 { %->
      Yscm  %->
      dup  %->
      X0 Xscm  %->
      X1 Xscm  %->
      3 1 roll  %->
      4 1 roll  %->
      0.5  %->
      fg  %->
      line  %->
    } for  %->
  R  %->
} B  %:%
@ %def pctmarks


\subsctn{Main functions definition}

<<POSTSCRIPT main function calls>>=
%%BeginProcSet: Openings 1.0 0
%
<<PSFunctions - do init>>
<<PSFunctions - do end>>
%
%%EndProcSet:   Openings 1.0 0
%
@

<<PSFunctions - do init>>=
/DoInit {             %-> DoInit
  tflg {              %->
    (%%% START NEW PLOT %%%) msg  %->
    /vflg true D      %->
  } if                %->
  %-%
  aplotdict begin     %->
    %-%
    Dpage 0 0 bbox    %-> filling page background with bg color
    S                 %->
      bg cmyk         %->
      fill            %->
    R                 %-> nothing can be drawn out of the page so we clip
    clip              %->  by page bbox path, we have to clear path because
    newpath           %->  clip does not initialize current path by itself
                    %->  (only stroke and fill do that)
    %-% 
    FXO FYO T  %-> we translate origin to top left corner of the page
    %-% 1 -1 F %%% we do not invert the Y-axes,
               %-% positive values still go from top to bottom
               %-% remember that global vertical displacements must be negated
    %-%
    flgcrd {   %->  check if credits are shown
      shwcrd   %->
    } if       %->
} B          %:%
@ %def DoInit

<<PSFunctions - do end>>=
/DoEnd {  %-> DoEnd
  end     %-> close aplotdict
  %-%
  tflg {                     %->
    (%%% PLOT DONE %%%) msg  %->
  } if                       %->
} B       %:%
@ %def DoEnd


<<POSTSCRIPT main functions>>=
%-% Title and Credits
<<PSFunctions - header>>
<<PSFunctions - shwcrd>>
%-% ALIGNMENT PLOT BOX
<<PSFunctions - begindata>>
<<PSFunctions - enddata>>
<<PSFunctions - seqs annotation>>
%-% MATCHES PERCENT BOX
<<PSFunctions - beginmatches>>
<<PSFunctions - endmatches>>
%-% EXTRA FEATURES BOX
<<PSFunctions - beginextra>>
<<PSFunctions - endextra>>
%-% OTHER FUNCTIONS
<<PSFunctions - estlbl>>
<<PSFunctions - getXscale>>
<<PSFunctions - beginfunct>>
<<PSFunctions - endfunct>>
@

<<PSFunctions - header>>=
%
/DoHeader {     %-> DoHeader
  vflg { (DoHeader) msg } if  %-%
  %-%
  TTLb {        %-> if show_title
    S           %->
      TTLl      %-> title_string
      0         %-> angle
      AXL       %-> left margin
      TTLz neg  %-> vertical displacement
      TTLf      %-> title_font
      fg        %-> text color
      rtshw     %-> 
    R           %->
  } if          %->
  %-%
  TTlb {        %-> if show_title
    S           %->
      TTll      %-> title_string
      0         %-> angle
      AXL       %-> left margin
      TTLz TTLp add %-> vertical displacement:
      TTlz add  neg %->    - ( title_size + title_spacer + subtitle_size )
      TTlf      %-> title_font
      fg        %-> text color
      rtshw     %-> 
    R           %->
  } if          %->
  %-% 
} B             %:%
@ %def DoHeader


<<PSFunctions - shwcrd>>=
/shwcrd {           %->
  vflg { (shwcrd) msg } if  %-%
  S                 %->
    2 dict begin    %-> open anonymous
      /Cz             %-> credits_font_size = Ch - ( 1pt * (PPC / 2) )
        Ch 1 pt PPC   %->
        2 div mul sub %->
      D               %->
      /Cf {         %-> credits_font
        Cz /Courier %->
      } D           %->
      FL            %-> width heigth
      Ch add        %-> x = width, y = heigth + Ch
      neg           %-> x y (right bottom corner of usable area)
      2 copy        %-> x y x y
      0             %-> x y x y angle
(This plot has been obtained using GFF2APLOT.     %-% octal values:
 The most recent version of GFF2APLOT is freely   %-% \042 == doublequotes
 available at                                     %-% \057 == slash (/)
\042http:\057\057www1.imim.es\057software\057gfftools\057GFF2APLOT.html\042. %-% 
Copyright\040\0401999                             %-% \040 == white space
by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO)  %-> x y x y angle string
      (bv)          %-> x y x y angle string v-align
      (rh)          %-> x y x y angle string v-align h-align
      Cf            %-> x y x y angle string v-align h-align cred_font
      fg            %-> x y x y angle string v-align h-align cred_font color
      ttshw         %-> x y | showing credits string
      exch          %-> y x ::
      S             %-> y x ::
        Cf sfnt     %-> y x :: cred_font
(\0401999 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO) %-%
        stringwidth %-> y x :: substring_length_x substring_length_y  
        pop         %-> y x :: substring_length
        sub         %-> y, x = x - substring_length
      R             %-> y x
      exch          %-> x y
      0             %-> x y angle
      (\343)        %-> x y angle string (\343 octal code for copyright symbol)
      (bv)          %-> x y angle string v-align
      (ch)          %-> x y angle string v-align h-align
      Cz            %-> x y angle string v-align h-align cred_font_size
      /Symbol       %-> x y angle string v-align h-align scaled_symbol_font
      fg            %-> x y angle string v-align h-align font color
      ttshw         %-> showing copyright symbol
    end             %-% close anonymous dict
  R                 %->
} B                 %:%
@ %def shwcrd

<<PSFunctions - begindata>>=
/begindata {      %->
  vflg { (### BEGINdata) msg } if  %-%
  %-%
  S               %->
    AXL           %->
    AYB neg       %->
    T             %-> setting current point to (LLx,LLy) of aplot bbox
    %-% aplot box BG color
    S             %-> first of all we fill aplot box with the corresponding
      0 0         %-> background color, so we have to draw a bbox path and
      AX AY       %-> fill in it 
      bbox        %->
      ABc cmyk    %-> this process is similar for all main plot boxes
      fill        %->
    R             %->
    %-% setting variables
    /Xscale       %-> finding X-sequence scale
      AX XD div   %->
    D             %->
    /Yscale       %-> finding Y-sequence scale
      AY YD div   %-> (we do not need to check again axesb,
    D             %->  AX and AY have the required width and height)
    %-% tickmarks
    S             %->
      KAXb {      %-> if show h-tickmarks, start on the current point
        AY nucltick  %-> as we are going to recycle nucltick funtion
      } if        %->    we have to provide the height of each box
    R             %->    
    S  %->
      KAYb {      %-> if show v-tickmarks, start on the current point
        AX        %-> width
        YO YE     %-> Y-sequence start and end
        KASm KASn %-> major and minor tickmarks (in nucleotides)
          vtick   %-> when calling vtick we must to move to (LLx,LRy=LLY+AX)
      } if        %->
    R             %->  
    %-% Axes annotation labels
    S             %->
      XSLb {      %->
        XSLl      %->
        0         %->
        AX 2 div  %->
        AY        %->
        ATX add   %->
        XSLp add  %->
        XSLf      %->
        fg        %->
        ctshw     %->
      } if        %->
      YSLb {      %->
        YSLl      %->
        90        %->
        ATY neg   %->
        YSLp sub  %->
        AY 2 div  %->
        YSLf      %->
        fg        %->
        ctshw     %->
      } if        %->
    R             %->
    %-%
    %-% vars to get defined
    /yo YO D %->
    /ye YE D %->
    /TxWB {  %->
      WBox Xscale div  %->
    } D      %->
    /TyWB {  %->
      WBox Yscale div  %->
    } D      %->
    /GDspl {  %->
      xGDspl  %->
      GDmore  %->
    } D  %->
    /GLDspl {  %->
      xGLDspl  %->
      GDmore  %->
    } D  %->
    /BDspl {  %->
      xBDspl  %->
      GDmore  %->
      BDmore  %->
    } D  %->
} B               %:%
@ %def begindata

<<PSFunctions - enddata>>=
/enddata {      %->
    %-% aplot box border
    S           %-> here we draw the aplot bbox but now we are going to 
      0 0       %-> stroke the bbox path so we have a border surrounding the
      AX AY     %-> previously filled aplot bbox
      ZM {      %->
        4 copy  %-> here we look if we must draw the zoom marks
        zoomtk  %->
      } if      %->
      Blw obox  %->
      fg cmyk   %->
      Blw slw   %->
      K         %->
    R           %->
  R             %->
  %-% vars to get defined
  /GDspl  xGDspl  D  %->
  /GLDspl xGLDspl D  %->
  /BDspl  xBDspl  D  %->
  %-%
  vflg { (### ENDdata) msg } if  %-%
} B             %:%
@ %def enddata

<<PSFunctions - seqs annotation>>=
/beginXseq {     %-> setting X-sequence origin and clip path
  S              %->
    XO neg Xscm  %->
    AY           %->
      T          %->
} B              %-%
%-%
/beginYseq {     %-> setting Y-sequence origin and clip path
  S              %->
    0            %->
    YO neg Yscm  %->
      T          %->
    90 rotate    %->
} B              %-%
%-%
/beginaln {      %-> setting aplot origin and clip path
  S              %->
    0  0         %->
    AX AY        %->
    bbox         %->
    clip         %->
    newpath      %->
    XO neg Xscm  %->
    YO neg Yscm  %->
      T          %->    
} B              %-%
%-%
/endseq {        %-> closing any of above three functions:
  R              %->   beginXseq, beginYseq or beginaln
} B              %:%
@ %def beginXseq beginYseq beginaln endseq


<<PSFunctions - beginmatches>>=
/beginmatches {   %->
  vflg { (### BEGINmatches) msg } if  %-%
  S               %->
    AXL           %->
    PYB neg       %->
    T             %->
    %-% percent box BG color
    S             %->
      0 0         %->
      AX PY       %->
      bbox        %->
      PBc cmyk    %->
      fill        %->
    R             %->
    %-% setting variables
    /Yscale       %-> finding percent scale
      PY PD div   %-> (we do not need to check again axesb, PY has
    D             %->  the required height, and width is same for all boxes)
    %-% tickmarks
    S             %->
      KPXb {      %-> if show h-tickmarks, start on the current point
        PY nucltick  %-> as we are going to recycle nucltick funtion
      } if        %->    we have to provide the height of each box
    R             %->    
    S             %->
      KPYb {      %-> if show v-tickmarks, start on the current point
        AX        %-> width
        PO PE     %-> Y-sequence start and end
        KPSm KPSn %-> major and minor tickmarks (in percents)
          vtick   %-> when calling vtick we must to move to (LLx,LRy=LLY+AX)
      } if        %->
    R             %->  
    %-% box labels
%    S             %->
%      XSLb {      %->
%      } if        %->
%    R             %->
    S   %->
} D               %:%
/beginmatchesOLD {  %->
  /ZoomON 0 D  %->
  S  %->
      5 /y1 X  %-> (5 must be provided by perl)
    100 /y0 X  %-> (5 must be provided by perl)
    PY getXscale  %->
    /Yscale  %->
      PY  %->
      y1 y0 sub  %->
      div  %->
    D  %->
    X0 Xscm neg  %->
    y0 Yscm neg  %->
    T  %->
    S  %->
      X0 Xscm  %->
      y0 Yscm  %->
      X1 Xscm  %->
      y1 Yscm  %->
      bbox  %->
      S  %->
        S  %->
          PBc cmyk  %->
          fill  %->
        R  %->
        S  %->
          PBLl  %->
          PBLf  %->
          Banner  %->
          PBll  %->
          PBlf  %->
          SbBanner  %->
          KPXb {  %->
            nucltick  %->
            /Spacer 1 cm D  %->
          } {  %->
            /Spacer 0.5 cm D  %->
          } ifelse  %->
        R  %->
        S  %->
          KPYb {  %->
            -1 -1 pctmxt pctmnt  %->
            y0 y1 X1 0  %->
            vtick  %->
          } if  %->
        R  %->
        S  %->
          X0 Xscm  %->
          y0 Yscm  %->
          X1 Xscm  %->
          y1 Yscm  %->
          bbox  %->
          2 slw  %->
          fg cmyk  %->
          K  %->
        R  %->
      R  %->
      clip  %->
      newpath  %->
} D  %:%
@ %def beginmatches

<<PSFunctions - endmatches>>=
/endmatches {   %->
    R  %->
    %-% percent box border
    S           %->
      0 0       %->
      AX PY     %->
      Blw obox  %->
      fg cmyk   %->
      Blw slw   %->
      K         %->
    R           %->
  R             %->
  vflg { (### ENDmatches) msg } if  %-%
} D             %:%
@ %def endmatches

<<PSFunctions - beginextra>>=
/beginextra {  %->
  vflg { (### BEGINextra) msg } if  %-%
  S            %->
    AXL        %->
    QYB neg    %->
    T          %->
    S          %->
      0 0      %->
      AX QY    %->
      bbox     %->
      QBc cmyk %->
      fill     %->
    R          %->
    %-% tickmarks
    S             %->
      KQXb {      %-> if show h-tickmarks, start on the current point
        QY nucltick  %-> as we are going to recycle nucltick funtion
      } if        %->    we have to provide the height of each box
    R             %->    
    S  %->
      KQYb {      %-> if show v-tickmarks, start on the current point
        AX        %-> width
        YO YE     %-> Y-sequence start and end
        KASm KASn %-> major and minor tickmarks (in nucleotides)
          vtick   %-> when calling vtick we must to move to (LLx,LRy=LLY+AX)
      } if        %->
    R             %->  
    %-% extra box border
    S          %->
      0 0      %->
      AX QY    %->
      Blw obox %->
      fg cmyk  %->
      Blw slw  %->
      K        %->
    R          %->
    S          %->
} B            %:%
/beginextraOLD {  %->
  vflg { (### BEGINextra) msg } if  %-%
  S  %->
    5 /nlines X  %-> (5 must be provided by perl)
    /y0 0 D  %->
    QY getXscale  %->
    /Yscale  %->
      QY  %->
      nlines 1 add  %->
      div  %->
    D  %->
    /Xlwdt  %->
      Yscale 0.75 mul  %->
    D   %->
    /xwdt  %->
      Yscale 2 div  %->
    D  %->
    /y1  %->
      QY Yscale div  %->
    D  %->
    X0 Xscm neg 0 T  %->
    S  %->
      X0 Xscm  %->
      y0 Yscm  %->
      X1 Xscm  %->
      y1 Yscm  %->
      bbox  %->
      S  %->
        QBc cmyk  %->
        fill  %->
      R  %->
      S  %->
        QBLl  %->
        QBLf  %->
        Banner  %->
        QBLl  %->
        QBLf  %->
        SbBanner  %->
        KQXb {  %->
          nucltick  %->
        } if  %->
      R  %->
      newpath  %->
} D  %:%
@ %def beginextra

<<PSFunctions - endextra>>=
/endextra {  %->
    R        %->
  R          %->
  vflg { (### ENDextra) msg } if  %-%
} D          %:%
/endextraOLD {  %->
  vflg { (### ENDextra) msg } if  %-%
      /Yscale  %->
        QY  %->
        nlines 1 add  %->
        div  %->
      D  %->
      X0 Xscm  %->
      y0 Yscm  %->
      X1 Xscm  %->
      y1 Yscm  %->
      bbox  %->
      2 slw  %->
      fg cmyk  %->
      K  %->
    R  %->
  R  %->
} D  %:%
@ %def endextra

<<PSFunctions - beginfunct>>=
/beginfunct {  %->
  vflg { (### BEGINfunct) msg } if  %-%
      R  %->
      S  %->
        3 dict begin  %->
          /maxx  %->
            exch  %->
            ceiling  %->
          D  %->
          /minx  %->
            exch  %->
            floor  %->
          D  %->
          /Yscale  %->
            XBoxY  %->
            maxx minx sub  %->
            div  %->
          D  %->
          minx 0 lt {  %->
            0 minx neg Yscm T  %->
          } if  %->
          S  %->
            XBYtickflg 1 eq {  %->
              -1 -1  %->
              xtrmxt xtrmnt  %->
              minx maxx  %->
              X1 0  %->
              vtick  %->
              S  %->
                X0 Xscm  %->
                0  %->
                m  %->
                X1 Xscm  %->
                0  %->
                l  %->
                dotted  %->
                fg cmyk  %->
                K  %->
              R  %->
            } if  %->
          R  %->
} D  %:%
@ %def beginfunct

<<PSFunctions - endfunct>>=
/endfunct {  %->
  vflg { (### ENDfunct) msg } if  %-%
        end  %->
      R  %->
} D  %:%
@ %def endfunct

<<PSFunctions - estlbl>>=
/estlbl {  %->
  vflg { (estlbl) msg } if  %-%
  S  %->
    3 dict begin  %->
      /lbl X  %->
      /ypos X  %->
      /xpos X  %->
      HT  %->
      0 Xlwdt 4 div neg T  %->
      lbl 0  %->
      xpos Xscm  %->
      ypos Yscm  %->
      5 /Helvetica  %->
      black  %->
      ctshw  %->
      VT  %->
    end  %->
  R  %->
} B  %:%
@ %def estlbl

<<PSFunctions - getXscale>>=
/getXscale {  %->
  vflg { (getXscale) msg } if  %-%
  /Y  %->
    exch  %->
    Y  %->
    Spacer sub  %->
    exch  %->
    sub  %->
  D  %->
  Xmarg Y T  %->
  axesp 0 eq {  %->
    /Xscale {  %->
      BBoxX  %->
      X1 X0 sub  %->
      Y1 Y0 sub  %->
      max  %->
      div  %->
    } D  %->
  } {  %->
    /Xscale {  %->
      BBoxX  %->
      X1 X0 sub  %->
      div  %->
    } D  %->
  } ifelse  %->
} B  %:%
@ %def getXscale


\newpage

\sctn{Reporting Program Execution} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Signal trapping}

In this version of {\prog} we are trapping signals, to exit from this program but reporting that was a user action, not a program error. We will close '[[LOGFILE]]' if opened. 

<<Trapping signals>>=
$SIG{HUP}  = \&trap_signals_prog;
$SIG{ABRT} = \&trap_signals;
$SIG{INT}  = \&trap_signals;
$SIG{QUIT} = \&trap_signals;
$SIG{TERM} = \&trap_signals;
$SIG{KILL} = \&trap_signals;
$SIG{CHLD} = 'IGNORE';
@ 

<<Common Routines>>=
sub trap_signals() {
    &prt_to_logfile($Messages{'USER_HALT'});
    &close_logfile();
    die($Messages{'USER_HALT'});
} # trap_signals
@ %def &trap_signals

<<Common Routines>>=
sub trap_signals_prog() {
    &prt_to_logfile($Messages{'PROCESS_HALT'});
    &close_logfile();
    die($Messages{'PROCESS_HALT'});
} # trap_signals_prog
@ %def &trap_signals_prog

<<warnings - input/output>>=
USER_HALT =>
  $spl.$Warn."$PROGRAM has been stopped by user !!!\n".
  $spl.$Warn."---------- Exiting NOW !!! ----------\n".$spl,
PROCESS_HALT =>
  $spl.$Warn."------- $PROGRAM is down !!! -------\n".
  $spl.$Warn."---------- Exiting NOW !!! ----------\n".$spl,
@

\subsctn{Dumping complex data structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them. We include also a command-line switch to enable this feature, but it requires a log file definition with '[[-V]]' option.

<<Use Modules>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 

<<perl requires help>>=
"Data::Dumper" - pretty printing data structures for debugging (*).
@

<<command-line options>>=
"debug"  => \$Debug, # Dumps Vars -> LogFile
@ 
<<command-line help>>=
--debug
    Reporting variable contents when testing the program.
    Requires that log report file option was also activated.
@

\subsctn{Reporting program status}

\label{sec:MessagesHsh}

<<Global Vars>>=
# Program status strings.
%Messages = (
    # ERROR MESSAGES
    <<warnings - input/output>>
    <<warnings - parsing command-line options>>
    <<warnings - parsing custom files>>
    <<warnings - parsing GFF files>>
    # WORKING MESSAGES
    <<messages - input/output>>
    <<messages - parsing command-line options>>
    <<messages - parsing custom files>>
    <<messages - parsing GFF files>>
    <<messages - sorting GFF data>>
   ); # %Messages
@

\subsubsctn{Reporting errors and warnings}

<<Global Constants>>=
my $Error = "\<\<\<  ERROR  \>\>\> ";
my $Warn  = "\<\<\< WARNING \>\>\> ";
my $spl   = "\<\<\<\-\-\-\-\-\-\-\-\-\>\>\>\n";
my $spw   = "\<\<\<         \>\>\> ";
@ 

<<Common Routines>>=
sub warn() {
    my $type = shift @_;
    my $screen_flg = shift @_;
    my $comment = sprintf($Messages{$type}, @_);
    # ALWAYS to STDERR if $screen_flg==$T unless $Quiet==$T
    $screen_flg && ($Quiet || print STDERR $comment); 
    &prt_to_logfile($comment);
} # warn
@ %def &warn

<<Common Routines>>=
sub prt_to_logfile() { $LogFile && (print LOGFILE $_[0]) }
sub prt_to_stderr()  { $Verbose && ($Quiet || print STDERR $_[0]) }
@ %def &prt_to_logfile &prt_to_stderr

\subsubsctn{Process messages}

<<Global Constants>>=
my $line = ("#" x 80)."\n";
my $sp = "###\n";
@ 

<<Common Routines>>=
sub report() {
    my $type = shift @_;
    my $comment = sprintf($Messages{$type},@_);
    &prt_to_stderr($comment);
    &prt_to_logfile($comment);
} # report
@ %def &report

<<Common Routines>>=
sub header() {
    my $comment = $line;
    foreach my $ln (@_) { 
        $comment .= "### ".&fill_mid("$ln",72," ")." ###\n";
        };
    $comment .= $line;
    &prt_to_stderr($comment);
    &prt_to_logfile($comment);
} # header
sub footer() {
    $total_time = &timing($F);
    &header(@_,$total_time);
    &prt_to_stderr("###\n");
    &prt_to_logfile("###\n");
} # footer
@ %def &header &footer


\subsubsctn{Reporting parsing progress}

<<Common Routines: Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    my $str;
    $str = "$_[1]";
    (($_[0] % 50) == 0) && ($str .= " [".&fill_left($_[0],6,"0")."]\n");
    &prt_to_stderr($str);
    &prt_to_logfile($str);        
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    my $str;
    (($_[0] % 50) != 0) && do {
        $str = " [".&fill_left($_[0],6,"0")."]\n";
        &prt_to_stderr($str);
        &prt_to_logfile($str);        
    }
} # counter_end
@


\subsctn{Timing procedures}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules>>=
use Benchmark;
  <<Timer ON>>
@ 

<<perl requires help>>=
"Benchmark" - checking and comparing running times of code.
@

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common Routines>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ %def &timing

We also set here the date when the script is running and who is the user running it.

<<Global Vars>>=
my $total_time = 0;
my $DATE = localtime;
my $USER = defined($ENV{USER}) ? $ENV{USER} : 'Child Process';
@ 

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\appendix

\newpage

\sctn{Supplementary scripts} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{[[parameter2tex.pl]]: formatting variable definitions for manual.}

The main reason for writing this script was the idea to keep sincronized any changes in the program with the \textbf{``User's Manual''}. The main problem we had to face was to keep updated any change or include any new definition of customization variables and command-line options. The way we are trying to solve is to have each variable description in a code chunk that follows each variable definition on the program in a structured record format that will be easy to parse later and to convert it into {\LaTeX} files. Those {\LaTeX} files are going to be read by the main document of the manual. This solution also reduces redundancy and keeps variable definition free of formatting changes that can be applied here, when translating those definitions into {\LaTeX}. Automatizing the whole process avoids not only to miss features in the manual but also human errors when updating and formatting that information (by keeping all the relevant information close to the related code).%'

\subsubsctn{Extracting and running [[parameter2tex.pl]]}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"parameter2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/parameter2tex.pl ;
chmod a+x $BIN/parameter2tex.pl ;
#
@ 

<<tangling complementary LaTeX files for manual>>=
# Preparing variables and options descriptions for User's manual #'
echo "Extracting VARS/OPTIONS definitions for LaTeX files..." 1>&2 ;
notangle -R"parameter2tex - LaTeX" $WORK/$nwfile.nw | \
         cpif $DOCS/tabledefs.tex ;
echo "Extracting COMMAND-LINE options for LaTeX files..." 1>&2 ;
notangle -R"DESC command-line options" $WORK/$nwfile.nw | \
         $BIN/parameter2tex.pl -c -o $DOCS/tables/AplotCLopts.tex -- - ;
echo "Extracting CUSTOM-FILE variables for LaTeX files..." 1>&2 ;
notangle -R"DESC custom file variables" $WORK/$nwfile.nw | \
         $BIN/parameter2tex.pl -v -o $DOCS/tables/AplotCFvars.tex -- - ;
#
@ 

<<HIDE: new LaTeX commands>>=
\input tabledefs.tex
@

\subsubsctn{[[parameter2tex.pl]] implementation}

<<parameter2tex.pl>>=
<<PERL shebang>>
# 
# parameter2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
use Getopt::Std;
use File::Basename;
#
<<parameter2tex - global vars>>
#
# MAIN
&getcmdlineopts;
&$parseinput;
exit(0);
#
# SUBS
<<parameter2tex - functions>>
<<Common Routines: text fill>>
@
 
By default, if no command-line option is given, input records must be in custom-file vars record format:

<<parameter2tex - global vars>>=
my $USAGE = << "+++EOU+++";
################################################################################
###
#### $0
###
####\t\t@{[ (localtime)." : ".(defined($ENV{USER})?$ENV{USER}:"nouser") ]} 
###
#### USAGE:
###
###    parameter2tex [options] -o <output_file> -- <input_files>
###
###    -h              prints this help.
###    -v              process custom-file vars input.
###    -c              process command-line options input.
###    -o <path+file>  output base name for the whole path/file (required).
###
################################################################################
+++EOU+++
#
my %VARS = ();
my ($base_dir,$base_file,$base_ext) = ('./','out','.tex');
my $parseinput = \&parseVars;
@

We use [[Getopt::Std]] because we only need to set two boolean variables that define which main parsing function must be applied to input records (remember that [[fileparse]] function returns file name, leading path and file extension, in that order):

<<parameter2tex - functions>>=
sub getcmdlineopts() {
    our($opt_v,$opt_c,$opt_o,$opt_h);
    getopts('vco:h');
    $opt_h && do {
        print STDERR $USAGE;
        exit(1);
    }; # $opt_h
    $opt_v && ($parseinput = \&parseVars);
    $opt_c && ($parseinput = \&parseOpts);
    ($base_file,$base_dir,$base_ext) = fileparse($opt_o, '\..*');
    # print STDERR "::$base_dir\::$base_file\::$base_ext\::\n";
    (-d $base_dir) ||
        die("##\n## ERROR ## OUTPUT DIRECTORY DOES NOT EXIST... $!\n##\n"); 
    $base_file eq '' && ($base_file = 'out');
	$base_ext eq '' && ($base_ext = '.tex');
    #
    @files = ();
    scalar(@ARGV) > 0 && do {
        foreach my $fl (@ARGV) {
            $fl eq '-' && do {
                push @files, "-";
                next;
            };
            -e $fl || do {
                print STDERR "### FILE $fl DOES NOT EXIST, SKIPPING... $!\n";
                next;
            };
            push @files, $fl;
		}; # foreach $fl
        return;
    }; # scalar(@ARGV) > 0
    push @files, "-";
} # getcmdlineopts
@

<<parameter2tex - global vars>>=
my @files;
@ 

\subsubsctn{Common functions between variable and option processing}

This function is common for both, customization variables and command-line options definitions, because record structure is similar. Record separator is '[[###EOR###]]' and field separator is '[[\n]]' (except for last field which starts when '[[LDE:]]' tag appears and ends when the record does). '[[ORD:]]' must be the first field on each record, 

<<parameter2tex - functions>>=
sub parseinput() {
    print STDERR "### Parsing input records...\n";
    my $char;
    my $c = 0;
    my $extra = 1000;
    foreach my $fl (@files) {
        my ($a,$b,$lstelm,$order);
        open(IFILE,"< $fl");
        $lstelm = 0;
        $order = undef;
        while (<IFILE>) {
            next if /^\s*$/o;
            chomp;
            $_ =~ s/\s*$//o;
            $char = '.';
            <<parameter2tex - loading Long DEscription>>
            <<parameter2tex - loading other fields>>
		} continue {
            print STDERR $char; # &counter(++$c,$char);
        }; # while read $fl
        close(IFILE);
    }; # foreach $fl
    print STDERR "\#\n";        # &counter_end($c,$char);
} # parseinput
@ 

<<parameter2tex - loading Long DEscription>>=
$lstelm && do {
    $_ =~ /^\#\#\#EOR\#\#\#/o && do {
        $lstelm = 0;
        $order = undef;
        print STDERR "\#\n";
        $char = ''; # $char = '#';
        next;
    }; # ###EOR###
    $_ =~ s/^\s*//o;
    $char = ':'; 
    $VARS{$order}{LDE} .= " $_";
    next;
};
$_ =~ /^LDE/o && do {
    $_ =~ /JOIN-NEXT\s*$/o && ($VARS{$order}{JOIN} = 1);
    $lstelm = 1;
    next;
}; # LDE
$_ =~ /^SDE/o && do {
    $_ =~ /JOIN-NEXT\s*$/o && ($VARS{$order}{JOIN_SHORT} = 1);
}; # SDE
@ 

[[$VARS{$order}{JOIN}]] takes care if the program must concatenate variable/option items that share a common description.

<<parameter2tex - loading other fields>>=
($a,$b) = split /:\s*/o, $_, 2;
defined($order) || do {
    CHECK: {
      $a =~ /^ORD/o && do {
          $order = (defined($b) && $b ne '') ? $b : ++$extra;
          $char = 'O';
          last CHECK;
      }; # ORD
      $order = ++$extra;
      $char = 'X';
    }; # CHECK
    $order = &fill_left($order,4,'0');
    %{ $VARS{$order} } = ();        
    $VARS{$order}{JOIN} = 0;
    $VARS{$order}{JOIN_SHORT} = 0;
    print STDERR &fill_left(++$c,3,'0')." ";
    next; 
}; # $order
(defined($b) && $b ne '') && do {
    $VARS{$order}{$a} = $b;
}; # $b
@

The following functions replace the special tags we use in the description fields to homogenize formats among option names, parameters and values.

<<parameter2tex - functions>>=
sub rep_varop()  { $_[0] =~ s/\[(.+?)\]/\\op\{$1\}/og;     return $_[0]; } 
# sub repq_varop() { $_[0] =~ s/\[(.+?)\]/\'\\op\{$1\}\'/og; return $_[0]; } 
sub repq_varop() { $_[0] =~ s/\[(.+?)\]/\\op\{$1\}/og;     return $_[0]; } 
@

<<parameter2tex - functions>>=
sub rep_param()  { $_[0] =~ s/<(.+?)>/\\pp\{$1\}/og;     return $_[0]; }
# sub repq_param() { $_[0] =~ s/<(.+?)>/\'\\pp\{$1\}\'/og; return $_[0]; }
sub repq_param() { $_[0] =~ s/<(.+?)>/\\pp\{$1\}/og;     return $_[0]; }
@

<<parameter2tex - functions>>=
sub rep_value()  { $_[0] =~ s/\|(.+?)\|/\\vp\{$1\}/og;     return $_[0]; }
# sub repq_value() { $_[0] =~ s/\|(.+?)\|/\'\\vp\{$1\}\'/og; return $_[0]; }
sub repq_value() { $_[0] =~ s/\|(.+?)\|/\\vp\{$1\}/og;     return $_[0]; }
@

<<parameter2tex - functions>>=
sub rep_chars()  { 
    $_[0] =~ s/\%\{/\[/og;  # to recover LaTeX []
    $_[0] =~ s/\%\}/\]/og;  # 
    $_[0] =~ s/\\n\\/\n/og; # to recover LaTeX newline
    return $_[0];
} # rep_chars
@

<<parameter2tex - functions>>=
sub tex_header() {
    my ($a,$b) = @_;
    $a =~ m{/([^/]*)$}o && ($a = $1);
    return "\%\n\% $a\n\%\n\% $b\n\%\n\%".
           ' $Id: gff2aplot.nw,v 1.28 2001-12-07 18:38:50 jabril Exp $ '.
           "\n\%\n"; 
} # tex_header
@

\subsubsctn{Parsing descriptions for customization variables}

Record tags available for customization vars definition file are: [[ORD]], [[SEC]], [[SUB]], [[OPT]], [[DEF]], [[PAR]], [[SDE]] and [[LDE]]. Here is a short description of each:

\hfill\parbox{0.95\linewidth}{
\begin{description}\small\setlength{\itemsep}{0ex}\setlength{\parsep}{0ex}
\item[ [[ORD]] ] Order when printing it out, if this variable is not defined then description is moved to end of output.
\item[ [[SEC]] ] To which section file has to be saved current variable description.
\item[ [[SUB]] ] Subsection on customization variables table.
\item[ [[OPT]] ] Customization variable name.
\item[ [[DEF]] ] Default value, if not defined it is not used by the program unless the variable is set to a valid parameter.
\item[ [[PAR]] ] Parameters required (optional).
\item[ [[SDE]] ] Short description for customization variables table. '[[JOIN-NEXT]]' enforces the current variable to be joined with the following because both they share a description.
\item[ [[LDE]] ] Long description for the corresponding manual section. '[[JOIN-NEXT]]' behaves here as in the previous item.
\end{description}
} %parbox
\hfill

<<parameter2tex - functions>>=
sub parseVars() {
    my ($k,$c);
    print STDERR "###\n### PARSING CUSTOM-FILE VARS DEFINITIONS\n###\n";
    &parseinput;
    print STDERR "### Opening Files ${base_dir}${base_file}\_\*${base_ext}\n";
    &open_varfiles;
    $c = 0;
    foreach $k (sort keys %VARS) {
        print STDERR "$k".((++$c % 10) ? ".." : "\n");
        ((defined($VARS{$k}{SEC}) && $VARS{$k}{SEC} ne '')
                                  &&
         (defined($VARS{$k}{SUB}) && $VARS{$k}{SUB} ne '')) || do {
             print STDERR "\n##\n## ERROR ## SECTION/SUBSECTION ".
                          "NOT DEFINED ON INPUT for $k ... $!\n##\n";
             next;
         }; # SEC/SUB NOT DEFINED ON INPUT
        my ($sec,$subsec, 
            $tmpdsc,$strdsc,$tmptbl,$strtbl,$par,$vareq,$vareqj);
        ($sec,$subsec) = ($VARS{$k}{SEC}, "$VARS{$k}{SEC}$VARS{$k}{SUB}");
        (defined($varO{$sec}) && defined($varO{$subsec})) || do {
             print STDERR "\n##\n## ERROR ## SECTION/SUBSECTION ".
                          "NOT DEFINED ON PROGRAM for $k ... $!\n##\n";
             next;
         }; # SEC/SUB NOT DEFINED ON PROGRAM
        if (defined($VARS{$k}{PAR}) && $VARS{$k}{PAR} ne '') {
            $par = &rep_param($VARS{$k}{PAR});
        } else {
            $par = '';
        }; # PAR
        (defined($VARS{$k}{OPT}) && $VARS{$k}{OPT} ne '') || do {
             print STDERR "\n##\n## ERROR ## VARIABLE NAME ".
                          "NOT DEFINED for $k ... $!\n##\n";
             next;         
        }; # DEFINED OPT
        #
        $tmpdsc = '\op{'.$VARS{$k}{OPT}.'} $\,=\,$ '.$par;
        $tmptbl = '\op{'.$VARS{$k}{OPT}.'}';
        #
        $vareqj = ' \hfill ';
        if (defined($VARS{$k}{DEF})) {
            $vareq  = (&rep_varop(&rep_param(&rep_value($VARS{$k}{DEF}))));
        } else {
            $vareq  = '\bydef';
        }; # DEF
        defined($VARS{$k}{SDE}) || ($VARS{$k}{SDE} = '{\tbdef}');
        defined($VARS{$k}{LDE}) || ($VARS{$k}{LDE} = ' {\tbdef}');
        if ($VARS{$k}{JOIN_SHORT}) {
            $strtbl = '\rvjoin{'.$tmptbl.'}{'.$vareq.'}'."\n\%\n";
        } else {
            $strtbl = '\rvdesc{'.$tmptbl.'}{'.$vareq.'}'."\n".'   { '.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{SDE}))))).' }'.
                "\n\%\n";
        }; # JOIN_SHORT
        if ($VARS{$k}{JOIN}) {
            $strdsc = '\ijoin{'.$tmpdsc.$vareqj.'[ '.$vareq.' ]}'."\n\%\n";
        } else {
            $strdsc = '\idesc{'.$tmpdsc.$vareqj.'[ '.$vareq.' ]}'."\n".'   {'.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{LDE}))))).' }'.
                "\n\%\n";
        }; # JOIN
        #
        $strdsc =~ s/(_|\%\-)/\\_/og;
        $strtbl =~ s/(_|\%\-)/\\_/og;
        print { $varO{$sec}[0] }    $strdsc;
        print { $varO{$subsec}[0] } $strtbl;
    }; # foreach keys %VARS
    ($c % 10) && print STDERR "\#\#\#\#\n";
    print STDERR "\#\#\#\n";
    &close_varfiles;
} # parseVars
@

Here we define the available values for the '[[SEC]]'/'[[SUB]]' fields:

<<parameter2tex - global vars>>=
local (*LAYa,*LAYb,*LAYc,*LAYd,*LAYe,*LAYf,*LAYg,
       *SEQa,*SEQb,*SRCa,*SRCb,*STRa,*STRb,*GRPa,*GRPb,*FEAa,*FEAb);
my %varO = (
    #                    [ HANDLE, EXTENSION, LABEL                     ]
    LAYOUT            => [ \*LAYa, 'Layout'                             ],
    LAYOUTPageLayout  => [ \*LAYb, 'playout', 'Page Layout'             ],
    LAYOUTZoom        => [ \*LAYc, 'zoom',    'Zoom Options'            ],
    LAYOUTLabels      => [ \*LAYd, 'label',   'Labels'                  ],
    LAYOUTTickmarks   => [ \*LAYe, 'ticks',   'Tick Marks'              ],
    LAYOUTAplot       => [ \*LAYf, 'aplot',   'Aplot Layout'            ],
    LAYOUTGeneral     => [ \*LAYg, 'general', 'General Definitions'     ],
    #
    SEQUENCE          => [ \*SEQa, 'Sequence'                           ],
    SEQUENCESequences => [ \*SEQb, 'seq',     'GFF-Sequence Attributes' ],
    #
    SOURCE            => [ \*SRCa, 'Source'                             ],
    SOURCESources     => [ \*SRCb, 'src',     'GFF-Source Attributes'   ],
    #
    STRAND            => [ \*STRa, 'Strand'                             ],
    STRANDStrands     => [ \*STRb, 'str',     'GFF-Strand Attributes'   ],
    #
    GROUP             => [ \*GRPa, 'Group'                              ],
    GROUPGroups       => [ \*GRPb, 'grp',     'GFF-Group Attributes'    ],
    #
    FEATURE           => [ \*FEAa, 'Feature'                            ],
    FEATUREFeatures   => [ \*FEAb, 'feat',    'GFF-Feature Attributes'  ],
    );
my @varMain = qw / LAYOUT SEQUENCE SOURCE STRAND GROUP FEATURE /;
my @varSub  = qw /
                   LAYOUTPageLayout  LAYOUTZoom      LAYOUTLabels 
                   LAYOUTTickmarks   LAYOUTAplot     LAYOUTGeneral
                   SEQUENCESequences SOURCESources   STRANDStrands
                   GROUPGroups       FEATUREFeatures
                 /;
@

<<HIDE: testing variables set as FILEHANDLES>>=
perl -e '$a="SEC";open(*{$a},"> kkkk"); print $a "HEYYYY"; close(*{$a})' 
perl -e 'use strict;
         my $a=\*SEC;
         open($a,"> kkkk");
         print { $a } "HEYYYY";
         close($a)'  # Works OK with USE STRICT pragma...
@ 

<<parameter2tex - functions>>=
sub open_varfiles() {
    my ($flh,$vlh,$mf);
    foreach $flh (@varMain) {
        $vlh = "_dsc".$varO{$flh}[1];
        $mf = "${base_dir}${base_file}${vlh}${base_ext}";
        open($varO{$flh}[0],"> $mf");
        print { $varO{$flh}[0] } 
              &tex_header($mf,"Description items for $flh");
	}; # foreach $flh
    foreach $flh (@varSub) {
        $vlh = "_tbl".$varO{$flh}[1];
        $mf = "${base_dir}${base_file}${vlh}${base_ext}";
        open($varO{$flh}[0],"> $mf");
        print { $varO{$flh}[0] } 
              &tex_header($mf,"Summary table for $flh: $varO{$flh}[2]");
        print { $varO{$flh}[0] } "\%\n".'\begin{tabular}{p{5cm}p{3cm}p{15cm}}';
        print { $varO{$flh}[0] } "\n\%\n".'\rvdef{'.$varO{$flh}[2].'}'."\n\%\n";
	}; # foreach $flh
} # open_varfiles
sub close_varfiles() {
    my $flh;
    foreach $flh (@varMain) {
        close($varO{$flh}[0]);
	}; # foreach $flh
    foreach $flh (@varSub) {
        print { $varO{$flh}[0] } '\end{tabular}'."\n";
        close($varO{$flh}[0]);
	}; # foreach $flh
} # close_varfiles
@ 

\subsubsctn{Parsing descriptions for command-line options}

Record tags available for command-line options definition file are: [[ORD]], [[OPT]], [[LNG]], [[PAR]], [[EQV]], [[SDE]] and [[LDE]]. Here is a short description of each:

\hfill\parbox{0.95\linewidth}{
\begin{description}\small\setlength{\itemsep}{0ex}\setlength{\parsep}{0ex}
\item[ [[ORD]] ] Order when printing it out, if this variable is not defined then description is moved to end of output.
\item[ [[OPT]] ] Short command-line option, a single char (optional).
\item[ [[LNG]] ] Long command-line option (words are ALWAYS joined with hypens, '-'). This field is mandatory (all command-line options has a long name while the opposite is not true).
\item[ [[PAR]] ] Parameters required (optional).
\item[ [[EQV]] ] Customization variable equivalence if it is appropriate and does exist (optional).
\item[ [[SDE]] ] Short description for command-line options table. '[[JOIN-NEXT]]' senforces the current option to be joined with the following because both they share a description.
\item[ [[LDE]] ] Long description for the corresponding manual section. '[[JOIN-NEXT]]' behaves here as in the previous item.
\end{description}
} %parbox
\hfill

<<parameter2tex - functions>>=
sub parseOpts() {
    my ($k,$c);
    print STDERR "###\n### PARSING CMD-LINE OPTIONS DEFINITIONS\n###\n";
    &parseinput;
    print STDERR "### Writing to ${base_dir}${base_file}\_\*${base_ext}\n";
    open(FDSC,"> ${base_dir}${base_file}\_dsc${base_ext}");
    open(FTBL,"> ${base_dir}${base_file}\_tbl${base_ext}");
    $c = 0;
    print FTBL '\begin{tabular}{rl}'."\n\%\n";
    foreach $k (sort keys %VARS) {
        print STDERR "$k".((++$c % 10) ? ".." : "\n");
        my ($tmpdsc,$strdsc,$tmptbl,$strtbl,$par,$varlng,$varsht,$vareq);
        if (defined($VARS{$k}{PAR}) && $VARS{$k}{PAR} ne '') {
            $par = &rep_param($VARS{$k}{PAR});
        } else {
            $par = '';
        }; # PAR
        (defined($VARS{$k}{LNG}) && $VARS{$k}{LNG} ne '') || do { 
             print STDERR "\n##\n## ERROR ## LONG OPTION NAME ".
                          "NOT DEFINED for $k ... $!\n##\n";
             next;
        }; # LONG OPTION NOT DEFINED
        $varlng = '\op{-\/-'.$VARS{$k}{LNG}.'} '.$par;
        if (defined($VARS{$k}{OPT}) && $VARS{$k}{OPT} ne '') { 
            $varsht  = '\op{-'.$VARS{$k}{OPT}.'}';
            $tmptbl  = $varsht.'{\x}'.$varlng;
            $varsht .= " $par";
            $tmpdsc  = '\shortstack[l]{\ '.$varsht.' \\\\ '.$varlng.'}';
        } else {
            $tmpdsc = $varlng;
            $tmptbl = $varlng;
        }; # OPT
        $vareq = ' \hfill ';
        (defined($VARS{$k}{EQV})) && 
            ( $vareq .= (&rep_varop(&rep_param(&rep_value($VARS{$k}{EQV})))) );
        defined($VARS{$k}{SDE}) ||
            ($VARS{$k}{SDE} = '{\tbdef}');
        defined($VARS{$k}{LDE}) ||
            ($VARS{$k}{LDE} = ' {\tbdef}');
        if ($VARS{$k}{JOIN_SHORT}) {
            $strtbl = '\rjoin{'.$tmptbl.'}'."\n\%\n";
        } else {
            $strtbl = '\rdesc{'.$tmptbl.'}'."\n".'   { '.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{SDE}))))).' }'.
                "\n\%\n";
        }; # JOIN_SHORT
        if ($VARS{$k}{JOIN}) {
            $strdsc = '\ijoin{'.$tmpdsc.$vareq.'}'."\n\%\n";
        } else {
            $strdsc = '\idesc{'.$tmpdsc.$vareq.'}'."\n".'   {'.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{LDE}))))).' }'.
                "\n\%\n";
        }; # JOIN
        #
        $strdsc =~ s/(_|\%\-)/\\_/og;
        $strtbl =~ s/(_|\%\-)/\\_/og;
        print FDSC $strdsc;
        print FTBL $strtbl;
    }; # foreach keys %VARS
    ($c % 10) && print STDERR "\#\#\#\#\n";
    print STDERR "\#\#\#\n";
    print FTBL '\end{tabular}'."\n";
    close(FDSC);
    close(FTBL);
} # parseOpts
@

\subsubsctn{{\LaTeX} definitions}

<<parameter2tex - LaTeX>>=
%
% Definitions for variables and options description
%
\newcommand{\x}{\textmd{,\,}}
% \newcommand{\hd}{\textbf{\textsf{\textsc{Default}} $\,=\,$}}
\newcommand{\bydef}{\textbf{\textsl{\textsf{undef\ }}}}
\newcommand{\tbdef}{\textbf{\large TO BE DEFINED !!!}}
%
\newcommand{\op}[1]{\textbf{\textsf{#1}}}
\newcommand{\pp}[1]{\textmd{\textsf{{\footnotesize$<$}#1{\footnotesize$>$}}}}
\newcommand{\vp}[1]{\textbf{\textsf{ #1}}}
%
\newcommand{\idesc}[2]{\item #1 \\ #2 }
\newcommand{\ijoin}[1]{\item #1 \\[-5ex]}
%
\newcommand{\rdesc}[2]{ #1 & #2 \\}
\newcommand{\rjoin}[1]{ #1 &    \\[-0.75ex]}
%
\newcommand{\rvdef}[1]{
\multicolumn{3}{l}{
 \vspace{2ex}                        % \begin{flushright}
  \hrulefill
  \raisebox{-0.5ex}[0pt]{
    \psframebox[framearc=1,framesep=0.75ex,linestyle=solid,
                linecolor=black,fillcolor=white,fillstyle=solid]{
                   \textbf{\textsc{#1}}
                } % psframebox
    } % raisebox                     % \end{flushright}
} \\[1.5ex] % multicolumn
} % rvdef
\newcommand{\rvdesc}[3]{ \hfill #1 \hfill & \centering #2 & #3 \\}
\newcommand{\rvjoin}[2]{ \hfill #1 \hfill & \centering #2 &    \\[-0.75ex]}
%
@ 

\newpage

\subsctn{[[colors2tex.pl]]: formatting color definitions for manual.} %%%%%%%%%
\label{sec:COLORprg}

\subsubsctn{Extracting and running [[colors2tex.pl]]}
\label{sec:cmykfiles}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"colors2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/colors2tex.pl ;
notangle -R"colors2tex.pl" $WORK/$nwfile.nw | cpif $BIN/colors2tex.pl ;
chmod a+x $BIN/colors2tex.pl ;
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting color tables for the User's Manual #'
echo "Extracting \"$DOCS/AplotColorDefs.tex\"..." 1>&2 ;
notangle -R"cmyk colors perl definition" $WORK/$nwfile.nw  | \
    $BIN/colors2tex.pl -d - | cpif $DOCS/tables/AplotColorDefs.tex ;
echo "Extracting \"$DOCS/AplotColorTbl.tex\"..." 1>&2 ;
notangle -R"cmyk colors perl definition" $WORK/$nwfile.nw  | \
    $BIN/colors2tex.pl -t "seagreen" - | cpif $DOCS/tables/AplotColorTbl.tex ;
@ 

\subsubsctn{[[colors2tex.pl]] implementation}

<<colors2tex.pl>>=
<<PERL shebang>>
# 
# colors2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
use Getopt::Std;
#
<<colors2tex - global vars>>
#
# MAIN
&getcmdlineopts;
&parseinput;

exit(0);
#
# SUBS
<<colors2tex - functions>>
@

Input records have always the same format, but we need to produce two output files formatted differently, one of them will contain a set of colors definitions ([[-d]] option) and the other one will make a {\LaTeX} table to show the colors that were defined in the ``User's Manual''. %'
So that, we only need a single loop to read data from input stream, and a set functions called with a boolean flag to choose between one format or the other.

<<colors2tex - global vars>>=
my $USAGE = << "+++EOU+++";
################################################################################
###
#### $0
###
####\t\t@{[ (localtime)." : ".(defined($ENV{USER})?$ENV{USER}:"nouser") ]} 
###
#### USAGE:
###
###    colors2tex.pl [options]  < STDIN  > STDOUT
###
###    -h          prints this help.
###    -d          output is set to colors CMYK definition.
###    -t "color"  output is set to colors LaTeX table.
###                In this mode, a color name (defined on input)
###                is required to choose which color starts 
###                a new column in final LaTeX table.
###
################################################################################
+++EOU+++
#
my $tblflg = 0;
my $splitcolor = '';
@

We use [[Getopt::Std]] because we only need to set a boolean and a single parameter variables (with such parameter being optional), having any of those will set the output function, by deafult set to [[&output_defs]].

<<colors2tex - functions>>=
sub getcmdlineopts() {
    our($opt_d,$opt_t,$opt_h);
    getopts('dt:h');
    $opt_h && do {
        print STDERR $USAGE;
        exit(1);
    }; # $opt_h
    $opt_d && ($tblflg = 0);
    defined($opt_t)
           && ($splitcolor = $opt_t, $tblflg = 1);
} # getcmdlineopts
@

<<colors2tex - functions>>=
sub parseinput() {
    my @rec;
    &print_prologue($tblflg);
    while (<STDIN>) {
        next if /^\s*$/o;
        chomp;
        $_ =~ s/^\s*//o;
        @rec = split /\s+/og, $_;
        $rec[0] eq '#' && do {
            defined($rec[1]) || next;
            &print_color_name($tblflg, $rec[1]);
            next;
        }; # set color header
        (defined($rec[1]) && $rec[1] eq '=>') && do {
            &print_color_row($tblflg, @rec[0,5..8]);
        }; # set color line
    }; # while
    &print_trailer($tblflg);
} # parseinput
@

As the {\LaTeX} color definition is done also in the CMYK color space, we have not to recompute any of the values assigned to each color.

<<colors2tex - functions>>=
sub print_prologue() {
    my ($flg) = @_;  
    $flg || do {
        print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors defs: open>>
+++EOP+++
        return;
    }; # !$flg
    print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors table: open>>
+++EOP+++
    return;
} # print_prologue
@ 

<<colors2tex - functions>>=
sub print_color_name() {
    my ($flg,$name) = @_;    
    $flg || do {
        <<colors2tex - LaTeX colors defs: name>>
        return;
    }; # !$flg
    <<colors2tex - LaTeX colors table: name>>
    return;
} # print_color_name
@ 

<<colors2tex - functions>>=
sub print_new_col() {
    print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors table: split>>
+++EOP+++
} # print_new_col
@ 

<<colors2tex - functions>>=
sub print_color_row() {
    my ($flg,$name,$cyan,$magenta,$yellow,$black) = @_; # CMYK   
    $flg || do {
        <<colors2tex - LaTeX colors defs: row>>
        return;
    }; # !$flg
    <<colors2tex - LaTeX colors table: row>>
    return;
} # print_color_row
@ 

<<colors2tex - functions>>=
sub print_trailer() {
    my ($flg) = @_;    
    $flg || do {
        print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors defs: close>>
+++EOP+++
        return;
    }; # !$flg
    print STDOUT << '+++EOP+++';   
<<colors2tex - LaTeX colors table: close>>
+++EOP+++
    return;
} # print_trailer
@ 


<<HIDE: DONE>>=
\doneitem{20011113}{Automatize color table and definition file, and page sizes table, using a script which include the perl code for those colors and page sizes and a '\_\_\_DATA\_\_\_' trailer. This approach will allow to synchronize definitions with the manual without manual revision.}


\subsubsctn{{\LaTeX} code for CMYK color definitions}

Building the color definition file used by this file to produce the CMYK color definitions used in this document and the ``{\prog} User's Manual''.
% Table~\ref{tbl:CMYKcolor}.

<<colors2tex - LaTeX colors defs: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotColorDefs.tex
%
% Color CMYK definition used in "gff2aplot".
%
% <<Version Control Id Tag>>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

<<colors2tex - LaTeX colors defs: name>>=
print STDOUT '% '."$name\n";
@

<<colors2tex - LaTeX colors defs: row>>=
print STDOUT '\definecolor{'.$name.'}'.(" " x (20 - length($name))).
             '{cmyk}{'."$cyan,$magenta,$yellow,$black".'}'."\n";
@

<<colors2tex - LaTeX colors defs: close>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

\subsubsctn{{\LaTeX} code for CMYK color table}

Building the CMYK color table for the ``{\prog} User's Manual''.
% Table~\ref{tbl:CMYKcolor} \LaTeX{} file.

<<colors2tex - LaTeX colors table: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotColorTbl.tex
%
% Colors used in "gff2aplot": CMYK values table.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\label{sec:colortable}
\newcommand{\clrow}[1]{
  \fcolorbox{black}{#1}{
    \textcolor{#1}{\rule[-.3ex]{1cm}{1.8ex}}
    } % fcolorbox
  & #1
  } % newcommand
%
\newcommand{\clspc}{&&&&&\\}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\begin{table}[!ht]
%\setlength{\parindent}{-0.5cm}
\begin{center}
\begin{scriptsize}
\begin{tabular}{c@{\quad}c}
    \begin{tabular}{|c|c|cccc|} \hline
@

<<colors2tex - LaTeX colors table: name>>=
$name eq $splitcolor && &print_new_col;
print STDOUT '% '."$name\n".'\clspc'."\n";
@

<<colors2tex - LaTeX colors table: row>>=
print STDOUT '\clrow{'.$name.'}'.(" " x (24 - length($name))).
             "& $cyan & $magenta & $yellow & $black \\\\\n";
@

<<colors2tex - LaTeX colors table: split>>=
      \clspc
      \hline
    \end{tabular} 
   &
    \begin{tabular}{|c|c|cccc|} \hline
@

<<colors2tex - LaTeX colors table: close>>=
      \clspc
      \hline
    \end{tabular}
   \\
  \end{tabular}
\end{scriptsize}
%\begin{center}
  \caption{\label{tbl:CMYKcolor}
    {\prog} CMYK color definition table and Color Names.
    } % caption
  %\refstepcounter{table}
  %\addcontentsline{lot}{section}{
  %   \thetable\hspace{1em}{\prog}\ CMYK color definition table.
  %   }
\end{center}
\end{table}
\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@


\newpage

\subsctn{[[pagebbox2tex.pl]]: formatting page sizes for manual.} %%%%%%%%%%%%%%
\label{sec:PBBOXprg}

\subsubsctn{Extracting and running [[pagebbox2tex.pl]]}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"pagebbox2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/pagebbox2tex.pl ;
notangle -R"pagebbox2tex.pl" $WORK/$nwfile.nw | cpif $BIN/pagebbox2tex.pl ;
chmod a+x $BIN/pagebbox2tex.pl ;
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting page-size tables for the User's Manual #'
echo "Extracting \"$DOCS/AplotPageSizeTbl.tex\"..." 1>&2 ;
notangle -R"page sizes perl definition" $WORK/$nwfile.nw | \
    $BIN/pagebbox2tex.pl - | cpif $DOCS/tables/AplotPageSizeTbl.tex ;
@

\subsubsctn{[[pagebbox2tex.pl]] implementation}

<<pagebbox2tex.pl>>=
<<PERL shebang>>
# 
# pagebbox2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
#
<<pagebbox2tex - global vars>>
#
# MAIN
&parseinput;
exit(0);
#
# SUBS
<<pagebbox2tex - functions>>
<<Common Routines: text fill>>
@

<<pagebbox2tex - global vars>>=
my $USAGE = "###  pagebbox2tex  <STDINPUT  >STDOUTPUT \n";
@

<<pagebbox2tex - functions>>=
sub parseinput() {
    my @rec;
    &print_prologue;
    while (<STDIN>) {
        next if /^\s*$/o;
        chomp;
        $_ =~ s/^\s*//o;
        $_ =~ s/["',]//og; #'"
        @rec = split /\s+/og, $_;
        $rec[0] eq '#' && do {
            <<pagebbox2tex - LaTeX formats table: spacer>>
            next;
        }; # set color header
        (defined($rec[1]) && $rec[1] eq '=>') && do {
            <<pagebbox2tex - LaTeX formats table: row>>
        }; # set color line
    }; # while
    &print_trailer;    
} # parseinput
@

<<pagebbox2tex - functions>>=
sub print_prologue() {
    print STDOUT << '+++EOP+++';
<<pagebbox2tex - LaTeX formats table: open>>
+++EOP+++
} # print_prologue
@

<<pagebbox2tex - functions>>=
sub print_trailer() {
    print STDOUT << '+++EOP+++';
<<pagebbox2tex - LaTeX formats table: close>>
+++EOP+++
} # print_trailer
@


\subsubsctn{{\LaTeX} wrappers for available page sizes}

<<pagebbox2tex - LaTeX formats table: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotPageSizeTbl.tex
%
% Page Sizes used in "gff2aplot".
%
% <<Version Control Id Tag>>
%
\label{sec:pagesizes}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\begin{table}[!ht]
\begin{center}
\setlength{\fboxsep}{2pt}
%\setlength{\arrayrulewidth}{1pt}
\fbox{
 \begin{tabular}{|c||r|r||r|r||r|r|} \hline
  \raisebox{-0.5ex}[0pt]{ PAGE } &
    \multicolumn{6}{c|}{ PAGE SIZE }\\ \cline{2-7}
  \raisebox{0.25ex}[0pt]{ FORMAT } &
    \multicolumn{2}{c||}{ (in points) } &
    \multicolumn{2}{c||}{ (in cms) } &
    \multicolumn{2}{c|}{ (in inches) } \\
@

<<pagebbox2tex - LaTeX formats table: spacer>>=
print STDOUT '\hline\hline'."\n";
print STDOUT '%                  points    -  centimeters  -     inches'."\n";
@

<<pagebbox2tex - LaTeX formats table: row>>=
print STDOUT (&fill_right($rec[0],12," ")).
             (&get_sizes(@rec[4,5]))." \\\\\n";
@

<<pagebbox2tex - functions>>=
sub get_sizes() {
    my ($w,$h) = @_;
    my $str = '';
    $str  = ' &'.(&fill_left($w,6," ")).       ' &'.(&fill_left($h,6," "));
    $str .= ' &'.(&fill_left(&tocm($w),6," ")).' &'.(&fill_left(&tocm($h),6," "));
    $str .= ' &'.(&fill_left(&toin($w),6," ")).' &'.(&fill_left(&toin($h),6," "));
    return $str;
} # get_sizes
@

<<pagebbox2tex - functions>>=
# to cm:   28.35 pts == 1 cm
sub tocm() { return sprintf("%.1f", ($_[0] / 28.35)); }
# to inch:    72 pts == 1 inch
sub toin() { return sprintf("%.1f", ($_[0] / 72.00)); }
@

<<pagebbox2tex - LaTeX formats table: close>>=
  \hline % \hline
 \end{tabular}
} % fbox
\caption{\label{tbl:PageSizes}Page Sizes defined in {\prog}.}\hspace{1cm}
\vskip 1ex
\fbox{
\begin{tabular}{c@{\quad$\equiv$\quad}c}
28.35 pt & 1 cm   \\
72.00 pt & 1 inch \\
\end{tabular}
} % fbox
  %\refstepcounter{table}
  %\addcontentsline{lot}{section}{
  %   \thetable\hspace{1em}Page Sizes available at {\prog}.}
\end{center}
\end{table}
\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

\newpage

\subsctn{Compacting {\ps} code with [[PScompactnw.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:PSnowebfilter}

\subsubsctn{Extracting and running [[PScompactnw.pl]]}

<<tangling>>=
# PostScript code flattening
notangle -R"PScompactnw.pl" $WORK/$nwfile.nw | cpif $BIN/PScompactnw.pl ;
chmod a+x $BIN/PScompactnw.pl ;
#
notangle -R"flt.sh" $WORK/$nwfile.nw | cpif $BIN/flt.sh ;
chmod a+x $BIN/flt.sh ;
#
@ 

<<tests on PScompactnw.pl script>>=
notangle -R"APLOT" \
  -filter '$BIN/flt.sh $WORK/tests/PScompact_pre $WORK/tests/PScompact_post' \
  $WORK/$nwfile.nw > $WORK/tests/PScompact_out 2> $WORK/tests/PScompact_err ;
@ 

We use the following script to check the intermediate outputs from [[notangle]], before and after running our filter that removes extra comments from {\ps} code (in case you guess, [[PScompactnw.pl]]).

<<flt.sh>>=
#!/bin/bash
#
# USAGE:
#   notangle ... -filter '$BIN/flt.sh pre_logfilename post_logfilename' ... 
#
# this function duplicate input sending part to standard error
# and everything to standard output (so 'notangle' does not complain).
toerr () {
  perl -e '
    $cdon=0;
    while (<STDIN>) {
      $_ =~ /^@(begin|end) code/o && do {
        $cdon = 1 - $cdon;
        print STDERR $_ unless $cdon;
      };
      $cdon && do { print STDERR $_ };
      print STDOUT $_;
    };
  ' $1 2> $2;
}
#
# we are getting part of the pipeline to different log files
toerr - $1 |
  $BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables" - | \
  toerr - $2 ; 
#
@ 

<<HIDE: tests on PScompact script>>=
#
# first command-line draft
notangle -R'POSTSCRIPT shortnames' $nwfile.nw | \
  perl -ne 'BEGIN{$clflg=0;$ln=0};
    chomp; $clflg && ($_ =~ s/^\s*//o);
    $clflg = ($_ =~ s/\s+\%\-\%.*$//og) ? 1 : 0 ; 
    $_ =~ s/\s+/ /og; $lnw=length($_); 
    $_ =~ /^\%/o && do { $clflg && ($_ = "\n$_"); };
    $ln>25 && do { $clflg && ($_ = "  $_"); 
    $_ = ($_ =~ /^[\n]/o ? "" : "\n").$_; $ln=0; };
    $ln+=$lnw; print STDERR "$ln : $_\n"; 
    ($_ =~ /\n$/o || !$clflg) && ($ln = 0); 
    print $_.($clflg ? " " : "\n")' 2> kkkk | more ;    
#
# perl version tests
@ 


\subsubsctn{[[PScompactnw.pl]] implementation}

<<PScompactnw.pl>>=
<<PERL shebang>>
# 
# USAGE:  PScompactnw.pl "regexp" <STDIN >STDOUT
#
<<Version Control Id Tag>>
#
use strict;
# my $MaxLen = 80; # Not Used now
my ($clflg,$usflg,$ln,$cln,$go) = (0,0,0,0,0);

my $regexp = shift @ARGV;
my $thori = '@defn';
my $colin = '@text';
my $nw    = '@nl';
my $nwlin = "$nw\n";
my $uslin = '@use';
my $idxln = '@index';
my $thend = '@end code';

(defined($regexp) && $regexp ne '') || do {
    while (<STDIN>) {
        print STDOUT $_;
    };
    exit(0);
};

while (<STDIN>) {
    <<PScompactnw - looking for code chunks>>
    <<PScompactnw - skipping the rest of the notangle output>>
    <<PScompactnw - processing code>>
}; # while

exit(0);
@

We do not proces the whole file only those chunks of code which name starts with the command-line given regular expression.

<<PScompactnw - looking for code chunks>>=
$_ =~ /^$thori\s+($regexp)/o && do {
    $go = 1;
    print STDOUT "$_$nwlin";
    next;
};
$_ =~ /^$thend/o && do {
    $go = 0;
    print STDOUT ($clflg ? "\n$nwlin$_" : "$_");
    next;
};
@ 

Anything else is just printed as it comes from input stream.

<<PScompactnw - skipping the rest of the notangle output>>=
$go || do {
    print STDOUT $_;
    next;
}; # !$go
@

<<PScompactnw - processing code>>=
<<PScompactnw - processing '@nl'>>
chomp;
<<PScompactnw - processing '@use'>>
<<PScompactnw - processing '@text'>>
@ 

[[noweb]] newlines code is skipped directly, we will print out them where needed.

<<PScompactnw - processing '@nl'>>=
$_ =~ /^$nw/o && next;
@ 

[[@use]] and [[@index]] are printed as is, without changes, first one defines a link to another code chunk in the noweb intermediate file while the second adds an item to the code index.

<<PScompactnw - processing '@use'>>=
$usflg = 0;
$_ =~ /^$uslin/o && do {
    print STDOUT ($clflg ? "\n$nwlin" : "")."$_\n$nwlin";
    $usflg = 1;
    $clflg = 0;
    next;        
}; # $_ =~ /^$uslin/
$_ =~ /^$idxln/o && do {
    print STDOUT ($clflg ? "\n$nwlin" : '')."$_\n";
    $clflg = 0;
    next;        
}; # $_ =~ /^$idxln/
@ 

<<PScompactnw - processing '@text'>>=
$_ =~ /^$colin/o && do {
    $_ =~ s/^$colin //o;
    $usflg && do {
        $usflg = 0;
        next;
    };
#    $_ =~ /^\s*$/o && next;
    $_ =~ s/^\s*//o;
    <<PScompactnw - raw comments to output>>
    <<PScompactnw - remove initial spaces>>
    <<PScompactnw - special tag types>>
    <<PScompactnw - checking lengths>>
    <<PScompactnw - printing output>>
}; # $_ =~ /^$colin/
@

Comments are printed without the 'extra' comments (all three types are explained later on this section but have no differences when filtering comments).

<<PScompactnw - raw comments to output>>=
$_ =~ /^\%/o && do { # raw comments are thrown to output directly...
    $_ =~ s/\s*\%\:\%.*$//o && do {
        $clflg = 0;
    };
    $_ =~ s/\s*\%(\-(\%|\>)).*$//o;
    $_ eq '' && do {
        next;
    };
    print STDOUT ($clflg ? "\n$nwlin" : "")."$colin $_\n$nwlin" ;
    $clflg = 0;
    next;
}; # $_ =~ /^\%/o
@

We clean up of extra white spaces.

<<PScompactnw - remove initial spaces>>=
$_ =~ s/\s+/ /og;
$_ eq '' && do {
    next;
};
@

Now we are looking for three different tags:

\begin{description}
\item{[[%:%]]} A comment that is replaced by a newline.
\item{[[%-%]]} A comment that joins next line to current one.
\item{[[%->]]} Also joins next line to current one, we use it to distinguish between simple comments and stack/functions description, [[%-%]] and [[%->]] respectively.
\end{description}

What we are going to do now is to join each new line that was preceeded by one of the 'join' tags, or leave as is. If an empty line is found is just removed. After that, we prepend the [[noweb]] text line header if we are starting a new code line.

<<PScompactnw - special tag types>>= 
TYPE: {
    $clflg || ($_ = "$colin $_");
    ($_ =~ s/\s*\%\-(\>|\%).*$//og) && do {
        $_ .= " ";
        $clflg = 1;
        last TYPE;
    };
    $_ =~ s/\s*\%\:\%.*$//og && do {
        $_ .= "\n$nwlin";
        $clflg = 0;
        last TYPE;
    };
    $clflg && ($_ = "\n$nwlin$colin $_");
    $_ .= "\n$nwlin";
    $clflg = 0;
}; # TYPE
@

<<PScompactnw - checking lengths>>=
# $cln = length($_);
# $cln > 0 || next;
# $_ =~ /^\s*$/o && next;
# SIZES: {
#    $ln == 0 && ( $_ = "$colin $_" );
#    $clflg || ( $ln = 0, last SIZES );
##    $clflg && ( $_ = "\n$nwlin$colin $_" );
#    $ln += $cln + $clflg;
#}; # SIZES
@

And finally, we return the processed output to [[noweb]] pipeline:

<<PScompactnw - printing output>>=
# $_ .= $clflg ? " " : "\n$nwlin";
print STDOUT "$_";
# print STDERR "$cln ($ln) : \n$_\n";
@


<<HIDE: PScompact.pl>>=
<<PERL shebang>>
##################################################################
# 
# PScompact.pl
#
<<Version Control Id Tag>>
#
use strict;
my ($MaxLen,$clflg,$fnflg,$ln,$cln) = (25,0,0,0,0);

while (<STDIN>) {
    my $tt;
    chomp;
    $_ =~ /^\%/o && do { # raw commentss are thrown to output directly...
        $tt = $clflg ? "\n" : '';
        $fnflg = $clflg = $ln = 0;
        print STDOUT "$tt$_\n";
        next;
    }; 
    $_ =~ s/\s+/ /og;
    $clflg && ($_ =~ s/^\s//o);
  TYPE: {
      ($_ =~ s/\s\%\-\>.*$//og) && do {
          $fnflg = $clflg = 1;
          last TYPE;
      };
      $fnflg = 0;
      $clflg = ($_ =~ s/\s\%\-\%.*$//og) ? 1 : 0;
  }; # TYPE
    $cln = length($_);
    $ln > $MaxLen && do {
        $fnflg && ($_ = "  $_"); # indenting opened functions
        $_ = "\n$_";
        $ln = 0;
    };
    $ln += $cln;
    print STDERR "$cln ($ln) : $_\n";
    $tt = $clflg ? " " : "\n";
    print STDOUT "$_$tt";
}; # while

exit(0);
@
<<HIDE: PScompactnw - processing '@text'>>=
# We tryed to get less than 80 chars columns,
# now each function in a single line (see previous code chunk) 
$_ =~ /^$colin/o && do {
    $_ =~ s/^$colin //o;
    $_ =~ /^\%/o && do { # raw commentss are thrown to output directly...
        $_ =~ s/\s\%\:\%.*$//og;
        $tt = $clflg ? "\n$nwlin" : '';
        $fnflg = $clflg = $ln = 0;
        print STDOUT "$tt$colin $_\n$nwlin";
      # print STDERR "$tt$colin $_\n$nwlin";
        next;
    }; 
    $_ =~ s/\s+/ /og;
    $clflg && ($_ =~ s/^\s*//o);
  TYPE: {
      $jmflg = 0;
      ($_ =~ s/\s\%\:\%.*$//og) && do {
          $jmflg = 1;
          last TYPE;
      };
      ($_ =~ s/\s\%\-\>.*$//og) && do {
          $fnflg = $clflg = 1;
          last TYPE;
      };
      $fnflg = 0;
      $clflg = ($_ =~ s/\s\%\-\%.*$//og) ? 1 : 0;
  }; # TYPE
    $cln = length($_);
  SIZES: {
    ($ln == 0 && $cln > 0) && do {
        $_ = "$colin $_";
    }; 
    $clflg || do {
        $ln = 0;
        last SIZES;
    };
    $tln = 0;
    $clflg && do {
      for (my $j = 0; $j < $cln; $j++) {
        substr($_,$j,1) =~ /\s/o && do {
            my $pp = $j + 1;
            $pp = $ln + $pp;
            $pp < $MaxLen && ($tln = $j, next);
            $tln > $cln && last;
            substr($_,$tln,0) = "\n$nwlin$colin ";
            $tln = $cln - $tln + 1;
            $cln = $tln;
            $ln = 0;
            last;
        }; # substr($_,$j,1)
      }; # for
    }; # $clflg 
    $ln += $cln + $clflg + $fnflg;
    $ln >= $MaxLen && do {
        $fnflg && ($_ = " $_"); # indenting opened functions
        $_ = ($clflg ? "\n$nwlin" : "")."$colin $_";
        $ln = $tln;
    };
  }; # SIZES
    # print STDERR "$cln ($ln) : $_\n";
    $tt = $clflg ? " " : "\n$nwlin";
print STDERR "$cln : $tln : ($ln) : \n$_\n";
    print STDOUT "$_$tt";
}; # $_ ~ @text
@


\newpage

\subsctn{Making tests with [[aplottester.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Running gff2aplot.pl on a test GFF file>>=
$BIN/gff2aplot.pl --debug -V $WORK/tests/running.log \
    --subtitle "A simple test set is being drawn using GFF2APLOT..." \
    --background-color verylightviolet  \
    --aplot-box-color   lightyellow     \
    --percent-box-color lightcyan       \
    --extra-box-color   lightseagreen   \
    --show-percent-box --show-extra-box \
    -- $WORK/tests/GFFmix.gff   \
     > $WORK/tests/running.ps.t \
    2> $WORK/tests/running.err  ;
egrep -v '^#' $WORK/tests/running.ps.t > $WORK/tests/running.ps ;
gv -portrait $WORK/tests/running.ps ;
@ 

\label{todo:TAA}
<<HIDE: new defs TODO>>=
\def\todoTAA{
Implement a perl script to test {\prog} functions.
} % todoTAA
@
<<HIDE: TODO>>=
\todoitem{\todoTAA}{todo:TAA}
@
\todo{ \item \todoTAA } % todo

\subsubsctn{[[aplottester.pl]] implementation}

<<aplottester.pl>>=
<<PERL shebang>>
# 
# aplottester.pl
#
<<Version Control Id Tag>>
#
use strict;
use Test;
#
BEGIN { plan tests => 14, todo => [3,4] } # set to approiate values
#
#################
use gff2aplot.pl;
#################
#
<<aplottester - global vars>>
#
# MAIN

exit(0);
#
# SUBS
<<aplottester - functions>>
@ 

\subsubsctn{Tests to be implemented}

<<testing regular expressions for element@id>>=
The following does not work pretty well:

$string =~ /^(.*)(?:@(.*?))?$/ && (($tmpstr, $tmpid) = ($1,$2));

As we can see in the perl script below, reversing the regular expression is a good choice: 

perl -ne ' 
    chomp;
    $a=$b=undef;
    (reverse($_) =~ /^([^\/]*?)(?:\@)(?!\\)(.*)$/o) && 
        ($a=reverse($2),$b=reverse($1));
    defined($b) && 
        (print ">>> \"$a\" \@ \"".($b?$b:"NIL")."\"\n") ||
            (print ">>> \"$_\"\n"); '
jhkjfhgkjdf@one # feature string and ID, both defined
>>> "jhkjfhgkjdf" @ "one"
/.*@@.*/        # only feature regexp, no ID
>>> "/.*@@.*/"
ffgdg           # only feature string, no ID
>>> "ffgdg"
jhkjfhgkjdf@    # only feature string, but an empty ID field ? 
>>> "jhkjfhgkjdf" @ "NIL"
jhkjfhgkjdf\@   # use "\" to preserve "@" if feat ends with "@" (most unlikely)
>>> "jhkjfhgkjdf\@"
/.*@@.*/@kk     # feature regexp and ID, both defined
>>> "/.*@@.*/" @ "kk"
*@yoyo          # feature pseudo-regexp ("*" ~ "/.*/") and ID, both defined
>>> "*" @ "yoyo"
!@@@@@lio       # a very extrange test, isn't it ? ... ;^D
>>> "!@@@@" @ "lio"
@ %$


<<testing regexes: regexptester.pl>>=
BEGIN { ($NULL,$T,$F) = ("+@+NULL+@+",1,0); }
    chomp;
    s{^:::\s+}{}o;
    print ">>> $_ \n";
    ($a,$b) = split /\s+:::\s+/o, $_, 2;
    @results = &find_regexp($a);
    @results_mod = (($results[0] ? "TRUE" : "FALSE"),
                    ($results[1] ? "TRUE" : "FALSE"),
                    (defined($results[2]) ? $results[2] : "FALSE"),
                    "$results[3]");
    printf ">>> IS_OK::%s::  IS_NEG::%s::  GET_ID::%s::  GET_STRING::%s::\n",
           @results_mod;
    !$results[1] &&
         print ">>> ".
             (  ( (eval { $b =~ m{$results[3]}; 1 } || 0) ?
                         ($b =~ m{$results[3]}) : 0 ) ? 
                     "\"$b\" MATCHES \/$results[3]\/ " : 
                     "\"$b\" DOES NOT MATCH \/$results[3]\/ ")."\n\n";
    $results[1] &&
         print ">>> ".
             (!(( (eval { $b =~ m{$results[3]}; 1 } || 0) ?
                         ($b =~ m{$results[3]}) : 0 )) ? 
                       "\"$b\"  MATCHES !\/$results[3]\/ " : 
                       "\"$b\" DOES NOT MATCH !\/$results[3]\/ ")."\n\n";
sub find_regexp() {
    my $string = $_[0];
    my ($isOK_flg,$not_flg,$id_flg,$tmpstr,$tmpid);
    $isOK_flg = $T;
    $not_flg = $F;
    $id_flg = undef;
    $string =~ s{^!}{}o && ($not_flg = $T); # not_regexp is true
    $string =~ s{(\\@)$}{@@}o;
    $string = &escape_input($string);
    ($tmpstr, $tmpid) = (undef, undef);
    ( reverse($string) =~ m{^([^\/@]*?)(?:@){1}(.*)$}o ) && do {
        $tmpstr = reverse($2);
        $tmpid  = reverse($1);
    };
  REGEXPS: {
      print ">>> STRING($tmpstr) ID($tmpid)\n";
      (defined($tmpid) && $tmpid ne "") && ($id_flg = $tmpid);
      (defined($tmpstr) && $tmpstr ne "") || do {
          $string eq '@' && ($string="", $isOK_flg=$F);
          $tmpstr = $string;
      };
      $tmpstr eq '*' && do {
          $string = '^.*$';
          last REGEXPS;
      };
      $tmpstr =~ m{^/(.*)/$}o && do {    
          ($string, $isOK_flg) = &eval_regexp($1);
          last REGEXPS;
      }; # $tmpstr is a regexp
      $string = '^'.(quotemeta($tmpstr)).'$';
    }; # REGEXPS
    return ($isOK_flg, $not_flg, $id_flg, $string);
} # find_regexp
sub eval_regexp() {
    my $str = $_[0];
    my $flag;
    # $str =~ s{^[^\\]*?/+}{}o;
    # $str =~ s{/+.*?$}{}o;
    eval { "" =~ m{$str}; $flag = $T; } || ($flag = $F);
    return ($str, $flag);
} # eval_regexp
sub escape_input() {
  $_[0] =~ s{([;<>&!{}'`"])}{\\$1}og; # "`'
  return $_[0];
} # escape_input
@

<<HIDE: testing regexes: regexes.test>>=
::: @ ::: @
::: \@ ::: @
::: @@ ::: @
::: element ::: element
::: element ::: any
::: !element ::: element
::: !element ::: any
::: element@id ::: element
::: !element@id ::: element
::: /.*any.*/ ::: chooseanyfeat
::: /; system(" echo \"I have found your name: \$USER ... X.D\" "); / ::: any
::: /; `echo "I have found your name: \$USER ... X.D"`; / ::: any
::: / @{[ system("echo \"I have found your name: \$USER ... X.D\"") ]} / ::: any
::: / @{[ system('echo "I have found your name: $USER ... X.D"') ]} / ::: any
::: / @{ \( system("echo \"I have found your name: \$USER ... X.D\"") ) } / ::: any
::: / @{ \( exec "echo \"I have found your name: \$USER ... X.D\"" ) } / ::: any
::: /(a)+ny/ ::: any
::: /(a)+ny/ ::: aany
::: /^(a)+ny/ ::: any
::: /^a?ny/ ::: any
::: /^a?ny/ ::: aany
::: /^a?ny/@id ::: any
::: /^a?ny/@id ::: onyony
::: /^a?ny/@id ::: nyony
::: !/^a?ny/ ::: any
::: !/^a?ny/ ::: aany
::: !/^a?ny/ ::: ony
::: 5'cds ::: 5'cds
::: /^5'.*$/ ::: 5'utr
::: /^a.*?y$/ ::: annnnny
::: /^a.*?y$/ ::: anyany
::: /^a[^y]*y$/ ::: annnnny
::: /^a[^y]*y$/ ::: anyany
::: /a.+?y/ ::: annnnny
::: /a.+?y/ ::: ayyyyyy
::: /y{6}/ ::: ayyyyyy
@

<<test file for the previous regexp tester>>=
notangle -L -R'testing regexes: regexptester.pl' $WORK/$nwfile.nw | \
         cpif $BIN/regexptester.pl ;
notangle -R'HIDE: testing regexes: regexes.test' $WORK/$nwfile.nw | \
         cpif $TEST/regexes.test ;
perl -n $BIN/regexptester.pl < $TEST/regexes.test > $TEST/regexes.report ;
@ 


<<testing regular expressions for SEQ\_UNIT>>=
perl -ne '$q = undef; chomp;
          $a = $_;
          ($_ =~ /^\.$|^\s*$/o) && do {
               print "$a ::: Wrong VALUE... !!!\n";
               next;
          };
          $_ =~ s/(?:\.)?
                  (?:(g(?:iga)?|m(?:ega)?|k(?:ilo)?)?
                  b(?:ase)?
                  (?:p(?:air)?)?
                  (?:s)?)$
                 //ox && ($q = $1);
          defined($q) || do {
              $_ =~ /[^\d]+$/o && do {
                   print "$a ::: Wrong UNITS !!!\n";
                   next;
              };
          };
          (defined($_) && $_ ne "") ||  do {
               print "$a ::: Wrong VALUE !!!\n";
               next;
          };
          ($q,undef) = split //o,$q,2;
          $q .= 'bp';
          print "$a ::: $_ $q\n"; ' << 'EOF'
10kbp
10kilobp
10gigabp
11.33kk
-1kb
0.5bp
.

0.bp
0
10+e15bp
EOF

The results are the following:

10kbp ::: 10 kbp
10kilobp ::: 10 kbp
10gigabp ::: 10 gbp
11.33kk ::: Wrong UNITS !!!
-1kb ::: -1 kbp
0.5bp ::: 0.5 bp
. ::: Wrong VALUE... !!!
 ::: Wrong VALUE !!!
0.bp ::: 0 bp
0 ::: 0 bp
10+e15bp ::: 10+e15 bp
@ 


<<testing regular expressions for PS\_UNIT>>=
perl -ne '$q = undef; chomp;
          $a = $_;
          ($_ =~ /^\.$|^\s*$/o) && do {
               print "$a ::: Wrong VALUE... !!!\n";
               next;
          };
          PSLEN: {
              $_ =~ s/m(eter(s)?)?$//o && do {
                  $_ =~ s/(\.)?c(enti)?$//o && ($q = "cm", last PSLEN);
                  $_ =~ s/(\.)?m(ili)?$//o  && ($q = "mm", last PSLEN);
                  last PSLEN;
              };
              $_ =~ s/(\.)?in(ch(es)?)?$//o && ($q = "in", last PSLEN);
              $_ =~ s/(\.)?(pt|point(s)?)$//o    && ($q = "pt");
          }; # PSLEN
          defined($q) || do {
              $_ =~ /[^\d]+$/o && do {
                   print "$a ::: Wrong UNITS !!!\n";
                   next;
              };
              $q = "pt";
          };
          (defined($_) && $_ ne "") ||  do {
               print "$a ::: Wrong VALUE !!!\n";
               next;
          };
          print "$a ::: $_ $q\n"; ' << 'EOF'
10cm
10centimeters
10mmeters
11.33kk
-1in
0.5pt
100inches
1inch
.

0.points
0
10+e15pts
EOF

The results are the following:

10cm ::: 10 cm
10centimeters ::: 10 cm
10mmeters ::: 10 mm
11.33kk ::: Wrong UNITS !!!
-1in ::: -1 in
0.5pt ::: 0.5 pt
100inches ::: 100 in
1inch ::: 1 in
. ::: Wrong VALUE... !!!
 ::: Wrong VALUE... !!!
0.points ::: 0 pt
0 ::: 0 pt
10+e15pts ::: Wrong UNITS !!!
@ 


\newpage

\sctn{Common code blocks} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/local/bin/perl -w
# This is perl, v5.6.1 built for i686-linux
# /usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
@ 

The 'shebang' line can be emulated in several ways. Those systems that do not support '[[#!]]' will emulate it with:

<<PERL shebang emulation>>=
#!/usr/bin/perl -w
eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}' if $running_under_some_shell;
@ 

Another way to emulate the 'shebang' line is the following devious construct that will work under any of csh, sh, or perl system.

<<PERL shebang general emulation>>=
eval '{exit $?0}' && 
  eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}' &&
    eval 'exec /usr/bin/perl -w -S $0 $argv:q' 
      if 0;
@

We also include a copy of the GNU-GPL as a comment at first lines on the program, and the version control tag.

<<Program Info>>=
#
<<GNU License PERL>>
#
<<Version Control Id Tag>>
#
@

We are using here [[perl -w]] to show all warnings when running the script. We also [[use strict]] to force all variable names to be declared.

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common Routines>>=
<<Common Routines: min-max>>
<<Common Routines: text fill>>
<<Common Routines: Counter>>
@

In the functions calculating minimum and maximum values of a list we have to take into account the case in which the list contains a single element.

<<Common Routines: min-max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common Routines: text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@


\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script closure>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: gff2aplot.nw,v 1.28 2001-12-07 18:38:50 jabril Exp $
@ 

\subsctn{GNU General Public License}

<<GNU License PERL>>=
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# %                          GFF2APLOT                               %
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# 
#    Converting alignments in GFF format to PostScript dotplots.
# 
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                  Thomas WIEHE                   
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ 

<<GNU License PostScript>>=
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %                          GFF2APLOT                               %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
%    Converting alignments in GFF format to PostScript dotplots.
% 
%     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                  Thomas WIEHE                   
%                                 Roderic GUIGO SERRA       
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ 

\newpage

\sctn{Extracting code blocks from this document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracting Script code chunks from the [[noweb]] file} % \\[-0.5ex]

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"APLOT" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/gff2aplot.pl ;
# we remove here the comments within "use vars qw/ ... /",
# numbers may change if noweb doc is changed
notangle -L -R"APLOT" $WORK/$nwfile.nw | \
    perl -ne '( $.>1 &&
                $_ !~ /^\#line (467|477|486|1212|1308|1482|4531|4999|455)/o
               ) && print' - | cpif $BIN/gff2aplot.pl ;
#
chmod a+x $BIN/gff2aplot.pl ;
#
@ 

<<HIDE: new LaTeX urls>>=
\def\perltidy{
 \htmladdnormallinkfoot{\texttt{perltidy}}
                   {\url|http://perltidy.sourceforge.net/|}
 } % def perltidy
@
We use {\perltidy} to reformat final versions of perl scripts (without line numbering comments, correct indentations, etc...) and to pretty-print in html format.

<<tangling>>=
# reformating program with perltidy
notangle -R"APLOT" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/$nwfile.pl ;
# html pretty-printing program with perltidy
notangle -R"APLOT" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/$nwfile.html ;
#
@

<<tangling>>=
############################
# FLATTENING of PS CODE...
#
notangle -L -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perl -ne '$.>1 && print' - | cpif $BIN/gff2aplot.pl ;
#
notangle -L -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | \
      perl -ne '( $.>1 &&
                  $_ !~ /^\#line (467|477|486|1212|1308|1482|4531|4999|455)/o
                 ) && print' - | perltidy - | cpif $BIN/gff2aplot.pl ;
# reformating program with perltidy
notangle -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perltidy - | cpif $BIN/$nwfile.pl ;
# html pretty-printing program with perltidy
notangle -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perltidy -html - | cpif $DOCS/html/$nwfile.html ;
#
@ 


\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
@

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
# extracting main document processors
notangle -R"weaving"    $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -R"LaTeXing"   $WORK/$nwfile.nw | cpif $WORK/ltx ;
notangle -R"The Manual" $WORK/$nwfile.nw | cpif $WORK/mkdoc ;
#
@

[[cpif]] is an auxiliary tool for use with [[notangle]] and [[make]]. [[cpif]] compares its standard input to each of the named files, overwriting the file if the comparison succeeds or if the named file does not exist.

<<tangling complementary LaTeX files>>=
# extracting complementary material 
echo "Extracting \"$DOCS/defs.tex\"..." 1>&2 ;
notangle -R"HIDE: LaTeX aplot new definitions" $WORK/$nwfile.nw | \
         noweave -v -t4 -delay - | cpif $DOCS/defs.tex ;
echo "Extracting \"$DOCS/todo.tex\"..." 1>&2 ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | \
         noweave -v -t4 -delay - | cpif $DOCS/todo.tex ;
echo "Extracting \"$DOCS/localrefs.bib\"..." 1>&2 ;
notangle -R"HIDE: BiBTeX references" $WORK/$nwfile.nw | \
         cpif $DOCS/localrefs.bib ;
#
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting tables for the documentation
echo "Extracting \"$DOCS/DataStructure_GFF.tex\"..." 1>&2 ;
notangle -R"HIDE: GFF DATA STRUCTURE" $WORK/$nwfile.nw | \
         cpif $DOCS/tables/DataStructure_GFF.tex ;
#
@ 

[[noweave]] options:

\begin{tabular}{>{\bfseries}rp{14cm}}\hline
[[-v]] & be verbose. \\
[[-t4]] & tabs are made of 4 spaces. \\
[[-delay]] & putting file-name and other information into the output before the first chunk of the  program, enabling a user to put a specialized \LaTeX [[\documentclass]] command and other preamble material in the first documentation chunk. It also forces trailing cross-referencing information to be emitted just before the final chunk, instead of at the end of the document; the final chunk is expected to contain [[\end{document}]]. Also implies [[-n]] option, meanning not to wrap the output with a \LaTeX header/trailer. \\
\multicolumn{2}{l}{[[-filter 'elide "HIDE: *"']]} \\
 & this filter removes those code chunks we define in the pattern, in this case those starting with `[[HIDE: *]]'. \\
[[-index]] & \\\hline
\end{tabular}

<<weaving>>=
<<BASH shebang>>
#
### weaving and LaTeXing
#
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
# extracting main documentation
echo "Weaving \"$DOCS/$nwfile.tex\"..." ;
noweave -v -t4 -delay -index -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# LaTeXing 
echo "LaTeXing \"$DOCS/$nwfile.tex\"..." ;
pushd $DOCS/ ;
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
popd;
<<BASH script closure>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
#
### only LaTeXing
#
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
# ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script closure>>
@ %$

<<The Manual>>=
<<BASH shebang>>
#
### weaving and LaTeXing DOCUMENTATION
#
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
<<tangling complementary LaTeX files for manual>>
#
MANUAL="GFF2APLOT_MANUAL";
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $MANUAL.tex" 1>&2 ;
latex $MANUAL.tex ; 
latex $MANUAL.tex ; 
latex $MANUAL.tex ;
dvips $MANUAL.dvi -o $MANUAL.ps -t a4 ;
#
# echo "### CONVERTING PS to PDF: $MANUAL" 1>&2 ;
# ps2pdf $MANUAL.ps $MANUAL.pdf ;
#
popd ;
<<BASH script closure>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
# Global Variables
WORK="$HOME/development/softjabril/gfftools/gff2aplot" ;
BIN="$WORK/bin" ;
PARAM="$BIN/param" ;
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
nwfile="gff2aplot" ;
export WORK BIN PARAM DOCS DATA TEST nwfile ;
@ 

<<tangling>>=
#
# BASH Environment Variables
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
source $WORK/.bash_VARS ;
#
@

\newpage

\sctn{Code chunks list}

\nowebchunks

\end{document}
