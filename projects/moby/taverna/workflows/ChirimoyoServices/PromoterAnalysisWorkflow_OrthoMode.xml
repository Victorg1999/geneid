<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:F3GMCPPN615" author="" title="" />
  <s:processor name="regexp" boring="true">
    <s:stringconstant>\n</s:stringconstant>
  </s:processor>
  <s:processor name="articleName_1" boring="true">
    <s:stringconstant>map1</s:stringconstant>
  </s:processor>
  <s:processor name="CombineMoby">
    <s:beanshell>
      <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(MobyA));
InputSource Source2 = new InputSource(new StringReader(MobyB));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document doc2=db.parse(Source2);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
NodeList nodelist2an = doc2.getElementsByTagName("moby:Simple");
NodeList nodelist2a = doc2.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
NodeList nodelist2bn = doc2.getElementsByTagName("moby:Collection");
NodeList nodelist2b = doc2.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");
NodeList nodelist2cn = doc2.getElementsByTagName("moby:Parameter");
NodeList nodelist2c = doc2.getElementsByTagName("Parameter");

// We will iterate over these lists
NodeList[] globalS={
	nodelist1an,
	nodelist1a,
	nodelist2an,
	nodelist2a
};

NodeList[] globalC={
	nodelist1bn,
	nodelist1b,
	nodelist2bn,
	nodelist2b,
	nodelist1cn,
	nodelist1c,
	nodelist2cn,
	nodelist2c
};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

// We are skipping over Collected Simples
for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalS[gi].getLength();i&lt;maxi;i++) {
		Node found=globalS[gi].item(i);
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalC[gi].getLength();i&lt;maxi;i++) {
		Node found=globalC[gi].item(i);
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

CombinedMOBY = OutObj;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/xml'">MobyA</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/xml'">MobyB</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/xml'">CombinedMOBY</s:beanshelloutput>
      </s:beanshelloutputlist>
    </s:beanshell>
  </s:processor>
  <s:processor name="MobyChangeArticleName_1">
    <s:beanshell>
      <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(input));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");

NodeList[] globalS={nodelist1an,nodelist1a};
NodeList[] globalC={nodelist1bn,nodelist1b,nodelist1cn,nodelist1c};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	if(globalS[gi].getLength()&gt;0) {
		Node found=globalS[gi].item(0);
		// Skipping Simples inside collections
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		Node changed=docsalida.importNode(found,true);
		changed.setAttribute("articleName",articleName);
		comienzo.appendChild(changed);
		break;
	}
}

if(gi==maxgi) {
	for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
		if(globalC[gi].getLength()&gt;0) {
			Node found=globalC[gi].item(0);
			// Skipping Simples inside collections
			Node changed=docsalida.importNode(found,true);
			changed.setAttribute("articleName",articleName);
			comienzo.appendChild(changed);
			break;
		}
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

output = OutObj;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/xml'">input</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/xml'">output</s:beanshelloutput>
      </s:beanshelloutputlist>
    </s:beanshell>
  </s:processor>
  <s:processor name="MobyChangeArticleName">
    <s:beanshell>
      <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(input));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");

NodeList[] globalS={nodelist1an,nodelist1a};
NodeList[] globalC={nodelist1bn,nodelist1b,nodelist1cn,nodelist1c};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	if(globalS[gi].getLength()&gt;0) {
		Node found=globalS[gi].item(0);
		// Skipping Simples inside collections
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		Node changed=docsalida.importNode(found,true);
		changed.setAttribute("articleName",articleName);
		comienzo.appendChild(changed);
		break;
	}
}

if(gi==maxgi) {
	for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
		if(globalC[gi].getLength()&gt;0) {
			Node found=globalC[gi].item(0);
			// Skipping Simples inside collections
			Node changed=docsalida.importNode(found,true);
			changed.setAttribute("articleName",articleName);
			comienzo.appendChild(changed);
			break;
		}
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

output = OutObj;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/xml'">input</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/xml'">output</s:beanshelloutput>
      </s:beanshelloutputlist>
    </s:beanshell>
  </s:processor>
  <s:processor name="Split_string_into_string_list_by_regular_expression">
    <s:local>org.embl.ebi.escience.scuflworkers.java.SplitByRegex</s:local>
  </s:processor>
  <s:processor name="Create_moby_genelist_data">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.CreateMobyData</s:local>
  </s:processor>
  <s:processor name="runMetaAlignment">
    <s:description>Promoter regions analysis program. Meta-alignment produces alignments of sequences of TF binding sites. It returns the predictions in 'Meta-alignment' format. Use runMatScanGFF to produce the input GFF files</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMetaAlignment</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="getUpstreamSeqfromEnsembl_OrthoMode">
    <s:description>Upstream sequence retrieval tool from Ensembl database. It returns the upstream sequence of a given set of Ensembl gene identifiers. This identifiers could be external ones, such as Refseq Ids or Affymetrix ids.
 In case you select the orthologous mode, it will returns the upstream sequence of all orthologous genes of a given input gene (only one input gene identifier in that case)</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>getUpstreamSeqfromEnsembl</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMatScanGFF_1">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. You can search for example the Transfac database, but also MEME or jaspar matrices. This service only accepts a simple DNASequence object and returns a simple GFF object. If you want to give MatScan output to Meta-alignment program, you MUST use the 'log-likelihood matrix' mode.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFF</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="getUpstreamSeqfromEnsembl">
    <s:description>Sequence retrieval tool from Ensembl database. It returns the upstream sequence of a given set of Ensembl gene identifiers. These identifiers could be external ones, such as Refseq Ids or Affymetrix ids.
 In case you select the orthologous mode, it will returns the upstream sequence of all orthologous genes of a given input gene (only one input gene identifier in that case)</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>getUpstreamSeqfromEnsembl</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMatScanGFF_2">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. You can search for example the Transfac database, but also MEME or jaspar matrices. This service only accepts a simple DNASequence object and returns a simple GFF object. If you want to give MatScan output to Meta-alignment program, you MUST use the 'log-likelihood matrix' mode.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFF</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="NestedWorkflow">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:72RSYENLPL7" author="" title="" />
        <s:processor name="CreateMOBYSecondary">
          <s:beanshell>
            <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;moby:Parameter moby:articleName=''&gt;&lt;moby:Value&gt;EMPTY&lt;/moby:Value&gt;&lt;/moby:Parameter&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";

DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource SourceSkel = new InputSource(new StringReader(skel));

Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:Parameter");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

comienzo.setAttribute("articleName",articleName);
// As the skeleton already contains a &lt;moby:Value&gt; with a TEXT_NODE,
// and it is its only child, we are going to reuse it!
comienzo.getFirstChild().getFirstChild().setNodeValue(value);

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

MobySecondary = OutObj;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">value</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/xml'">MobySecondary</s:beanshelloutput>
            </s:beanshelloutputlist>
          </s:beanshell>
        </s:processor>
        <s:processor name="String_Constant" boring="true">
          <s:stringconstant>orthologous mode</s:stringconstant>
        </s:processor>
        <s:processor name="String_Constant1" boring="true">
          <s:stringconstant>True</s:stringconstant>
        </s:processor>
        <s:link source="String_Constant1:value" sink="CreateMOBYSecondary:value" />
        <s:link source="String_Constant:value" sink="CreateMOBYSecondary:articleName" />
        <s:link source="CreateMOBYSecondary:MobySecondary" sink="MobySecondary" />
        <s:sink name="MobySecondary" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:processor name="articleName_2" boring="true">
    <s:stringconstant>map2</s:stringconstant>
  </s:processor>
  <s:link source="CombineMoby:CombinedMOBY" sink="getUpstreamSeqfromEnsembl_OrthoMode:input" />
  <s:link source="Create_moby_genelist_data:mobydata" sink="CombineMoby:MobyA" />
  <s:link source="Create_moby_genelist_data:mobydata" sink="getUpstreamSeqfromEnsembl:text-formatted(genes)" />
  <s:link source="gene_ids_list" sink="Split_string_into_string_list_by_regular_expression:string" />
  <s:link source="MobyChangeArticleName:output" sink="runMetaAlignment:GFF(map2)" />
  <s:link source="NestedWorkflow:MobySecondary" sink="CombineMoby:MobyB" />
  <s:link source="Split_string_into_string_list_by_regular_expression:split" sink="Create_moby_genelist_data:id" />
  <s:link source="Split_string_into_string_list_by_regular_expression:split" sink="Create_moby_genelist_data:stringvalue" />
  <s:link source="namespace" sink="Create_moby_genelist_data:namespace" />
  <s:link source="MobyChangeArticleName_1:output" sink="runMetaAlignment:GFF(map1)" />
  <s:link source="articleName_1:value" sink="MobyChangeArticleName_1:articleName" />
  <s:link source="articleName_2:value" sink="MobyChangeArticleName:articleName" />
  <s:link source="getUpstreamSeqfromEnsembl:output" sink="runMatScanGFF_1:input" />
  <s:link source="getUpstreamSeqfromEnsembl_OrthoMode:output" sink="runMatScanGFF_2:input" />
  <s:link source="regexp:value" sink="Split_string_into_string_list_by_regular_expression:regex" />
  <s:link source="runMatScanGFF_1:output" sink="MobyChangeArticleName_1:input" />
  <s:link source="CombineMoby:CombinedMOBY" sink="MobyOutput" />
  <s:link source="Create_moby_genelist_data:mobydata" sink="Gene_Id_Moby" />
  <s:link source="getUpstreamSeqfromEnsembl:output" sink="Seq1_Moby" />
  <s:link source="getUpstreamSeqfromEnsembl_OrthoMode:output" sink="Seq2_Moby" />
  <s:link source="runMatScanGFF_1:output" sink="MatScan_Moby_1" />
  <s:link source="runMatScanGFF_2:GFF(matscan_predictions)" sink="MatScan_Moby_2" />
  <s:link source="runMatScanGFF_2:output" sink="MobyChangeArticleName:input" />
  <s:link source="runMetaAlignment:output" sink="Meta_Moby" />
  <s:source name="namespace" />
  <s:source name="gene_ids_list" />
  <s:sink name="Gene_Id_Moby" />
  <s:sink name="Seq1_Moby" />
  <s:sink name="Seq2_Moby" />
  <s:sink name="MatScan_Moby_1" />
  <s:sink name="MatScan_Moby_2" />
  <s:sink name="MobyOutput" />
  <s:sink name="Meta_Moby" />
</s:scufl>


