% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: humus.nw,v 1.13 2002-04-05 19:04:47 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
\usepackage{verbatim}
%\usepackage{version}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}

<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
  \item[$\triangleright$] [\textit{Section}~\ref{#2}, 
                           \textit{page}~\pageref{#2}]\\ {#1}
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\shorttit{\textbf{Human + Mouse}}
\def\tit{\textsc{\shortstack{Human Genome Annotation\\using Mouse Homology}}}
%
\def\mtauthor{
 \htmladdnormallink{\texttt{author@imim.es}}
                   {MAILTO:author@imim.es?subject=[humus]}
 } % def mtauthor
%
\def\authorslist{
 The Author/s {\mdseries\small\dotfill \mtauthor } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF; Parra, G; Guig\'o, R
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
We are going to scale up all the processes we have tested on {\lhsap} chromosomes 22 and 21, to the whole genome approach, in which we take advantage of the homology between {\hsap} and {\lmmus} genomes to increase gene prediction accuracy and producing a better genome annotation of the coding regions.
 } % def progdesc
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\shorttit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
\newcommand{\mylst}[2]{
 \begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{#1}
   \begin{itemize}
     #2
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}
} % newcommand->mylst
\newcommand{\whtlst}[1]{\mylst{What to do here:}{#1}} % newcommand->chklst
\newcommand{\chklst}[1]{\mylst{Check points:}{#1}} % newcommand->chklst
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es?subject=[HuMus]}}
\def\mtgparra{\htmladdnormallink{\textbf{gparra@imim.es}}{MAILTO:gparra@imim.es?subject=[HuMus]}}
\def\mtrguigo{\htmladdnormallink{\textbf{rguigo@imim.es}}{MAILTO:rguigo@imim.es?subject=[HuMus]}}
\def\mthomology{\htmladdnormallink{\textbf{homology@viaken.com}}{MAILTO:homology@viaken.com?subject=[HuMus]}}
@ 
<<HIDE: new LaTeX definitions>>=
\def\perl{\textsc{Perl}}
\def\biop{\textsc{BioPerl}}
\def\ps{\textsc{PostScript}}
\def\rptm{\textsc{RepeatMasker}}
\def\bl{\textsc{Blast}}
\def\bn{\textsc{blastn}}
\def\bx{\textsc{blastx}}
\def\bp{\textsc{blastp}}
\def\tbn{\textsc{tblastn}}
\def\tbx{\textsc{tblastx}}
\def\pb{\texttt{parseblast}}
\def\gnid{\texttt{geneid}}
\def\gnsc{\texttt{genscan}}
\def\twsc{\texttt{twinscan}}
\def\slam{\textsc{slam}}
\def\sgp{\textsc{sgp}}
\def\gps{\texttt{gff2ps}}
\def\aps{\texttt{gff2aplot}}
\def\apo{\textsl{Apollo}}
\def\refseq{\textsc{RefSeq}}
\def\ens{\textit{\texttt{emsembl}}}
\def\hsap{\textit{H. sapiens}}
\def\lhsap{\textit{Homo sapiens}}
\def\mmus{\textit{M. musculus}}
\def\lmmus{\textit{Mus musculus}}
@ 
<<HIDE: new defs TODO>>=
@ 

%

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\textbf{\Huge \tit}\\[5ex]

% \textbf{\Large Authors List Here}\\[1ex]
\textbf{\Large Josep F. Abril}\\[1ex]
\textbf{\Large Gen\'{\i}s Parra}\\[1ex]
\textbf{\Large Roderic Guig\'o}\\[5ex] % \raisebox{0.85ex}{\footnotesize$\,\dag$}\\[0.5ex]

\textbf{\large --- \today ---}\\[10ex]

\begin{abstract}
\begin{center}
\parbox{0.75\linewidth}{
\progdesc
} % parbox
\end{center}
\end{abstract}

\vfill

\begin{raggedleft}
\showaffiliation
\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: {\mtjabril}, {\mtgparra} and {\mtrguigo}}\\
\end{raggedleft}
\end{center}

\end{titlepage} %'

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}

\ \ \\
% EMPTY PAGE

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: humus.nw,v 1.13 2002-04-05 19:04:47 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{Project protocol}

\textbf{Issues:}
\begin{itemize}
 \item Whole genome, chromosome and process (all sequences or single sequence) runs.
 \item Results validation.
 \item Unassembled sequences IDs (those ``random''). Loop through each sequence in chromosomes.
 \item Move all verified software to a global path, like [[/usr/local/molbio/share]], \\ instead of [[/projects/sgp/bin]].
 \item Make every protocol step runnable on any machine (so wrapper must handle PBS queues too).
 \item Generate global report by chromosome.
 \item ...
\end{itemize}


\subsctn{Making up the jobs list}

Here we are going to define which will be the fields structure for the jobs file. That file will contain a set of jobs to be executed, each step within a job must have an input/output directories pair from where to read/write, and that depends on the execution date of the main job. Jobs must also be sequence oriented, where sequences are grouped within chromosomes (which will work the same way as job/steps), but this will be handled by the step-runner program (see [[stepper.pl]] definition on corresponding apendix section).\\

\noindent\hspace{-1cm}
\begin{tabular}{|@{\hspace{2ex}}c@{\hspace{2ex}}|@{\hspace{2ex}}c@{\hspace{2ex}}|}\hline
& \\
\begin{minipage}[t]{8cm}
\textbf{JOBS FILE DEFINITION}
\scriptsize
\begin{verbatim}
...
  ...
JOB_j
  * Job ID
  * Job description
  * Job main path
  * Job execution JOBXID (to set subpath)
  * STEP list:
    ...
      ...
    STEP_s
      + Step ID
      + Step description
      + Step main path
      + Step execution SXID (to set subpath) ?
      + Input dir:  IDIR
      + Output dir: ODIR
      + Error dir:  EDIR (also logs)
      + Step shell commands:
        #># STEP_CODE ----...
        ... commands ...
        #># END_OF_STEP --...
    end-of-STEP_s
    ...
      ...
end-of-JOB_j
...
  ...

\end{verbatim}
\end{minipage}
&
\begin{minipage}[t]{10cm}
\textbf{LOOPING JOBS THROUGH DATA}
\scriptsize
\begin{verbatim}
...
  ...
CHR_c
  * Set chromosome directory
  * Get sequences associated to chromosome "c"
  * SEQ list:
    ...
      ...
    SEQ_q
      + Output file is set to sequence "q" name
      + For each selected step:
        - Combine into $$ script (saving into a tmp dir)
           > common bash exports from '.project_VARS':
             HUMUS, BIN, SRC,
             LIBPERL, LIBSTEP, MySQLPAR, ...
           > current sequence definitions:
             CHR, SEQ, JOB, STEP, XID,
             CHRDIR ($HUMUS/$NCHR),
             JOBDIR ($CHRDIR/$JOB/$XID),
             IDIR, ODIR, EDIR, ...
           > build directories: 
             MkDirs ODIR;
             [EDIR != ODIR] && MkDirs EDIR
           > current step (use STEP_ID ?)
        - Report start status to DB execution table 
        - Launch $$ script to local/remote machine
        - Report termination status to DB execution table 
      + ...
    end-of-SEQ_q
    ...
      ...
end-of-CHR_c
...
  ...

\end{verbatim}
\end{minipage}
\\\hline
\multicolumn{2}{|c|}{\shortstack{
\ \\[1ex]
\textbf{PATH CONSTRUCTOR}\\[1ex]
\texttt{/projects/H.sapiens/\textbf{CHR\_c}/\textbf{JOB\_j}/\textbf{JOBXID}/\textbf{STEP\_s}/\textbf{SEQ\_q}.files}\\[1ex]
}}
\\\hline
\end{tabular}


\subsctn{Basic squetch of job and step records }

<<Empty JOB Definition Record>>=
             #.........................(max ID length: 25chars)
####>#########>#######################<########################################<#
#># JOB_ID    ...
#># JOB_DESC  ...
#>#        :  ...
#>#        :  ...
#># JOB_PATH  ...
#># JOB_XID   ...
#># JOB_FILE  $LIBSTEP/...
#># END_OF_JOB ##################################################################
@ 


<<Empty STEP Definition Record>>=
             #.........................(max ID length: 25chars)
####>#########>#######################<########################################<#
#># STEP_ID   ...
#># STEP_DESC ...
#>#         : ...
#>#         : ...
#># STEP_PATH ...
#># STEP_XID  $<JOB_ID>
#># STEP_IDIR ...
#># STEP_ODIR ...
#># STEP_EDIR ...
#># STEP_CODE   --------------------------------------------------------------#<#
...
#<# Remove this line from code when tangling
#<#   (commands used when testing script)...
...
#># END_OF_STEP --------------------------------------------------------------#<#
@

<<Empty STEP Definition FILE>>=
<<Empty STEP Definition Record>>
<<Empty STEP Definition Record>>
...
<<Empty STEP Definition Record>>
@

\subsctn{Main job collector}

<<JOB COLLECTOR>>=
####>#########>################################################################<#
### 
### Collecting step records for each pipeline job
###
####>#########>################################################################<#
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling: mySQL param' $WORK/$nwfile.nw ; } | bash ;
#
notangle -R'JOBS: Sequence Analysis'                   $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/annotation.job ;
notangle -R'JOBS: HsapGPa x MmusPHa WUTBLASTX'         $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/tblastx.job ;
notangle -R'JOBS: Running GENEID standard'             $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/geneid.job ;
notangle -R'JOBS: SGP with HSAPgpa x MMUSpha homology' $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/sgp.job ;
notangle -R'JOBS: Visualizing Results with Apollo'     $WORK/$nwfile.nw | \
    egrep -v '^#<#' - | cpif $LIBSTEP/apollo.job ;
#
$MySQLPAR/admin_db_Hsapiens.pl ;
#
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Sequence Analysis}

\whtlst{
\item Get annotations for each sequence from Golden Path annotation.
\item Get fragment lengths, fragment number.
\item Get coords of N-masked regions from assembly gaps.
\item Get G+C content.
}

<<JOBheader: Sequence Analysis>>=
####>#########>#######################<########################################<#
#># JOB_ID    HSAP_GP_ANNOTATION
#># JOB_DESC  Homo sapiens Golden Path annotation.
#>#        :  Processing files downloaded from Golden-Path server
#>#        :  ( URL: http://genome.ucsc.edu/ ).
#>#        :  We retrieve fasta sequences, gaps, annotation (RefSeq and 
#>#        :  Ensembl), genscan predicted genes and so on.
#>#        :  Last UCSC-GP version being analyzed is August, 2001.
#># JOB_PATH  annotation
#># JOB_XID   20010806
#># JOB_FILE  ${LIBSTEP}/annotation.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Sequence Analysis>>=
<<STEPS(Sequence Analysis): INITIALIZE>>
<<STEPS(Sequence Analysis): ASSEMBLY GAPS>>
<<STEPS(Sequence Analysis): ORIGINAL MASKING>>
<<STEPS(Sequence Analysis): REFSEQ>>
<<STEPS(Sequence Analysis): ENSEMBL>>
<<STEPS(Sequence Analysis): GENSCAN>>
@

\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

<<Global: >>=
#
#
# HUMUS="$BASE/H.sapiens" -> .project_VARS
#
MkDirs $HUMUS/.ftp $HUMUS/.ftp/PankajAgarwal
#
@
 
<<Global: >>=
#
# Retrieving Golden path sequence names and length
#
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806";
# 
# getfastadesc.pl must be executed after table update
#   on mySQL database (after admin_db_Hsapiens.pl)
#
$BIN/getfastadesc.pl $MySQLPAR/chrs.tbl $HSAP/chromosomes \
                     > $HUMUS/seqid_list 2> $HUMUS/seqid_list.rpt ;
#
@

<<HIDE: STEPS(Sequence Analysis): >>=
CHRLIST="22" ;
#
for n in $CHRLIST;
  do {
       chrdir="$HUMUS/chr$n" ;
       MkDirs $chrdir ;
       MkDirs $chrdir/fasta $chrdir/annotation $chrdir/masking \
                 $chrdir/tblastx $chrdir/geneid $chrdir/sgp ;
     };
  done ;
#
CHRNUM="22" ; # length -> 47748585
CHR="chr$CHRNUM" ;
XID="20020122";
#
IDIR="$HSAP/database" ;
ODIR="$HUMUS/$CHR/annotation/$HSAPID" ;
MkDirs $ODIR $ODIR/refseq $ODIR/genscan $ODIR/ensembl $ODIR/gaps $ODIR/repeats ;
#
@

<<HIDE: Global: >>=
#
# Retrieving Golden path sequence names
#
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806";
# 
$BIN/getfastadesc.pl $MySQLPAR/chrs.tbl $HSAP/chromosomes > $HUMUS/seqid_list ;
#
perl -e '
  use strict;
  use global qw( :ExitStatus );
  my %chr = ();
  my ($idir,$ifile) = @ARGV;
  $idir =~ s%/$%%o;
  open(FI,"< $ifile");
  while (<FI>) {
      my @l;
      next if /^[#>]/o;
      next if /^\s*$/o;
      s/^\s*//o;
      @l = split /\s+/o, $_, 2;
      $chr{$l[0]} .= $l[1];
  };
  close(FI);

  my @dirs = qw( annotation fasta masking tblastx geneid sgp );
  foreach my $l (keys %chr) {
      my $odir = "$idir/chr$l";
      &check_dirs($odir,$l) || next;
      foreach my $pd (@dirs) {
          &check_dirs("$odir/$pd",$l);
      };
      open(FO,"> $odir/seqid_list");
      print FO $chr{$l};
      close(FO);
  };

  exit(0);

  sub check_dirs() {
      my ($odir,$chr) = @_;
      ( -e $odir && -d _ ) || do {
          print STDERR "# Making chr $chr directory: $odir\n";
          (mkdir $odir) || do {
              print STDERR "# Error making directory \"$odir\" ".
                           "for chr $chr : SKIPPING !!!\n";
              return 0;
          };
          return 1;
      };
      print STDERR "# Directory \"$odir\" for chr $chr ALREADY EXIST...\n".
      return 1;
  } # check_dirs
' $HUMUS $HUMUS/seqid_list ;
#
@ 

\subsctn{Sequence analysis: \textit{H.sapiens}}

<<HIDE: >>=
#
# NOT filtering overlapping genes (gp2gff '--no-overlap' option)...
#
### 679 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/ensGene.txt".
### 816 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/genscan.txt".
### 343 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/refGene.txt".
#
# Filtering overlapping genes (gp2gff '--no-overlap' option)...
#
### 575 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/ensGene.txt".
### 816 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/genscan.txt".
### 318 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/refGene.txt".
@
 
<<STEPS(Sequence Analysis): INITIALIZE>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_INITIALIZE
#># STEP_DESC Preparing files for current chromosome.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<#
CheckFile R $IDIR/seqid_list ;
gawk 'BEGIN{ chrom="\^"ARGV[1]"\$"; ARGV[1]=""; }
      $1 ~ chrom { print $0; }
     ' $CHR $IDIR/seqid_list > $ODIR/desc || TheEnd GAWKKO ;
gawk '{ print $2, $3; }' $ODIR/desc > $ODIR/length || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Retrieving annotations from Golden Path}

<<STEPS(Sequence Analysis): REFSEQ>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_REFSEQ
#># STEP_DESC Retrieving RefSeq annotated genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH refseq
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/refseq" ;
#<# MkDirs $ODIR $EDIR ;
CheckFile R $IDIR/refGene.txt ;
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ refseq $IDIR/refGene.txt \
             > $ODIR/$SEQ.fullgff \
            2> $EDIR/$SEQ.report  || TheEnd PERLKO ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

<<STEPS(Sequence Analysis): ENSEMBL>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ENSEMBL
#># STEP_DESC Retrieving Ensembl annotated genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH ensembl
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID" ;
#<# MkDirs $ODIR $EDIR ;
CheckFile R $IDIR/ensGene.txt ;
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ ensembl $IDIR/ensGene.txt \
             > $ODIR/$SEQ.fullgff \
            2> $EDIR/$SEQ.report  || TheEnd PERLKO ;
#
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item Annotations for {\refseq} and {\ens} genes.
}


\subsubsctn{Preparing annotation files for evaluation}

<<Sequence: >>=
#
# TO BE redefined................ include frame0-mapping too
function pre_eval {
  gawk 'BEGIN{
          src = ARGV[1]; len = ARGV[2]; ARGV[1] = ARGV[2] = ""; 
          print "chr22\t"src"\tsequence\t1\t"len"\t.\t.\t."
       }' $n $lenaug > $TDIR/${HSAPIDaug}_seqlength.gff ;
  sort +3n -5 $TDIR/${HSAPIDaug}_$n.gff > $TDIR/${HSAPIDaug}.tmp ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  gawk '$7 == "+" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  gawk '$7 == "-" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  /bin/rm -v $TDIR/${HSAPIDaug}.tmp ;
} ;
#
@ 

\chklst{
\item Evaluation files for {\refseq} and {\ens} genes: SR projection of features when mapping all frames to 0, and forward/reverse selection of non-overlapping genes.
}


\subsubsctn{Retrieving gaps and masked regions from annotated sequences}

<<STEPS(Sequence Analysis): ASSEMBLY GAPS>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ASSEMBLY_GAPS
#># STEP_DESC Retrieving assembly gaps coords for current 
#>#         : H. sapiens Golden Path sequence (masked with N's).
#># STEP_PATH gaps
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/gaps" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/${SEQ}_gap.txt ;
perl -e '
  ($seq,$ori,$end,$char,$size,$type) = (1,2,3,5,6,7);
  $n = 1;
  while (<STDIN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      defined($l[$type]) || ($l[$type] = "gap");
      print STDOUT join("\t", $l[$seq],"sequence","gap",
                              @l[$ori,$end],".",".",".",
            $l[$type].".".($n++)." # $l[$type]\: $l[$size]bp ($l[$char])\n");
  }; # while   
  ' < $IDIR/${SEQ}_gap.txt \
    > $ODIR/${SEQ}.gff || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

<<STEPS(Sequence Analysis): ORIGINAL MASKING>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_ORI_MASKED
#># STEP_DESC Retrieving masked regions coords for current H. sapiens Golden
#>#         : Path sequence (original masking of repetitive regions).
#># STEP_PATH repeats
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/repeats" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/${SEQ}_rmsk.txt ;
perl -e '
  ($sco,$seq,$ori,$end,$str,$name,$class,$fam) = (1,5,6,7,9,10,11,12);
  $n = 1;
  while (<STDIN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      print STDOUT join("\t", $l[$seq],"repeatmasker","repeat",
                              @l[$ori,$end,$sco,$str],".",
                              $l[$class].".".($n++))." # @l[$name,$fam]\n";
  }; # while 
  ' < $IDIR/${SEQ}_rmsk.txt \
    > $ODIR/${SEQ}.gff || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Retrieving gene prediction results from Golden Path ({\gnsc})}

<<STEPS(Sequence Analysis): GENSCAN>>=
####>#########>#######################<########################################<#
#># STEP_ID   HSAP_GP_GENSCAN
#># STEP_DESC Retrieving genscan predicted genes for current 
#>#         : H. sapiens Golden Path sequence.
#># STEP_PATH genscan
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HSAP/database
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HSAP/database" ;
#<# ODIR="$HUMUS/$NCHR/annotation/$HSAPID/genscan" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/genscan.txt ;
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $SEQ genscan $IDIR/genscan.txt \
             > $ODIR/$SEQ.fullgff \
            2> $EDIR/$SEQ.report  || TheEnd PERLKO ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
               $ODIR/$SEQ.fullgff > $ODIR/$SEQ.gff || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item Annotations for {\gnsc} genes.
}


\subsubsctn{Evaluating {\gnsc} results from Golden Path versus annotation}

<<Sequence: H.sapiens>>=
#
# Evaluation of genscan results
#
SDIR="$HSAP/database" ;
IDIR="$HUMUS/$NCHR/annotation/$HSAPID/genscan" ;
ODIR="$HUMUS/$NCHR/annotation/$HSAPID/genscan" ;
#
# run_evaluation #chrom program param prog_results_dir \
#                annotation_dir   testset   lenght_file
run_evaluation   $SEQ "genscan" $XID $IDIR $SDIR "refseq" $LFILE;
#
@

\chklst{
\item Evaluation records (extended and brief) for each seq and for each chromosome.
\item ...
}


\subsctn{Sequence analysis: \textit{M.musculus}}

<<Sequence: M.musculus>>=
#
# 
#
MMUS="/seq/genomes/M.musculus/sanger_phusion_20011109" ;
ODIR="" ;
#
#

@ 

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Masking sequences} %%%%%%%%%%%%%%%%%%%%%%

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
    \item Human genome assembly from UCSC Golden Path August release (20010806).
    \item Pankaj run {\rptm} with the following parameters:\\[-3ex]
\begin{small}
\begin{verbatim}
###
I used the masked sequence from UCSC and masked it again. I used -s
"slow" option. We actually used RepeatBlaster and not Repeatmasker. RB
is faster version of RM that uses Blast instead of crossmatch.
\end{verbatim}
\end{small}
   \end{itemize}
  \end{minipage}
% } % fbox
\end{center}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Processing {\tbx} results} %%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
Ensembl:
	http://www.ensembl.org/Homo_sapiens/
	http://www.ensembl.org/Mus_musculus/
Ensembl mouse assembly v1.0
Sanger Institute Phusion Nov 6 Assembly
Whitehead Arachne Oct 26 Assembly
\end{comment}
\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
 \item Process {\tbx} results from Pankaj:
  \begin{itemize}
   \item Human genome assembly from UCSC Golden Path August release (20010806).
   \item Mouse genome assembly from Sanger Center Phusion assembly (20011106).\\[-3ex]
\begin{verbatim}
# Database:  /bioinfo/gapdb/blastdb/MusPhusion
# Title:  MusPhusion
# # of letters in database:  2,374,690,634  (Z = 3000000000)
# # of sequences in database:  431,480
# Format:  XDF-1
# Created:  5:32:13 PM EST Dec 10, 2001
# Posted:  5:32:14 PM EST Dec 10, 2001
\end{verbatim}
   \item {\tbx} was run with the following parameters:\\[-3ex]
%	   \begin{center}
%	   \begin{minipage}[c]{0.75\linewidth}
\begin{verbatim}
W=5  Z=3000000000
matrix=blosum62mod  filter=xnu+seg
nogaps  hspmax=500  topcomboN=100
B=9000  V=9000  E=0.01  E2=0.01  S2=80
warnings  cpus=4  ctxfactor=36.0
\end{verbatim}
% tail -54 ori/chr22_* | sort | uniq -c | sort +0nr | more
%	   \end{minipage}
%	   \end{center}
  \end{itemize}
\item Get HSPs $\Rightarrow$ SRs $\Rightarrow$ HSP-SRs
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}


<<JOBheader: HsapGPa x MmusPHa WUTBLASTX>>=
####>#########>#######################<########################################<#
#># JOB_ID    HSAPgpa_MMUSpha_WUTBLASTX
#># JOB_DESC  Homology search by WU-TBLASTX for H.sapiens UCSC Golden Path 
#>#        :  assembly against M.musculus Sanger Center Phusion assembly 
#>#        :  (TBLASTX results obtained by Pankaj Agarwal,  
#>#        :   last update was jan 11, 2002, downladed from GSBP).
#># JOB_PATH  tblastx
#># JOB_XID   20020111
#># JOB_FILE  ${LIBSTEP}/tblastx.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: HsapGPa x MmusPHa WUTBLASTX>>=
<<STEPS(HsGPa*MmPHa WUTBLASTX): retrieve blast output>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): parsing blast output>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): project HSPs into SRs>>
<<STEPS(HsGPa*MmPHa WUTBLASTX): evaluating SRs>>
@ 

\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

\subsctn{Unpacking {\tbx} results obtained by Pankaj}

<<STEPS(HsGPa*MmPHa WUTBLASTX): retrieve blast output>>=
####>#########>#######################<########################################<#
#># STEP_ID   TBLASTX_OUTPUT
#># STEP_DESC Unpacking TBLASTX results obtained by Pankaj Agarwal
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH ori
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/.ftp/PankajAgarwal/$<JOB{.}{JOB_XID}>.tbxPhusion
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/.ftp/PankajAgarwal/20020111.tbxPhusion" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/ori" ;
#<# MkDirs $ODIR ;
MkDirs $ODIR/$SEQ ;
mega "cp -v" $IDIR "^${SEQ}_" $ODIR/$SEQ || TheEnd FUNCKO;
#
$BIN/sbp_checkblastout.pl $SEQ $ODIR/$SEQ > $ODIR/$SEQ.report || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item get number of sequences from DB matching each chromosome fragment.
\item do the regions without HSPs correspond to N regions at original sequences (being gaps or masked) ? (maybe using [[evaluation]])
}

\subsctn{Retrieving {\tbx} results by chromosome}

\begin{figure}[!t]
\begin{center}
 \input psfigures/blast_frames.tex
\end{center}
\end{figure}

We had to deal with the frame issue of the HSPs fragments; once the HSP coords were mapped to the chromosome, frames also must be recomputed taking into account if HSP was in forward or in reverse strand (see figure~\ref{fig:blastframes}).

<<STEPS(HsGPa*MmPHa WUTBLASTX): parsing blast output>>=
####>#########>#######################<########################################<#
#># STEP_ID   PARSING_TBLASTX
#># STEP_DESC Retrieving HSPs from raw TBLASTX output
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH hsp
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{TBLASTX_OUTPUT}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/ori" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/hsp" ;
#<# MkDirs $ODIR ;
#<# LEN="$HUMUS/$NCHR/annotation/$HSAPID/length" ;
LEN="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/length" ;
#
$BIN/sbp_blast2gff.pl $SEQ $LEN $IDIR/$SEQ \
         > $ODIR/$SEQ.fullgff 2> $EDIR/$SEQ.report || TheEnd PERLKO ;
#
( perl -ne '/^#/o && next;
          /^\s+$/o && next; 
          $_ =~ s/;\s+Strand//o; 
          $_ =~ s/;\s+Frame//o; 
          $_ =~ s/;\s+E_value.*$//o;
          print STDOUT $_;' $ODIR/$SEQ.fullgff | \
          sort +3n -6 +6 -7 - > $ODIR/$SEQ.gff ) || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item find number of HSPs per fragment and total per chromosome.
}

\subsubsctn{Projecting HSPs into SRs}

<<STEPS(HsGPa*MmPHa WUTBLASTX): project HSPs into SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   PROJECTING_HSPs
#># STEP_DESC Projecting HSPs into SRs
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH sr
#># STEP_XID  $<STEP{.}{PARSING_TBLASTX}{STEP_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{PARSING_TBLASTX}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/hsp" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/sr" ;
#<# MkDirs $ODIR ;
CheckFile R $IDIR/$SEQ.gff ;
$BIN/blast2gff -g $IDIR/$SEQ.gff > $ODIR/$SEQ.gff || TheEnd CKO ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $SEQ $ODIR/$SEQ.gff > $EDIR/$SEQ.report || TheEnd GAWKKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item Get SRs number for each sequence.
\item ...
}

\subsubsctn{Evaluating SRs versus annotation}

<<STEPS(HsGPa*MmPHa WUTBLASTX): evaluating SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   EVALUATING_SRs
#># STEP_DESC Evaluating SRs versus different annotations
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH eval
#># STEP_XID  $<STEP{.}{PARSING_TBLASTX}{STEP_XID}>
#># STEP_IDIR $JOBDIR/$<STEP{.}{PROJECTING_HSPs}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/tblastx/$XID/sr" ;
#<# ODIR="$HUMUS/$NCHR/tblastx/$XID/eval" ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item Evaluation records (extended and brief) for each seq and for each chromosome.
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Gene Prediction} %%%%%%%%%%%%%%%%%%%%%%

\subsctn{Initialization}

\subsctn{Gene Prediction: {\gnid}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Run {\gnid} without homology, then evaluate results.
\item Remember to run [[/projects/sgp/src/geneid_v1.1]] 
\item ...
}

<<JOBheader: Running GENEID standard>>=
####>#########>#######################<########################################<#
#># JOB_ID    GENEID_STD
#># JOB_DESC  Running "geneid" on unmasked H.sapiens UCSC Golden Path 
#>#        :  assembly sequences.
#># JOB_PATH  geneid
#># JOB_XID   20020225
#># JOB_FILE  ${LIBSTEP}/geneid.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Running GENEID standard>>=
<<STEPS(geneid): Initialization>>
<<STEPS(geneid std): Running geneid on raw sequences>>
<<STEPS(geneid std): Processing geneid output>>
<<STEPS(geneid std): Evaluating geneid results>>
@ 

<<STEPS(geneid): Initialization>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_INITIALIZE
#># STEP_DESC Preparing subdirectories for geneid results.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<
#
#<# ODIR="$HUMUS/$NCHR/geneid/$XID" ; MkDirs $ODIR ;
#
( for c in out gff gtf2 cds prot logs tmp ;
    do {
      MkDirs $ODIR/$c ;
      } ;
    done ) || TheEnd BASHKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Running {\gnid} (without homology)}


<<STEPS(geneid std): Running geneid on raw sequences>>=
####>#########>#######################<########################################<#
#># STEP_ID   RUNNING_GENEID
#># STEP_DESC Running geneid (without homology) on Hsapiens sequences from
#>#         : Golden Path assembly.
#># STEP_PATH out
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/logs
#># STEP_CODE   --------------------------------------------------------------#<#
#<# 
GENEID="$SRC/geneid_v1.1/bin/geneid" ; # geneid v1.1
PARAM="$SRC/geneid_v1.1/param/human3iso.param" ;
EW=0 ; # add to exon weigth
#
#<# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ; 
#<# IDIR="$HUMUS/$NCHR/geneid/$XID/" ;
#<# ODIR="$HUMUS/$NCHR/geneid/$XID/out" ;
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$SEQ.fa" ;
#
CheckFile R $PARAM $ISEQ ;
#
{ ( $GENEID -v -DE $EW -P $PARAM $ISEQ \
            || TheEnd CKO ) |          \
  grep -v 'evidence' > $ODIR/$SEQ ;
  } 2>&1 | tee $EDIR/$SEQ.geneid 1>&2 ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\gnid} (without homology)}

<<STEPS(geneid std): Processing geneid output>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_OUTPUT
#># STEP_DESC Processing geneid format from geneid output (without homology).
#># STEP_PATH gff
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/geneid/$XID" ;
#
CheckFile R $IDIR/out/$SEQ ;
#
geneid_raw2GFF $IDIR $IDIR/out/$SEQ || TheEnd FUNCKO ;
#
( ls -1 $IDIR/gff/ | egrep "^$SEQ" | \
    while read n;
      do {
        cat $IDIR/gff/$n;
        };
      done | sort +3n +4n -5 - > $IDIR/gff/$SEQ ) || TheEnd BASHKO ;
#
get_geneid_genes $IDIR/gff/$SEQ > $IDIR/$SEQ.gene_list || TheEnd FUNCKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\gnid} predictions (without homology)}

<<STEPS(geneid std): Evaluating geneid results>>=
####>#########>#######################<########################################<#
#># STEP_ID   GENEID_EVALUATION
#># STEP_DESC Evaluation of geneid predictions (without homology).
#># STEP_PATH evaluation
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/geneid/$XID" ;
#
# run_evaluation #chrom program param       prog_results_dir \
#                annotation_dir           testset  lenght
run_evaluation   $SEQ   geneid  $XID \
   $ANALYSIS/geneid $DATASETS/annotation/set/pseudo VH_pseudo 47662662 \
   || TheEnd CKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Gene Prediction: {\sgp}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Re-score similarity regions: SRs to HSP-SRs.
\item Initialize any auxiliarly file (like those [[*.termini]]).
\item Run {\sgp} with homology, then evaluate results.
\item Run {\sgp} with homology plus evidences, then evaluate results.
}

<<JOBheader: SGP with HSAPgpa x MMUSpha homology>>=
####>#########>#######################<########################################<#
#># JOB_ID    SGP_HSAPgpa_MMUSpha_TBX
#># JOB_DESC  Running "SGP" on unmasked H.sapiens UCSC Golden Path 
#>#        :  assembly sequences, using TBLASTX homology results as
#>#        :  homology evidences once they have been projected into SRs.
#># JOB_PATH  sgp
#># JOB_XID   20020225
#># JOB_FILE  ${LIBSTEP}/sgp.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: SGP with HSAPgpa x MMUSpha homology>>=
<<STEPS(SGP): Initialization>>
<<STEPS(SGP HSAPgpa x MMUSpha): Auxiliarly files>>
<<STEPS(SGP HSAPgpa x MMUSpha): Running SGP>>
<<STEPS(SGP HSAPgpa x MMUSpha): Processing SGP results>>
<<STEPS(SGP HSAPgpa x MMUSpha): Evaluating SGP results>>
@ 

<<STEPS(SGP): Initialization>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_INITIALIZE
#># STEP_DESC Preparing subdirectories for sgp results.
#># STEP_PATH .
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR
#># STEP_EDIR $JOBDIR
#># STEP_CODE   --------------------------------------------------------------#<
#
#<# ODIR="$HUMUS/$NCHR/sgp/$XID" ; MkDirs $ODIR ;
#
( for c in out gff gtf2 cds prot hsp-sr logs tmp ;
    do { 
      MkDirs $ODIR/$c ;
      } ;
    done ) || TheEnd BASHKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\subsubsctn{Re-scoring SRs}

<<STEPS(SGP HSAPgpa x MMUSpha): Re-scoring SRs>>=
####>#########>#######################<########################################<#
#># STEP_ID   RE-SCORING_SRs
#># STEP_DESC Re-scoring SRs to produce HSP-SRs
#>#         : (Hsapiens GP assembly against Mmusculus Phusion assembly).
#># STEP_PATH hsp-sr
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_PATH}>/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_XID}>/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{PROJECTING_HSPs}{STEP_PATH}>
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/$<JOB{HSAPgpa_MMUSpha_WUTBLASTX}{JOB_PATH}>/$XID/sr" ;
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/hsp-sr" ;
#
CheckFile R $IDIR/$SEQ.gff ;
$BIN/getHSPSR.pl $SEQ < $IDIR/$SEQ.gff \
                      > $ODIR/$SEQ.gff 2> $EDIR/$SEQ.report || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item ...
}

\subsubsctn{Preparing auxiliarly files}

<<STEPS(SGP HSAPgpa x MMUSpha): Auxiliarly files>>=
####>#########>#######################<########################################<#
#># STEP_ID   AUX_FILES
#># STEP_DESC Preparing auxiliarly files: CHR.termini
#># STEP_PATH tmp
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR .
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/tmp" ;
#<# LEN="$HUMUS/$NCHR/annotation/$HSAPID/length" ;
LEN="$CHRDIR/$<JOB{HSAP_GP_ANNOTATION}{JOB_PATH}>/$<JOB{HSAP_GP_ANNOTATION}{JOB_XID}>/length" ;
#
CheckFile R $LEN ;
#
perl -e '
  use strict;
  my $chr = shift @ARGV;
  my %SEQlen;
  my $seqln = shift @ARGV;
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  print STDOUT join("\t", $chr, qw/ force cap  -2  0 . + 0 / )."\n";
  print STDOUT join("\t", $chr, qw/ force poly /,
                        ($SEQlen{$chr} - 1) x 2, qw/ . + 0/ )."\n";
' $SEQ $LEN > $ODIR/$SEQ.termini || TheEnd PERLKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item ...
}

\subsubsctn{Running {\sgp} ({\gnid} with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Running SGP>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_HSAPgpa_MMUSpha
#># STEP_DESC Running geneid on Hsapiens sequences from Golden Path assembly
#>#         : with homology evidences taken from Mmusculus Phusion assembly.
#># STEP_PATH out
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/logs
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# 
#
GENEID="$SRC/geneid_v1.1-sgp/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SRC/geneid_v1.1-sgp/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
#<# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ; 
#<# IDIR="$HUMUS/$NCHR/sgp/$XID/" ;
#<# ODIR="$HUMUS/$NCHR/sgp/$XID/out" ;
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$SEQ.fa" ;
#
HOMOLOGY="$HUMUS/$NCHR/sgp/$XID/hsp-sr/$SEQ.gff" ;
if [ -f "$HOMOLOGY" ] ;
  then
    echo "### Using homology data from: $HOMOLOGY" 1>&2 ;
    HOMOLOGY_PAR="-S $HOMOLOGY" ;
  else
    echo "### Homology file NOT found: $HOMOLOGY" 1>&2 ;
    HOMOLOGY_PAR="" ;
  fi ;
#
TERMINI="$IDIR/tmp/$SEQ.termini" ;
if [ -f "$TERMINI" ] ;
  then
    echo "### Using termini file: $TERMINI" 1>&2 ;
    TERMINI_PAR="$TERMINI" ;
  else
    TERMINI_PAR="" ;
  fi ;
#
CheckFile R $PARAM $ISEQ ;
#
{ ( $GENEID -v -DE $EW -P $PARAM             \
            $HOMOLOGY_PAR $TERMINI_PAR $ISEQ \
            || TheEnd CKO ) |                \
  grep -v 'evidence' > $ODIR/$SEQ ;
  } 2>&1 | tee $EDIR/$SEQ.geneid 1>&2 ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\sgp} (with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Processing SGP results>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_OUTPUT
#># STEP_DESC Processing geneid format from sgp output (with homology).
#># STEP_PATH gff
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/sgp/$XID" ;
#
CheckFile R $IDIR/out/$SEQ ;
#
geneid_raw2GFF $IDIR $IDIR/out/$SEQ || TheEnd FUNCKO ;
#
( ls -1 $IDIR/gff/ | egrep "^$SEQ" | \
    while read n;
      do {
        cat $IDIR/gff/$n;
        };
      done | sort +3n +4n -5 - > $IDIR/gff/$SEQ ) || TheEnd BASHKO ;
#
get_geneid_genes $IDIR/gff/$SEQ > $IDIR/$SEQ.gene_list || TheEnd FUNCKO ;
#
#># END_OF_STEP --------------------------------------------------------------#<#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\sgp} predictions (with homology)}

<<STEPS(SGP HSAPgpa x MMUSpha): Evaluating SGP results>>=
####>#########>#######################<########################################<#
#># STEP_ID   SGP_EVALUATION
#># STEP_DESC Evaluation of SGP predictions (geneid with homology).
#># STEP_PATH evaluation
#># STEP_XID  $<JOB{.}{JOB_XID}>
#># STEP_IDIR $HUMUS/$NCHR/$<JOB{.}{JOB_PATH}>/$XID
#># STEP_ODIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_EDIR $JOBDIR/$<STEP{.}{.}{STEP_PATH}>
#># STEP_CODE   --------------------------------------------------------------#<#
#
#<# IDIR="$HUMUS/$NCHR/sgp/$XID" ;
#
#
#># END_OF_STEP --------------------------------------------------------------#<#
@

\chklst{
\item ...
}

\subsubsctn{Running {\sgp} with homology and evidences}

<<SGP: >>=
#
#  Running geneid with homology + evidences
#
SGP2="/projects/sgp/src/geneid_v1.1-sgp" ;
     # binaries, scripts and params in SGP2
GENEID="$SGP2/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SGP2/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ;
IDIR="$HUMUS/$NCHR/sgp/$XID/" ;
# ODIR="$HUMUS/$NCHR/sgp/$XID/out" ;
HOMOLOGY="$HUMUS/$NCHR/sgp/$XID/hsp-sr/$SEQ.gff" ;
EVIDENCES="/$SEQ.gff" ;
#
{ $GENEID -v -D -E $EW -P $PARAM -S $HOMOLOGY \
        -R $EVIDENCES $ISEQ > $IDIR/out/$SEQ ;
  } 2> $IDIR/logs/$SEQ ;
#  } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Masking gene-predictions along masked sequences}

<<Global: >>=
#
#
# HUMUS="$BASE/H.sapiens" -> .project_VARS
#
CHRLIST="22" ;
#
for n in $CHRLIST;
  do {
       chrdir="$HUMUS/chr$n" ;
       MkDirs $chrdir ;
       MkDirs $chrdir/tblastx+ $chrdir/sgp+ ;
     };
  done ;
#
CHRNUM="22" ; # length -> 47748585
CHR="chr$CHRNUM" ;
XID="20020212";
#
@

<<>>=
# bash
# CLEAR, RESET, CONCEALED,
# BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE,
# BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, 
# ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE 
#
function show_masked {
    perl -npe '
        use Term::ANSIColor;
        s/^(>.*?)(\s+.*)$/color("bold red").$1.color("reset").$2/oe;
        # masked
        s/(N+)/color("green").$1.color("reset")/oge;
        s/(n+)/color("yellow").$1.color("reset")/oge;
        # starts
        s/(ATG)/color("black on_green").$1.color("reset")/oge; # forward
        s/(CAT)/color("white on_green").$1.color("reset")/oge; # reverse
        # stops
        s/(TAA|TAG|TGA)/color("black on_red").$1.color("reset")/oge; # forward
        s/(TTA|CTA|TCA)/color("white on_red").$1.color("reset")/oge; # reverse
    ' "$@" | more
}
#
@ 

\subsctn{Masking cds on Pankaj masked sequence fragments}

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
    \item Mask CDSs predicted by {\sgp} on the sequence fragmetns already masked by Pankaj.
   \end{itemize}
  \end{minipage}
% } % fbox
\end{center}

<<>>=
perl -e '
  use strict;
  my ($base,$ipath,$opath,$gnlst,@files,
      %offset,%cds,%genes,$n,$totgns,$totcds,$tgenes,$tcds);
  my $chr = shift @ARGV;
  $base = "/projects/H.sapiens";
  $ipath = "$base/.ftp/PankajAgarwal/20020123.seq-masked";
  $opath = "$base/.ftp/PankajAgarwal/20020208.seq-masked+genes-masked";
  my $gff = "$base/$chr/sgp/20020122/gff/$chr";
  # $gnlst = "$base/$chr/sgp/20020122/out.gene_list";
  # getting input filenames
  opendir(NA,$ipath);
  @files = grep { /^$chr/ } readdir(NA);
  closedir(NA);
  print STDERR "## Found ".scalar(@files)." input files for $chr...\n";
  # get sequence starting coord offset
  foreach my $fl (@files) {
      $fl =~ /_(\d+)_\d+$/o && ($offset{$1} = $fl);
  };
 #
  # reading gene coords
  # open(GF,"< $gnlst");
  # $n = 0;
  # while (<GF>) {
  #     my @l;
  #     next if /^#/o;
  #     next if /^\s*$/o;
  #     chomp;
  #     @l = split /\s+/og, $_, 5;
  #     $genes{$n++} = [ @l[1,2],"$l[0]$l[3]" ];
  # };
  # close(GF);
  # $tgenes = $n;
  # print STDERR "## Found $tgenes genes to mask on $chr...\n";
 #
  # reading from GFF
  open(GFF,"< $gff");
  $n = 0;
  %genes = ();
  while (<GFF>) {
      my @l;
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      $cds{$n++} = [ @l[3,4],"$l[8]$l[6]" ];
      $genes{"$l[8]$l[6]"}++;
  };  
  close(GFF);
  $tgenes = scalar (keys %genes);
  $tcds   = $n;
  print STDERR "## Found $tgenes genes ($tcds cds) to mask on $chr...\n";
  # processing fastas
  $totgns = $totcds = 0;
  foreach my $fl (sort keys %offset) {
      my ($sqn,$fstg,$fcds);
      open(FI,"< $ipath/$offset{$fl}");
      open(FO,"> $opath/$offset{$fl}.cds");
      $sqn = $fl;
      $n = $fstg = $fcds = 0;
      %genes = ();
      while ($cds{$n}[1] <= $fl) { $n++; }; # if gene ends before sequence ori
      while (<FI>) {
          my (@l,$ln);
          next if /^\s*$/o;
          /^>/o && do {
              print FO $_;
              next;
          };
          chomp;
          s/\s*$//o; s/^\s*//o;
          @l = split //, uc($_);
          $ln = "";
          for (my $i = 0; $i <= $#l; $i++) {
              $sqn++;
              $ln .= ($sqn >= $cds{$n}[0] && $sqn <= $cds{$n}[1]) 
                     ? "n" : $l[$i] ;
              ($sqn == $cds{$n}[0]) && ($fcds++);
              ($sqn == $cds{$n}[1]) && ($n++, $genes{$cds{$n}[2]}++);
          }; 
          print FO "$ln\n";
      };
      close(FO);
      close(FI);
      $fstg = scalar (keys %genes);
      print STDERR "### $fstg genes ($fcds cds) were masked on \"$offset{$fl}\"...\n";
      # $totgns += $fstg;
      $totgns += $fstg;
      $totcds += $fcds;
  };
  print STDERR "### $totgns of $tgenes genes ($totcds of $tcds cds) were masked on $chr...\n";
  # counter sums are not well done... but masking is ok
' chr22 2> ./masking_cds.log ; # 2> ./masking_genes.log ;
@ 


\subsctn{Processing Pankaj {\tbx} results}

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
 \item Process {\tbx} results from Pankaj:
  \begin{itemize}
   \item Masked sequences plus {\sgp} predicted cds also masked (20020208).
   \item Mouse genome assembly from Sanger Center Phusion assembly (20011109 ???).\\[-3ex]
\begin{verbatim}
# Database:  /bioinfo/gapdb/blastdb/MusPhusion
# Title:  MusPhusion
# # of letters in database:  2,374,690,634  (Z = 3000000000)
# # of sequences in database:  431,480
# Format:  XDF-1
# Created:  5:32:13 PM EST Dec 10, 2001
# Posted:  5:32:14 PM EST Dec 10, 2001
\end{verbatim}
   \item {\tbx} was run with the following parameters:\\[-3ex]
%	   \begin{center}
%	   \begin{minipage}[c]{0.75\linewidth}
\begin{verbatim}
W=5  Z=3000000000
matrix=blosum62mod  filter=xnu+seg
nogaps  hspmax=500  topcomboN=100
B=9000  V=9000  E=0.01  E2=0.01  S2=80
warnings  cpus=4  ctxfactor=36.0
\end{verbatim}
% tail -54 ori/chr22_* | sort | uniq -c | sort +0nr | more
%	   \end{minipage}
%	   \end{center}
  \end{itemize}
\item Get HSPs $\Rightarrow$ SRs $\Rightarrow$ HSP-SRs
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}

<<Homology: >>=
#
# Unpacking TBLASTX results obtained by Pankaj
#
IDIR="$HUMUS/.ftp/PankajAgarwal/20020212.genes-masked+tbxPhusion" ;
ODIR="$HUMUS/$NCHR/tblastx+/$XID" ;
#
MkDirs $ODIR $ODIR/ori ;
#
mv -v $IDIR/${CHR}* $ODIR/ori ;
#
$BIN/sbp_checkblastout.pl $SEQ $ODIR/ori > $ODIR/ori/$SEQ.report ;
#
@ 

\subsctn{Retrieving {\tbx} results by chromosome}

<<Homology: >>=
#
# Retrieving TBLASTX results by chromosome
#
IDIR="$HUMUS/$NCHR/tblastx+/$XID/ori" ;
ODIR="$HUMUS/$NCHR/tblastx+/$XID/hsp" ;
SDIR="$HUMUS/$NCHR/annotation" ;
#
MkDirs $ODIR ;
#
$BIN/sbp_blast2gff.pl $SEQ $SDIR/$HSAPID/length $IDIR \
         > $ODIR/$SEQ.fullgff 2> $ODIR/$SEQ.report ;
#
perl -ne '/^#/o && next; /^\s+$/o && next; 
          $_ =~ s/;\s+Strand//o; 
          $_ =~ s/;\s+Frame//o; 
          $_ =~ s/;\s+E_value.*$//o;
          print STDOUT $_;' $ODIR/$SEQ.fullgff | \
          sort +3n -6 +6 -7 - > $ODIR/$SEQ.gff ;
#
@ 

\subsubsctn{Merging HSPs from first {\tbx} run and the new ones}

<<Homology: >>=
#
# Merging TBLASTX results 
PXID="20020122" ; # XID of the tblastx run we want to merge (default PXID==XID)
IDIR="$HUMUS/$NCHR/tblastx/$PXID/hsp" ;
ODIR="$HUMUS/$NCHR/tblastx+/$XID/hsp" ;
#
cat $IDIR/$SEQ.gff $ODIR/$SEQ.gff |  \
          sort +3n -6 +6 -7 - > $ODIR/$SEQ.merged.gff ;
#
@ 

\subsubsctn{Projecting HSPs into SRs}

<<Homology: >>=
#
# Projecting HSPs into SRs
#
IDIR="$HUMUS/$NCHR/tblastx+/$XID/hsp" ;
ODIR="$HUMUS/$NCHR/tblastx+/$XID/sr" ;
#
MkDirs $ODIR ;
#
BLAST2GFF="/projects/bin/blast2gff";
$BLAST2GFF -g $IDIR/$SEQ.gff > $ODIR/$SEQ.gff ;
$BLAST2GFF -g $IDIR/$SEQ.merged.gff > $ODIR/$SEQ.merged.gff ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $SEQ $ODIR/$SEQ.gff > $ODIR/$SEQ.report ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $SEQ $ODIR/$SEQ.merged.gff > $ODIR/$SEQ.merged.report ;
#
@

\subsctn{Gene Prediction: {\sgp}} %%%%%%%%%%%%%%%%%%%%%%

<<SGP: >>=
#
# Initialization
# 
ODIR="$HUMUS/$NCHR/sgp+/$XID" ;
#
MkDirs $ODIR ;
for c in hsp-sr out gff gtf2 cds prot logs tmp ;
    do { MkDirs $ODIR/$c ; } ; done ;
#
@

\subsubsctn{Re-scoring SRs}

<<SGP: >>=
#
# Re-scoring SRs to produce HSP-SRs
#
IDIR="$HUMUS/$NCHR/tblastx+/$XID/sr" ;
ODIR="$HUMUS/$NCHR/sgp+/$XID/hsp-sr" ;
#
$BIN/getHSPSR.pl $SEQ < $IDIR/$SEQ.merged.gff \
                      > $ODIR/$SEQ.gff 2> $ODIR/$SEQ.report ;
#
@

\subsubsctn{Preparing auxiliarly files}

<<SGP: >>=
#
# Preparing auxiliarly files: CHR.termini
#
ODIR="$HUMUS/$NCHR/sgp+/$XID/tmp" ;
SDIR="$HUMUS/$NCHR/annotation/$HSAPID" ;
#
perl -e '
  use strict;
  my $chr = shift @ARGV;
  my %SEQlen;
  my $seqln = shift @ARGV;
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  print STDOUT join("\t", $chr, qw/ force cap  -2  0 . + 0 / )."\n";
  print STDOUT join("\t", $chr, qw/ force poly /,
                        ($SEQlen{$chr} - 1) x 2, qw/ . + 0/ )."\n";
' $SEQ $SDIR/length > $ODIR/$SEQ.termini ;
#
@

\subsubsctn{Running {\sgp} ({\gnid} with homology)}

<<SGP: >>=
#
# Running geneid with homology
#
SGP2="/projects/sgp/src/geneid_v1.1-sgp" ;
     # binaries, scripts and params in SGP2
GENEID="$SGP2/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SGP2/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$SEQ.fa.masked" ; 
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$SEQ.fa" ;
IDIR="$HUMUS/$NCHR/sgp+/$XID/" ;
# ODIR="$HUMUS/$NCHR/sgp/$XID/out" ;
HOMOLOGY="$HUMUS/$NCHR/sgp+/$XID/hsp-sr/$SEQ.gff" ;
#
# {
  { $GENEID -v -DE $EW -P $PARAM -S $HOMOLOGY \
        -R $IDIR/tmp/$SEQ.termini $ISEQ | grep -v evidence \
        > $IDIR/out/$SEQ ;
  } 2> $IDIR/logs/$SEQ ;
#   } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@ 

\subsubsctn{Processing output for {\sgp} (with homology)}

<<SGP: >>=
#
# Processing geneid format from sgp output (with homology)
#
IDIR="$HUMUS/$NCHR/sgp+/$XID" ;
#
geneid_raw2GFF $IDIR $IDIR/out/$SEQ ;
#
ls -1 $IDIR/gff/ | egrep "^$SEQ" | \
  while read n;
    do {
         cat $IDIR/gff/$n;
       };
    done | sort +3n +4n -5 - > $IDIR/gff/$SEQ ;
#
get_geneid_genes $IDIR/gff/$SEQ > $IDIR/out.gene_list ;
#
@

\subsubsctn{Evaluation of {\sgp} predictions (with homology)}

<<SGP: >>=
#
# Evaluation of SGP predictions (with homology)
#
IDIR="$HUMUS/$NCHR/sgp+/$XID" ;
#
#
@

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Visualizing results}

<<JOBheader: Visualizing Results with Apollo>>=
####>#########>#######################<########################################<#
#># JOB_ID    APOLLO_VIEWER
#># JOB_DESC  Preparing all the files required to show the results on the Apollo
#>#        :  genomic annotations browser. Apollo is a collaborative project 
#>#        :  between the Berkeley Drosophila Genome Project (www.bdgp.org) and 
#>#        :  Ensembl (www.ensembl.org). 
#>#        :  URL: http://www.ensembl.org/apollo/
#># JOB_PATH  apollo
#># JOB_XID   20020225
#># JOB_FILE  ${LIBSTEP}/apollo.job
#># END_OF_JOB ##################################################################
@ 

<<JOBS: Visualizing Results with Apollo>>=
<<STEPS(Apollo Browser): >>
@ 

\subsctn{Visualizing annotations with {\apo}}

\subsubsctn{Preparing GFF files for {\apo}}

<<STEPS(Apollo Browser): >>=
@ 
<<Visualizing: >>=
#
IDIR="$HUMUS/$NCHR" ;
ODIR="$IDIR/apollo" ;
#
MkDirs $ODIR $ODIR/$XID ;
#
ODIR="$ODIR/$XID" ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $6=1; 
          print $1,$2,$3,$4,$5,$6,$7,$8,$9;
      }
     ' $IDIR/annotation/$HSAPID/gaps/${CHR}.gff \
     > $ODIR/${CHR}_gaps.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          print $1,$2,$3,$4,$5,$6,$7,$8,$9;
      }
     ' $IDIR/annotation/$HSAPID/repeats/${CHR}.gff \
     > $ODIR/${CHR}_repeats.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $3="exon"; $6=1; print $0;
      }
     ' $IDIR/annotation/$HSAPID/refseq/${CHR}.gff \
     > $ODIR/${CHR}_refseq.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $3="exon";
          $6=1;
          gsub(/ENST0+/,"ENST",$9);
          print $0;
      }
     ' $IDIR/annotation/$HSAPID/ensembl/${CHR}.gff \
     > $ODIR/${CHR}_ensembl.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $3="exon"; $6=1; print $0;
      }
     ' $IDIR/annotation/$HSAPID/genscan/${CHR}.gff \
     > $ODIR/${CHR}_genscan.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $2="geneid";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/geneid/$XID/gff/${CHR} \
     > $ODIR/${CHR}_geneid.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $2="homology";
          $3="hsp-sr";
          $8=".";
          print $0;
      }
     ' $IDIR/sgp/20020122/hsp-sr/${CHR}.gff \
     > $ODIR/${CHR}_hsp-sr.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $2="sgp";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/sgp/20020122/gff/${CHR} \
     > $ODIR/${CHR}_sgp.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $2="homology+";
          $3="hsp-sr"; 
          $8=".";
          print $0;
      }
     ' $IDIR/sgp+/20020212/hsp-sr/${CHR}.gff \
     > $ODIR/${CHR}_hsp-sr+.gff ;
#
gawk 'BEGIN{OFS="\t"}
      $1 !~ /^\#|^[ \t]*$/ {
          $2="sgp+";
          $3="exon"; 
          gsub(/chr.*_/,"",$9);
          print $0;
      }
     ' $IDIR/sgp+/20020212/gff/${CHR} \
     > $ODIR/${CHR}_sgp+.gff ;
#
cat $ODIR/${CHR}_gaps.gff    \
    $ODIR/${CHR}_repeats.gff \
    $ODIR/${CHR}_refseq.gff  \
    $ODIR/${CHR}_ensembl.gff \
    $ODIR/${CHR}_genscan.gff \
    $ODIR/${CHR}_geneid.gff  \
    $ODIR/${CHR}_hsp-sr.gff  \
    $ODIR/${CHR}_sgp.gff     \
    $ODIR/${CHR}_hsp-sr+.gff \
    $ODIR/${CHR}_sgp+.gff    \
  > $ODIR/all_${CHR}.gff
#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{Auxiliarly Perl Scripts}

\subsctn{Annotation phase}

\subsubsctn{Scripts: retrieving sequence names and nucleotide composition}

<<tangling: perl scripts>>=
echo "# --> \$BIN/getfastadesc.pl" 1>&2 ;
notangle -R"getfastadesc.pl" $WORK/$nwfile.nw | cpif $BIN/getfastadesc.pl ;
perl -c $BIN/getfastadesc.pl ;
is_exec $BIN/getfastadesc.pl ;
@ 

<<getfastadesc.pl>>=
<<PERL shebang>>
# getfastadesc.pl
#
# USAGE:
#   getfastadesc.pl chr_list.file fasta_files.dir > chr_seqs.list
#
# [chr_seqs.list] -> chr_id seq_id length date_file description
#
use strict;
#
use global;
#
# VARS
$PROG = 'getfastadesc.pl';
$PRGVER = '0.9alpha';
my ($chrlistfile,$ipath) = @ARGV;
$ipath =~ s%/$%%o;
my (@files,%seqs,@order);
@@files = ();
%seqs = ();
@@order = ();
#
# MAIN
&program_started($PROG);

&load_chr_tbl();
&get_file_names();
&parse_fasta_seqs();
&output_results();

&program_finished($PROG);
exit(0);

#
# SUBS
sub load_chr_tbl() {
    open(CHR,"< $chrlistfile");
    while (<CHR>) {
        my $chr;
        next if /^#/o;
        next if /^\s*$/o;
        chomp;
        s/^\s+//o;
        s/\s+$//o;
        ($chr,undef) = split /\s+/og, $_, 2;
        push @order, $chr;
        @{ $seqs{$chr} } = ();
    }; # while 
    close(CHR);
} # load_chr_tbl

sub get_file_names() {
    opendir(FA, $ipath);
    @files = grep { /\.fa$/ } readdir(FA);
    closedir(FA);
} # get_file_names

# 
# we are going to assume that input filenames
# have the following "chr"$chr"(.*).fa" (so we can assign
# "automagically" which sequence correspond to each chromosome)
# without having to set a table with the files corresponding to each chromosome
#
sub parse_fasta_seqs() {
    foreach my $fl (@files) {
        my ($thechr,$modtime,$ct,$cc,$go,@lengths);
        ($thechr) = uc($fl) =~ /^CHR([\d]+|[XY]|NA|UL)/o;
        $fl = "$ipath/$fl";
        open(FAF,"< $fl") || do {
            print STDERR "### Cannot open file \"$fl\" for chr \"$thechr\"...\n";
            next;
        };
        print STDERR "### Working on chr \"$thechr\" file: \"$fl\"\n";
        $modtime = &get_fh_mod_date(\*FAF);
        $ct = 0;
        $cc = ".";
        $go = $F;
        @lengths = ();
        while (<FAF>) {
            my ($id,$desc);
            next if /^\s*$/o;
            chomp;
            m/^>/o && do {
                $go = $T;
                print STDERR "X";
                &add_lengths_to_hash(\@lengths,\@{ $seqs{$thechr} });
                ($id,$desc) = split /\s+/og, $_, 2;
                $id =~ s/^>//o;
                defined($desc) || ($desc = ".");
                push @{ $seqs{$thechr} }, [ $id, undef, $modtime, $desc ];
                next;
            };
            $go && do { &add_to_seq_length($_,\@lengths); };
        } continue {
            $ct++;
            ($ct%10 == 0) && (print STDERR "$cc");
            ($ct%1000 == 0) && (print STDERR " [$ct]\n");
        }; # while <FAF>
        ($ct%1000 != 0) && (print STDERR " [$ct]\n");
        &add_lengths_to_hash(\@lengths,\@{ $seqs{$thechr} });
        close(FAF);
    }; # foreach $fl
} # parse_fasta_seqs
#  print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
#             (sprintf("%12s %12s %8s %8s %10s  %s\n",
#                      "begin","end","#seqs","#errors","rand","file"));

sub get_fh_mod_date() {
    my $fh = shift;
    my ($year,$month,$day,$hour,$min,$sec);
    ($year,$month,$day,$hour,$min,$sec) = 
            (localtime((stat $fh)[9]))[5,4,3,2,1,0];
    # stat ->  [8] is access date,
    #          [9] is modif date and
    #         [10] is inode change date
    return sprintf("%04d%02d%02d%02d%02d%02d",
                   $year + 1900,$month + 1,$day,$hour,$min,$sec);
} # get_fh_mod_date

sub add_lengths_to_hash() {
    my ($ref,$hsh) = @_;
    (scalar(@{$ref}) == 7) && do {
        my $s = $ref->[1] + $ref->[2] + $ref->[3] + $ref->[4];
        $hsh->[$#{$hsh}][1] = ($s > 0) ? $ref->[0] : 0;
        $hsh->[$#{$hsh}][3] = sprintf("A:%d T:%d G:%d C:%d N:%d ?:%d Desc: ",
                                      @{$ref}[1..6]).$hsh->[$#{$hsh}][3];
        @{$ref} = ();
    };
} # add_lengths_to_hash

sub add_to_seq_length() {
    my ($l,$a,$t,$g,$c,$n,$x) = (0..6);
    my ($str,$ary) = @_;
    (scalar(@{$ary}) == 7) || do { @{$ary} = (0) x 7; };
    $str = uc($str);
    $str =~ s/^\s+//o;
    $str =~ s/\s+$//o;
	$ary->[$l] += length($str);
    $ary->[$a] += scalar($str =~ s/A//og);
    $ary->[$t] += scalar($str =~ s/T//og);
    $ary->[$g] += scalar($str =~ s/G//og);
    $ary->[$c] += scalar($str =~ s/C//og);
    $ary->[$n] += scalar($str =~ s/N//og);
    $ary->[$x] += length($str) > 0 ? length($str) : 0;
} # add_to_seq_length
   
sub output_results() {
    foreach my $cs (@order) {
        defined($seqs{$cs}) || do {
            print STDERR "## No sequences found for chromosome $cs !!!\n";
            next;
        };
        scalar(@{ $seqs{$cs} }) > 1 && do {
            @{ $seqs{$cs} } = map { $_->[1] }
                              sort { $a->[0] cmp $b->[0] } # ascending alpha sort
                              map { [ $_->[0], $_ ] } @{ $seqs{$cs} };
        };
        foreach my $sq (@{ $seqs{$cs} }) {
            scalar(@{ $sq }) != 4 && do { 
                # why must be only 4 elements there? -> see &add_lengths_to_hash
                print STDERR "## Chromosome $cs: ".
                             "Sequence $sq->[0] data set incomplete !!!\n";
                next;
            };
            (defined($sq->[2]) && $sq->[2] > 0) || do {
                print STDERR "## Chromosome $cs: ".
                             "Sequence $sq->[0] has zero length !!!\n";
                next;
            };
            print STDOUT "$cs @{$sq}\n";
        }; # foreach $sq
    }; # foreach $cs
} # output_results
@

<<HIDE: >>=
use db_Hsapiens;
#
################## MAIN
&open_DB();
&output_results();
&close_DB();
################## SUBS
sub output_results() {
    my ($ctbl,$cscode,@coflds,@cqflds,$stbl,@sfld,@soflds,@sqflds);
    ($ctbl,$stbl) = qw( tb_chromosome tb_sequence );
    @sfld = qw( 0 2 );
    @coflds = qw( code );
    @cqflds = qw( id );    
    @soflds = qw( id chr length version descr );
    foreach my $cs (@order) {
        defined($seqs{$cs}) || do {
            print STDERR "# No sequences found for chromosome $cs !!!";
            next;
        };
        scalar(@{ $seqs{$cs} }) > 1 && do {
            @{ $seqs{$cs} } = map { $_->[1] }
                              sort { $a->[0] cmp $b->[0] } # ascending alpha sort
                              map { [ $_->[0], $_ ] } @{ $seqs{$cs} };
        };
        foreach my $sq (@{ $seqs{$cs} }) {
            print STDOUT "$cs @{$sq}\n";
        }; # foreach $sq
        $isDBon && do {
            ($cscode) = &get_row_fields($ctbl, \@coflds, \@cqflds, [ $cs ]);
            foreach my $sq (@{ $seqs{$cs} }) {
                @sqflds = ( $sq->[0], $cscode, @{$sq}[1..3] );
                &put_row_fields($stbl, \@sfld, \@soflds, \@sqflds);
                print STDERR "$cs($cscode) @{$sq}[0,1,3]\n";
            }; # foreach $sq
        }; # $isDBon
    }; # foreach $cs
} # output_results
@ 

\subsubsctn{Scripts: Processing Golden Path annotation}

<<tangling: perl scripts>>=
echo "# --> \$BIN/gp2gff.pl" 1>&2 ;
notangle -R"gp2gff.pl" $WORK/$nwfile.nw | cpif $BIN/gp2gff.pl ;
perl -c $BIN/gp2gff.pl ;
is_exec $BIN/gp2gff.pl ;
@ 
<<gp2gff.pl>>=
<<PERL shebang>>
# Transforms the goldenpath format to gff file
#   retrieving gene(mrna)/utr/cds coordinates.
#
# USAGE: gp2gff.pl "chrname" "source" goldenpath_file > stdout
#
<<PERL strict pragma + info>>
my $PROG = 'gp2gff.pl';
my $PRGVER = '0.9alpha';
#
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;

my ($overlap,$exon_ori_fix,$exon_end_fix) = (0,0,0);
$SIG{__WARN__} = sub {
                       print STDERR "### UNKNOWN COMMAND-LINE OPTION: $_[0]\n";
                     };
GetOptions(
           'no-overlap'        => \$overlap,
           'exonori-nuclfix=i' => \$exon_ori_fix,
           'exonend-nuclfix=i' => \$exon_end_fix,
           ) || do {
               print STDERR "### ERROR when PARSING ARGUMENTS\n";
               exit(1);
           };
$SIG{__WARN__} = 'DEFAULT';

my ($seqname,$source,$ifile) = @ARGV;
my $c = 0;
my @exary;
my %laste = ();

open(GPFILE,"< $ifile");
while (<GPFILE>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    $c++ if &process_gene($_);
};
close(GPFILE);
print STDERR "### $c genes for $seqname were found in \"$ifile\".\n";
exit(0);

sub process_gene() {
    my $rec = shift;
    my $maxrec = 10; # refseq record structure
    my ($gene,$seq,$strand,$mrna_ori,$mrna_end,
        $cds_ori,$cds_end,$exons_num,$exons_ori,$exons_end) = (0..($maxrec - 1));
    my (@l,@o,@e,$frame,$cdso,$cdse);
    @l = split /\s+/og, $rec;
    ((scalar(@l) >= $maxrec) && ($l[$seq] eq $seqname)) || return 0;
    @o = split /,/og, $l[$exons_ori];
    @e = split /,/og, $l[$exons_end];
    # fixing displacement at exon coordinates (also at mrna and cds levels)
    $exon_ori_fix == 0 || do {
         $l[$mrna_ori] += $exon_ori_fix;
         $l[$cds_ori]  += $exon_ori_fix;
         @o = map { $_ += $exon_ori_fix } @o;
    };
    $exon_end_fix == 0 || do {
         $l[$mrna_end] += $exon_end_fix;
         $l[$cds_end]  += $exon_end_fix;
         @e = map { $_ += $exon_end_fix } @e;
    };
    #
    ($cdso,$cdse) = @l[$cds_ori,$cds_end];
    # checking if gene overlaps previous one...
    #   (we assume they are sorted by acceptor)
    $overlap && do {
        defined($laste{$l[$strand]}) && do {
            ($laste{$l[$strand]} > $cdso) && return 0;
		};
        $laste{$l[$strand]} = $cdse;
    }; # $overlap
    #
    &prt_gene(@l[$mrna_ori,$mrna_end,$strand,$gene,$exons_num]);
    @exary = ();
    $frame = 0;
    for (my $j = 0; $j < $l[$exons_num]; $j++) {
        my ($ori,$end,$p);
        $p = ($l[$strand] eq '-') ? ($l[$exons_num] - ($j + 1)) : $j;
        ($ori,$end) = ($o[$p],$e[$p]);
        ($end < $cdso || $ori > $cdse) && do {
            &prt_utr($ori,$end,@l[$strand,$gene]);
            next;
        };
        ($ori < $cdso  && $end <= $cdse) && do {
            &prt_utr($ori,($cdso - 1),@l[$strand,$gene]);
            $frame = &prt_exon($cdso,$end,$frame,@l[$strand,$gene],$cdso,$cdse);
            &swap_items(0) if ($l[$strand] eq '-');
            next;
        };
        ($ori >= $cdso && $end > $cdse) && do {
            $frame = &prt_exon($ori,$cdse,$frame,@l[$strand,$gene],$cdso,$cdse);
            &prt_utr(($cdse + 1),$end,@l[$strand,$gene]);
            &swap_items(0) if ($l[$strand] eq '-');
            next;
        };
        ($ori < $cdso  && $end > $cdse) && do {
            &prt_utr($ori,($cdso - 1),@l[$strand,$gene]);
            $frame = &prt_exon($cdso,$cdse,$frame,@l[$strand,$gene],$cdso,$cdse);
            &prt_utr(($cdse + 1),$end,@l[$strand,$gene]);
            &swap_items(1) if ($l[$strand] eq '-');
            next;
        };
        $frame = &prt_exon($ori,$end,$frame,@l[$strand,$gene],$cdso,$cdse);
    };
    ($l[$strand] eq '-') && (@exary = reverse @exary);
    print STDOUT join('',@exary); # each line already has its own linefeed
    return 1;
} # process_gene
# GFF: seqname source feat start end score strand frame group
sub prt_gene() {
    my @data = @_;
    print STDOUT "# Gene: $data[3]   Strand: $data[2]   Exons: $data[4]\n";
    print STDOUT join("\t",$seqname,$source,"mrna",@data[0,1],
                      ".",$data[2],".",$data[3])."\n";
} # prt_gene
sub prt_utr() {
    my @data = @_;
    push @exary, join("\t",$seqname,$source,"utr",@data[0,1],
                      ".",$data[2],".",$data[3])."\n";
} # prt_utr
sub prt_exon() {
    my ($eo,$ee,$frm,$str,$grp,$co,$ce) = @_;
    my $feat;
#     my ($myfrm,$feat);
    # remainder = ((exon_end - exon_ori + 1) + frame) mod 3;
    # nextframe = (3 - ((exon_end - exon_ori + 1) + frame) mod 3) mod3;
#   $myfrm = ($str eq '-') # exon frame is set to remainder for - strand
#            ? ( (($ee - $eo + 1) + $frm) % 3 )
#            : $frm;
    $feat = &get_feat($eo,$ee,$str,$co,$ce);
#   $feat =~ /Single/io && ($myfrm = 0); # single frame hack (specially for -)
    push @exary, join("\t",$seqname,$source,$feat,$eo,$ee,
                      ".",$str,$frm,$grp)."\n";
#                       ".",$str,$myfrm,$grp)."\n";
    return ( (3 - (($ee - $eo + 1) + $frm) % 3 ) % 3 ); # return nextframe
} # prt_exon
# gene structure GFF-feature names
sub get_feat() {
    my ($eo,$ee,$str,$co,$ce) = @_;
    my ($fts,$fto,$fti,$fte);
    ($fts,$fto,$fti,$fte) = ("Single","First","Internal","Terminal");
    $str eq "-" && do {
        ($fto,$fte) = ($fte,$fto);
    };
    ($eo == $co && $ee == $ce) && return $fts;
    ($eo == $co) && return $fto;
    ($ee == $ce) && return $fte;
    return $fti;
} # get_feat
sub swap_items() {
     shift || do {
         ($exary[$#exary],$exary[$#exary-1]) =
             ($exary[$#exary-1],$exary[$#exary]);
         return;
     };
     ($exary[$#exary],$exary[$#exary-1],$exary[$#exary-2]) =
         ($exary[$#exary-2],$exary[$#exary-1],$exary[$#exary]);
     return;
} # swap_items
@ 


\subsctn{Homology search phase}

\subsubsctn{Scripts: Verifying SBP {\tbx} output for chromosome fragments}

<<tangling: perl scripts>>=
echo "# --> \$BIN/sbp-checkblastout.pl" 1>&2 ;
notangle -R"sbp-checkblastout.pl" $WORK/$nwfile.nw | \
     cpif $BIN/sbp_checkblastout.pl ;
perl -c $BIN/sbp_checkblastout.pl ;
is_exec $BIN/sbp_checkblastout.pl ;
@ 
<<sbp-checkblastout.pl>>=
<<PERL shebang>>
# Parsing tblastx files from SBP to check blast output
#   contents for each fragment of the broken chromosomic sequence
#
# USAGE: sbp_checkblastout.pl "chrname" input_dir > stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'sbp_checkblastout.pl';
my $PRGVER = '0.9alpha';
#
my $chr = shift @ARGV;
my $path = shift @ARGV;
my @files = ();
my ($c,$e,$z);
opendir(TBX, $path);
@files = map { [ $_ ,
                 /^.*_(\d+)_(\d+)(?:\..*)?$/o,
                 (/^.*_(\D+)_.*$/o || "-"),
               ] } 
         grep { /^[^\.]/ } readdir(TBX);
closedir(TBX);
@files = map { $_->[1] }
         sort { $a->[0] <=> $b->[0] }
         map { [ $_[0], $_ ] } @files;
print STDOUT "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
             (sprintf("%12s %12s %8s %8s %10s  %s\n",
                      "begin","end","#seqs","#errors","rand","file"));
$z = 0;
foreach my $fl (@files) {
    ($c,$e) = (0,0);
    my $fname = "$path/$fl->[0]";
    print STDERR "# Working on $fname\n";
    open(TBXFL,"< $fname");
    while (<TBXFL>) {
        /^>/o   && ($c++,next);
        /EXIT/o && ($e++);
    }; # while
    $c == 0 && ($z++);
    close(TBXFL);
    printf STDOUT "  %12s %12s %8s %8s %10s  %s\n",
           ($fl->[1] + 1),($fl->[1] + $fl->[2]),$c,$e,$fl->[3],$fl->[0];
}; # foreach
print STDOUT "# $chr ran into ".(scalar @files).
             " fragments, $z of which having NO HSPs.\n";
#
exit(0);
@ 

\subsubsctn{Scripts: Parsing SBP {\tbx} output to GFF}

<<tangling: perl scripts>>=
echo "# --> \$BIN/sbp-blast2gff.pl" 1>&2 ;
notangle -R"sbp-blast2gff.pl" $WORK/$nwfile.nw | \
     cpif $BIN/sbp_blast2gff.pl ;
perl -c $BIN/sbp_blast2gff.pl ;
is_exec $BIN/sbp_blast2gff.pl ;
@ 
<<sbp-blast2gff.pl>>=
<<PERL shebang>>
# Parsing tblastx files from SBP to get HSPs in GFF format
#
# USAGE: sbp_blast2gff.pl "chrname" length_file input_dir \
#                          > gff_output  2> stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'sbp_blast2gff.pl';
my $PRGVER = '0.9alpha';
#
my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
my @frame = ( 3, 1, 2 ); # frm 0 -> blastfrm 3
                         # frm 1 -> blastfrm 1
                         # frm 2 -> blastfrm 2
my %SEQlen;
my ($chr, $seqln, $input) = @ARGV;
my @files = ();
my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
          "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                     "all" => 8,            "sum" => [ (0) x 9 ] );
my ($cf,$cr);
open(FRGLEN, "< $seqln");
while (<FRGLEN>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    my @l = split /\s+/og, $_;
    $SEQlen{$l[0]} = $l[1];
}; # while
close(FRGLEN);
open(FRGLST, "< $input/$chr.report");
while (<FRGLST>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    s/^\s*//o;
    my @l = split /\s+/og, $_;
    ($l[2] > 0) && do {
        push @files, [ $l[$#l], ($l[0] - 1) ];
    };
    # skipping fragments without HSPs
}; # while
close(FRGLST);
#
print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
             (sprintf("%8s %8s %8s  %s\n","#hsp","#hsp(+)","#hsp(-)","file"));
system("/bin/rm","$input.parseblast.err");
foreach my $fl (@files) {
    $cf = $cr = 0;
    my ($fname,$offset) = ("$input/$fl->[0]", $fl->[1]);
    open(TBXFL, "parseblast --fullgff --full-scores --comments".
                " --verbose --bit-score $fname 2>> $input.parseblast.err |");
    my @l;
    while (<TBXFL>) {
        next if /^\s*$/o;
        /^#/o && do {
            print STDOUT $_;
            next;
        };
        chomp;
        @l = split /\s+/og, $_, 9;
        $l[$seq] = $chr;
        $l[$src] = "tblastx";
        $l[$ftr] = "hsp";
        $l[$ori] += $offset;
        $l[$end] += $offset;
        if ($l[$str] eq "-") {
            $l[$frm] = $frame[(($SEQlen{$chr} - $l[$end] + 1) % 3)];
            $cr++;
        } else {
            $l[$frm] = $frame[($l[$ori] % 3)];
            $cf++;
        };
        print STDOUT join("\t", @l)."\n";
        $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
    }; # while
    close(TBXFL);
    printf STDERR "  %8s %8s %8s  %s\n",($cf+$cr),$cf,$cr,$fl->[0];
}; # foreach
$g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
$g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
$g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
             $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
   printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
}; # foreach
#
exit(0);
@


\subsctn{Gene-prediction phase}

\subsubsctn{Scripts: Running evaluation for gene-prediction}

<<tangling: perl scripts>>=
echo "# --> \$BIN/runeval.pl" 1>&2 ;
notangle -R"runeval.pl" $WORK/$nwfile.nw | cpif $BIN/runeval.pl ;
perl -c $BIN/runeval.pl ;
is_exec $BIN/runeval.pl ;
@ 
<<runeval.pl>>=
<<PERL shebang>>
# Running evaluation by chromosome.
#
# USAGE: runeval.pl chromosome 
#
<<PERL strict pragma + info>>
my $PROG = 'runeval.pl';
my $PRGVER = '0.9alpha';
#

#
## MAIN
open(FSHRT,"> ");
open(FLONG,"> ");

&print_file_header(\*FSHRT,);
&print_file_header(\*FLONG,);
exit(0);

#
## SUBS
sub print_file_header() {
    my ($fh,$prog,$chr,$run,$outname,$gver) = ;
    print $fh <<"EOTXT";
### 
### EVALUATION of $prog RESULTS on CHR $chr ($run)
###
### $outname
###
### $USER - $DATE 
###
### $gver
###
EOTXT
} # print_file_header
@ 


\subsubsctn{Scripts: Re-scoring SRs}

<<tangling: perl scripts>>=
echo "# --> \$BIN/getHSPSR.pl" 1>&2 ;
notangle -R"getHSPSR.pl" $WORK/$nwfile.nw | cpif $BIN/getHSPSR.pl ;
perl -c $BIN/getHSPSR.pl ;
is_exec $BIN/getHSPSR.pl ;
@ 
<<getHSPSR.pl>>=
<<PERL shebang>>
# Re-scoring SRs to produce HSP-SRs for SGP homology.
#
# USAGE: getHSPSR.pl "chrname" < SR_file.gff > HSP-SR_file.gff > stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'getHSPSR.pl';
my $PRGVER = '0.9alpha';
#
my $chr = shift;
my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
          "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                     "all" => 8,            "sum" => [ (0) x 9 ] );
my $HSPminLEN = 1; # $ori + $HSPminLEN - 1 ==> minimum length is 1 nucleotide
my $S_CUTOFF = 26;
my $SCF = 0; # substract to tblastx scores S_CUTOFF - SCF
my $DSC = $S_CUTOFF - $SCF;
my $SHSP  = 0;    # SHSP=6 # shrink hsp by $SHSP
my $WTBX  = 0.19; # weigth of tblastx score
my $WTBXF = 0.30; # weigth of tblastx score
my $WTBXI = 0.20; # weigth of tblastx score
my $WTBXT = 0.30; # weigth of tblastx score
while (<STDIN>) {
    my @l;
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    @l = split /\s+/og, $_;
    next unless $l[$sco] > $S_CUTOFF;
    $l[$sco] = ($l[$sco] - $DSC) * $WTBX;
    $l[$ori] += $SHSP;
    $l[$end] -= $SHSP;
    next if $l[$end] < ($l[$ori] + $HSPminLEN - 1);
    print STDOUT join("\t",@l)."\n";
    $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
}; # while
$g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
$g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
$g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
             $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
   printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
}; # foreach
#
exit(0);
@


\sctn{Job Control System}

\subsctn{Interacting with MySQL} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsctn{Building database}

<<MySQL: Creating Database Report>>=
#
# Creating mysql DataBase (root)
#
shell>  mysql -u root -p   (u:user, p:passwd)
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 772 to server version: 3.23.36

Type 'help;' or '\h' for help. Type '\c' to clear the buffer

mysql> CREATE DATABASE db_Hsapiens;
Query OK, 1 row affected (0.06 sec)

mysql> show databases;
+-----------------+
| Database        |
+-----------------+
| admin_db        |
| db_Hsapiens     |
| db_SPtest       |
| ensembl_generic |
| horde           |
| mysql           |
| ontology_db     |
| popper          |
| smartie         |
| test            |
| texbiblio_db    |
| web_db          |
+-----------------+
12 rows in set (0.01 sec)

mysql> GRANT ALL on db_Hsapiens.* TO genome@localhost IDENTIFIED BY "xxxx" ;
Query OK, 0 rows affected (0.10 sec)
#
# Accessing to mysql DataBase (user)
#
shell>  mysql -u genome -p db_Hsapiens 
#
@ 


<<MySQL: Setting up Tables>>=
/* Setting working database */
USE db_Hsapiens ;

/* Sequence related tables */
CREATE TABLE tb_chromosome
(
  id          CHAR(2)      NOT NULL,
  code        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  version     VARCHAR(50),
  descr       TEXT
);
CREATE TABLE tb_sequence
(
  id          VARCHAR(25)  NOT NULL,
  code        INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  chr         INT UNSIGNED NOT NULL,
  length      INT UNSIGNED NOT NULL,
  version     CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  composition VARCHAR(150) NOT NULL,
  descr       TEXT
);

/* Process related tables */
CREATE TABLE tb_job
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT,
  path    VARCHAR(100) NOT NULL,
  jxid    VARCHAR(25)  NOT NULL
);
CREATE TABLE tb_step
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  job     INT UNSIGNED NOT NULL,
  version VARCHAR(40), /* which program and its version is being run */
  descr   TEXT,
  path    VARCHAR(100) NOT NULL,
  sxid    VARCHAR(25)  NOT NULL,
  idir    VARCHAR(200) NOT NULL,
  odir    VARCHAR(200) NOT NULL,
  edir    VARCHAR(200) NOT NULL,
  script  TEXT         NOT NULL
);

/* Execution related tables */
CREATE TABLE tb_status
(
  id      VARCHAR(10)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT,
  color   VARCHAR(30)  NOT NULL
);
CREATE TABLE tb_exec
(
  status       INT UNSIGNED NOT NULL,
  chr_seq      INT UNSIGNED NOT NULL,
  job_step     INT UNSIGNED NOT NULL,
  exec_pid     INT UNSIGNED NOT NULL,
  exec_date    CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  host         VARCHAR(15)  NOT NULL,
  user         VARCHAR(15)  NOT NULL,
  stdout       TEXT,
  stderr       TEXT
);

/* EOF */
@
<<tangling: mySQL scripts>>=
#
# MySQL tables description for db_Hsapiens
echo "# --> \$MySQLPAR/db_Hsapiens.sql" 1>&2 ;
notangle -R'MySQL: Setting up Tables' $WORK/$nwfile.nw | \
    cpif $MySQLPAR/db_Hsapiens.sql;
#
@ 
 

\subsubsctn{Initialitation files}

<<MySQL: initialization file for Perl scripts>>=
#
# db_Hsapiens_in.pm
#
#   setting user access to db_Hsapiens mySQL database
#
<<Version Control Id Tag>>
#
package db_Hsapiens_in;
use strict;
use vars qw( @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION
             $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw( $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );
# @@EXPORT_OK = qw( );
# %EXPORT_TAGS = ();

$mySQL_db   = 'db_Hsapiens';
$mySQL_host = 'monstre1.imim.es';
$mySQL_user = 'genome';
$mySQL_pswd = ''; # use vi to introduce the pswd for this user!!!

1;
@
<<BASH Variables: Perl>>=
#
PERL5OPT="-I$BBIN/libperl" ;
export PERL5OPT;
#
@ 


This file was tangled the first time, since then it is under version control and edited by hand...

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files
# 
# notangle -R'MySQL: initialization file for Perl scripts' \
#     $WORK/$nwfile.nw | cpif $MySQLPAR/db_Hsapiens_in.pm ;
# chmod 660 $MySQLPAR/db_Hsapiens_in.pm ;
#
@ 

The following files will serve to load rows on different tables with [[admin_db_Hsapiens.pm]].

<<MySQL: adm file - chrs>>=
#
# chrs.tbl
#
#   chromosome table
#
<<Version Control Id Tag>>
#
# Setting global version (must start with '#># ')
#
#># Golden Path 20010806
#
# Record Format:
#   <chr_id> <version> <description>
# where:
#       <version> == . --> global version
#   <description> == . --> undef
 1 . .
 2 . .
 3 . .
 4 . .
 5 . .
 6 . .
 7 . .
 8 . .
 9 . .
10 . .
11 . .
12 . .
13 . .
14 . .
15 . .
16 . .
17 . .
18 . .
19 . .
20 . .
21 . .
22 . .
 X . .
 Y . .
#
NA . .
UL . .
#
@  %%% MySQL: adm file - chrs

<<MySQL: adm file - seqs>>=
#
# seqs.tbl
#
#   sequences for each chromosome
#
<<Version Control Id Tag>>
#
# Record Format:
#   <chr_id> <sequence_id> <length> <file_modifying_date> <description>
# where:
#   <file_modifying_date> is in YYYYMMDDhhmmss format
#   <description> == . --> undef
# 
@  %%% MySQL: adm file - seqs

<<MySQL: adm file - jobs>>=
#
# jobs.tbl
#
#   main process id table
#
<<Version Control Id Tag>>
#
<<JOBheader: Sequence Analysis>>
<<JOBheader: HsapGPa x MmusPHa WUTBLASTX>>
<<JOBheader: Running GENEID standard>>
<<JOBheader: SGP with HSAPgpa x MMUSpha homology>>
<<JOBheader: Visualizing Results with Apollo>>
@  %%% MySQL: adm file - jobs

<<MySQL: adm file - steps>>=
#
# steps.tbl
#
#   process step (executable scripts) id table
#
<<Version Control Id Tag>>
#
@  %%% MySQL: adm file - steps
 
<<MySQL: adm file - status>>=
#
# status.tbl
#
#   program execution status table
#
<<Version Control Id Tag>>
#
# Record format:
#   <process_ID> <color_name>
#   <description-line_0>
#    ...
#   <description-line_n>
#   // # this is the new record separator
#
TODO     lightblue
Process was not started yet... 
//
RUNNING  steelblue
Current step is being executed at this moment...
//
DONE     seagreen
This step has finished without errors...
//
CHECK    orange
Process reported warnings...
Verify its execution log but following steps are going to be run...
//
KILLED   salmon
Program execution was interrupted by user... 
Following steps are being skipped...
//
DIED     red
An error ocurred when running this step...
Please, check error report that has been produced...
//
SKIPPED  gold
This step has been skipped due to a unfinished previous step... 
Please, check previous steps of the current job...
//
N/A      lightgrey
Job status is Not Available at this moment...
Just wait to the next update round to see if connection problem persist...
//
@  %%% MySQL: adm file - status

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files 
for n in chrs jobs steps status;
  do { 
       echo "# --> \$MySQLPAR/$n.tbl" 1>&2 ;
       notangle -R"MySQL: adm file - $n" \
           $WORK/$nwfile.nw | cpif $MySQLPAR/$n.tbl ;
     }; 
  done;
# seqs.tbl is produced by initialization script on sequence analysis section
echo "# --> \$MySQLPAR/seqs.tbl" 1>&2 ;
{ notangle -R'MySQL: adm file - seqs' $WORK/$nwfile.nw ; 
  cat $HUMUS/seqid_list ; } | cpif $MySQLPAR/seqs.tbl ;
#
@ 


\subsubsctn{Perl interface to mySQL database}

<<tangling: mySQL perl scripts>>=
# 
# mySQL perl scripts: interacting with mySQL DB
echo "# --> \$LIBPERL/db_Hsapiens.pm" 1>&2 ;
notangle -R'MySQL: perl DB interface' \
    $WORK/$nwfile.nw | cpif $LIBPERL/db_Hsapiens.pm ;
perl -c $LIBPERL/db_Hsapiens.pm ;
is_exec $LIBPERL/db_Hsapiens.pm ;
#
@ 

<<MySQL: perl DB interface>>=
<<PERL shebang>>
# db_Hsapiens.pm
#
package db_Hsapiens;
use strict;
<<Use Modules - Dumper>>
#
use vars qw(
           @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION 
           $mySQL_db $mySQL_host $mySQL_user $MySQLPAR $dbh $sth
           $isDBon %status %chrs %jobs @seqs @steps
           );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw(
    $mySQL_db $mySQL_host $mySQL_user $isDBon
    &open_DB &close_DB $MySQLPAR $dbh $sth
    &get_tbl_hash &get_row_fields &put_row_fields
    &get_DB_codes %status %chrs %jobs @seqs @steps
    &del_all_from_tbl
  );
@@EXPORT_OK = qw(
    &connection_details &load_to_tbl_ifdef
    &list_tables &show_tbl_desc &count_tbl_elements
  );
%EXPORT_TAGS = (
    AdminFunc => [ qw( &connection_details &load_to_tbl_ifdef
                       &list_tables &show_tbl_desc &count_tbl_elements
                       ) ],
    );

# use lib "$LIBPERL";
use db_Hsapiens_in;
my $dsn = "DBI:mysql:database=$mySQL_db;host=$mySQL_host";
#
use DBI;
#
use global;
#
$MySQLPAR = $ENV{MySQLPAR} || do {
        print STDERR $Messages{'ENVNOTDEF'}->("MySQLPAR");
        exit(1);
    };

$global::_verbose{RAW} = $T;
$global::_verbose{DBCMD} = $F;
$global::_verbose{DB} = $F;
$isDBon = $F;
$global::CmdLineOpts{'DB-Verbose'} = sub {
        $_verbose{DB} = $T;
        $_verbose{DBCMD} = $T;
    };
$global::CmdLineOpts{'DB-verbose'} = sub { $_verbose{DB} = $T };
$global::CmdLineOpts{'DBsc|DB-showcommands'} = sub { $_verbose{DBCMD} = $T };

sub connection_details() {
    print STDERR $Messages{'DBIHEADER'}->("DBI: Available DBD Drivers");
    print STDERR $Messages{'DBIMSG'}->(
        "",(map { "\t$_" } DBI->available_drivers),"");
    print STDERR $Messages{'DBIHEADER'}->("mySQL DataBase Connection Info:");
    print STDERR $Messages{'DBIMSG'}->("","\tDBname: $mySQL_db",
        "\t  Host: $mySQL_host","\t  User: $mySQL_user","");
} # connection_details

sub open_DB() {
    my $trace_level = shift || 0;
    print STDERR $Messages{'DBIHEADER'}->(
        "Openning mySQL connection to \'$mySQL_db\' DB...");
    DBI->trace($trace_level);
    $dbh = DBI->connect($dsn, $mySQL_user, $mySQL_pswd,
                        { RaiseError => 1, AutoCommit => 1 } );
    # put here error processing...
    print STDERR $Messages{'DBIMSG'}->(
        "","mySQL connection to \'$mySQL_db\' DB succesfully established.","");
    $isDBon = $T;
} # open_DB

sub close_DB() {
    defined($dbh) && $dbh->disconnect();
    # put here error processing...
    print STDERR $Messages{'DBIHEADER'}->(
        "mySQL connection to \'$mySQL_db\' DB has been closed.");
    $isDBon = $F;
} # close_DB

sub list_tables() {
    my @tbls;
    print STDERR $Messages{'DBIHEADER'}->(
        "Retrieving tables definition for '$mySQL_db' DB...");
    @tbls = $dbh->func('_ListTables');
    # put here error processing...
    return @tbls;
} # do_DB

sub show_tbl_desc() {
    my ($table, $fhref) = @_;
    my @strdesc = ();
    $sth = $dbh->prepare(qq{
           DESC $table /* Shows mySQL table description */
         });
    # put here error processing...
    $sth->execute;
    # put here error processing...
    push @strdesc, '|-> DESC '.$table;
    while (my @fld = $sth->fetchrow_array()) {
        # put here error processing...
        push @strdesc, sprintf("\t%-10s : %s",$fld[0],@fld[1..$#fld]);
    };
    $sth->finish;
    # put here error processing...
    print $fhref $Messages{'DBIMSG'}->("",@strdesc);
} # show_tbl_desc

sub count_tbl_elements() {
    my ($fhref) = @_;
    print $fhref $Messages{'DBIHEADER'}->(
        "Counting elements number for tables on '$mySQL_db' DB...");
    my %tbls = ();
    foreach my $t (&list_tables()) {
        my $str = qq{
            SELECT COUNT(*) FROM $t /* Counting elements for mySQL table */
            };
        print $fhref $Messages{'DBICMD'}->("$str") if $_verbose{DBCMD};
        $sth = $dbh->prepare($str);
        $sth->execute();
        $tbls{$t} = $sth->fetchrow_array();
        $sth->finish;
    }; # foreach $t
    print $fhref $Messages{'DBIMSG'}->("");
    foreach my $k (keys %tbls) {
        print $fhref $Messages{'DBIMSG'}->(
                         sprintf("---> %-15s : %s",$k,$tbls{$k}));
    }; # foreach $k
    print $fhref $Messages{'DBIMSG'}->("");
} # count_tbl_elements

sub del_all_from_tbl() {
    my $table = shift;
    my ($dsth,$dstr);
    $dstr = qq{
        DELETE FROM $table
		};
    print STDERR $Messages{'DBICMD'}->("$dstr") if $_verbose{DBCMD};
    $dsth = $dbh->prepare($dstr);
    $dsth->execute();
    $dsth->finish();
    print STDERR $Messages{'DBIMSG'}->("All rows in \"$table\" were deleted...");
} # del_all_from_tbl

sub load_to_tbl_ifdef() { # mv $field to end of args and set as an array to allow multiple fields select... ;^D
    my ($table, $fields, $aryfld, $aryrow, $delflg) = @_;
    my ($fldstr,$valstr,$filter,$ssth,$sstr,$isth,$istr);
    defined($delflg) || ($delflg = $F);
    print STDERR $Messages{'DBIHEADER'}->(
        "REBUILDING FIELDS for TABLE \"$table\"") if $_verbose{DB};
    $fldstr = "(".join(', ',@{$aryfld}).")"; 
    $valstr = "VALUES(".join(',',('?') x scalar(@{$aryfld})).")"; 
    $filter = join("\n                 AND ",
                   ( map { $aryfld->[$_].'=?' } @{ $fields } ));
    $sstr = qq{
        SELECT COUNT(*)        /* COUNT(Saryfld->[Sfield]) */
               FROM $table
               WHERE $filter   /* Saryfld->[Sfield]=Q */
		};
    $istr = qq{
        INSERT $table
               $fldstr
               $valstr /* adding new records */
        };
    &del_all_from_tbl($table) if $delflg;
    print STDERR $Messages{'DBICMD'}->("$sstr$istr") if $_verbose{DBCMD};
    $ssth = $dbh->prepare($sstr);
    $isth = $dbh->prepare($istr);
    foreach my $row (@{$aryrow}) {
        my $count;
        my @trow = (map { $row->[$_] } @{ $fields });
        $ssth->execute(@trow);
        $count = $ssth->fetchrow_array();
        ($count == 0) && do {
            print STDERR $Messages{'DBIMSG'}->(
                "\"@trow\" NOT found in \"$table\": INSERTING...");
            $isth->execute(@{$row});
            next;
		};
        print STDERR $Messages{'DBIMSG'}->(
            "\"@trow\" already defined in \"$table\": SKIPPING...");
    }; # foreach $row 
    print STDERR $Messages{'DBIMSG'}->(
        "",(scalar (@{$aryrow}))." records were checked on \"$table\"...","");
    $ssth->finish();
    $isth->finish();
} # load_to_tbl_ifdef

sub get_tbl_hash() {
    # here we assume that the first element of $aryfld is a hash key
    my ($href, $table, $aryflds, $queryflds, $queryvals) = @_;
    print STDERR $Messages{'DBIHEADER'}->(
        "RETRIEVING HASH from TABLE \"$table\"") if $_verbose{DB};
    my ($ssth,$sstr,@ary,$aryfld_len,$fldstr,$valstr);
    $aryfld_len = $#{ $aryflds };
    $fldstr = join(', ',@{ $aryflds });
    $valstr = &build_where_clause($queryflds,$queryvals);
    $sstr = qq{
        SELECT $fldstr
               FROM $table $valstr
        }; 
    print STDERR $Messages{'DBICMD'}->("$sstr") if $_verbose{DBCMD};
    $ssth = $dbh->prepare($sstr);
    $ssth->execute();
    while (@ary = $ssth->fetchrow_array()) {
        %{ $href->{$ary[0]} } = map { $aryflds->[$_] => $ary[$_]
                                      } (1..$aryfld_len);
    }; # while @ary
    print STDERR $Messages{'DBIMSG'}->(
        "",(scalar (keys %{$href}))." records were retrieved from \"$table\"...","");
    $ssth->finish();
} # get_tbl_hash
sub build_where_clause() {
    my ($queryflds, $queryvals) = @_;
    my ($valstr,$q_len);
    $valstr = "";
    ((defined($queryflds) && scalar(@{ $queryflds }) > 0) &&
     (defined($queryvals) && scalar(@{ $queryvals }) > 0)) && do {
        # ensure that both arys ($queryflds & $queryvals)
        # have same length in calling function/script, and that are paired too...
        $q_len = &min($#{ $queryflds }, $#{ $queryvals });
        for (my $i = 0; $i <= $q_len; $i++) {
           $valstr .= "$queryflds->[$i] = ".
                      ($dbh->quote($queryvals->[$i]))." \n";
	    };
        chomp($valstr);
        $valstr = join('\n               AND ', (split /\n/og, $valstr));
        $valstr = "\n               WHERE $valstr";
	};
    return $valstr;
} # build_where_clause
sub get_row_fields() {
    my ($table, $outflds, $queryflds, $queryvals) = @_;
    my ($ssth,$sstr,$fldstr,$valstr,$q_len,@out);
    $fldstr = join(', ',@{$outflds});
    print STDERR $Messages{'DBIHEADER'}->(
        "RETRIEVING \"$fldstr\" ROW(s) from TABLE \"$table\"") if $_verbose{DB};
    $valstr = &build_where_clause($queryflds,$queryvals);
    $sstr = qq{
        SELECT $fldstr
               FROM $table $valstr
		};
    print STDERR $Messages{'DBICMD'}->("$sstr") if $_verbose{DBCMD};
    $ssth = $dbh->prepare($sstr);
    $ssth->execute();
    @out = $ssth->fetchrow_array();
    $ssth->finish();
    scalar(@out) > 0 || do {
        print STDERR $Messages{'DBIMSG'}->(
            "","NONE rows were selected from \"$table\"",
               "NONE fields were retrieved...","");
        return ( undef );
    };
    print STDERR $Messages{'DBIMSG'}->(
        "",scalar(@out)." fields were retrieved from \"$table\"...","");
    return @out;
} # get_row_fields

sub get_DB_codes() {
    my (@sel_fields,@qry_fields,@qry_values);
    print STDERR $Messages{'DBIHEADER'}->(
        "LOADING MAIN TABLES into PROGRAM VARIABLES") if $_verbose{DB};
    #
    # Loading Status tables
    %status = ();
    @sel_fields =  qw( id code descr color );
    &get_tbl_hash(\%status, 'tb_status', \@sel_fields);
    print STDERR (Data::Dumper->Dump([ \%status ],
                                  [ qw( *status ) ])) if $_verbose{DEBUG};
    #
    # Loading Chromosome tables
    %chrs = ();
    @sel_fields =  qw( id code version descr );
    &get_tbl_hash(\%chrs, 'tb_chromosome', \@sel_fields);
    foreach my $key (keys %chrs) {
        %{ $chrs{$key}{seqs} } = ();
        @sel_fields = qw( id code length version composition descr );
        @qry_fields = qw( chr );
        @qry_values = ( $chrs{$key}{code} );
        &get_tbl_hash(\%{ $chrs{$key}{seqs} }, 'tb_sequence',
                      \@sel_fields, \@qry_fields, \@qry_values);        
    }; # foreach $key
    print STDERR (Data::Dumper->Dump([ \%chrs ],
                                  [ qw( *chrs ) ])) if $_verbose{DEBUG};
    #
    # Loading Job tables
    %jobs = ();
    @sel_fields =  qw( id code path jxid descr );
    &get_tbl_hash(\%jobs, 'tb_job', \@sel_fields);
    foreach my $key (keys %jobs) {
        %{ $jobs{$key}{steps} } = ();
        @sel_fields = qw( id code version descr path
                          sxid idir odir edir script );
        @qry_fields = qw( job );
        @qry_values = ( $jobs{$key}{code} );
        &get_tbl_hash(\%{ $jobs{$key}{steps} }, 'tb_step',
                      \@sel_fields, \@qry_fields, \@qry_values);        
    }; # foreach $key
    print STDERR (Data::Dumper->Dump([ \%jobs ],
                                  [ qw( *jobs ) ])) if $_verbose{DEBUG};
    #
    # Building order arrays for chromosome seqs and job steps
    &build_ordering_ary(\@seqs, \%chrs, 'code', 'seqs',  'code');
    &build_ordering_ary(\@steps, \%jobs, 'code', 'steps', 'code');
    print STDERR (Data::Dumper->Dump([ \@seqs, \@steps ],
                                  [ qw( *seqs   *steps ) ])) if $_verbose{DEBUG};
} # get_DB_codes
sub build_ordering_ary() {
    my ($arf,$hrf,$Skey,$sfeat,$skey) = @_;
    print STDERR $Messages{'DBIMSG'}->(
        "","SORTING \"$sfeat\" to build ordering array (\@$sfeat)...","");
    @{ $arf } = ();
    foreach my $key (keys %{ $hrf }) {
        my @order = ();
        foreach my $yek (keys %{ $hrf->{$key}{$sfeat} }) {
            push @order, [ $hrf->{$key}{$sfeat}{$yek}{$skey}, [ $key, $yek ] ];
        }; # foreach $key
        @order = map  { $_->[1] }
                 sort { $a->[0] <=> $b->[0] }
                 map  { [ $_->[0], $_->[1] ] } @order;
        push @{ $arf }, [ $hrf->{$key}{$Skey}, [ @order ] ]
    }; # foreach $key
    @{ $arf } = map  { @{ $_->[1] } }
                sort { $a->[0] <=> $b->[0] }
                map  { [ $_->[0], $_->[1] ] } @{ $arf };
} # build_ordering_ary
#
sub put_row_fields() {
    my ($table, $fields, $aryfld, $aryrow) = @_;
    my ($q_len,$filter,$fldstr,$valstr,$setstr,
        $usth,$ustr,$ssth,$sstr,$isth,$istr,@trow,$count);
    print STDERR $Messages{'DBIHEADER'}->(
        "UPDATING FIELDS for TABLE \"$table\"") if $_verbose{DB};
    $q_len = &min($#{ $aryfld }, $#{ $aryrow });
#    my @setstr = ();
#    for (my $i = 0; $i <= $q_len; $i++) {
#        push @setstr, $aryfld->[$i].'='.($dbh->quote($aryrow->[$i]));
#	 };
    $filter = join("\n                 AND ",
                   ( map { $aryfld->[$_].'=?' } @{ $fields } ));
    $fldstr = "(".join(', ',@{$aryfld}).")"; 
    $valstr = "VALUES(".join(',',('?') x scalar(@{ $aryfld })).")";
    $setstr = join(",\n                   ",
                   ( map { $_.'=?' } @{ $aryfld } ));
#    $setstr = join(",\n                   ",@setstr);
    $sstr = qq{
        SELECT COUNT(*)        /* COUNT(Saryfld->[Sfield]) */
               FROM $table
               WHERE $filter   /* Saryfld->[Sfield]=Q */
		};
    $istr = qq{
        INSERT $table
               $fldstr
               $valstr /* adding new records */
        };
    $ustr = qq{
        UPDATE $table
               SET $setstr
               WHERE $filter   /* Saryfld->[Sfield]=Q */
		};
    print STDERR $Messages{'DBICMD'}->("$sstr$istr$ustr") if $_verbose{DBCMD};
    $ssth = $dbh->prepare($sstr);
    @trow = (map { $aryrow->[$_] } @{ $fields });
    $ssth->execute(@trow);
    $count = $ssth->fetchrow_array();   
    $ssth->finish();
    if ($count) {
        print STDERR $Messages{'DBIMSG'}->(
            "","UPDATING fields on selected record from \"$table\"...","")
            if $_verbose{DB};
        $usth = $dbh->prepare($ustr);
        $usth->execute(@{ $aryrow },@trow);
        $usth->finish();
	} else {
        print STDERR $Messages{'DBIMSG'}->(
            "","INSERTING new field on selected record from \"$table\"...","")
            if $_verbose{DB};
        $isth = $dbh->prepare($istr);
        $isth->execute(@{ $aryrow });
        $isth->finish();
    };
} # put_row_fields

1;
@ 


\subsubsctn{Loading administrative tables}

<<tangling: mySQL perl scripts>>=
# 
# mySQL perl scripts: loading mySQL admin tables
echo "# --> \$MySQLPAR/admin_db_Hsapiens.pl" 1>&2 ;
notangle -R'MySQL: Initialize administrative tables' \
    $WORK/$nwfile.nw | cpif $MySQLPAR/admin_db_Hsapiens.pl ;
perl -c $MySQLPAR/admin_db_Hsapiens.pl ;
is_exec $MySQLPAR/admin_db_Hsapiens.pl ;
#
@ 

<<MySQL: Initialize administrative tables>>=
<<PERL shebang>>
# admin_db_Hsapiens.pl
#
use strict;
# use lib "$LIBPERL";
use db_Hsapiens qw( :DEFAULT :AdminFunc );
# $MySQLPAR/$admfiles[$i].tbl
# my @admfiles = qw/ chrs seqs jobs steps status /;
#
use global;
$PROG = 'admin_db_Hsapiens.pl';
$PRGVER = '0.9alpha';
#
my (%PARAM, %tjobs); 
$PARAM{LIBSTEP} = $ENV{LIBSTEP} || do {
        print STDERR $Messages{'ENVNOTDEF'}->("MySQLPAR");
        exit(1);
    };

#
## MAIN
&parse_cmdline();
&program_started($PROG);

&connection_details();

&open_DB();

&listing_tables();

&load_status_tbl("$MySQLPAR/status.tbl");
&load_chromosome_tbl("$MySQLPAR/chrs.tbl");
&load_sequences_tbl("$MySQLPAR/seqs.tbl");
&load_jobs_tbl("$MySQLPAR/jobs.tbl");
&del_all_from_tbl('tb_exec');

&get_DB_codes();
&count_tbl_elements(*STDERR);

&close_DB();

&program_finished($PROG);
exit(0);

#
## SUBS
sub listing_tables() {
    my @k = &list_tables();
    for (my $n=0; $n<=$#k; $n++) {
        &show_tbl_desc($k[$n], *STDERR);
    };
} # listing_tables
sub load_status_tbl() {
    my $ifile = shift;
    my @rows = ();
    open(IFILE,"< $ifile");
    local $/ = "\/\/\n";
    while (<IFILE>) {
        chomp;
        my @r = ();
        my @f = split /\n/og, $_;
        foreach my $l (@f) {
            next if $l =~ /^#/o;
            next if $l =~ /^\s*$/o;
            $l =~ s/^\s+//o;
            $l =~ s/\s+$//o;
            defined($r[0]) || do {
                ($r[0],$r[1]) = (split /\s+/o, $l, 2);
                next;
            };
            $r[2] .= "$l\n";
        };
        push @rows, [ @r ];
    };
    close(IFILE);
	my @flds = qw( id color descr );
    my ($tbl, @fld) = qw( tb_status 0 );
    &load_to_tbl_ifdef($tbl, \@fld, \@flds, \@rows, $T);
} # load_status_tbl
sub load_chromosome_tbl() {
    my $ifile = shift;
    my @rows = ();
    my $gpver = '';
    open(IFILE,"< $ifile");
    while (<IFILE>) {
        my @f;
        next if /^\s*$/o;
        /^#/o && do {
            /^#>#\s+(.*?)\s*$/o && ($gpver = $1);
            next;
        };
        chomp;
        s/^\s+//o;
        s/\s+$//o;
        @f = split /\s+/og, $_, 3;
        ($f[1] eq '.' && $gpver ne '') && ($f[1] = $gpver);
        push @rows, [ @f ];
    };
    close(IFILE);
	my @flds = qw( id version descr );
    my ($tbl, @fld) = qw( tb_chromosome 0 );
    &load_to_tbl_ifdef($tbl, \@fld, \@flds, \@rows, $T);
} # load_chromosome_tbl
sub load_sequences_tbl() {
    my $ifile = shift;
    my ($ctbl,$cscode,@coflds,@cqflds,$stbl,@sfld,@soflds,@sqflds);
    ($ctbl,$stbl) = qw( tb_chromosome tb_sequence );
    @coflds = qw( code );
    @cqflds = qw( id );    
    @sfld = qw( 0 1 );
    @soflds = qw( id chr length version composition descr );
    @sqflds = ();
    open(IFILE,"< $ifile");
    while (<IFILE>) {
        my @f;
        next if /^\s*$/o;
        next if /^#/o;
        chomp;
        s/^\s+//o;
        s/\s+$//o;
        @f = split /\s+/og, $_, 5;
        (@f[4,5]) = split /\s+Desc:\s+/o, $f[4], 2;
        ($cscode) = &get_row_fields($ctbl, \@coflds, \@cqflds, [ $f[0] ]);
        (@f[0,1]) = ($f[1],$cscode);
        push @sqflds, [ @f ];
        printf STDERR "%s(%d) %s %s %s\n",@f[0..2,4,5];
    };
    close(IFILE);
    &load_to_tbl_ifdef($stbl, \@sfld, \@soflds, \@sqflds, $T);
    # foreach my $row (@sqflds) {
    #     &put_row_fields($stbl, \@sfld, \@soflds, \@{ $row });
    # };
} # load_sequences_tbl
sub load_jobs_tbl() {
    my $ifile = shift;
    my ($jobcnt,$skipflg,%thsh,$ljob);
    open(JFILE,"< $ifile");
    $jobcnt = 0;
    %tjobs = ();
    %thsh = ();
    $ljob = '';
    $skipflg = $F;
    while (<JFILE>) {
        my ($name,$desc);
        next unless /^#>#/o;
        chomp;
        (undef,$name,$desc) = split /\s+/o, $_, 3;
        $desc =~ s/\s*$//o;
        ($name eq 'END_OF_JOB') && do {
            $skipflg || do {
                foreach my $k (keys %thsh) {
                    $tjobs{$ljob}{$k} = $thsh{$k};
                };
                &replace_link_holders(\%{ $tjobs{$ljob} },$ljob,undef,'JOB_XID');
                %{ $tjobs{$ljob}{'JOB_STEPS'} } = ();
                $tjobs{$ljob}{'JOB_FILE'} =~ s{(\$\{(.+?)\})}
                                              { defined($PARAM{$2})
                                                ? $PARAM{$2}
                                                : $1
                                                }ogex;
                &load_step_tbl($ljob,$tjobs{$ljob}{'JOB_FILE'},
                                 \%{ $tjobs{$ljob}{'JOB_STEPS'} });
            };
            %thsh = ();
            $skipflg = $F;
            next;
        };
        next if $skipflg;
        ($name eq 'JOB_ID') && do {
            $ljob = $desc;
            defined($tjobs{$ljob}) || do {
                %{ $tjobs{$ljob} } = ();
                $tjobs{$ljob}{'JOB_CNT'} = $jobcnt++;
                next;
            };
            $skipflg = $T;
            next;
        }; 
        ($name eq ':') && do {
            $thsh{'JOB_DESC'} .= " $desc";
            next;
        };
        $thsh{$name} = $desc;
    };
#    print STDOUT (Data::Dumper->Dump([ \%tjobs ],
#                                  [ qw( *tjobs ) ])) if $_verbose{DEBUG};
    close(JFILE);
    &load_job_steps_tbl(\%tjobs);
} # load_jobs_tbl
sub load_step_tbl() {
    my ($sjob,$ifile,$href) = @_;
    print STDERR ">>>>>>>>>>>>>> $ifile\n";
    my ($stpcnt,$skipflg,$codeflg,%thsh,$lstep);
    open(SFILE,"< $ifile");
    $stpcnt = 0;
    %thsh = ();
    $lstep = '';
    $skipflg = $codeflg = $F;
    while (<SFILE>) {
        my ($name,$desc,$go);
        $go = /^#>#/o ? $T : $F;
        next unless ($go || $codeflg);
        ($codeflg && !$go) && do {
            $href->{$lstep}{'STEP_CODE'} .= "$_";
            next;
        };
        chomp;
        (undef,$name,$desc) = split /\s+/o, $_, 3;
        $desc =~ s/\s*$//o;
        ($name eq 'END_OF_STEP') && do {
            $skipflg || do {
                foreach my $k (keys %thsh) {
                    $href->{$lstep}{$k} = $thsh{$k};
                };
                &replace_link_holders(\%{ $href->{$lstep} },$sjob,$lstep,
                    'STEP_XID','STEP_IDIR','STEP_ODIR','STEP_EDIR','STEP_CODE');
#                print STDERR join("\n", 
#                           ( map { '#>>> '.$_ }
#                                 ( split /\n/o, $href->{$lstep}{'STEP_CODE'} )
#                             ) )."\n".(':'x40)."\n"; 
            };
            %thsh = ();
            $skipflg = $codeflg = $F;
            next;
        };
        next if $skipflg;
        ($name eq 'STEP_ID') && do {
            $lstep = $desc;
            defined($href->{$lstep}) || do {
                %{ $href->{$lstep} } = ();
                $href->{$lstep}{'STEP_CNT'} = $stpcnt++;
                next;
            };
            $skipflg = $T;
            next;
        }; 
        ($name eq ':') && do {
            $thsh{'STEP_DESC'} .= " $desc";
            next;
        };
        ($name eq 'STEP_CODE') && do {
            $codeflg = $T;
            next;
        };
        $thsh{$name} = $desc;
    };
    close(SFILE);
} # load_step_tbl
sub replace_link_holders() {
    my ($href,$kjob,$kstp,@chk_keys) = @_;
    foreach my $k (@chk_keys) {
        $href->{$k} =~ s{\$\<(.*?){(.*?)}{(.*?)}(?:{(.*?)})?\>}
            { &get_link_vals($kjob, $kstp, $1, $2,
                             (defined($4) ? ($4, $3) : ($3, undef))); }gex;
    };
} # replace_link_holders
sub get_link_vals() {
    my ($j,$s,$v,$vj,$vv,$vs) = @_;
    my $out;
    $vj eq '.' && ($vj = $j);
    defined($vs) && do {
        $vs eq '.' && ($vs = $s);
        $out = $tjobs{$vj}{'JOB_STEPS'}{$vs}{$vv};
        print STDERR "---> $v : $out\n";
        return $out;
    };
    $out = $tjobs{$vj}{$vv};
    print STDERR "---> $v : $out\n";
    return $out;
} # get_link_vals
sub load_job_steps_tbl() {
    my $href = shift;
    my (@rows,@flds,$tbl,@fld,@oflds,@qryflds,@qryvals);
    # load jobs
    @rows = map  { $_->[1] }
            sort { $a->[0] <=> $b->[0] }
            map  { [ $href->{$_}{'JOB_CNT'},
                     [ $_, $href->{$_}{'JOB_XID'},
                           $href->{$_}{'JOB_PATH'},
                           $href->{$_}{'JOB_DESC'} ]
                   ] }
            (keys %{ $href });
	@flds = qw( id jxid path descr );
    ($tbl, @fld) = qw( tb_job 0 );
    &load_to_tbl_ifdef($tbl, \@fld, \@flds, \@rows, $T);
    # load steps
    @rows = ();
    @oflds = qw( code );
    @qryflds = qw( id );
    foreach my $k (keys %{ $href }) {
        my (@trows,$jcode,$tref);
        @qryvals = ( $k );
        ($jcode) = &get_row_fields($tbl, \@oflds, \@qryflds, \@qryvals);
        $tref = \%{ $href->{$k}{'JOB_STEPS'} };
        @trows = map  { $_->[1] }
                 sort { $a->[0] <=> $b->[0] }
                 map  { [ $tref->{$_}{'STEP_CNT'},
                          [ $_, $jcode,
                            $tref->{$_}{'STEP_XID'},
                            $tref->{$_}{'STEP_PATH'},
                            $tref->{$_}{'STEP_IDIR'},
                            $tref->{$_}{'STEP_ODIR'},
                            $tref->{$_}{'STEP_EDIR'},
                            $tref->{$_}{'STEP_DESC'},
                            $tref->{$_}{'STEP_CODE'} ]
                        ] }
                 (keys %{ $tref });
        push @rows, @trows;
    }; # foreach my $k
    @flds = qw( id job sxid path idir odir edir descr script );
    ($tbl, @fld) = qw( tb_step 0 1 );    
    &load_to_tbl_ifdef($tbl, \@fld, \@flds, \@rows, $T);
#   print STDOUT (Data::Dumper->Dump([ \@rows ],
#                                 [ qw( *rows ) ])) if $_verbose{DEBUG};
} # load_jobs_tbl
@ 


\subsctn{Step processing script: [[stepper.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl scripts>>=
# 
# mySQL perl scripts: running single/multiple jobs on single/multiple hosts
echo "# --> \$BIN/stepper.pl" 1>&2 ;
notangle -R'Step Execution Script' \
    $WORK/$nwfile.nw | cpif $BIN/stepper.pl ;
perl -c $BIN/stepper.pl ;
is_exec $BIN/stepper.pl ;
#
@ 

<<Step Execution Script>>=
<<PERL shebang>>
# stepper.pl
#
# USAGE:
#  stepper.pl [ --chr  chr_0,...,chr_c                --chr  chr_cc        ]
#             [ --seq  chr_c:seq_0,...,chr_c:seq_q    --seq  chr_c:seq_qq  ]
#             [ --job  job_0,...,job_j                --job  job_jj        ]
#             [ --step job_j:step_0,...,job_j:step_s  --step job_j:step_ss ]
#               --param <param_file> 
#               -- <jobs_file> 
#
# if no chr or seq are given then job is done for all seqs on every chr.
# if no job or step are given then all steps in all jobs are done for each seq.
# <param_file> contains all shell definitions to make child shells 
#   runnable anywhere (exported variables, shell functions, ...).
# jobs file 
use strict;
#
<<Use Modules - Dumper>>
<<stepper.pl: Use module IPC>>
#<stepper.pl: Use module POSIX>>
#
use db_Hsapiens;
#
use global;
#
$PROG = 'stepper.pl';
$PRGVER = '0.91alpha';
# $MySQLPAR/$admfiles[$i].tbl
# my @admfiles = qw/ chrs seqs jobs steps status /;
#
&init_timer(\@exectime);

#
## VARS
my ($pre_script,$post_script);
$pre_script = <<'+++EOPre+++';
<<BASH shebang>>
#
### SCRIPT HEADER
#
+++EOPre+++
$post_script = <<'+++EOPre+++';
#
### SCRIPT TRAILER
#
TheEnd OK;
+++EOPre+++

my %filter = ( 'CHR' => [], 'SEQ' => [], 'JOB' => [], 'STP' => [] );
my $paramfile = undef;
$global::CmdLineOpts{'c|chr=s'}   = \@{ $filter{CHR} };
$global::CmdLineOpts{'q|seq=s'}   = \@{ $filter{SEQ} };
$global::CmdLineOpts{'j|job=s'}   = \@{ $filter{JOB} };
$global::CmdLineOpts{'s|step=s'}  = \@{ $filter{STP} };
$global::CmdLineOpts{'p|param=s'} = \$paramfile;

if (!defined($paramfile)) {
    $paramfile = "./.project_VARS";
    (defined($ENV{WORK})) && ($paramfile = "$ENV{WORK}/.project_VARS");
};
( -e $paramfile && -r _ ) || die("No param file found");
      
<<stepper.pl: forked childs related vars>>
<<stepper.pl: global vars>>

#
## MAIN
&init_signals(); # &my_init_signals();
&parse_cmdline();
&program_started($PROG);

&get_param($paramfile);
my $stepfls = shift @ARGV;
&get_steps($stepfls);

&set_filter(\%filter);

&open_DB();
&get_DB_codes(); # sets %chrs, $chrs{}{seqs}, %jobs, $jobs{}{steps}, @seqs, @steps

&brown_dispatcher();

&close_DB();

IPC::Shareable->clean_up;
&program_finished($PROG);
exit(0);

#
## SUBS
#<stepper.pl: trapping signals>>
<<stepper.pl: subs>>
<<stepper.pl: job scheduling functions>>
@

<<stepper.pl: subs>>=
sub get_param() {
    my $ifile = shift;
    open(PFL,"< $ifile");
    while (<PFL>) {
        next if /^\s*$/o;
        $pre_script .= $_;
    }; # while PFL
    close(PFL);
} # get_param
@ 

<<stepper.pl: subs>>=
sub set_filter() {
    my $href = shift;
    foreach my $k (keys %{$href}) {
        @{ $href->{$k} } = split(/,/,join(',',@{ $href->{$k} }));
    };
    # print STDERR (Data::Dumper->Dump([ \%{$href} ],
    #                               [ qw( *{$href} ) ])) if $_verbose{DEBUG};
} # set_filter
@ 

<<stepper.pl: subs>>=
sub get_steps() {
} # get_steps
@ 


\subsubsctn{Trapping system signals}

<<HIDE: stepper.pl: Use module POSIX>>=
<<global.pm: use POSIX>>
@ 

<<HIDE: stepper.pl: trapping signals>>=
#
# Trapping signals
sub my_init_signals() {
    $SIG{HUP}  = \&trap_signals_prog;
    $SIG{ABRT} = \&trap_signals;
    $SIG{INT}  = \&trap_signals;
    $SIG{QUIT} = \&trap_signals;
    $SIG{TERM} = \&trap_signals;
    $SIG{KILL} = \&trap_signals;
    $SIG{CHLD} = \&child_reaper; # \&my_child_reaper;
    @skip_next = ($F, $F, $F);
} # my_init_signals
@ 

We require the status checking function from the POSIX module we used in [[<<global.pm: trapping signals>>]] code chunk to reap zombie child processes, removing their process execution id from [[@semaphore]]. But we must redefine the child exit signal handler function to take care of the semaphore variable.

<<HIDE: stepper.pl: trapping signals>>=
# redefining child-exit signal handler (already defined in global.pm)
sub my_child_reaper() {
    $handle->shlock();
    for (my $v = 0; $v < $maxjobs; $v++) {
        my ($spid,$cpid,$ecod);
        ($semaphore[$v][0] != 0) && do {
            $semaphore[$v][0] =~ m/^(.*?)\./o && ($spid = $1);
            $cpid = waitpid($spid, &WNOHANG);
            $ecod = $?;
            if ($cpid > 0) {
                # child died
                print $ERRFH "## $spid ## CHILD EXIT STATUS:\n".
                             "## $spid -> $ecod\n";
            };
        }; # ($semaphore[$v][0] != 0)
    }; # for 
    $handle->shunlock();
    $SIG{CHLD} = \&my_child_reaper;
} # my_child_reaper
@


\subsubsctn{Forking child processes to local/remote machines}

The [[&brown_dispatcher]] function requires a semaphore variable that controls how many childs were forked, so we can fork a new one once any of the current childs job has finished (no matter where...). We require the following package, just to have such variable shared among the running child processes.

<<stepper.pl: Use module IPC>>=
use IPC::Shareable; 
IPC::Shareable->clean_up_all;
@ 

Here, we define the main function that launches child processes through [[fork]] perl function. Those child jobs are saving a temporary bash script that will be executed locally or remotely (using [[rsh]]) via a [[system]] command.

<<stepper.pl: job scheduling functions>>=
sub brown_dispatcher() {
#    my $oldFHE = $ERRFH;
#    open(FHERR, "> $TMP/run.rpt");
#    $ERRFH = \*FHERR;
    my ($seqs_done,$seqnum,@tmpsq,$thesem);
    print $ERRFH "### MAIN $gid ### BEGIN MAIN LOOP\n";
    &show_curr_pids($gid);
    $seqs_done = 0;
    $seqnum = scalar(@seqs);
    while ($seqs_done < $seqnum) { # loop through sequences
        for ($sem = 0; $sem < $maxjobs; $sem++) {
            $semaphore[$sem] =~ m/^(.*?):/o && ($thesem = $1);
            ($thesem != 0) || do {
               next if $seqs_done == $seqnum; 
               next if (&no_host_there($hosts[$sem]));
               @tmpsq = @{ $seqs[$seqs_done] };
               &breed_crows(@tmpsq, $sem);
               @{ $pids{$pid} } = @tmpsq;
               $seqs_done++;
           }; # if job semaphore == 0 then fork child
           &do_wait();
        }; # for semaphores...
    }; # while
    while (&not_all_done()) { &do_wait(); };
    print $ERRFH "### MAIN $gid ### All Jobs ID: \n ".
                 join(" ",(sort keys %pids))."\n".
                 "### MAIN $gid ### END MAIN LOOP\n";    
#    close(FHERR);
#    $ERRFH = $oldFHE;
} # brown_dispatcher
#
sub do_wait() {
    sleep 5; # select(undef,undef,undef,1);
    &show_curr_pids($gid);
} # do_wait
sub show_curr_pids() {
    my $gd = shift;
    $handle->shlock();
    print $ERRFH "### MAIN $gd ### SEMAPHORE: ".
          (join(" ", ( map { $_ =~ m/^(.*?):/o; $1 } @semaphore )))."\n";
    $handle->shunlock();
} # show_curr_pids
sub not_all_done() {
    my $sum = 0;
    $handle->shlock();
    for (my $s = 0; $s < $maxjobs; $s++) {
        my $th;
        $semaphore[$s] =~ m/^(.*?):/o && ($th = $1);
        $sum += $th;
    }; # for semaphores...
    $handle->shunlock();
    return ($sum>0) ? $T : $F;
} # not_all_done
sub no_host_there() {
      my $host = shift;
      # print $ERRFH "### MAIN $gid ### CHECKING $host CONECTION...\n";
      ($skip_next[0]) && do {
          print $ERRFH "### MAIN $gid ### STOPPING PROGRAM: \"$host\" NOT CHECKED !!!\n";
          return $F;
      };
      ($host eq $HOST) && do { # running locally
          print $ERRFH "### MAIN $gid ### Local execution on $host...\n";
          return $F;
      };
      my $err;
      (undef,undef,$err) = 
          &check_syscall_exit(system("rsh $host.imim.es exit 0"));
      ($err == 0) && do {
          print $ERRFH "### MAIN $gid ### Connection to $host available...\n";
          return $F;
      };
      print $ERRFH "### MAIN $gid ### UNREACHEABLE \"$host\", SKIPPING HOST !!!\n";
      return $T;
} # no_host_there
sub breed_crows() {
    my ($chrseq_code,$jobstep_code,$run_at,
        $script,$scriptx,$scripto,$scripte,$script_stat,$script_err,
        $pre_job,$chldpid,$chpid,$syscmd,$syserr);
    my ($thechr,$theseq,$pos) = @_;
    return if $pid = fork(); # return to parent, follows child code
    local *TMPFH;
    $chrseq_code = $chrs{$thechr}{seqs}{$theseq}{code};
    $chpid = "$$";
    $chldpid = "$chpid.$gid";
    if ($skip_next[0]) {
        print $ERRFH "## $chldpid ## Skipping ALL JOBS".
                     " for sequence \"$theseq($thechr)\".\n";
        &init_DB_exec_tbl($hosts[$pos],$chldpid,$chrseq_code,
                          $status{'SKIPPED'}{'code'},
                          $exit_codes{'NOTRUN'}{SHORT},\@steps);
        exit(0); # exiting child process if skipping
    } else {
        print $ERRFH "## $chldpid ## Running child process jobs".
                     " on sequence \"$theseq\" (chr $thechr).\n";
        &init_DB_exec_tbl($hosts[$pos],$chldpid,$chrseq_code,
                          $status{'TODO'}{'code'},
                          "Job [$chldpid] has been scheduled...",\@steps);
    };
    foreach my $jobary (@steps) {
        my ($stdin,$stdout,$stderr);
        my ($thejob,$thestep) = @{ $jobary };
        $jobstep_code = $jobs{$thejob}{steps}{$thestep}{code};
        # &mod_semaphore($pos,$chldpid,$chrseq_code,$jobstep_code);
        $handle->shlock();
        $semaphore[$pos] = "$chpid\:$chrseq_code\:$jobstep_code";
        $handle->shunlock();
        ($stdin,$stdout,$stderr) = ( $jobs{$thejob}{steps}{$thestep}{idir},
                                     $jobs{$thejob}{steps}{$thestep}{odir},
                                     $jobs{$thejob}{steps}{$thestep}{edir} );
        if ($skip_next[0]) {
            $script_stat = $status{'SKIPPED'}{'code'};
            $script_err = $exit_codes{'NOTRUN'}{SHORT};
            print $ERRFH "## $chldpid ## Skipping job \"$thestep($thejob)\"".
                         " for sequence \"$theseq($thechr)\".\n";
        } else {
            $script_stat = $status{'RUNNING'}{'code'};
            $handle->shlock();
            &update_DB_exec_tbl($script_stat,$chrseq_code,$jobstep_code,
                                $hosts[$pos],$chldpid,
                                undef,"Job [$chldpid] is runnning...");
            $handle->shunlock();
            # names were shortened to avoid problem with file creation
            $script  = "$TMP/$thechr.$theseq.$jobstep_code.$chldpid";
            ($scriptx,$scripto,$scripte) =
                ("$script.x","$script.o","$script.e");
            ###
            $pre_job = <<"+++EOPre+++";
#
### CURRENT PROCESS DEFS
#
# Make these two vars independent from script
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806";
#
CHR="$thechr" ;
NCHR="chr\$CHR" ;
SEQ="$theseq" ;
JOB="$thejob" ;
JOBP="$jobs{$thejob}{path}" ;
STEP="$thestep" ;
XID="$jobs{$thejob}{steps}{$thestep}{sxid}" ;
MPID="$chldpid" ;
CHRDIR="\$HUMUS/\$NCHR" ;
CJBDIR="\$CHRDIR/\$JOBP" ;
JOBDIR="\$CJBDIR/\$XID" ;
IDIR="$stdin" ;
ODIR="$stdout" ;
EDIR="$stderr" ;
PSRF="$scriptx" ; # Process Status Reporter File
#
export CHR NCHR SEQ JOB JOBP STEP XID MPID      \\
       CHRDIR CJBDIR JOBDIR IDIR ODIR EDIR PSRF ;
#
# Making directories
MkDirs \$CHRDIR \$CJBDIR \$JOBDIR \$ODIR ;
[ "\$EDIR" != "\$ODIR" ] && MkDirs \$EDIR ;
#
### SCRIPT CODE
#
+++EOPre+++
            ###
            if ($hosts[$pos] ne $HOST) {
                $run_at = <<"+++EOSCRIPT+++";
# Run script remotely
#
# cat $script ;
{ rsh $hosts[$pos].imim.es \\
      $ENV{BIN}/remotelauncher.pl "$script > $scripto 2> $scripte" ;
  } || exit 10 ;
     # exit_code==10 if RSH fails
#
+++EOSCRIPT+++
            } else {
                $run_at = <<"+++EOSCRIPT+++";
# Run script locally
#
# cat $script ;
$script > $scripto 2> $scripte ;
#
+++EOSCRIPT+++
            }; # if ($hosts[$pos] ne $HOST)
            ###
            print $ERRFH "## $chldpid ## Running job \"$thestep($thejob)\"".
                         " on sequence \"$theseq($thechr)\".\n".
                         "## $chldpid ## Writing script to \"$script\"...\n";
            $handle->shlock();
            open(TMPFH,"> $script");
            print TMPFH $pre_script.$pre_job.
                      $jobs{$thejob}{steps}{$thestep}{script}.$post_script;
            close(TMPFH);
            $handle->shunlock();
            ###
            $syscmd = <<"+++EOFRSH+++";
## LAUNCH JOB ##
/bin/chmod a+x $script ;
# Process Status Reporter File
export PSRF="$scriptx" ;
# Run Job
$run_at
# Returning exit status from executed script
c=0;
while [ \\( ! -e "\$PSRF" \\) -a \$c -lt 900 ] ; # 900sec == 15min
  do {
    sleep 2 ;
    c=`expr \$c + 2` ;
    } ;
  done ;
exit \`cat \$PSRF 2> /dev/null || echo 3\` ;
                               # exit_code==3 if cannot open PSRF (UNAVAILABLE)
## END OF JOB ##
+++EOFRSH+++
            print $ERRFH $syscmd if $_verbose{DEBUG};
            $syserr = system($syscmd);
            ###
            # print $ERRFH $mesg{};
            ($script_stat,$script_err) =
                 &report_crow_status($syserr,$thejob,$theseq,$chldpid);
        }; # else if !$skip_next[0]
        $handle->shlock();
        &update_DB_exec_tbl($script_stat,$chrseq_code,$jobstep_code,
                            $hosts[$pos],$chldpid,$stdout,$script_err);
        $handle->shunlock();
        # removing scripts once they have been run
        print $ERRFH "## $chldpid ## Removing scripts from tmp dir !!!\n";
        system("cat $scripte >> $TMP/.err/$thechr.$theseq.err");
        system("cat $scripto >> $TMP/.out/$thechr.$theseq.out");
        unlink($script,$scriptx,$scripto,$scripte);
    }; # foreach job
    # &mod_semaphore($pos,0,0,0);
    $handle->shlock();
    $semaphore[$pos] = '0:0:0';
    $handle->shunlock();
    #
    print $ERRFH "## $chldpid ## Child process is exiting now !!!\n";
    exit(0); # child process exits when done
} # breed_crows
sub mod_semaphore() {
    my ($p,$v,$sq,$jb) = @_;
    $handle->shlock();
    $semaphore[$p] = "$v\:$sq\:$jb";
    $handle->shunlock();
} # mod_semaphore
sub report_crow_status() {
    my ($err,$job,$seq,$ppid) = @_;
    my ($okflg,$emsg,$whatever,$whatelse);
    ($okflg,$emsg,$err) = &check_syscall_exit($err);
    $err = $exit_codes{'CODES'}{$err};
    print $ERRFH "## $ppid ## ERROR MSG: ".
                 ($exit_codes{$err}{MSG}->($ppid,$job,$seq,$emsg))."\n";
    $whatelse = $exit_codes{$err}{SHORT};
    $whatever = ($okflg) ? $status{'DONE'}{'code'}
                         : $status{'CHECK'}{'code'};
    return ($whatever, $whatelse);
} # report_crow_status
sub init_DB_exec_tbl() { # to db_Hsapiens.pm ?
    my ($thehost,$thepid,$seqcode,$statcode,$statstr,$stepary) = @_;
    $handle->shlock();
    foreach my $stpary (@{ $stepary }) {
        my ($j,$s) = @{ $stpary };
        &update_DB_exec_tbl($statcode,$seqcode,$jobs{$j}{steps}{$s}{code},
                            $thehost,$thepid,undef,$statstr);
    }; # foreach $stpary
    $handle->shunlock();
} # init_DB_exec_tbl
sub update_DB_exec_tbl() { # to db_Hsapiens.pm
    my ($stat,$cseq,$cstep,$chost,$ppid,$sout,$serr) = @_;
    my (@sel_fields,@data_fields,$tbl,@fld);
    defined($sout) || ($sout = 'NULL');
    defined($serr) || ($serr = 'NULL');
    if ($stat != $status{'SKIPPED'}{'code'} && $skip_next[0]) {
        # if (!defined($skip_next[1])) { # $skip_next[1] is always set as $T/$F
        #    $stat = $status{'DIED'}{'code'}; # Something happened to child
        # } else {
        if ($skip_next[1]) {
            $stat = $status{'DIED'}{'code'};
            $serr  = $exit_codes{'PROGDOWN'}{SHORT};
        } else {
            $stat = $status{'KILLED'}{'code'};
            $serr  = $exit_codes{'USERHALT'}{SHORT};
        };
        # };
    };
    ($tbl, @fld) = qw( tb_exec 0 1 ); # we do not tae care of execution PID (2)
    @sel_fields =  qw( chr_seq job_step exec_pid
                       status exec_date host user stdout stderr );
    @data_fields = ( $cseq, $cstep, $ppid,
                     $stat, $CDATE, $chost, $USER, "$sout", "$serr" );
    &put_row_fields($tbl, \@fld, \@sel_fields, \@data_fields);
} # update_DB_exec_tbl
@ 

<<stepper.pl: forked childs related vars>>=
my (%hosts_list,@hosts,$hc,$gid,%pids,$pid,$maxjobs,
    $handle,$sem,@semaphore,$seqs_done);
%pids = ();
$hc = 0;
%hosts_list = (
  # hostname => [ order   numjobs  bash.p            pbsflg ]
  # aleph    => [ $hc++,  1,       '/bin/bash',      $T     ],
    monstre1 => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    monstre2 => [ $hc++,  2,       '/usr/bin/bash',  $F     ],
    monstre3 => [ $hc++,  2,       '/usr/bin/bash',  $F     ],
  # monstre4 => [ $hc++,  2,       '/bin/bash',      $F     ],
    ik12     => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    ik13     => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    i8       => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    i10      => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    i26      => [ $hc++,  1,       '/usr/bin/bash',  $F     ],
    );
@@hosts = map  { shift @$_; @$_ }
         sort { $a->[0] <=> $b->[0] }
         map  { [ $hosts_list{$_}[0], ($_) x $hosts_list{$_}[1] ] }
         keys %hosts_list;
$maxjobs = scalar(@hosts);
$gid = $$;
$handle = tie @semaphore, 'IPC::Shareable', undef, { destroy => 1 };
@@semaphore = ( '0:0:0' ) x $maxjobs;
@

<<remotelauncher.pl>>=
<<PERL shebang>>
# remotelauncher.pl
#
# USAGE: remotelauncher.pl <filename>
#
use strict;
<<Global Vars - Counter>>
my (@param,$err,$secs_incr);
#
@@param = split /\s+/o, "@ARGV";
#
print STDERR "###--WAITING--> $param[0] \n";
($n,$c,$_cntN,$secs_incr) = (0,".",60,2);
while (!(-x $param[0])) {
    sleep $secs_incr;
    $n += $secs_incr;
    &counter($n,$c);
    exit(127) if $n >= 900; # exit_code==127 if command not found (NOCMD) 
};
&counter_end($n,$c);
#
print STDERR "###--RUNNING--> @param \n";
$err = system("@param");
exit($err);
#
sub fill_left() { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
<<Common PERL subs - Counter>>
@ 

<<tangling: perl scripts>>=
# 
echo "# --> \$BIN/remotelauncher.pl" 1>&2 ;
notangle -R'remotelauncher.pl' \
    $WORK/$nwfile.nw | cpif $BIN/remotelauncher.pl ;
perl -c $BIN/remotelauncher.pl ;
is_exec $BIN/remotelauncher.pl ;
#
@

<<Checking IPC system stack>>=
c=0;
while [ 1 ];
  do {
    clear ;
    perl -e '
      ($s,$m,$h,undef,undef,undef,undef,undef,undef) = localtime(shift @ARGV);
      print "#" x 50, sprintf(" \%02d:\%02d:\%02d\n",$h-1,$m,$s);
      ' $c;
    ipcs;
    sleep 15;
    c=`expr $c + 15`;
    };
  done;
@ 

\subsubsctn{Sequence and jobs related vars}

<<stepper.pl: global vars>>=
my $TMP = $ENV{TMP};
@ 

<<HIDE: stepper.pl: global vars>>=
my ($BASE,@seqs,@jobs,%jobscode);
$BASE = "/home/ug/jabril/development/projects/sgp/humus/tests/childs";
@@seqs = qw( seq1  seq2  seq3  seq4  seq5  seq6  seq7  seq8  seq9  seq10
            seq11 seq12 seq13 seq14 seq15 seq16 seq17 seq18 seq19 seq20 );
@@jobs = qw( job1 job2 job3 job4 job5 );
%jobscode = ();
@ 

\subsubsctn{Checking current values of [[tb_exec]]}

<<tangling: perl scripts>>=
# 
echo "# --> \$BIN/viewstatustbl.pl" 1>&2 ;
notangle -R'viewstatustbl.pl' \
    $WORK/$nwfile.nw | cpif $BIN/viewstatustbl.pl ;
perl -c $BIN/viewstatustbl.pl ;
is_exec $BIN/viewstatustbl.pl ;
#
@ 

<<viewstatustbl.pl>>=
<<PERL shebang>>
# viewstatustbl.pl
#
use strict;
use db_Hsapiens;
use global qw( :ExecReport );
$PROG = 'viewstatustbl.pl';
$PRGVER = '0.9beta';
#
# MAIN
&program_started($PROG);
&open_DB();
&view_exec_tbl();
&close_DB();
&program_finished($PROG);
exit(0);
#
# SUBS
sub view_exec_tbl() {
    my $txt;
    $sth = $dbh->prepare(qq{
      SELECT  c.id AS CHR,
              s.id AS SEQNAME,
              m.id AS JOB,
              j.id AS STEP,
              t.id AS STATUS,
              x.host AS HOST,
              x.exec_pid AS PID,
              x.stderr AS ERRORMSG
         FROM tb_chromosome AS c,
              tb_sequence AS s,
              tb_job AS m,
              tb_step AS j,
              tb_status AS t,
              tb_exec AS x
        WHERE s.chr = c.code
          AND x.chr_seq = s.code
          AND j.job = m.code
          AND x.job_step = j.code
          AND x.status = t.code
        ORDER BY c.code, s.code, m.code, j.code
           });
    $sth->execute;
    $txt = "\| \%".join("s \| \%",@{ $sth->{mysql_max_length} })."s \|\n";
    printf STDOUT $txt, @{ $sth->{NAME} };
    while (my @fld = $sth->fetchrow_array()) {
        printf STDOUT $txt, @fld;
    };
    $sth->finish;
} # view_exec_tbl
@ 


\subsctn{Shared code: [[global.pm]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl modules>>=
# 
# mySQL perl scripts: interacting with mySQL DB
echo "# --> \$LIBPERL/global.pm" 1>&2 ;
notangle -R'shared functions and settings' \
    $WORK/$nwfile.nw | cpif $LIBPERL/global.pm ;
perl -c $LIBPERL/global.pm ;
is_exec $LIBPERL/global.pm ;
#
@ 

<<shared functions and settings>>=
<<PERL shebang>>
# global.pm
#
package global;
use strict;
use vars qw(
           @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION 
           $PLVER $PROG $PRGVER $USAGE $DATE $CDATE $USER $HOST
           $T $F @skip_next @exectime %_verbose
           $ERRFH %Messages %exit_codes $EXIT_REPORT_FILE
           %CmdLineDefs %CmdLineOpts
           );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw(
           $PLVER $PROG $PRGVER $USAGE $DATE $CDATE $USER $HOST
           $T $F @skip_next %Messages %_verbose $ERRFH
           &init_timer &timing @exectime
           &init_signals &trap_signals &trap_signals_prog
           &program_started &program_finished
           &parse_cmdline %CmdLineDefs %CmdLineOpts
           &check_syscall_exit &the_end %exit_codes $EXIT_REPORT_FILE
           &check_file &check_dir
           &min &max
           );
@@EXPORT_OK = qw(
           &comment_line &header &left_header &right_header
           &fill_right &fill_left &fill_mid
           );
%EXPORT_TAGS = (
           # ParseCMDLN => [ qw( &parse_cmdline %CmdLineDefs %CmdLineOpts ) ],
           ExecReport => [ qw( $PLVER $PROG $PRGVER $USAGE 
                               $DATE $CDATE $USER $HOST
                               &program_started &program_finished ) ],
           StringFill => [ qw( &fill_right &fill_left &fill_mid ) ],
           ExitStatus => [ qw( &check_syscall_exit &the_end 
                               %exit_codes $EXIT_REPORT_FILE ) ],
           );
    # AdminFunc => [ qw( &connection_details &load_to_tbl_ifdef ) ],
    # );
# use lib "$LIBPERL";

###
### Setting Default Variables
###
$ERRFH = \*STDERR;
($T,$F) = (1,0);
$PLVER = sprintf("v%vd",$^V);
$PROG  = 'UNDEF';
$PRGVER = 'UNDEF';
$USAGE = 'WARNING: Program variable "$USAGE" was not defined yet...';
$DATE  = localtime;
$CDATE = sprintf("%04d%02d%02d%02d%02d%02d",
    sub { $_[5] + 1900, $_[4] + 1, $_[3], $_[2], $_[1], $_[0] }->(localtime) );
if (defined($ENV{USER})) {
    $USER = $ENV{USER};
} else {
    chomp($USER = `whoami`);
};
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
$HOST =~ s/\.imim\.es$//o;
if (defined($ENV{PSRF})) {
    $EXIT_REPORT_FILE = $ENV{PSRF};
} else {
    $EXIT_REPORT_FILE = "/tmp/$$";
};
<<global.pm: messages>>
<<global.pm: normalized exit codes>>

###
### Shareable functions
###
<<global.pm: timing>>
<<global.pm: trapping signals>>
<<global.pm: reporting messages>>
<<global.pm: parsing command-line args>>
<<global.pm: validate file/dir>>
<<global.pm: check exit status for sys calls>>
<<global.pm: normalized exit>>
<<global.pm: general functions>>

#
# Exiting from "global" package
1;
@
@ 

\subsubsctn{Timing processes}

<<global.pm: timing>>= 
#
# Timing definitions
use Benchmark;
@exectime = ();
sub init_timer() {
    my $refary = shift;
    @{ $refary } = (new Benchmark);
    return;
} # init_timer
sub timing() {
    my ($refary,$tmp) = @_;
    my $flg = defined($tmp) || $F;
    push @{ $refary } , (new Benchmark);
    my $mx = $#{ $refary };
    # partial time 
    $flg || do {
        return timestr(timediff($refary->[$mx],$refary->[($mx - 1)]));
    };
    # total time
    return timestr(timediff($refary->[$mx],$refary->[0]));
} # timing
@ 

\subsubsctn{Trapping system signals}

<<global.pm: trapping signals>>=
#
# Trapping signals
<<global.pm: use POSIX>>
sub init_signals() {
    $SIG{HUP}  = \&trap_signals_prog;
    $SIG{ABRT} = \&trap_signals;
    $SIG{INT}  = \&trap_signals;
    $SIG{QUIT} = \&trap_signals;
    $SIG{TERM} = \&trap_signals;
    $SIG{KILL} = \&trap_signals;
    $SIG{CHLD} = \&child_reaper; # 'IGNORE';
    @skip_next = ($F, undef);
} # init_signals
sub trap_signals() {
    print $ERRFH $Messages{'USER_HALT'}->($PROG);
    @skip_next = ($T, $F);
} # trap_signals
sub trap_signals_prog() {
    print $ERRFH $Messages{'PROCESS_HALT'}->($PROG);
    @skip_next = ($T, $T);
} # trap_signals_prog
@ 

Just to avoid zombie child processes we are now trying the following code\footnote{The code has been adapted from recipe 16.19, pp592, of ``Perl CookBook''} instead of setting [[$SIG{CHLD}]] to [[IGNORE]] (causing child processed to be automatically reaped), because that approach does not work reliably in our case. 
 
% $SIG{CHLD} = 'IGNORE' child processes are automatically reaped, or not ???
<<global.pm: trapping signals>>=
sub child_reaper() {
    my $cpid;
    $cpid = waitpid(-1, &WNOHANG);
    if (($cpid != -1) && WIFEXITED($?)) {
        # $skip_next[2] = $T;
        print $ERRFH $Messages{'CHILD_EXIT'}->($PROG, $cpid);
    };
    # $SIG{CHLD} = \&child_reaper;
} # child_reaper
@

We also require the following module to get [[&child_reaper]] working:

<<global.pm: use POSIX>>=
use POSIX qw( :signal_h :errno_h :sys_wait_h );
@

<<global: warnings - input/output>>=
USER_HALT    => sub {
         my $name = shift;
         return
           &header(
             $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "$name has been stopped by user !!!",
             "---------- Exiting NOW !!! ----------",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
PROCESS_HALT => sub {
         my $name = shift;
         return
           &header(
             $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "------- $name is down !!! -------",
             "---------- Exiting NOW !!! ----------",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
CHILD_EXIT => sub {
         my ($cxprg,$cxpid) = @_;
         return
           &header(
	         $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "---- $cxprg main loop child reaper ----",
             "Child process >>$cxpid<< has died !!!",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
CHILD_KILLED => sub {
         my ($cxprg,$cxpid) = @_;
         return
           &header(
	         $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "---- $cxprg main loop child reaper ----",
             "Child process >>$cxpid<< has died !!!",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
@

\subsubsctn{Processing messages}

<<global.pm: messages>>=
#
# Program status strings.
($_verbose{DEBUG}, $_verbose{RAW}, $_verbose{COLOR}) = ($F) x 3;
#
use Term::ANSIColor;
my $_pre_flg = $F;
my $term_width = 80;
my %mlin = (
    error_base     => sub {
                        my $str = "\<\<\<\< ERROR \>\>\>\>";
                        $_verbose{COLOR} && 
                            ($str = color("bold red").$str.color("reset"));
                        return $str." ";
                      },
    error_pre      => sub {
                        my $str = "\<\<\<";
                        $_verbose{COLOR} && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    error_post     => sub {
                        my $str = "\>\>\>";
                        $_verbose{COLOR} && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    error_len      => sub { return ($term_width - ( 16 + 3 + 3 )) },
      # error_base + error_pre + error_post
    warn_base      => sub {
                        my $str = "\<\<\< WARNING \>\>\>";
                        $_verbose{COLOR} && 
                            ($str = color("bold yellow").$str.color("reset"));
                        return $str." ";
                      },
    warn_pre       => sub {
                        my $str = "\<\<\<";
                        $_verbose{COLOR} && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    warn_post      => sub {
                        my $str = "\>\>\>";
                        $_verbose{COLOR} && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    warn_len       => sub { return ($term_width - ( 16 + 3 + 3 )) },
      # error_base + error_pre + error_post
    comment_base   => sub { return "" },
    comment_pre    => sub {
                        my $str = "###";
                        $_verbose{COLOR} && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      },
    comment_post   => sub {
                        my $str = "###";
                        $_verbose{COLOR} && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      },
    comment_len    => sub { return ($term_width - ( 0 + 3 + 3 )) },
      # comment_base + comment_pre + comment_post
    dbi_base       => sub {
                        my $str = "### ";
                        $_verbose{COLOR} && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_pre        => sub {
                        my $str = "MySQL *";
                        $_verbose{COLOR} && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_post       => sub {
                        my $str = "*";
                        $_verbose{COLOR} && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_len        => sub { return ($term_width - ( 4 + 7 + 1 )) },
      # dbi_base + dbi_pre + dbi_post
    spacer         => sub { return "###" },
    );
#
$mlin{'error_line'} = sub {
                        my $str = ('-' x $mlin{'error_len'}->());
                        $_verbose{COLOR} && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_error_line'} = sub { return (' ' x $mlin{'error_len'}->()) };
#
$mlin{'warn_line'} = sub { return $mlin{'error_line'}->() };
$mlin{'empty_warn_line'} = sub { return $mlin{'empty_error_line'}->() };
#
$mlin{'comment_line'} = sub {
                        my $str = ("#" x $mlin{'comment_len'}->());
                        $_verbose{COLOR} && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_comment_line'} = sub { return (' ' x $mlin{'comment_len'}->()) };
#
$mlin{'dbi_line'} = sub {
                        my $str = ("*" x $mlin{'dbi_len'}->());
                        $_verbose{COLOR} && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_dbi_line'} = sub { return (' ' x $mlin{'dbi_len'}->()) };
#
%Messages = (
    # ERROR MESSAGES
    <<global: warnings - environment settings>>
    <<global: warnings - input/output>>
    <<global: warnings - parsing command-line options>>
    # WORKING MESSAGES
    <<global: messages - program start-stop>>
    <<global: messages - interacting with DB>>
    <<global: messages - parsing command-line options>>
   ); # %Messages
@

<<global.pm: reporting messages>>=
#
# Reporting program status and messages
sub comment_line() {
    my ($tlen,$base,$pre,@lns) = @_;
    my ($comment,$ln);
    foreach $ln (@lns) {
        $ln =~ s/^$/ /o; 
        $comment .= "$base$pre $ln\n";
        };
    return $comment;
} # header
sub header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_mid($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # header
sub left_header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_left($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # left_header
sub right_header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_right($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # right_header
sub program_started() {
    my $prog = shift;
    print $ERRFH $Messages{'HEADER'}->("RUNNING $prog",'',
        "Host: $HOST","User: $USER","Perl: $PLVER",'',"Date: $DATE");
} # program_started
sub program_finished() {
    my $prog = shift;
    my $txt = &timing(\@exectime,$T);
    $txt =~ s/(secs)\s+(\()/$1\n$2/o;
    print $ERRFH $Messages{'HEADER'}->("$prog HAS FINISHED",'',
                 (split /\n/, $txt));
} # program_finished
@

<<global: messages - program start-stop>>=
HEADER       => sub {
         my @mssg = @_;
         return
           &header(
	         $mlin{'comment_len'}->(),$mlin{'comment_base'}->(),
             $mlin{'comment_pre'}->(),$mlin{'comment_post'}->(),
             $mlin{'comment_line'}->(),
             "", @mssg, "",
             $mlin{'comment_line'}->(),
             );
     },
@

<<global: warnings - environment settings>>=
ENVNOTDEF    => sub {
         my $mssg = shift;
         return
           &header(
             $mlin{'error_len'}->(),$mlin{'error_base'}->(),
             $mlin{'error_pre'}->(),$mlin{'error_post'}->(),
             $mlin{'error_line'}->(),$mlin{'empty_error_line'}->(),
             "Following environment variable is NOT defined: $mssg",
             $mlin{'empty_error_line'}->(),$mlin{'error_line'}->(),           
             );
     },
@

\subsubsctn{Interacting with DB standard messages}

<<global: messages - interacting with DB>>=
DBIHEADER    => sub {
         my @mssg = @_;
         return
           &right_header(
	         $mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
             $mlin{'dbi_pre'}->(),$mlin{'dbi_post'}->(),
             $mlin{'dbi_line'}->(),
             &prespc(@mssg),
             $mlin{'dbi_line'}->(),
             );
     },
DBIMSG       => sub {
         my @mssg = @_;
         return &comment_line($mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
                              $mlin{'dbi_pre'}->(),@mssg);
     },
DBICMD       => sub {
         my @mssg = (split /[\n]/o, $_[0]);
         @mssg = map { s/^\s{6}//o; $_ } @mssg;
         return &comment_line($mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
                              $mlin{'dbi_pre'}->(),@mssg);
     },
@


\subsubsctn{Parsing command-line}

<<global.pm: parsing command-line args>>=
#
# Parsing command-line options
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
%CmdLineDefs = ();
%CmdLineOpts = ();

sub parse_cmdline() {
    # we ensure here that options hash always exist 
    # (and that it has a default option: 'help')
    $CmdLineOpts{'version'} = sub { 
            print STDERR "#### Hi, you are running $PROG version $PRGVER ...\n";
            exit(1);
        };
    $CmdLineOpts{'debug'} = sub {
            ($_verbose{DEBUG}, $_verbose{RAW}) = ($T, $T);
        };
    $CmdLineOpts{'v|verbose'} = sub {
            $_verbose{RAW} = $T;
        };
    $CmdLineOpts{'V|color-verbose'} = sub {
            ($_verbose{RAW}, $_verbose{COLOR}) = ($T, $T);
        };
    $CmdLineOpts{'h|help|?'} = sub {
            print $ERRFH $Messages{'SHOW_HELP'}->($USAGE);
            exit(1);
        };
    # looking for STDIN "-" to avoid problems with GetOptions
    my $cmdln_stdin = undef;
    for (my $a = 0; $a <= $#ARGV; $a++) { 
        next unless $ARGV[$a] =~ /^-$/o;
        $cmdln_stdin = $a - $#ARGV;
        splice(@ARGV,$a,1);
    };    
    # parsing command-line
    $SIG{__WARN__} = sub {
            print $ERRFH $Messages{'CMDLINE_OPT_ERR'}->($_[0]);
        };
    GetOptions(%CmdLineOpts) || do {
            &program_started($PROG);
            print $ERRFH $Messages{'CMDLINE_ERROR'}->($PROG,"@ARGV");
            exit(1);
        };
    $SIG{__WARN__} = 'DEFAULT';
    # if "-" return to its position on cmd-line
    my $t = scalar(@ARGV);
    defined($cmdln_stdin) && do {
        abs($cmdln_stdin) > $t && ($cmdln_stdin = -$t);
	    $cmdln_stdin > 0  && ($cmdln_stdin = 0 );
        $t += $cmdln_stdin;
        splice(@ARGV,$t,0,'-');
    };
} # parse_cmdline
@ 

<<global: messages - parsing command-line options>>=
SHOW_HELP    => sub {
         my @mssg = split /[\n]/og, shift;
         return 
           &right_header(
	         $mlin{'comment_len'}->(),$mlin{'comment_base'}->(),
             $mlin{'comment_pre'}->(),$mlin{'comment_post'}->(),
             $mlin{'comment_line'}->(),
             &prespc(@mssg),
             $mlin{'comment_line'}->(),
             );
     },
@ 

<<global: warnings - parsing command-line options>>=
CMDLINE_OPT_ERR => sub {
         my $mssg = shift;
         $mssg =~ s/^\s*//o;
         $mssg =~ s/\s*$//o;
         return
           &right_header(
	         $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),
             &prespc("Error trapped while processing command-line:",
                     (" "x8)."--> $mssg <--"),
             $mlin{'warn_line'}->(),
             );
     },
CMDLINE_ERROR   => sub {
         my ($name,@mssg) = @_;
         return
           &right_header(
	         $mlin{'error_len'}->(),$mlin{'error_base'}->(),
             $mlin{'error_pre'}->(),$mlin{'error_post'}->(),
             $mlin{'error_line'}->(),
             &prespc("??? @mssg", "",
                     "Please, check your command-line options!!!",
                     (" "x8)."Type \"$name --help\" for help..."),
             $mlin{'error_line'}->(),
             );
     },
@


\subsubsctn{Validating filenames and directories}

<<HIDE: global.pm: validate file/dir>>=
#
# Filename and directories validation
sub check_file() {
    my $stdin_flg = $F;
    &report("CHECKING_FILENAMES");
  FILECHK: foreach my $test_file (@ARGV) {
        $test_file ne '-' && do {
            -e $test_file || do {
                &warn('FILE_NO_OPEN',$T,$test_file);
                next FILECHK;
            };
            &report('READING_FILE',$test_file);
            push @data_files, $test_file;
            next FILECHK;
        };
        $stdin_flg = $T;
        push @data_files, '-';
	}; # foreach
    scalar(@data_files) == 0 && do {
        push @data_files, '-';
        $stdin_flg = $T;
    };
    $stdin_flg && &report('READING_STDIN');
} # check_file
@ 

<<warnings - input/output>>=
FILE_NO_OPEN =>
  $spl.$Warn."Cannot Open Current file \"\%s\" . Not used !!!\n".$spl,
@
<<messages - input/output>>=
CHECKING_FILENAMES =>
  $sp."### Validating INPUT FILENAMES\n".$sp,
READING_FILE =>
  "###---> \"\%s\" exists, including as Input File.\n",
READING_STDIN =>
  "###---> Including GFF records from standard input.\n",  
@

<<global.pm: validate file/dir>>=
#
sub check_dir() {
    my ($flg,@odir) = @_;
    (scalar(@odir) == 0) && (return 0);
    my @okdir = ();
    foreach my $thisdir (@odir) {
        ( -e $thisdir && -d _ ) || do {
#            print $ERRFH "# Making chr $chr directory: $odir\n";
            (mkdir $thisdir) || do {
#                print $ERRFH "# Error making directory \"$odir\" ".
#                             "for chr $chr : SKIPPING !!!\n";
                push @okdir, $F;
                next;
            };
            push @okdir, $T;
            next;
        };
#        print $ERRFH "# Directory \"$odir\" for chr $chr ALREADY EXIST...\n".
        push @okdir, $T; 
    }; # foreach $d
    return @okdir;
} # check_dir
@


\subsubsctn{Checking exit status for system calls}

We check for exit signals returned by system once it has run the command-line defined in [[$cmdline]] variable (we use the recipe shown in the O'Reilly book, ``Programming Perl'', 2$^n$ edition, page 230). %' 

<<global.pm: check exit status for sys calls>>=
# 
# Checking exit status for sys calls
sub check_syscall_exit() {
    my $prog_exit = 0xffff & shift;
    my ($exitflg,$exitstr) = ($F,'');
    $exitstr = sprintf("Command returned %#04x : ", $prog_exit);
    if ($prog_exit == 0) {
        $exitflg = $T;
        $exitstr .= "ran with normal exit ...";
    }
    elsif ($prog_exit == 0xff00) {
        $exitstr .= "command failed: $! ...";
    }
    elsif (($prog_exit & 0xff) == 00) {
        $prog_exit >>= 8;
        $exitstr .= "ran with non-zero exit status $prog_exit ...";
    }
    else {
        $exitstr .= "ran with ";
        if ($prog_exit &   0x80) {
            $prog_exit &= ~0x80;
            $exitstr .= "coredump from ";
            };
        $exitstr .= "signal $prog_exit ...";
    };
    return ($exitflg,$exitstr,$prog_exit);
} # check_syscall_exit
@

<<HIDE: >>=
perl -e '
  use global;
  @kmd = (
           "echo $USER",
           "echo $USER; exit;",
           "echo $USER; exit 0;",
           "echo $USER; exit 1;",
           "ls echo",
           "ls echo; exit",
           "ls echo; exit 0",
           "perl -e \"exit(0);\"",
           "perl -e \"exit(1);\"",
           "perl -e \"exit(2);\"",
         ); 
  foreach $cmd (@kmd) {
      $kk = system($cmd);
      ($f,$s) = &check_syscall_exit($kk);
      print STDOUT ("#" x 60)."\n".
                   "# Command line:\n".$cmd."\n".
                   "# Program returned signal $kk\n".
                   "# Did it run ? ".($f ? "Yes" : "No")."\n".
                   "# Diagnostics:\n$s\n\n";
  }; # foreach 
' 
@ 

\begin{table}[!t]
\begin{center}
\begin{tabular}{|lrl|}\hline
\textbf{EXIT KEY}  & \textbf{EXIT CODE}  & \textbf{DESCRIPTION} \\ \hline\hline
OK            &   0 & Everything was OK (as default) \\
KO            &   1 & Errors found (standard)        \\
UNDEF         &   2 & Unknown exit status (not defined)   \\
UNAVAILABLE   &   3 & Could not find/create status file   \\ \hline\hline
USERHALT      &   4 & Process halted by user ([[CTRL+C]]) \\
PROGHALT      &   5 & Process halted by program (kill -9) \\
PROGDOWN      &   6 & Process is down                \\
NOFORK        &   8 & Could not fork child           \\
RSH           &  10 & RSH command failed             \\
PBS           &  12 & PBS command failed             \\ \hline\hline
NOTRUN        &  14 & Program was not executed (skipping) \\
CKO           &  15 & C program failed...            \\
PERLKO        &  16 & PERL script failed...          \\
GAWKKO        &  17 & GAWK script failed...          \\
BASHKO        &  18 & BASH script failed...          \\
FUNCKO        &  19 & BASH user defined function failed... \\ \hline\hline
NOFILE        &  20 & File not found                 \\
NOREADFILE    &  22 & Could not open file to read    \\
NOWRITEFILE   &  24 & Could not open file to write   \\
NOAPPENDFILE  &  26 & Could not open file to append  \\ \hline
NODIR         &  30 & Dir not found                  \\
NOREADDIR     &  32 & Could not open dir to read     \\
NOWRITEDIR    &  34 & Could not open dir to write    \\
NONEWDIR      &  36 & Could not create new dir       \\ \hline
NOBASHPIPE    &  40 & Error found in bash pipe       \\
NOREADPIPE    &  42 & Could not open pipe to read    \\
NOWRITEPIPE   &  44 & Could not open pipe to write   \\ \hline\hline
COMMANDLINE   &  60 & Error trapped when parsing commandline options \\
BADCMDLINEOPT &  62 & Wrong command-line option forced program exit  \\
ENVERROR      &  70 & Error trapped when setting shell environment   \\
ENVUNDEFVAR   &  72 & Environment variable not defined    \\ \hline\hline
DBCONNECT     & 100 & Could not connect to DataBase  \\
NOTRANSACTION & 110 & Could not process transaction  \\ \hline\hline
NOCMD         & 127 & Command not found              \\ \hline
\end{tabular}
\caption[Exit codes definition]{\label{tbl:exitcodes} \textbf{Exit codes definition.} When running external scripts will be interesting to retrieve the cause of abnormal exiting (given that OK exit is set to its default system exit code), so we set here a fixed code error description to be shared along different scripts. This enables us to distingish between remote shell execution errors and the errors generated by submitted scripts.}
\end{center}
\end{table}

<<global.pm: normalized exit>>=
# 
# Return to program caller a "normalized" error code
sub the_end() { 
    my $k = shift || 'UNDEF';
    defined($exit_codes{$k}) || ($k = 'UNDEF');
    ($k eq 'OK' || $k eq 'KO') || do {
        $exit_codes{$k}{MSG}->();
    };
    open(XRF,"> $EXIT_REPORT_FILE") || do {
        exit($exit_codes{'UNAVAILABLE'}{CODE});
    };
    print XRF $exit_codes{$k}{CODE};
    close(XRF);
    exit($exit_codes{$k}{CODE});
} # the_end
@

<<global.pm: normalized exit codes>>=
%exit_codes = (
    'OK' => { 
         CODE  =>   0,
         SHORT => "Everything was OK",
         MSG   => sub { return $exit_codes{'OK'}{SHORT} },
         },
    'KO' => { 
         CODE  =>   1,
         SHORT => "Errors found (not specified)",
         MSG   => sub { return $exit_codes{'KO'}{SHORT} },
         },
    'UNDEF' => { 
         CODE  =>   2,
         SHORT => "Unknown exit status (not defined)",
         MSG   => sub { return $exit_codes{'UNDEF'}{SHORT} },
         },
    'UNAVAILABLE' => { 
         CODE  =>   3,
         SHORT => "Could not find/create status file",
         MSG   => sub { return $exit_codes{'UNAVAILABLE'}{SHORT} },
         },
    'USERHALT' => { 
         CODE  =>   4,
         SHORT => "Process halted by user ([[CTRL+C]])",
         MSG   => sub { return $exit_codes{'USERHALT'}{SHORT} },
         },
    'PROGHALT' => { 
         CODE  =>   5,
         SHORT => "Process halted by program (kill -9)",
         MSG   => sub { return $exit_codes{'PROGHALT'}{SHORT} },
         },
    'PROGDOWN' => { 
         CODE  =>   6,
         SHORT => "Process is down",
         MSG   => sub { return $exit_codes{'PROGDOWN'}{SHORT} },
         },
    'NOFORK' => { 
         CODE  =>   8,
         SHORT => "Could not fork child",
         MSG   => sub { return $exit_codes{'NOFORK'}{SHORT} },
         },
    'RSH' => { 
         CODE  =>  10,
         SHORT => "RSH command failed",
         MSG   => sub { return $exit_codes{'RSH'}{SHORT} },
         },
    'PBS' => { 
         CODE  =>  12,
         SHORT => "PBS command failed",
         MSG   => sub { return $exit_codes{'PBS'}{SHORT} },
         },
    'NOTRUN' => { 
         CODE  =>  14,
         SHORT => "Program was not executed",
         MSG   => sub { return $exit_codes{'NOTRUN'}{SHORT} },
         },
    'CKO' => { 
         CODE  =>  15,
         SHORT => "C program failed...",
         MSG   => sub { return $exit_codes{'CKO'}{SHORT} },
         },
    'PERLKO' => { 
         CODE  =>  16,
         SHORT => "PERL script failed...",
         MSG   => sub { return $exit_codes{'PERLKO'}{SHORT} },
         },
    'GAWKKO' => { 
         CODE  =>  17,
         SHORT => "GAWK script failed...",
         MSG   => sub { return $exit_codes{'GAWKKO'}{SHORT} },
         },
    'BASHKO' => { 
         CODE  =>  18,
         SHORT => "BASH script failed...",
         MSG   => sub { return $exit_codes{'BASHKO'}{SHORT} },
         },
    'FUNCKO' => { 
         CODE  =>  19,
         SHORT => "BASH user defined function failed...",
         MSG   => sub { return $exit_codes{'FUNCKO'}{SHORT} },
         },
    'NOFILE' => { 
         CODE  =>  20,
         SHORT => "File not found",
         MSG   => sub { return $exit_codes{'NOFILE'}{SHORT} },
         },
    'NOREADFILE' => { 
         CODE  =>  22,
         SHORT => "Could not open file to read",
         MSG   => sub { return $exit_codes{'NOREADFILE'}{SHORT} },
         },
    'NOWRITEFILE' => { 
         CODE  =>  24,
         SHORT => "Could not open file to write",
         MSG   => sub { return $exit_codes{'NOWRITEFILE'}{SHORT} },
         },
    'NOAPPENDFILE' => { 
         CODE  =>  26,
         SHORT => "Could not open file to append",
         MSG   => sub { return $exit_codes{'NOAPPENDFILE'}{SHORT} },
         },
    'NODIR' => { 
         CODE  =>  30,
         SHORT => "Directory not found",
         MSG   => sub { return $exit_codes{'NODIR'}{SHORT} },
         },
    'NOREADDIR' => { 
         CODE  =>  32,
         SHORT => "Could not open directory to read",
         MSG   => sub { return $exit_codes{'NOREADDIR'}{SHORT} },
         },
    'NOWRITEDIR' => { 
         CODE  =>  34,
         SHORT => "Could not open directory to write",
         MSG   => sub { return $exit_codes{'NOWRITEDIR'}{SHORT} },
         },
    'NONEWDIR' => { 
         CODE  =>  36,
         SHORT => "Could not create new directory",
         MSG   => sub { return $exit_codes{'NONEWDIR'}{SHORT} },
         },
    'NOBASHPIPE' => { 
         CODE  =>  40,
         SHORT => "Error found in bash pipe",
         MSG   => sub { return $exit_codes{'NOBASHPIPE'}{SHORT} },
         },
    'NOREADPIPE' => { 
         CODE  =>  42,
         SHORT => "Could not open pipe to read",
         MSG   => sub { return $exit_codes{'NOREADPIPE'}{SHORT} },
         },
    'NOWRITEPIPE' => { 
         CODE  =>  44,
         SHORT => "Could not open pipe to write",
         MSG   => sub { return $exit_codes{'NOWRITEPIPE'}{SHORT} },
         },
    'COMMANDLINE' => { 
         CODE  =>  60,
         SHORT => "Error trapped when parsing commandline options",
         MSG   => sub { return $exit_codes{'COMMANDLINE'}{SHORT} },
         },
    'BADCMDLINEOPT' => { 
         CODE  =>  62,
         SHORT => "Wrong command-line option forced program exit",
         MSG   => sub { return $exit_codes{'BADCMDLINEOPT'}{SHORT} },
         },
    'ENVERROR' => { 
         CODE  =>  70,
         SHORT => "Error trapped when setting shell environment",
         MSG   => sub { return $exit_codes{'ENVERROR'}{SHORT} },
         },
    'ENVUNDEFVAR' => { 
         CODE  =>  72,
         SHORT => "Environment variable not defined",
         MSG   => sub { return $exit_codes{'ENVUNDEFVAR'}{SHORT} },
         },
    'DBCONNECT' => { 
         CODE  => 100,
         SHORT => "Could not connect to DataBase",
         MSG   => sub { return $exit_codes{'DBCONNECT'}{SHORT} },
         },
    'NOTRANSACTION' => { 
         CODE  => 110,
         SHORT => "Could not process transaction",
         MSG   => sub { return $exit_codes{'NOTRANSACTION'}{SHORT} },
         },
    'NOCMD' => { 
         CODE  => 127,
         SHORT => "Command not found",
         MSG   => sub { return $exit_codes{'NOCMD'}{SHORT} },
         },
    );
%{ $exit_codes{'CODES'} } = ( map { $exit_codes{$_}{'CODE'}, $_ }
                              keys %exit_codes );
@

\subsubsctn{Execution status helper scripts: [[exit.pl]] and [[]]}

<<exit.pl: retrieving status codes>>=
<<PERL shebang>>
# exit.pl
#
use strict;
use global qw( :ExitStatus );
my $key = shift @ARGV || 'UNDEF';
printf STDOUT "%d", ( defined($exit_codes{$key})
                        ? $exit_codes{$key}{CODE}
                        : $exit_codes{UNDEF}{CODE} );
exit(0);
@ 

The following short script informs us about few parameters we must check on remote machines that affect the execution of all the scripts we could launch via [[rsh]] from [[stepper.pl]]:

<<getremoteinfo.pl: checking remote hosts shared params>>=
<<PERL shebang>>
# getremoteinfo.pl
#
$MOLBIO="/usr/local/molbio";
$TMP="$MOLBIO/share/sgp/tmp";
$TMP2="/projects/H.sapiens/tmp";
# Get hostname
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
$HOST =~ s/\.imim\.es$//o;
#
chomp($WB = `which bash`);
#
# Directories that must exist in host
if (-e "$MOLBIO" && -d _) { $DIRFLG="YES" }
else { $DIRFLG=" NO" };
#
if (-e "$TMP" && -d _ ) { $TMPFLG="YES" }
else { $TMPFLG=" NO" };
$flg = 1;
open(KK,"> $TMP/kk") || ($flg = 0);
$flg && do {
    close(KK);
    unlink("$TMP/kk");
};
if ($TMPFLG eq "YES" && $flg) { $TMPWTRFLG="Writable" }
else {
    if ($TMPFLG eq "YES") {
        $TMPWTRFLG="ReadOnly";
    } else {
        $TMPWTRFLG="UnMountd";
    };
};
#
if (-e "$TMP2" && -d _ ) { $TMPFLG2="YES" }
else { $TMPFLG2=" NO" };
$flg = 1;
open(KK,"> $TMP2/kk") || ($flg = 0);
$flg && do {
    close(KK);
    unlink("$TMP2/kk");
};
if ($TMPFLG2 eq "YES" && $flg) { $TMPWTRFLG2="Writable" }
else {
    if ($TMPFLG2 eq "YES") {
        $TMPWTRFLG2="ReadOnly";
    } else {
        $TMPWTRFLG2="UnMountd";
    };
};
#
# Output required info about host
print STDOUT sprintf("--> %16s --> perl v%vd ".
                     "--> \"bash\" ? %s ".
                     "--> \"molbio\" ? %s ".
                     "--> \"tmpbin\" ? %s (%s) ".
                     "--> \"tmpprj\" ? %s (%s)\n",
       "$HOST.imim.es",$^V,$WB,$DIRFLG,$TMPFLG,$TMPWTRFLG,$TMPFLG2,$TMPWTRFLG2);
#
exit(0);
@ 

<<tangling: perl scripts>>=
# 
# Retrieve status codes from step scripts execution
echo "# --> \$BIN/exit.pl" 1>&2 ;
notangle -R'exit.pl: retrieving status codes' \
    $WORK/$nwfile.nw | cpif $BIN/exit.pl ;
perl -c $BIN/exit.pl ;
is_exec $BIN/exit.pl ;
#
echo "# --> \$BIN/getremoteinfo.pl" 1>&2 ;
notangle -R'getremoteinfo.pl: checking remote hosts shared params' \
    $WORK/$nwfile.nw | cpif $BIN/getremoteinfo.pl ;
perl -c $BIN/getremoteinfo.pl ;
is_exec $BIN/getremoteinfo.pl ;
#
for n in monstre1 monstre2 monstre3 monstre4 ik12 ik13 i8 i10 i26 aleph ;
  do {
       rsh $n.imim.es $BIN/getremoteinfo.pl ;
    } ;
  done ;
#
@ 

<<HIDE: >>=
perl -e '
  use global;
  foreach $h (keys %exit_codes) { $mesg{$exit_codes{$h}{CODE}} = $h; };
  $kk=system("echo HOLA; exit 20;");
  ($a,$b,$c)= &check_syscall_exit($kk);
  printf "## EXEC %s (%s:%s) --- flg: %s > %s\n", $kk, $c, $mesg{$c}, $a, $b;
  $ko=system <<'\''++++EOF++++'\'';
function the_end () {
  perl -e '\''use global qw( :ExitStatus );
    $a = shift @ARGV;
    printf STDOUT "%d", ( defined($exit_codes{$a})
                          ? $exit_codes{$a}{CODE}
                          : $exit_codes{UNDEF}{CODE} ); '\'' $1;
}
echo "HOLA";
exit `the_end "UNDEF"` ;
++++EOF++++
  ($a,$b,$c)= &check_syscall_exit($ko);
  printf "## EXEC %s (%s:%s) --- flg: %s > %s\n", $ko, $c, $mesg{$c}, $a, $b; '
@ 


\subsubsctn{General functions}

<<global.pm: general functions>>=
# 
# General functions
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
#
sub fill_right() { return $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { return ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    return ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l + $k)));
} # fill_mid
sub prespc() { return ( map { " $_" } @_ ); } 
@


\subsctn{Implementing scripts with [[Tk]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl Tk scripts>>=
# 
# Tk perl scripts
echo "# --> \$BIN/stv" 1>&2 ;
notangle -R'stv: Status Table Viewer' $WORK/$nwfile.nw | cpif $BIN/stv ;
perl -c $BIN/stv ;
is_exec $BIN/stv ;
#
@ 

<<stv: Status Table Viewer>>=
<<PERL shebang>>
# stv - visualizing a dinamic status table in perl Tk (pTk)
#
use strict;
use Tk;
# database interface module
# use lib "$LIBPERL";
use db_Hsapiens;
#
use global;
$PROG = 'stv';
$PRGVER = '0.9alpha';

<<RGB color codes hash>>
my @chrom = qw/ 1 2 3 4 X Y /; # to load from DB
my @jobs  = qw/ Masking Homology GenePred SGP /; # to load from DB
my (%col,%row); 

#
## MAIN
&parse_cmdline();
&program_started($PROG);
# Open mySQL DataBase conection
&open_DB();
# Initialize Tk table
&Init_Window();
# Infinite loop to dispatch incoming events
MainLoop();
# Disconecting from mySQL DB
&close_DB();
#
&program_finished($PROG);
exit(0);

#
## SUBS
sub Init_Window() {
    # Create main window
    my $main_window = MainWindow->new();
    $main_window->title("Status Table Viewer");

    # Instatiating widgets
    $col{HEADER} = $main_window->Frame(
                    borderwidth => 2,
                    foreground  => $color{yellow},
                    )->pack(
                        side   => 'left',
                        fill   => 'y', 
                        expand => 'y',
                        );
    $row{HEADER}{HEADER} = $col{HEADER}->Label(
                               text        => "CHR->\nPROG-v",
                             # anchor      => 'n',
                               width       => 10,
                               height      => 2,
                               foreground  => $color{black},
                               background  => $color{lightgrey},
                               borderwidth => 2,
                               )->pack();
    foreach my $j (@jobs) {
        $row{HEADER}{$j} = $col{HEADER}->Label(
                               text        => "$j",
                             # anchor      => 'n',
                               width       => 10,
                               height      => 2,
                               foreground  => $color{black},
                               background  => $color{dodgerblue}, #'lightblue',
                               borderwidth => 2,
                               )->pack();
    }; # foreach @jobs

    foreach my $j (@chrom) {
        my $frame = $main_window->Frame(
                    borderwidth => 2,
                    foreground  => $color{yellow},
                    )->pack(
                        side   => 'left',
                        fill   => 'y', 
                        expand => 'y',
                        );
        %{ $row{$j} } = (); 
        $col{$j} = $frame;
        $row{$j}{HEADER} = $col{$j}->Label(
                               text        => "Chr $j",
                             # anchor      => 'n',
                               width       => 6,
                               height      => 2,
                               foreground  => $color{black},
                               background  => $color{lightgrey},
                               borderwidth => 2,
                               )->pack();
        foreach my $i (@jobs) {
            $row{$j}{$i} = $col{$j}->Label(
                               text        => "-",
                             # anchor      => 'n',
                               width       => 6,
                               height      => 2,
                               foreground  => $color{black},
                               background  => $color{orange},
                               borderwidth => 2,
                               )->pack();
        }; # foreach @jobs
    }; # foreach @chrom
} # Init_Window
@ 

<<RGB color codes hash>>=
my %color = (
#
        'white'        => '#FFFFFF',
        'black'        => '#000000',
        'slategrey'    => '#9FB6CD',
        'grey'         => '#BEBEBE',
        'lightgrey'    => '#D3D3D3',
        'lightslategrey' => '#708090',
#
        'magenta'      => '#FF00FF',
        'lightpink'    => '#FFB6C1',
        'purple'       => '#9370DB',
        'lavender'     => '#E6E6FA',
#
        'cyan'         => '#00FFFF',
        'lightcyan'    => '#E0FFFF',
        'skyblue'      => '#87CEEB',
        'palecyan'     => '#AFEEEE',
#
        'blue'         => '#0000FF',
        'lightblue'    => '#ADD8E6',
        'steelblue'    => '#4682B4',
        'dodgerblue'   => '#1C86EE',
        'midnightblue' => '#191970',
#
        'green'        => '#00FF00',
        'seagreen'     => '#2E8B57',
        'forestgreen'  => '#228B22',
        'darkgreen'    => '#006400',
        'palegreen'    => '#98FB98',
#
        'yellow'       => '#FFFF00',
        'orange'       => '#FFA500',
        'gold'         => '#FFD700',
        'khaki'        => '#F0E68C',
#
        'red'          => '#FF0000',
        'salmon'       => '#FA8072',
        'coral'        => '#FF7F50',
        'firebrick'    => '#B22222',
#
        'brown'        => '#A52A2A',
        'siena'        => '#A0522D',
        'saddlebrown'  => '#8B4513',
        'tan'          => '#D2B48C',
        'burlywood'    => '#FFD39B',
    );
@

\subsctn{Tests} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Testing scripts: >>=
#
perl -e '
  use strict;
  my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
  my @frame = ( 3, 1, 2 ); # frm 0 -> blastfrm 3
                           # frm 1 -> blastfrm 1
                           # frm 2 -> blastfrm 2
  my %SEQlen;
  my ($chr, $seqln, $input, $odir) = @ARGV;

  &child("$odir/$chr");
  &main();
  close(STDOUT);

sub child() {
  my $base = shift;
  open(FGFF,"> $base.fullgff");
  open(CGFF,"| sort +3n -6 +6 -7 - > $base.gff");
  # reopen STDOUT in parent and return
  return if my $pid = open(STDOUT, "| -");
  die("### Cannot fork: $!") unless defined($pid);
  # process STDIN in child
  while (<STDIN>) {
      my $j = $_;
      print FGFF $j;
      next if $j =~ /^#/o;
      next if $j =~ /^\s*$/o;
      $j =~ s/;\s+Strand//o;
      $j =~ s/;\s+Frame//o;
      $j =~ s/;\s+E_value.*$//o;
      print CGFF $j;
  }; # STDIN
  # do not let child return to main!!!
  exit;
} # sub child

sub main() {
  my @files = ();
  my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
            "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                       "all" => 8,            "sum" => [ (0) x 9 ] );
  my ($cf,$cr);
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  open(FRGLST, "< $input.report");
  while (<FRGLST>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      s/^\s*//o;
      my @l = split /\s+/og, $_;
      ($l[2] > 0) && do {
          push @files, [ $l[$#l], ($l[0] - 1) ];
      };
      # skipping fragments without HSPs
  }; # while
  close(FRGLST);
  #
  print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
               (sprintf("%8s %8s %8s  %s\n","#hsp","#hsp(+)","#hsp(-)","file"));
  system("/bin/rm","$input.parseblast.err");
  foreach my $fl (@files) {
      $cf = $cr = 0;
      my ($fname,$offset) = ("$input/$fl->[0]", $fl->[1]);
      open(TBXFL, "parseblast --fullgff --full-scores --comments".
                  " --verbose --bit-score $fname 2>> $input.parseblast.err |");
      my @l;
      while (<TBXFL>) {
          next if /^\s*$/o;
          /^#/o && do {
              print STDOUT $_;
              next;
          };
          chomp;
          @l = split /\s+/og, $_, 9;
          $l[$seq] = $chr;
          $l[$src] = "tblastx";
          $l[$ftr] = "hsp";
          $l[$ori] += $offset;
          $l[$end] += $offset;
          if ($l[$str] eq "-") {
              $l[$frm] = $frame[(($SEQlen{$chr} - $l[$end] + 1) % 3)];
              $cr++;
          } else {
              $l[$frm] = $frame[($l[$ori] % 3)];
              $cf++;
          };
          print STDOUT join("\t", @l)."\n";
          $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
      }; # while
      close(TBXFL);
      printf STDERR "  %8s %8s %8s  %s\n",($cf+$cr),$cf,$cr,$fl->[0];
  }; # foreach
  $g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
  $g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
  $g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
  print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
               $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
  foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
     printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
  }; # foreach
} # sub main
' $CHR $SDIR/$HSAPID/length $IDIR $ODIR 2> $ODIR.report ;
#
@
 
<<Testing scripts: >>=
#
# cat > run_local_childs <<'###EOF###';
cat > run_remote_childs <<'###EOF###';
#!/usr/local/bin/perl -w
  use strict;
  use IPC::Shareable; # XAVI must install this !!!!!
  my @seqs = qw( seq1  seq2  seq3  seq4  seq5  seq6  seq7  seq8  seq9  seq10
                 seq11 seq12 seq13 seq14 seq15 seq16 seq17 seq18 seq19 seq20 );
  my @jobs = qw( job1 job2 job3 job4 job5 );
  my $BASE = "/home/ug/jabril/development/projects/sgp/humus/tests/childs";
  my %jobscode = (
      job1 => <<'$$$EOF$$$',
#
perl -e '
  ($jn,$dr) = @ARGV;
  print STDOUT "Running $jn on $ENV{CWD}: $ENV{USER} at $ENV{HOSTNAME}\n";
  print STDERR "## Output was sent to $jn.out";
  sleep(5);
  print STDERR "## Sleep period has finished";
  exit(0);
  ' "job1($MPID)" $HOME > $SEQ.job1.out 2> $SEQ.job1.err;
#
$$$EOF$$$
      job2 => <<'$$$EOF$$$',
#
STRING=`hostname`;
#
echo "HEY it is me: $USER @ $STRING" > $SEQ.job2.out 2> $SEQ.job2.err;
#
$$$EOF$$$
      job3 => <<'$$$EOF$$$',
#
STRING=`hostname`;
wc /seq/genomes/H.sapiens/golden_path_20010806/chromosomes/chr1.fa | \
  perl -e '$h = shift;
           $wc = <>;
           print "# $ENV{USER} at $h \n# File length is: $wc\n";
          ' $STRING - \
          > $SEQ.job3.out \
         2> $SEQ.job3.err ;
#
$$$EOF$$$
      job4 => "",
      job5 => "",
  );
#  $jobscode{job1} =~ s/(\n)/$1#--> /og ;
#  print STDOUT "#--> ".$jobscode{job1}."\n" ;

  my @pids = ();
  my ($pid,$sem);
  my @hosts = qw( monstre1 monstre2 monstre3 monstre4 ik12 ik13 i8 i10 i26 );
  my $maxjobs = scalar(@hosts);
  my @semaphore ;
  my $gid = $$;

  my $handle = tie @semaphore, 'IPC::Shareable', undef, { destroy => 1 };
  @semaphore = ( 0 ) x $maxjobs;

open(FHERR, "> $BASE/run.rpt");
  # BEGIN brown_dispatcher
  print FHERR "### MAIN $gid ### BEGIN MAIN LOOP\n".
              "### MAIN $gid ### SEMAPHORE: @semaphore\n";
  my $pending_seqs = scalar(@seqs);
  while ($pending_seqs > 0) {
      for ($sem = 0; $sem < $maxjobs; $sem++) {
         $semaphore[$sem] || do {
             next if (! &is_host_there($hosts[$sem]));
             next if $pending_seqs == 0; # next unless scalar(@seqs) > 0;
             &breed_crows( shift @seqs, $sem);
             push @pids, $pid;
             --$pending_seqs;
         }; # if job semaphore == 0 then fork child
         &do_wait();
      }; # for semaphores...
  }; # while
  while (&all_done(\@semaphore)) { &do_wait(); };
  print FHERR "### MAIN $gid ### All Jobs ID: \n @pids \n".
              "### MAIN $gid ### END MAIN LOOP\n";
  # END brown_dispatcher

close(FHERR);
  exit(0);

  sub do_wait() {
      sleep 1; # select(undef,undef,undef,1);
      print FHERR "### MAIN $gid ### SEMAPHORE: @semaphore\n";
  } # do_wait
  sub all_done() {
      my $aryref = shift;
      my $sum = 0;
      $handle->shlock();
      for (my $s = 0; $s < $maxjobs; $s++) {
          $sum += $semaphore[$s];
      }; # for semaphores...
      $handle->shunlock();
      return ($sum>0) ? 1 : 0;
  } # all_done
  sub is_host_there() {
      my $host = shift;
      system("rsh $host echo $host 2>/dev/null 1>&2; exit") == 0  && do {
          print FHERR "### MAIN $gid ### Connection to $host available...\n";
          return 1;
      };
      print FHERR "### MAIN $gid ### Connection to $host NOT available...\n";       
      return 0;
  } # is_host_there
  sub breed_crows() {
      my ($pre,$clhpid);
      my ($seq,$pos) = @_;
      return if $pid = fork(); # return to parent, follows child code
      $clhpid = "$$.$gid";
      $handle->shlock();
      $semaphore[$pos] = $clhpid;
      $handle->shunlock();
      print FHERR "## $clhpid ## Running child \"$clhpid\" on sequence \"$seq\".\n";
      $pre = sprintf("SEQ=$BASE/data/%s ;\nMPID=%s ;\n",$seq,$clhpid);
      foreach my $job (qw( job1 job2 job3 )) {
          print FHERR "## $clhpid ## Running job \"$job\" on sequence \"$seq\".\n";
          open(TMP,"> $BASE/tmp/$clhpid");
          print TMP $pre.$jobscode{$job};
          close(TMP);
          system <<"#@#EOF#@#"
/bin/chmod a+x $BASE/tmp/$clhpid ;
rsh $hosts[$pos].imim.es $BASE/tmp/$clhpid ;
/bin/rm $BASE/tmp/$clhpid ;
#@#EOF#@#
      }; # foreach job
      $handle->shlock();
      $semaphore[$pos] = 0;
      $handle->shunlock();
      print FHERR "## $clhpid ## Child \"$clhpid\" is going to finish.\n";
      exit(0); # child process exits when done
  } # breed_crows
###EOF###
#
@ 

<<HIDE: >>=
cat > getremoteinfo.pl <<'###EOF###';
#!/usr/local/bin/perl -w
print STDOUT sprintf("--> %s --> v%vd\n",$ENV{HOSTNAME},$^V);
###EOF###
chmod a+x getremoteinfo.pl ;
#
for n in monstre1 monstre2 monstre3 monstre4 ik12 ik13 i8 i10 i26;
  do {
     rsh $n /home/ug/jabril/development/projects/sgp/humus/tests/childs/getremoteinfo.pl;
     };
  done 
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/local/bin/perl -w
# This is perl, version 5.6.1 built for i386-linux
#
<<Version Control Id Tag>>
#
@ 

<<PERL strict pragma + info>>=
use strict;
#
my $PVER = sprintf("v%vd",$^V);
my $DATE = localtime;
my ($USER,$HOST);
if (defined($ENV{USER})) {
    $USER = $ENV{USER};
} else {
    chomp($USER = `whoami`);
};
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
my $host = $HOST; ###
#
@

<<Global Constants - Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@ %def $T $F


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    my $flg = shift || 0;
    push @Timer, (new Benchmark);
    # partial time 
    $flg || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % $_cntN) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % $_cntN) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Global Vars - Counter>>=
my ($n,$c,$_cntN); # counter and char (for &counter function)
@ %def $n $c $_cntN


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%MessageList]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($MessageList{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also requires a hash variable '[[%ErrorList]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($ErrorList{ shift @_ }, @_) }
@

\subsctn{AWK scripts}

<<GAWK shebang>>=
#!/usr/bin/gawk -f
# GNU Awk 3.0.4
<<Version Control Id Tag>>
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
@ 

<<BASH script start>>=
<<BASH shebang>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: humus.nw,v 1.13 2002-04-05 19:04:47 jabril Exp $
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling programs>>=
echo "# TANGLING PERL MODULES:" 1>&2 ;
<<tangling: perl modules>>
echo "# TANGLING mySQL PERL SCRIPTS:" 1>&2 ;
<<tangling: mySQL perl scripts>>
echo "# TANGLING PERL SCRIPTS:" 1>&2 ;
<<tangling: perl scripts>>
echo "# TANGLING PERL TK SCRIPTS:" 1>&2 ;
<<tangling: perl Tk scripts>>
@ 

<<examples of tangling commands>>=
# showing line numbering comments in program
notangle -L -R"humus" $WORK/$nwfile.nw | \
   perl -ne '$.>1 && print' | cpif $BIN/humus ;
is_exec $BIN/humus ;
# reformating program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/humus ;
# html pretty-printing program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/humus.html ;
#
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling param files>>=
echo "# TANGLING MySQL SCRIPTS:" 1>&2 ;
<<tangling: mySQL scripts>>
echo "# TANGLING MySQL PARAM FILES:" 1>&2 ;
<<tangling: mySQL param>>
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | \
    cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH script start>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH script start>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$


\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<tangling shell variables>>=
# 
# BASH Environment Variables
echo "# Running notangle on $nwfile.nw: .bash_VARS" 1>&2 ;
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
echo "# Running notangle on $nwfile.nw: .project_VARS" 1>&2 ;
notangle -R'BASH Project Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.project_VARS ;
# source $WORK/.bash_VARS ;
#
@

<<BASH Environment Variables>>=
#
# Setting Global Variables
# WORK is set by "setcwd"
WBIN="$WORK/bin" ;
WPARAM="$BIN/param" ;
WSRC="$WORK/src" ; # where to put the distributable files
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
nwfile="humus" ;
export WBIN WPARAM WSRC DOCS DATA TEST nwfile ;
#
source $WORK/.project_VARS ;
@ 

<<BASH Project Variables>>=
#
umask 002 ;
#
BASE="/projects" ;
HUMUS="$BASE/H.sapiens" ;
BBIN="/usr/local/molbio/share/sgp" ;
BIN="$BBIN/bin" ;
MySQLPAR="$BBIN/mySQL" ;
LIBPERL="$BBIN/libperl" ;
LIBSTEP="$BBIN/libstep" ;
SRC="$BBIN/src" ;
# TMP="$BBIN/tmp" ; # this is a read only system....
TMP="$HUMUS/tmp" ;
export BASE HUMUS BBIN BIN MySQLPAR LIBPERL LIBSTEP SRC TMP ;
#
<<BASH Variables: Perl>>
#
<<BASH Basic Shell Functions>>
<<BASH Functions: Handling large directories>>
<<BASH Functions: Filtering GENEID RAW Output>>
<<BASH Functions: Get Gene Number from GENEID Output>>
#<BASH Functions: Gene-Prediction Evaluation>>
#
@ 

<<BASH Basic Shell Functions>>=
#
# BASIC Shell Functions
#
function TheEnd ()
{
  #
  # USAGE: TheEnd <STATUS_KEY>
  # PSRF is Process Status Reporter File
  if [ "$PSRF" ] ;
  then
     SCODE=`( $BIN/exit.pl $1 | tee $PSRF ) 2> /dev/null` ;
  else
     SCODE=3 ; # UNAVAILABLE
  fi ;
  exit $SCODE ;
}
#
function MkDirs ()
{
  #
  # USAGE: MkDirs <path_list>
  #
  for name in "$@" ;
    do {
         if [ -d "$name" ] ;
         then 
           echo "### Directory Already Exist: $name" 1>&2 ;
         elif mkdir $name 2> /dev/null ;
           then
             echo "### Making New Directory   : $name" 1>&2 ;
         else
           echo "### CANNOT Create Directory: $name" 1>&2 ; 
           TheEnd NONEWDIR ; 
         fi ;
      } ;
    done ;
}
#
function is_exec ()
{
  #
  # USAGE: is_exec <filename_0>...<filename_N>
  for file in $@ ;
    do {
         if [ -x $file ] ;
         then
           echo "#    Script $file has execute permissions ..." 1>&2 ;
         else
           echo "#    Setting execute permissions for $file ..." 1>&2 ;
           chmod a+x $file 2> /dev/null ;
         fi ;
      } ;
    done ;
}
#
function CheckFile ()
{
  #
  # USAGE: CheckFile <MODE(RWAE)> <filename_0>...<filename_N>
  mode="$1" ; shift ;
  case $mode in
    R|r) tst="-r" ; err="NOREADFILE"   ; msg="readable"  ;;
    W|w) tst="-w" ; err="NOWRITEFILE"  ; msg="writeable" ;;
    A|a) tst="-w" ; err="NOAPPENDFILE" ; msg="writeable" ;;
      *) tst="-e" ; err="NOFILE"       ; msg="found"     ;;
  esac; 
  for file in "$@" ;
    do {
      if [ -f $file -a $tst $file ] ;
         then
           echo "#    $file IS $msg ..." 1>&2 ;
         else
           echo "#    $file IS NOT $msg ..." 1>&2 ;
           TheEnd $err ;
         fi ;
      } ;
    done ;
}
@

<<BASH Functions: Handling large directories>>=
#
function mega ()
{
  #
  # USAGE: mega "<command> [<cmd_params>]" <input_dir> <pattern> [<output_dir>]
  # EXAMPLES:
  #           mega "mv -v" $IDIR "^chr2_" $ODIR/ori # moves all chr2_* files
  #           mega "ls -a" $IDIR "^[^.]*"           # lists all files (not .*)
  M_CMD="$1" ;
  I_DIR=`echo $2 | sed 's/\/$//'` ;
  X_PAT="$3" ;
  [ "$4" ] && O_DIR=`echo $4 | sed 's/\/$//'` || O_DIR='' ;
  ls -1 $I_DIR | egrep $X_PAT - | while read n ;
    do {
         [ "$O_DIR" ] && T_DIR="$O_DIR/$n" || T_DIR='' ;
         $M_CMD $I_DIR/$n $T_DIR ;
       } ;
    done;
}
#
@ 

<<BASH Functions: Filtering GENEID RAW Output>>=
#
# Script from gparra to retrieve GFF annotation from geneid big output
function geneid_raw2GFF ()
{
  # USAGE:  geneid_raw2GFF output_dir geneid_file
  # filtering geneid output (obtained with "-D" option -> default output+cDNA)
  PD=$1 ;
  /bin/rm -vf $PD/gff/* $PD/prot/* $PD/cds/* ;
  gawk 'BEGIN{ OFS="\t"; odir=ARGV[1]; ARGV[1]="" }
    { if ($2=="Sequence") seqname=$3;
      if ($2=="Gene") gene=$3;
      if (NF>8 && substr($1,1,1)!="#" && $1!="Annotation")
        print seqname,"geneid_v1.1",$1,$2,$3,$4,$5,$6,seqname"_"gene \
              > odir "/gff/" seqname"_"gene;
      if (substr($1,1,1)==">") {
        if (substr($1,length($1)-1,2)=="NN") {
          print ">"seqname"_"gene > odir "/cds/" seqname"_"gene;
          bol=1;
        } else if (substr($1,length($1)-1,2)=="AA") {
          print ">"seqname"_"gene > odir "/prot/" seqname"_"gene;
          bol=2;
        };
      } else {
        if (bol==1 && NF==1 && substr($1,1,1)!=">" ) 
          print $0 > odir "/cds/" seqname"_"gene;
      };
      if (bol==2 && NF==1 && substr($1,1,1)!=">" )
        print $0 > odir "/prot/" seqname"_"gene;
    }' $PD $2 ;
}
#
@

<<BASH Functions: Get Gene Number from GENEID Output>>=
#
# Counting gene number found in geneid output
function get_geneid_genes ()
{
  #
  # USAGE: get_geneid_genes geneid_out.gff > gene_list.rpt
  #
  gawk '{
      genes[$9]++;
      if (genes[$9]>1) {
        min[$9] = $4<min[$9] ? $4 : min[$9] ;
        max[$9] = $5>max[$9] ? $5 : max[$9] ;
      } else {
        min[$9] = $4 ;
        max[$9] = $5 ;
        strand[$9] = $7;
      };
      len[$9]+=$5-$4+1
    }
    END {
      for (n in genes) {
        print n, min[n], max[n], strand[n], len[n],genes[n];
      };
    }
  ' $1 | sort +1n +2n -3 - ;
}
#
@

<<BASH Functions: Gene-Prediction Evaluation>>=
#
# PREPARING EVALUATION STUFF
export GENEIDVERSION="geneid v1.1" ;
#
function run_evaluation ()
{
  #
  # USAGE:
  #     run_evaluation #chrom program param       prog_results_dir \
  #                    annotation_dir           testset  lenght
  # Ex: run_evaluation 22     geneid  Hsap.masked $ANALYSIS/geneid \
  #                    $DATASETS/annotation/all all ;
  #
  CHR="$1" ;
  prog="$2" ;
  PROG=`echo $prog | tr a-z A-Z` ;
  RUN="$3" ;
  BASE="$4" ;
  RESULTS="$BASE/gff/chr$CHR" ;
  SUBSET="$6" ;
  TESTSET="$5/chr$CHR" ;
  LENSEQ="$7";
  FINALTESTSET="/tmp/tmp$$" ;
  LONG_OUTPUT="$BASE/eval_$prog.$RUN.chr${CHR}_$SUBSET" ;
  SHORT_OUTPUT="$BASE/eval_${prog}_brief.$RUN.chr${CHR}_$SUBSET" ;
  GVER="------------------------- <${GENEIDVERSION}> -------------------------";
  # EVALUATION tool command-line options:
  #  -v: Verbose. Print all messages
  #  -a: Average. Print average stats (more than 1 sequence)
  #  -t: Total. Print total stats (more than 1 sequence)
  #  -s: Short. Print a short output
  # TEMPORAL FILE ADDING A RECORD WITH THE LENGHT OF THE SEQUENCE
  gawk "BEGIN{OFS=\"\t\";\
        print \"chr\"$CHR,1,\"Sequences\",1,$LENSEQ,\".\",\".\",\".\",1}\
        {print}" $TESTSET > /tmp/tmp$$;
  # /tmp/tmp$$ temporal file containing lenght+annotation gff records
  { echo "###" ; echo "### EVALUATION of $PROG RESULTS on CHR $CHR ($RUN)" ; echo "###" ;
    echo "### $LONG_OUTPUT" ; echo "###" ;
    echo "### "`whoami`" - "`date` ; echo "###" ;
    echo "### $GVER" ; echo "###" ; } > $LONG_OUTPUT ;
  $SGPBIN/evaluation -ta $RESULTS $FINALTESTSET >> $LONG_OUTPUT ;
  { echo "###" ; echo "### EVALUATION of $PROG RESULTS on CHR $CHR ($RUN)" ; echo "###" ;
    echo "### $SHORT_OUTPUT" ; echo "###" ;
    echo "### "`whoami`" - "`date` ; echo "###" ;
    echo "### $GVER" ; echo "###" ; } > $SHORT_OUTPUT ;
  $SGPBIN/evaluation -tsa $RESULTS $FINALTESTSET >> $SHORT_OUTPUT ;
}
#
@ 


\subsctn{Extracting code blocks for all the scripts}

Remember to set WORK variable at the very beggining, moving into the corresponding "[[/WORK/PATH/.../]]" directory and executing [[setcwd]] (a shell function that sets [[$WORK]] and sources [[.bash_VARS]]).

<<tangling>>=
#
# tangling all .*_VARS
notangle -R'tangling shell variables' $WORK/$nwfile.nw | bash ;
source $WORK/.bash_VARS ;
#
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
is_exec $WORK/nw2tex $WORK/ltx;
#
# tangling all param files
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling param files' $WORK/$nwfile.nw ; } | bash ;
#
# tangling all scripts
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling programs'    $WORK/$nwfile.nw ; } | bash ;
#
# tangling all steps
{ cat $WORK/.bash_VARS ;
  notangle -R'JOB COLLECTOR'        $WORK/$nwfile.nw ; } | bash ;
#
# updating LaTeX documents
$WORK/nw2tex ; $WORK/ltx ;
@ 

<<HIDE: >>=
pushd $TMP;
RM $TMP/.[eo]*/*;
$BIN/stepper.pl --debug 2> $TMP/.err/_ALL.err 1> $TMP/.out/_ALL.out
ipcrm sem ; ipcrm shm  
@ 

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
