% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% $Id: gff2aplot.nw,v 1.24 2001-11-23 19:28:49 jabril Exp $
%
\usepackage{noweb}
% noweb options
\noweboptions{smallcode,shortxref}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %
%
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
%\usepackage{colortbl}
\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
\usepackage{dcolumn}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
%\usepackage{fancyheadings}
%\usepackage{fancybox}
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
\usepackage{verbatim}
%\usepackage{version}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}
 
\input defs.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\ \vfill
%%\begin{center}
%%\textbf{\Huge A perl development for {\prog}}\\[5ex]
%%
%%\textbf{\Large Josep F. Abril}\raisebox{0.85ex}{\footnotesize$\,\dag$}\\[5ex]
%%
%%\textbf{\large --- \today ---}\\[10ex]
%%
%%\begin{abstract}
%%\begin{center}
%%\parbox{0.75\linewidth}{
%%I am trying to improve some aspects of the {\prog} utility that may be hard to solve in its old [[GNUawk]] format. Taking advantage of some capabilities of [[Perl]], such implemented quicksort sorting algorithm and the posibility of building complex data structures, will make the program faster and easier to maintain. Using [[noweb]] I pretend to improve the overall design and to open the code to other developers.
%%} % parbox
%%\end{center}
%%\end{abstract}\vskip 5ex
%%{\large$<$ \verb$Id: gff2aplot.nw,v 1.24 2001-11-23 19:28:49 jabril Exp $$>$ }
%%
%%\vfill
%%
%%\begin{flushright}
%%\scalebox{0.9 1}{\Large\textsl{\textbf{Genome Informatics Research Lab}}}\\
%%Grup de Recerca en Infom\`atica Biom\`edica\\
%%Institut Municipal d'Investigaci\'o M\`edica\\
%%Universitat Pompeu Fabra\\[2ex]
%%\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: \mtjabril}\\
%%\end{flushright}
%%\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

<<HIDE: LaTeX aplot new definitions>>=
%%%%% Colors for gff2ps
\input tables/AplotColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\subsubsubsctn}[1]{\paragraph{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\pa}[1]{{\footnotesize\textsf{$<$\textsl{#1}$>$}}}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
\item[$\triangleright$] [\textit{Section}~\ref{#2}, \textit{page}~\pageref{#2}]\\
              #1
} % newcommand todoitem
<<HIDE: new LaTeX commands>>
 
%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es}}
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\prog{\textsc{\textbf{gff2aplot}}}
\def\gps{\textsc{\textbf{gff2ps}}}
\def\gft{\textsc{\textbf{gfftools}}}
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
\def\eoline{$\backslash\backslash$}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\progname{gff2aplot.pl}
\def\tit{\textsc{\progname}}
%
\def\mtjabril{
 \htmladdnormallink{\texttt{jabril@imim.es}}
                   {MAILTO:jabril@imim.es?subject=[gff2aplot]}
 } % def mtjabril
\def\mttwiehe{
 \htmladdnormallink{\texttt{twiehe@ice.mpg.de}}
                   {MAILTO:twiehe@ice.mpg.de?subject=[gff2aplot]}
 } % def mttwiehe
\def\mtrguigo{
 \htmladdnormallink{\texttt{rguigo@imim.es}}
                   {MAILTO:rguigo@imim.es?subject=[gff2aplot]}
 } % def mtrguigo
%
\def\authorslist{
 Josep F. Abril   {\mdseries\small\dotfill \mtjabril } \\
 Thomas   Wiehe   {\mdseries\small\dotfill \mttwiehe } \\
 Roderic  Guig\'o {\mdseries\small\dotfill \mtrguigo } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF; Wiehe, T; Guig\'o, R % Other authors here...
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
{\prog} is a tool to visualize the alignment of two genomic sequences together with their annotations. Input to the program are single or multiple files in General Feature Format (GFF). Output is in PostScript format so the program serves to generate scalable print-quality images for comparative genomics sequence analysis.
 } % def progdesc 
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

@

<<HIDE: new LaTeX pstricks>>=
@
<<HIDE: new LaTeX definitions>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\begin{bfseries}
\begin{large}
\newlength{\lttbl}\setlength{\lttbl}{0.25\linewidth}
\newlength{\rttbl}\setlength{\rttbl}{0.70\linewidth}
%\fbox{
%\vskip 2ex
\begin{tabular}{>{\scshape}r@{\quad}l}
\rule{\lttbl}{0pt} & \rule{\rttbl}{0pt} \\[2ex]
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
Program Name: & {\Huge\progname}                       \\[3ex]
\multicolumn{2}{c}{\rule[0.5ex]{0.95\linewidth}{2pt}}\\[2ex]
     Authors: & {\Large
                 \begin{minipage}[t]{0.95\rttbl}
                 \authorslist
                 \end{minipage}}                       \\[2ex]
     License: & {\license}                             \\[2ex]
 Last Update: & {\today}                               \\[2ex]
 Description: & {\large\mdseries
                 \begin{minipage}[t]{0.95\rttbl}
                 \progdesc
                 \end{minipage}}                       \\[2ex]
\\
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
\end{tabular}
%} % fbox
\end{large}
\end{bfseries}
\end{center}

\vfill

\begin{raggedleft}
\showaffiliation
\end{raggedleft}

\end{titlepage}

%'%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage

\thispagestyle{empty}

\ % \vfill
% \hrulefill

\newpage
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\textbf{\prog}\hspace{4ex}\thesection.\ #1}} 
\renewcommand{\subsectionmark}[1]{\markboth{}{\textbf{\prog}\hspace{4ex}\thesubsection.\ \textsl{#1}}}

\tableofcontents

\clearpage

\listoftables

\listoffigures

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\label{todo:AAZ}
<<HIDE: new defs TODO>>=
\def\todoAAZ{Cite here Vista, PiP-maker, Dotter and other dotplot tools.} % todoAAZ
@
<<HIDE: TODO>>=
\todoitem{\todoAAZ}{todo:AAZ}
@
\todo{ \item \todoAAZ } % todo

<<HIDE: BiBTeX references>>=
@ 

\subsctn{Project description}

At the first stage of the new {\prog} implementation, we are going to define a simple main loop that performs a serial process, such in the old [[GNUawk]] version. So that, the program will read the input files and parameters defined by user and perform the plots, finishing the job. Once the new version will be operative, we will try to implement an iterative mode and/or a GUI in [[perlTK]].  

\label{todo:AAA}
<<HIDE: new defs TODO>>=
\def\todoAAA{Flow diagram (Serial/Filter mode) for figure~\ref{fig:filtermode}.} % todoAAA
@
<<HIDE: TODO>>=
\todoitem{\todoAAA}{todo:AAA}
@
\todo{ \item \todoAAA } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][6cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[``Filter'' mode of {\prog}.]{\label{fig:filtermode} Input, output and main code blocks are represented in this flowchart for the ``Filter'' mode of {\prog}.}
\end{center}
\end{figure}

\subsctn{Basic goals}

\begin{itemize}
\item I am trying to improve some aspects of the {\prog} utility that may be hard to solve in its old \texttt{GNUawk} format. Taking advantage of some capabilities of \texttt{Perl}, such implemented quicksort sorting algorithm and the posibility of building complex data structures, will make the program faster and easier to maintain, it will be more portable too. 

\item Using {\noweb} I pretend to improve the overall design and to open the code to other developers. From this {\LaTeX} document it should be possible to extract all the scripts and files needed for the current implementation.

\item \ldots 
\end{itemize}

\subsctn{Future extensions}

\begin{itemize}
\item An interactive (using text menus on xterms) mode.

\item A graphical interface (using [[perlTK]] maybe).

\item Web/CGI mode, looping through the interactive mode perhaps.

\item Move some code parts to perl packages, to share them with future implementations of [[gff2ps]]... (if we have time)

\item \ldots
\end{itemize}

\label{todo:AAB}
<<HIDE: new defs TODO>>=
\def\todoAAB{Flow diagram here (Interactive, Graphic and Web/CGI modes) for figure~\ref{fig:othermodes}.} % todoAAB
@
<<HIDE: TODO>>=
\todoitem{\todoAAB}{todo:AAB}
@
\todo{ \item \todoAAB } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Future modes of {\prog}.]{\label{fig:othermodes} Input, output and main code blocks are represented in this flowchart for the ``Interactive'', ``Graphic'' and ``Web/CGI'' versions of {\prog}.}
\end{center}
\end{figure}

\subsctn{TO DO: Unfinished stuff for current release}

\begin{itemize}
 \input todo.tex
\end{itemize}


\newpage

\sctn{Main program definition} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This is the {\prog} program outline:

<<APLOT>>=
<<PERL shebang>>
<<Program Info>>
#
# MODULES
#
<<Use Modules>>
#
# CONSTANTS
#
<<Global Constants>>
#
# VARIABLES
#
<<Global Vars>>
<<UNDEFINED VARS>>
#
# MAIN PROGRAM LOOP
#
<<Main Loop>>
#
# MAIN FUNCTIONS
#
<<Main Routines>>
#
# GENERAL FUNCTIONS
#
<<Common Routines>>
#
# POSTSCRIPT CODE
#
<<PostScript CODE Chunks>>
@ 

\subsctn{The main loop}

This is the main loop for the {\prog} ``Filter'' mode: 

<<Main Loop>>=

  # &set_default_vars;

  %CmdLineVars = ();            # Reseting Command-Line OPTIONS
  &parse_command_line;

  <<Basic common block for gfftools>>
  &make_plot;

  $total_time = &timing($T);
  &header("$PROGRAM HAS FINISHED","Timing: $total_time secs");
  
  &close_logfile();
  exit(0);
@ 

{\gft}, say here {\prog} and {\gps}, share many of the basic procedures, both must parse same format input files, must map the read fields to the customization variables and sort groups and their elements by acceptor site coord. That is the main reason for developing a module containing the definitions of such common functions.

<<Basic common block for gfftools>>=
%CustomVars = ();             # Reseting Customization OPTIONS
&parse_custom_files;

%Vars = ();
&merge_custom_vars;

%GFF_DATA = %ALN_DATA = (); # Reseting DATA
&parse_GFF_files;

&map_vars_data;

&sort_elements;

&set_page_vars;

@

We force that all the variables must be declared before using them and restrict unsafe constructs with'[[use strict]]'. After that we switch on signal trapping.

<<Use Modules>>=
use strict;
use vars qw/
     <<Pre-Declared Vars>>        
    /;
#
<<Trapping signals>>
#
@ 

% Typeglobs set to a referenced scalar forces a constant value for all execution
% They can only be set with 'local' (not 'my'), and must be de-referenced
% (say here $$T and $$F) so it is not woth using them for this little script.

<<Pre-Declared Vars>>=
$T $F $n $c
@

<<Global Constants>>=
($T,$F) = (1,0); # for 'T'rue and 'F'alse
@

Those are the main variables containing customization parameters and input data from GFF records. We split customization variables on three input classes: [[%DefaultVars]] to set default values and their type (what makes easy to check if a variable exists or not and if its given value has the expected format), [[%CmdLineVars]] for those parameters passed on command-line and [[%CustomVars]] which collects vaiables customization from external parameter files. Two temporary variables ([[%Defaults]] to initialize element variables and [[%Vars]] to provide the customization from command-line and parameter files to those element variables) allow us to merge all the information from these three variables and transfer to each GFF element in the GFF data variables ([[%GFF_DATA]] for annotations and [[%ALN_DATA]] for alignments).

<<Pre-Declared Vars>>=
%DefaultVars %CmdLineVars %CustomVars %Defaults %Vars %Order
%GFF_DATA %ALN_DATA
@ 

[[%ALN_DATA]] is set on section~\ref{sec:APLOThsh} (see page~\pageref{sec:APLOThsh}), [[%GFF_DATA]] is set on section~\ref{sec:GFFhsh} (see page~\pageref{sec:GFFhsh}), and [[%Order]] is set on section~\ref{sec:ORDERhsh} (see page~\pageref{sec:ORDERhsh}). 

Some info about the program itself.

<<Pre-Declared Vars>>=
$PROGRAM $VERSION $REVISION $REVISION_DATE $LAST_UPDATE
@ 
<<Global Constants>>=
($PROGRAM,$VERSION,$REVISION,$REVISION_DATE,$LAST_UPDATE) = 
   ( 'gff2aplot','v2.0',
     '$Revision: 1.24 $', #'
     '$Date: 2001-11-23 19:28:49 $', #'
     '$Id: gff2aplot.nw,v 1.24 2001-11-23 19:28:49 jabril Exp $', #'
    );
$REVISION =~ s/\$//og;
$REVISION_DATE =~ s/\$//og;
@  %$

<<UNDEFINED VARS>>=
@

\subsctn{Main function sections}

Main function calls share a similar internal structure: a '[[header]]' reporting which function is running, the '[[code]]' for that function and maybe a '[[closing report]]' summarizing what the function did. After each main function definition, you should find those constants, variables and routines being used by that function.  

<<Main Routines>>=
<<Setting Defaults>>
<<Parsing Command-Line Options>>
<<Parsing Custom Files>>
<<Parsing Input Data>>
<<Sorting Features>>
<<Features Setting>>
<<Layout Settings>>
<<Making PS Figures>>
@

\subsctn{Printing Help}

Here is shown the basic outline being diplayed when user choose the '[[help]]' command-line option. The '[[REQUIRES]]' section summarizes those perl modules used in this program by joining all the comments in this document under '[[<<requires help>>]]' tag. Similar happens to '[[COMMAND-LINE OPTIONS]]', in which the single descriptions for each option (that follows each option '[[Getopts]]' definition) are collected by the '[[<<command-line help>>]]' tag.

<<Main Routines>>=
sub prt_help() {
    open(HELP, "| more") ;
    print HELP <<"+++EndOfHelp+++";
PROGRAM:
                        $PROGRAM - $VERSION

    Converting GFF files for pairwise alignments to PostScript.

USAGE:        $PROGRAM [options] <GFF_files|STDIN>

DESCRIPTION:

    This program draws color-filled alignment plots from GFF
    files for that alignment and two sequences annotations.

REQUIRES:

    <<perl requires help>>

ENVIRONMENT VARIABLES:

    <<environment vars help>>

COMMAND-LINE OPTIONS:

    <<command-line help>>
    <<command-line help custom>>

    <<colors help>>

    <<pages help>>

BUGS:    Report any problem to 'jabril\@imim.es'.

AUTHORS:

            $PROGRAM is under GNU-GPL
         Josep Francesc ABRIL FERRANDO  
                 Thomas WIEHE                   
                Roderic GUIGO SERRA       

            Copyright (C) 1999-2001

+++EndOfHelp+++
    close(HELP);
    exit(1);
} # prt_help
@ %def &prt_help
%$

<<perl requires help>>=
$PROGRAM needs the following Perl modules installed in 
your system, we used those available from the standard 
Perl distribution. Those that are not in the standard 
distribution are marked with an '(*)', in such cases 
make sure that you already have downloaded them from 
CPAN (http://www.perl.com/CPAN) and installed.

@ %$

<<command-line help>>=
A double dash on itself "--" signals end of the options
and start of file names (if present). You can use a single
dash "-" as STDIN placeholder. Available options and a
short description are listed here:

<<command-line help prog>>
@


\newpage

\sctn{Variable Definition and Customization} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The functions described in this section process each GFF-record, each custom definition or each command-line options, not only loading the internal variables, also checking for the correctness of the user input in each case.

\label{todo:BBB}
<<HIDE: new defs TODO>>=
\def\todoBBB{Diagram for figure~\ref{fig:customvarstruc}:
Structure of main customization variables and their relationships.} % todoBBB
@
<<HIDE: TODO>>=
\todoitem{\todoBBB}{todo:BBB}
@
\todo{ \item \todoBBB } % todo
\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Structure of main customization variables]{\label{fig:customvarstruc} Structure of main customization variables: [[%DefaultVars]], [[%CmdLineVars]], [[%CustomVars]], [[%Defaults]], [[%Vars]]. Relationships among them and their interaction with [[%GFF_DATA]] and [[%ALN_DATA]] variables which contain data are also shown.}
\end{center}
\end{figure}

\subsctn{Setting customization parameters from defaults} 

The main difference from older versions, besides a cleaner hash structure than the GAWK one, is that we include some customization variables at sequence and strand levels. Almost all the variables are described in section~\ref{sec:customvardesc}, page~\pageref{sec:customvardesc}.

<<Setting Defaults>>=
sub set_default_vars() {
    %DefaultVars = (
        LAYOUT   => {           ## '# L #'
            <<default layout vars values>>
        },					  
        SEQUENCE => {           ## '# Q #'
            <<default sequence vars values>>
        },					  
        SOURCE   => {           ## '# S #'
            <<default source vars values>>
        },					  
        STRAND   => {           ## '# T #'
            <<default strand vars values>>
        },					  
        GROUP    => {           ## '# G #'
            <<default group vars values>>
        },					  
        FEATURE  => {           ## '# F #'
            <<default feature vars values>>
        },
    ); # %DefaultVars
    <<map default vars to defaults working copy>>
    print LOGFILE (Data::Dumper->Dump([ \%DefaultVars ],
                                   [ qw( *DefaultVars ) ]))
        if ($LogFile && $Debug);
} # set_default_vars
@ %def &set_default_vars
% print LOGFILE '>>> %DefaultVars : '.(Dumper(\%DefaultVars))

We also build from this structure, making easier variable maintenance because default value and variable type are edited together in [[%DefaultVars]] (as [[TYPE]]/[[VALUE]] pairs), an auxiliary variable which allows us to load default values into GFF elements.

\label{sec:tmpdefaults}
<<map default vars to defaults working copy>>=
%Defaults = ();
foreach my $sct (keys %DefaultVars) {
    foreach my $vnm (keys %{$DefaultVars{$sct}}) {
        $Defaults{$sct}{$vnm} = $DefaultVars{$sct}{$vnm}{'VALUE'};
	}; # foreach $vnm
}; # foreach $sct
@ 

\subsubsctn{Default customization files}

<<Global Vars>>=
my $Custom_path = defined($ENV{GFF2APLOT_CUSTOMPATH})
                  ? $ENV{GFF2APLOT_CUSTOMPATH} : '.';
my $Custom_file = defined($ENV{GFF2APLOT_CUSTOMFILE})
                  ? $ENV{GFF2APLOT_CUSTOMFILE} : '.gff2aplotrc';
$Custom_path =~ s{/$}{}o; 
@ 

We remove any trailing '[[/]]' from '[[$Custom_path]]' that user could have introduced to avoid any problem with full custom filenames later.

<<environment vars help>>=
    There are two environmental variables that can be set by 
users to their preferences:
 + You can specify the path where $PROGRAM can find the default
  files with the shell variable \"GFF2APLOT_CUSTOMPATH\". Default
  value is the path where you are running $PROGRAM.
 + You can also define the default custom filename you will like
  with the variable \"GFF2APLOT_CUSTOMFILE\", program default
  filename for custom file is \".gff2aplotrc\".
 + Now $PROGRAM does not need to write any temporary file, 
  so that previous versions default temporary directory path
  variable (\"GFF2APLOT_TMP\") is no longer used.
 + Setting those vars in Bourne-shell and C-shell:
   o Using a Bourne-Shell (e.g. bash):
        export GFF2APLOT_CUSTOMPATH=\"path\"
        export GFF2APLOT_CUSTOMFILE=\"file_name\"
   o Using a C-Shell:
        setenv GFF2APLOT_CUSTOMPATH \"path\"
        setenv GFF2APLOT_CUSTOMFILE \"file_name\"
@ %$


\subsctn{Setting customization parameters from command-line} 

'[[GetOptions]]' loads command-line options as key-value pairs in the hash variable '[[%CmdLineVars]]' 
that is reset in '[[<<Main Loop>>]]'. Once parsed all the command-line options what remains in '[[@ARGV]]' is just input filenames (which have to be in GFF format), or '[[STDIN]]' if there is none.

<<Parsing Command-Line Options>>=
sub parse_command_line() {
    <<looking for STDIN>>

    $SIG{__WARN__} = sub { &warn('UNKNOWN_CL_OPTION',$T,$_[0]) };
    GetOptions(
               <<command-line options prog>>
               <<command-line options>>
               <<command-line options custom>>
               <<command-line options with exit>>
               ) || (&warn('CMD_LINE_ERROR',$T), exit(1));
    $SIG{__WARN__} = 'DEFAULT';

    <<open LOGFILE>>

    &header('',"RUNNING $PROGRAM",'',"User: $USER","Date: $DATE");

    &header("SETTING DEFAULTS");
    %DefaultVars = ();
    &set_default_vars;

    &header("CHECKING COMMAND-LINE OPTIONS");
    @data_files = ();
    &set_input_file($cmdln_stdin);
    @ARGV = (); # ensuring that command-line ARGVs array is empty

    &set_custom_files();

    &check_command_line_vars();

    &footer("COMMAND-LINE CHECKED");
} # parse_command_line
@ %def &parse_command_line

As the '[[GetOptions]]' function has a problem, in the way we are using here to preserve backwards compatibility, when we want to use a single dash as a way to tell the program that '[[STDIN]]' must be read in the given order (when input filenames are also given and we would load input from a pipe after/before a given file). We show the warnings printed by the program when '[[--]]' is missing or missplaced in the table~\ref{tbl:STDINhandle}.

\begin{table}[!t]
\begin{center}
\begin{small}
\begin{tabular}{|c|}\hline
\begin{minipage}{15cm}
\begin{verbatim}

# CORRECT
> $BIN/gff2aplot -v -T 'Howdy World!' -- - DATA-SAMPLE.gff 
> $BIN/gff2aplot -v -T 'Howdy World!' -- DATA-SAMPLE.gff -

# WRONG???
> $BIN/gff2aplot -v -T 'Howdy World!' DATA-SAMPLE.gff -
> $BIN/gff2aplot -v -T 'Howdy World!' - DATA-SAMPLE.gff
> $BIN/gff2aplot -v -T 'Howdy World!' - -- tests/DATA-SAMPLE.gff

# COMMON MESSAGE when WRONG
### WARNING ### Error trapped while processing command-line:
                substr outside of string at lib/Getopt/Long.pm
                  (autosplit into lib/auto/Getopt/Long/FindOption.al)
                line >NNNNN<
### WARNING ### Error trapped while processing command-line:
                Use of uninitialized value at lib/Getopt/Long.pm
                  (autosplit into lib/auto/Getopt/Long/FindOption.al) 
                line >NNNNN<
### WARNING ### Error trapped while processing command-line:
                Unknown option:

\end{verbatim}
% $
\end{minipage}\\\hline
\end{tabular}
\end{small}
\caption[Fixing [[GetOptions]] for using '[[-]]' as '[[STDIN]]' mark.]{\label{tbl:STDINhandle} Errors reported when using '[[-]]' as '[[STDIN]]' mark and fixed width [[<<looking for STDIN>>]].}
\end{center}
\end{table}

To avoid such errors, we capture the single dash when present in the command-line arguments list. 

'[[$cmdln_stdin]]' will be used by '[[&set_input_file]]' function to include the '[[STDIN]]' in the correct ordering.\label{sec:stdinfix}

<<looking for STDIN>>=
my $cmdln_stdin = undef;
for (my $a = 0; $a <= $#ARGV; $a++) { 
    next unless $ARGV[$a] =~ /^-$/o;
    $cmdln_stdin = $a - $#ARGV;
    splice(@ARGV,$a,1);
};    
@ 

The following two code chunks define what to do if reports are sent to a file which is set in '[[$logs_filename]]'.

<<open LOGFILE>>=
CHKLOG:
  (defined($logs_filename)) && do {
      open(LOGFILE,"> ".$logs_filename) ||
          (&warn('FILE_NO_OPEN',$T,$logs_filename),last CHKLOG);
      $LogFile = 1;
  };
@

<<Common Routines>>=
sub close_logfile() { close(LOGFILE) if $LogFile };
@ %def &close_logfile

<<Use Modules>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
@ 

<<perl requires help>>=
"Getopt::Long" - processing command-line options.
@

See '[[man Getopt::Long]]' for further info about this package.

<<Global Vars>>=
my ($Debug,$Verbose,$Quiet,$LogFile,$logs_filename) = ($F,$F,$F,$F,undef);
@ 

<<warnings - parsing command-line options>>=
UNKNOWN_CL_OPTION =>
  $Warn."Error trapped while processing command-line:\n".(" "x16)."\%s\n",
CMD_LINE_ERROR =>
  $spl.$spw." Please, check your command-line options!!!\n".$Error."\n".
  $spw." ".("."x12)." Type \"$PROGRAM -h\" for help.\n".$spl,
@

\subsubsctn{Special command-line options (forcing exit from program)}

The first command-line checking looks for those options exiting the program: '[[help]]' and '[[version]]'. Both need to output to screen without any other message/warning being displayed at the same time.

<<command-line options with exit>>=
"version"   => \&prt_version, 
"h|help|?"  => \&prt_help,
@ 
<<command-line help prog>>=
-h, --help   Shows this help.
--version    Shows current version and exits.
@
<<DESC command-line options>>=
ORD: 1
OPT: h
LNG: help
SDE: Shows this help.
LDE:
Shows command-line help.
###EOR###
ORD: 2
LNG: version
SDE: Shows current version and exits.
LDE:
Shows current program version and exits.
###EOR###
@ 


<<Parsing Command-Line Options>>=
sub prt_version() {
    my $comment = $Messages{'SHOW_VERSION'};
    $comment = sprintf($comment,$PROGRAM,$VERSION);
    &prt_to_stderr($comment);
    exit(1);
} # prt_version
@ %def &prt_version

<<messages - parsing command-line options>>=
SHOW_VERSION =>
  $sp."### \%s -- \%s\n".$sp,
@

\subsubsctn{Testing command-line input filenames}

<<Parsing Command-Line Options>>=
sub set_input_file() {
    my $stdin_flg = $F;
    <<STDIN backwards compatibility>>
    &report("CHECKING_FILENAMES");
  FILECHK: foreach my $test_file (@ARGV) {
        $test_file ne '-' && do {
            -e $test_file || do {
                &warn('FILE_NO_OPEN',$T,$test_file);
                next FILECHK;
            };
            &report('READING_FILE',$test_file);
            push @data_files, $test_file;
            next FILECHK;
        };
        $stdin_flg = $T;
        push @data_files, '-';
	}; # foreach
    scalar(@data_files) == 0 && do {
        push @data_files, '-';
        $stdin_flg = $T;
    };
    $stdin_flg && &report('READING_STDIN');
} # set_input_file
@ %def &set_input_file

<<Global Vars>>=
my (@data_files,$file);
@ 

<<warnings - input/output>>=
FILE_NO_OPEN =>
  $spl.$Warn."Cannot Open Current file \"\%s\" . Not used !!!\n".$spl,
@

<<messages - input/output>>=
CHECKING_FILENAMES =>
  $sp."### Validating INPUT FILENAMES\n".$sp,
READING_FILE =>
  "###---> \"\%s\" exists, including as Input File.\n",
READING_STDIN =>
  "###---> Including GFF records from standard input.\n",  
@

Here is the fix for the explained in section~\ref{sec:stdinfix} on page~\pageref{sec:stdinfix} ([[<<looking for STDIN>>]] code).

<<STDIN backwards compatibility>>=
my $chk_stdin = shift @_;
my $t = scalar(@ARGV);
defined($chk_stdin) && do {
    abs($chk_stdin) > $t && ($chk_stdin = -$t);
	$chk_stdin > 0  && ($chk_stdin = 0 );
    $t += $chk_stdin;
    splice(@ARGV,$t,0,'-');
};
@

\subsubsctn{Verifying command-line settings}

<<HIDE: DONE>>=
\doneitem{20011023}{Implement [[&check_command_line_vars]] to verify if settings from command-line are OK.}
@

As we reset [[%CmdLineVars]] in main loop we do not need to take care for those key-value pairs that were not defined by [[GetOptions]] function. We will check for two kinds of command-line variables, those having a specific command-line option (and related to [[LAYOUT]] variables) and those that define a feature-specific variable (for GFF-features, groups, sequences and so on). Last ones are validated and set in the following section. Therefore, if layout variables are provided on command-line by this way, they have precedence over the corresponding layout pre-defined command-line option. 

<<Parsing Command-Line Options>>=
sub check_command_line_vars() {
    &report("CHECKING_CMDLN_VARS");
    &command_line_for_layout();
    defined($CmdLineVars{VARS}) &&
        &command_line_for_vars();
    &footer("COMMAND-LINE OPTIONS CHECKED");
} # check_command_line_vars
@ %def &check_command_line_vars

<<messages - input/output>>=
CHECKING_CMDLN_VARS =>
  $sp."### Checking COMMAND-LINE Settings\n".$sp,
@ 

Here we take advantage of the [[&varscheck]] function, that was created to validate input from [[&parse_custom_files]], and that is described in section~\ref{sec:paramvalid}, page~\pageref{sec:paramvalid}.

<<Parsing Command-Line Options>>=
sub command_line_for_layout() {
    $n = 0;
    foreach my $cvar (keys %{ $CmdLineVars{LAYOUT} }) {
        my @cary = ('LAYOUT',$cvar,$CmdLineVars{LAYOUT}{$cvar});
        $c = &varscheck($F,'LAYOUT',\@cary,\%CmdLineVars) ? '.' : $noCV;
        &counter(++$n,$c);
	}; # foreach $cvar
    &counter_end($n,$c);
} # command_line_for_layout
@ %def &command_line_for_layout

\subsubsctn{Loading GFF elements custom variables from command-line}

<<HIDE: DONE>>=
\doneitem{20011023}{
Parsing and loading command-line options having structure like:\\
\centerline{[[--feature feature_name::variable_name=value]]}
}
@

<<Parsing Command-Line Options>>=
sub command_line_for_vars() {
    $n = 0;   
    foreach my $calias ( qw/ L Q S T G F / ) {
        my ($cvar,$cflg);
        $cvar = $VarKeys{$calias};
        $cflg = ($calias ne 'L') ? $T : $F;
        defined($CmdLineVars{VARS}{$cvar}) && do {
            foreach my $ccv (@{ $CmdLineVars{VARS}{$cvar} }) {
                my @clin = ();
              TWOTHREE: {
                  $cflg && do {
			      	  $ccv =~ /^(.*?):{2}(.*?)={1}(.*?)$/o &&
                              (@clin = ($1,$2,$3));
			      	  last TWOTHREE;
			      };
                  $ccv =~ /^(.*?)={1}(.*?)$/o && (@clin = ($cvar,$1,$2));
		        }; # TWOTHREE
                $c = &varscheck($cflg,$cvar,\@clin,\%CmdLineVars)
                     ? $calias : $noCV;
                &counter(++$n,$c);
            }; # foreach $ccv
        }; # $CmdLineVars{VARS}{$cvar}
	}; # foreach $calias
    &counter_end($n,$c);
} # command_line_for_vars
@ %def &command_line_for_vars

<<command-line options custom>>=
"layout-var=s@"   => \@{ $CmdLineVars{VARS}{LAYOUT} },
"sequence-var=s@" => \@{ $CmdLineVars{VARS}{SEQUENCE} },
"source-var=s@"   => \@{ $CmdLineVars{VARS}{SOURCE} },
"strand-var=s@"   => \@{ $CmdLineVars{VARS}{STRAND} },
"group-var=s@"    => \@{ $CmdLineVars{VARS}{GROUP} },
"feature-var=s@"  => \@{ $CmdLineVars{VARS}{FEATURE} },
@ 
<<command-line help custom>>=
  --layout-var '<variable=value>'
--sequence-var '<sequence::variable=value>'
  --source-var '<source::variable=value>'
  --strand-var '<strand::variable=value>' 
   --group-var '<group::variable=value>'
 --feature-var '<feature::variable=value>'
         Loading a feature/group/strand/source/sequence/layout
         customization variable from command-line. You can set
         several variables by repeating any of these options, 
         i.e.:
               ... --feature-var cds::shape=box \
                   --feature-var cds::feature_color=blue ... 
@
<<HIDE: command-line latex short custom>>=
\rw{-\/-feature-var '\pr{feature::variable=value}'}
  {Set a feature customization variable from command-line.}
\rw{-\/-group-var '\pr{group::variable=value}'}
  {Set a group customization variable from command-line.}
\rw{-\/-strand-var '\pr{strand::variable=value}'}
  {Set a strand customization variable from command-line.}
\rw{-\/-source-var '\pr{source::variable=value}'}
  {Set a source customization variable from command-line.}
\rw{-\/-sequence-var '\pr{sequence::variable=value}'}
  {Set a sequence customization variable from command-line.}
\rw{-\/-layout-var '\pr{variable=value}'}
  {Set a layout customization variable from command-line.}
@ 
<<HIDE: command-line latex custom>>=
\clmitem{-\/-feature-var '\pr{feature::variable=value}'}
Loading a customization variable for a GFF feature element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-group-var '\pr{group::variable=value}'}
Loading a customization variable for a GFF group element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-strand-var '\pr{strand::variable=value}'}
Loading a customization variable for a GFF strand element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-source-var '\pr{source::variable=value}'}
Loading a customization variable for a GFF source element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-sequence-var '\pr{sequence::variable=value}'}
Loading a customization variable for a GFF sequence element from command-line. % '\pr{custom\_file}'. 
\clmitem{-\/-layout-var '\pr{variable=value}'}
Loading a customization variable for page layout from command-line. % '\pr{custom\_file}'. 
@

\subsctn{Setting customization parameters from files} 

Here we define the command-line option for loading customization files. Setting '[[C|custom-filename=s@]]' allows us to pass more than one custom file within the same command-line. Must be noted that latest file customization variables will override the previous ones.

<<command-line options custom>>=
"C|custom-filename=s@"  => \@custom_files,
@ 
<<command-line help custom>>=
-C, --custom-filename <filename>
      Loading customization parameters from a given file (if 
      default \".gff2aplotrc\" exists is loaded before it).
@
% If ORD is not defined then description is placed at the end of the description files.
<<DESC command-line options>>=
ORD: 
OPT: C
LNG: custom-filename
PAR: <filename>
SDE: Read customization parameters from file.
LDE:
Loading customization parameters from <filename>. Now you can load 
several customization files by passing this option several times. The 
precedence is the input order in the command-line, so, for the common 
definitions, the last |custom_file| will override previous |custom_files| 
settings. If default customization file "\texttt{.gff2aplotrc}" does exist,
it is the first customization that is loaded by the program.
###EOR###
@ 


\subsubsctn{Testing whether custom-files exist}

Customization parameters cannot be set from '[[STDIN]]'. What program does first of all, is to look whether default custom file does exist or not ([[$Custom_file]] was set from environment variable if [[GFF2APLOT_CUSTOMFILE]] was defined on the current shell). But we are taking advantage of the fact that we also have to check existence of the command-line custom files (if given), so we insert as first element of the array the default custom file to the variable '[[@custom_files]]' and then we check all its elements with the same function. We look for these files in current path and if they are not found in '[[$Custom_path]]'.

<<Parsing Custom Files>>=
sub set_custom_files() {
	unshift @custom_files, $Custom_file;
    my @files = ();
    &report("CHECKING_CUSTOM_NAMES");
  MLOOP: foreach my $test_file (@custom_files) {
      FILECHK: {
        -e $test_file && last FILECHK;
        ($test_file =~ m{/}og || $Custom_path eq '.') || do {
            my $tmpfl = $test_file;
			$test_file = "$Custom_path/$test_file";
            &report('READING_FROM_PATH',$tmpfl,$test_file);
            -e $test_file && last FILECHK;
        };
        scalar(@custom_files) == 1 && do {
            &report('NO_CUSTOM_FILES',$T);
            last MLOOP;
		};
        &warn('FILE_NO_OPEN',$T,$test_file);
        next MLOOP;
	  }; # FILECHK
        &report('READING_CUSTOM_FILE',$test_file);
        push @files, $test_file;
	}; # MLOOP: foreach
	@custom_files = @files;
} # set_custom_files
@ %def &set_custom_files

<<Global Vars>>=
my @custom_files = ();
@ 

<<messages - input/output>>=
CHECKING_CUSTOM_NAMES =>
  $sp."### Validating CUSTOM FILENAMES\n".$sp,
READING_FROM_PATH =>
  "###---> Custom File NOT FOUND in local path: \"\%s\"\n".
  "###     Trying to find in \"GFF2APLOT_CUSTOMPATH\": \"\%s\"\n",
READING_CUSTOM_FILE =>
  "###---> \"\%s\" exists, including as Custom File.\n",
NO_CUSTOM_FILES =>
  "###---> NO CUSTOM FILES found. Using program DEFAULTS.\n",
@

\subsubsctn{Parsing customization files}

Layout variables are defined as two fields, variable name and value, while the other variables require three fields, a feature to which is set the variable to the given value. To validate input records, '[[$var_flag]]' boolean will determine whether a two fields or a three fields record we currently are going to process. '[[&varscheck]]' function not only checks the customization parameters for correctness but also loads '[[%CustomVars]]' hash.

<<Parsing Custom Files>>=
sub parse_custom_files() {
    &header("READING CUSTOM FILES");
  MAIN: {
      scalar(@custom_files) == 0 && do {
          &report('NO_CUSTOM_FOUND',$file);
		  last MAIN;
	  };
    LOAD: foreach $file (@custom_files) {
        open(THIS,"< $file") ||
            ( &warn('FILE_NO_OPEN',$T,$file), next LOAD);
        &report('READ_CUSTOM_FILE',$file);
        ($n,$c) = (0,undef);
        while (<THIS>) {
            my (@line,$main,$_c,$_v,$v_flag);
		    /^\#/o && do {
                /^\# ([LQSTGF]) \#/o && do { 
                     $_c = $1; $c = '*';
                     $v_flag = ($_c ne 'L') ? $T : $F;
                     $_v = $VarKeys{$_c};
                     next;
                };
				$c = '.'; next;
            };
            ($c = '.', next) if /^\s*$/o;
            chomp;
            ($main,undef) = split /\b\s+\#/o;
          TWOTHREE: {
              $v_flag && do {
				  $main =~ /^(.*?):{2}(.*?)={1}(.*?)$/o &&
                           (@line = ($1,$2,$3));
				  last TWOTHREE;
			  };
              $main =~ /^(.*?)={1}(.*?)$/o && (@line = ($_v,$1,$2));
		  }; # TWOTHREE
            $c = &varscheck($v_flag,$_v,\@line,\%CustomVars) ? $_c : $noCV;
        } continue {
            &counter(++$n,$c) if ($Verbose && !$Quiet);
        }; # WHILE
        &counter_end($n,$c) if ($Verbose && !$Quiet);
        close(THIS);
    }; # LOAD
  }; # MAIN
    print LOGFILE (Data::Dumper->Dump([ \%CustomVars ],
                                   [ qw( *CustomVars ) ]))
        if ($LogFile && $Debug);
    &footer("CUSTOM FILES LOADED");
} # parse_custom_files
@ %def &parse_custom_files
% print LOGFILE '>>> \%CustomVars : '.(Dumper(\%CustomVars))

\begin{table}[!t]
\begin{center}
\begin{tabular}{cc}
\fbox{
\begin{tabular}[b]{c>{\bfseries}c}
\textbf{Record TYPE} & \textbf{Symbol} \\
Empty record            & . \\
Comment                 & . \\
Header (\# [LQSTGF] \#) & * \\
Layout Vars             & L \\
Sequence Vars           & Q \\
Source Vars             & S \\
Strand Vars             & T \\
Group Vars              & G \\
Feature Vars            & F \\
Unknown                 & ? \\
\end{tabular}
} %fbox
&
\parbox[b]{0.4\linewidth}{
\caption[Symbols used to report record type from custom files]{\label{tbl:CFkeysXreport} Symbols used to report record type when parsing customization files (and [[STDERR]] verbose mode is enabled with '[[-v]]' switch).}
} % parbox
\\
\end{tabular}
\end{center}
\end{table}

<<Pre-Declared Vars>>=
%VarKeys $noCV
@ 
<<Global Constants>>=
$noCV = '?';
%VarKeys = (
    L => 'LAYOUT',
    Q => 'SEQUENCE',
    S => 'SOURCE',
    T => 'STRAND',
    G => 'GROUP',
    F => 'FEATURE',
    );
@ 

<<messages - parsing custom files>>=
READ_CUSTOM_FILE => 
  $sp."### Reading Customization Parameters from \"\%s\"\n".$sp,
NO_CUSTOM_FOUND =>
  $sp."### NO CUSTOM FILES found: Using program DEFAULTS.\n".$sp,
@

\label{todo:BGA}
<<HIDE: new defs TODO>>=
\def\todoBGA{Include an ``XTRA'' section to custom files for ``markup'' shapes definition (box, circle, label, and so on).} % todoBGA
@
<<HIDE: TODO>>=
\todoitem{\todoBGA}{todo:BGA}
@
\todo{ \item \todoBGA } % todo


\subsubsctn{Validating customization parameters} 
\label{sec:paramvalid}

'[[$rec]]' is a reference to an array that contains three elements: feature, variable and value. First we check if variable name is defined in , then we check if the given value matches the variable type. After that we analyse the feature element, testing if it is a regular expression or not. We have slightly modified ths function to be able to process input from [[&parse_custom_files]] and [[&check_command_line_vars]], we pass by reference the main hash variable that must be loaded with the data being parsed ([[%CustomVars]] and [[%CmdLineVars]] respectively).

<<Parsing Custom Files>>=
sub varscheck() {
    my ($flag,$class,$rec,$varec) = @_;
    defined($DefaultVars{$class}) || 
        (&warn('SECTION_NOT_DEF',$F),return $F);
	my $_var = \%{$DefaultVars{$class}};
    defined($$rec[2]) || return $F;
    defined($_var->{$$rec[1]}) || 
        (&warn('VAR_NOT_DEFINED',$F,$class,$$rec[1]),return $F);
    &checkvarvalues($_var->{$$rec[1]}{'TYPE'},\$$rec[2],$$rec[1]) || return $F;
    $flag && do {
        my @tmpary = ();
        defined(@{ $varec->{$class}{$$rec[1]} }) || do {
            @{ $varec->{$class}{$$rec[1]} } = ();
        };
        @tmpary = &find_regexp($$rec[0]);
        (shift @tmpary) || return $F;
        push @{ $varec->{$class}{$$rec[1]} }, 
             ( @tmpary, $$rec[2] );
        return $T;
	};
    $varec->{$class}{$$rec[1]} = $$rec[2];
    return $T;
} # varscheck
@ %def &varscheck

\label{sec:DATAtriadarray}
For the same variable name, say here [[ $$rec[1] ]], we will have more than one setting (for the same element or not). This requirement force us to save element-value pairs (and a third field which tells us if element contains a regular expression that must not to be matched or not). The array will preserve the input ordering of each new setting for the same variable. We want this behaviour, as the global definitions must precede specific ones in the custom files. 

<<warnings - parsing custom files>>=
SECTION_NOT_DEF =>
  $Warn."You probably forgot a section header, unable to parse this record.\n",
VAR_NOT_DEFINED =>
  $Warn."\%s variable not defined: \"\%s\" .\n",
@

Different data requires different value tests, another function of those tests is to normalize when needed variable values to fixed internal values, so this will avoid later checkings or functions for reformating them and writing functions
will be simplest.

<<Parsing Custom Files>>=
sub checkvarvalues() {
	my ($_test,$_val,$_var) = @_;
    my $_t = lc($$_val);
    defined($TESTS{$_test}) || do {
        &warn('VARTYPE_NOT_DEFINED',$T,$_test,$_var);
        return $F;
    }; # !defined($TESTS->{$_test})
    return $TESTS{$_test}->($_val,$_var,$_t);
} # checkvarvalues
@ %def &checkvarvalues

<<warnings - parsing custom files>>=
VARTYPE_NOT_DEFINED =>
  $Error."Variable type \"\%s\" not defined,\n".
  $spw."  could not check value for \"\%s\".\n",
@

The following hash keys serve as references to annonymous functions, each one defining a single test for the variable value passed by reference and modifying it if needed. [[%Fonts]] is set on section~\ref{sec:FontsHsh} (page~\pageref{sec:FontsHsh}), [[%COLORS]] is set on section~\ref{sec:ColorsHsh} (page~\pageref{sec:ColorsHsh}), [[%FORMATS]] is set on section~\ref{sec:FormatsHsh} (page~\pageref{sec:FormatsHsh}), [[%Messages]] is set on section~\ref{sec:MessagesHsh} (page~\pageref{sec:MessagesHsh}) and [[%UNITS]] is set on section~\ref{sec:UnitsHsh} (page~\pageref{sec:UnitsHsh}).

<<Pre-Declared Vars>>=
%TESTS %Fonts %COLORS $colors %FORMATS $formats %Messages %UNITS
@ 
<<Global Vars>>=
%TESTS = (
    <<variable value checking>>
    );
@ 

\subsctn{Deciphering element fields}

If an [[element]] appears not to be a regular expression we transform it
to '[[^element$]]' before returning it. [[$not_flg]] and [[$id_flg]]
will be set to a true value in case that input string contains a
'[[!]]' as first character ([[!element]],[[!/regexp/]], [[!/regexp/@id]] and
[[!*]]) and that an ID is given ([[element@id]], [[/regexp/@id]] and
[[!/regexp/@id]]), respectively. Both flags will be helpful to
determine what test we have to perform in order to know if we have to
set the variable value for a GFF element (see
section~\ref{sec:mapcustoms}, page~\pageref{sec:mapcustoms}). For
[[$id_flg]], the true value will consist on the feature identifier, so
that we do not need to introduce a new field in the array.

<<Parsing Custom Files>>=
sub find_regexp() {
    my $string = $_[0];
    my ($isOK_flg,$not_flg,$id_flg,$tmpstr,$tmpid);
    $isOK_flg = $T;
    $not_flg = $F;
    $id_flg = undef;
    $string =~ s{^!}{}o && ($not_flg = $T); # not_regexp is true
    $string =~ s{(\\@)$}{@@}o; # scaping trailing '@' (if element ends with) 
    $string = &escape_input($string);
    ($tmpstr, $tmpid) = (undef, undef);
    ( reverse($string) =~ m{^([^\/@]*?)(?:@){1}(.*)$}o ) && do {
        $tmpstr = reverse($2);
        $tmpid  = reverse($1);
    }; # reverse($string)
    (defined($tmpid)  && $tmpid  ne "") && ($id_flg = $tmpid);
    (defined($tmpstr) && $tmpstr ne "") || do {
        $string eq '@' && ($isOK_flg = $F);
        $tmpstr = $string;
    }; # (defined($tmpstr) && $tmpstr ne "")
  REGEXPS: {
      <<does string contain a regular expression>>
    }; # REGEXPS
    $isOK_flg && do {
        eval { "" =~ m{$string}; } || do {
            $isOK_flg = $F;
        }; # check if final regexp string is OK
    }; # $isOK_flg
    $isOK_flg || do {
        &warn('BAD_REGEXP',$F,"$string");
        $string = "";
    }; # NOT $isOK_flg
    return ($isOK_flg, $not_flg, $id_flg, $string);
} # find_regexp
@ %def &find_regexp

<<warnings - parsing custom files>>=
BAD_REGEXP =>
  $Warn."Ill-formed regular expression found in custom file:\n".
  $spw." ---> \%s <---\n",
@

Two steps are needed for parsing element fields. We must ensure first
that there is an [[@id]] feature delimiter in the element field and,
after removing that delimiter, check if we have a regular expression
or not. The easiest way to extract any trailing 'id' substring from
element field is using a sexeger, a reversed regular expression
\footnote{Further information on sexeger (reversed regexes) can be
found at \url|http://www.perl.com/pub/2001/05/01/expressions.html| and
\url|http://www.pobox.com/~japhy/|.}

<<does string contain a regular expression>>=
$tmpstr eq '*' && do {
    $string = '^.*$'; #'
    last REGEXPS;
}; # $string eq '*'
$tmpstr =~ m{^/(.*)/$}o && do {    
    ($string, $isOK_flg) = &eval_regexp($1);
    last REGEXPS;
}; # $tmpstr is a regexp
# ($tmpstr =~ m{^/.*[^/]$}o || $tmpstr =~ m{^[^/].*/$}o) && do {
#     $isOK_flg = $F;  
#     last REGEXPS;
# }; # $tmpstr is a bad defined regexp
$string = '^'.(quotemeta($tmpstr)).'$'; #' 
@ 

<<Parsing Custom Files>>=
sub eval_regexp() {
    my $str = $_[0];
    my $flag;
    eval { "" =~ m{$str}; $flag = $T; } || ($flag = $F);
    return ($str, $flag);
} # eval_regexp
@ %def &eval_regexp

From a list of possible tainted shell metacharacters, \\[1ex]
\centerline{[[ ; < > * | & $ ! ? # ( ) [ ] { } : ` ' " \ ]]}\vskip 0.5ex
% # @_ =~ s/([;<>\*\|`&\$!?#\(\)\[\]\{\}:'"\\])/\\$1/g;
we quote those that are not going to be used as regular expression metacharacters, \\[1ex]
\centerline{[[ ; < > & ! { } ` ' " ]]}\vskip 0.5ex % "'`
to avoid security issues. This will make a CGI developed on {\prog} a little bit more secure because the user cannot send something like:\\[1ex]
\centerline{\shortstack{[[//; `/bin/rm -rf`;//]]\ \ \ ,\\[[/ @{[ system('mail user@server /etc/passwd') ]} /]]\ \ \ or\\[[/ ${ \( exec('chmod -R 0777 /root') ) } /]]}} %$

<<Parsing Custom Files>>=
sub escape_input() {
    my $var = $_[0];
    $var =~ s{([;,<>&!\{\}`'"])}{\\$1}g; #"'`
    return $var;
} # escape_input
@ %def &escape_input


\subsctn{Customization variable values validation}

This section is dedicated to those test we need to ensure that customization variables contain acceptable values, so we do not need to check them later in the program. Table~\ref{tbl:varformats} summarizes the variable types defined for customization parameters.

\begin{table}[!t]
\begin{center}
\fbox{
\begin{tabular}{cl}
[[BOOLEAN]]  & A true/false variable.\\
[[ALPHA]]    & A string set as '[[ [a-zA-Z][a-zA-Z_0-9]* ]]'.\\
[[STRING]]   & A free text character string.\\
[[NATURAL]]  & A positive integer (nor decimals neither sign).\\
[[INTEGER]]  & Positive or negative integers.\\
[[FLOAT]]    & Numbers with decimal values (subset of reals).\\
[[REAL]]     & Any real number (including scientific notation).\\
[[COLOR]]    & Available colors are defined in '[[%COLORS]]' hash.\\
[[FONT]]     & A {\ps} font from those defined in '[[%Fonts]]' hash.\\
[[BBOX]]     & '[[<width>,<height>]]' pair (in [[PS_UNIT]] units).\\
[[PAGE]]     & Page sizes are set in '[[%FORMATS]]' variable.\\
[[SEQ_UNIT]] & A numeric value with nucleotide units (Gb, Mb, Kb or bases).\\
[[PS_UNIT]]  & A numeric value with {\ps} units (pt, cm, mm or in).\\
[[RANGE]]    & A '[[lower-limit..upper-limit]]' numeric pair.\\
[[PSRANGE]]  & A '[[lower-limit..upper-limit]]' {\ps} lengths pair.\\
[[SEQRANGE]] & A '[[lower-limit..upper-limit]]' sequence coords pair.\\
\end{tabular}
} % fbox
\caption[Customization parameters available formats]{\label{tbl:varformats} Parameter available formats we are going to use for customization variables checking.}
\end{center}
\end{table}
 
<<HIDE: DONE>>=
\doneitem{20011107}{Maybe [[UNITS]] instead of [[FONT_SZ]] will have broader applicability.}
@

\label{todo:BBE}
<<HIDE: new defs TODO>>=
\def\todoBBE{
More format variables need to be defined, such as: [[SHAPES]] from a shapes array, [[LINES]]/[[LINESTYLES]] (none, dotted, dashed, solid/default), [[GROUP-BRACKETS]] (bracket, arrow, half-arrow, dotted-bracket --with vertical dotted lines at both ends like conecting to baseline--).
} % todoBBE
@
<<HIDE: TODO>>=
\todoitem{\todoBBE}{todo:BBE}
@
\todo{
 \item \todoBBE
 } % todo

\subsubsctn{Handling sequence and {\ps} units}

Here we define the annonymous functions that will provide units exchange to points ({\ps} units) or nucleotides (sequence units).
\label{sec:UnitsHsh}

<<Global Vars>>=
%UNITS = (
    <<units exchange functions>>
    );
@

<<Pre-Declared Vars>>=
$kilo $mega $giga $cm2pt $mm2pt $in2pt
@

Those units are used in layout/font-size lengths setting:

<<Global Constants>>=
($cm2pt,$mm2pt,$in2pt) = (28.35,2.835,72);
@ 
<<units exchange functions>>=
"pt"  => sub ($) { return $_[0] },
"mm"  => sub ($) { return $_[0] * $mm2pt },
"cm"  => sub ($) { return $_[0] * $cm2pt },
"in"  => sub ($) { return $_[0] * $in2pt },
@ 

Those allow to recover base-pair nucleotide coords for sequence related calculations:

<<Global Constants>>=
($kilo,$mega,$giga) = (10**3,10**6,10**9);
@
<<units exchange functions>>=
"bp"  => sub ($) { return $_[0] },
"kbp" => sub ($) { return $_[0] * $kilo },
"mbp" => sub ($) { return $_[0] * $mega },
"gbp" => sub ($) { return $_[0] * $giga },
@

As you can note, we have defined a function to convert from gigabases, but at this moment {\ps} can only handle numbers smaller than $2.1*10^9$ and {\prog} is not ready to workaround that. [[pt]] and [[bp]] have been introduced for consistency, so the functions using those units can be more general and avoid to check special cases, then whole program code will be simpler.

Finally, we need a simple function to recover the corresponding value for a given reference to an array which contain coords (as they are outputed by the test functions as a two elements array containing position and unit, in this order). This will simplify the code a little bit (as in section~\ref{sec:LAYOUTsec}). 

<<Common Routines>>=
sub get_units() { return $UNITS{$_[0]->[1]}->($_[0]->[0]); }
@  %def &get_units

\subsubsctn{Checking boolean variables}

We define as 'BOOLEAN' those variables used as flags or switches, which can hold only a binary value such ON/OFF. Booleans are NOT case sensitive.

<<variable value checking>>=
BOOLEAN => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      $_l =~ /^(1|on|t(rue)|y(es))$/o  && ($$_v = $T, return $T);
      $_l =~ /^(0|off|f(alse)|n(o))$/o && ($$_v = $F, return $T);
      &warn('NOT_A_BOOLEAN',$F,$_n);
      return $F;
  },
@ %def {BOOLEAN}

<<warnings - parsing custom files>>=
NOT_A_BOOLEAN =>
  $Warn."\"\%s\" variable requires a boolean value:\n".
  $spw."     (ON/OFF, 1/0, TRUE/FALSE, YES/NO)\n",
@

We also need a small function returning a 'true'/'false' string value to convert those booleans variables to {\ps} format.

<<Common Routines>>=
sub tobool() { return ( $_[0] ? 'true' : 'false' ); }
@ %def &tobool


\subsubsctn{Alphanumeric values}

Although {\ps} allows object ``names'' consisting in any character, except delimiters and white space, string, we are going to restrict user-defined ``names'' to a string that must start with a letter and may contain letters, numbers and underscores.

<<variable value checking>>=
ALPHA => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[a-zA-Z][a-zA-Z_0-9]*$/o && return $T;
      &warn('NOT_ALPHA',$F,$_n);
      return $F;
  },
@ %def {ALPHA}

<<warnings - parsing custom files>>=
NOT_ALPHA =>
  $Warn."\"\%s\" variable parameter must fit \"[a-zA-Z][a-zA-Z_0-9]*\"...\n",
@

\subsubsctn{Protecting reserved characters in strings}

Having a 'STRING' implies to replace/protect those characters that will produce indesirable effects in {\ps} code (such unbalanced parentheses). No error is reported for strings because they are assumed to be free text. Line returns can be forced using '[[\n]]'.

<<variable value checking>>=
STRING => sub { # Value
      my ($_v,undef,undef) = @_;
      defined($$_v) && do {
          $$_v =~ s{[\\]}{\\134}og;
          $$_v =~ s{[\(]}{\\050}og;
          $$_v =~ s{[\)]}{\\051}og;
      }; 
      return $T;
  },
@ %def {STRING}

<<Common Routines>>=
sub tostring() {
    (defined($_[0]) && $_[0] ne '') || return '()';
    $_[0] =~ s{[\(]}{\\050}og;
    $_[0] =~ s{[\)]}{\\051}og;
    return '('.$_[0].')';
}; # tostring
@ %def &tostring

\label{todo:BBG}
<<HIDE: new defs TODO>>=
\def\todoBBG{
Remember to check for some of the strings values such: '++none++', '++sequence++', and so on.
} % todoBBG
@
<<HIDE: TODO>>=
\todoitem{\todoBBG}{todo:BBG}
@
\todo{ \item \todoBBG } % todo


\subsubsctn{Validating numbers}

The following tests look for four different number types.

<<variable value checking>>=
NATURAL => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^\d+$/o && return $T;
      &warn('NOT_A_NATURAL',$F,$_n);
      return $F;
  },
INTEGER => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[+-]?\d+$/o && return $T;
      &warn('NOT_AN_INTEGER',$F,$_n);
      return $F;
  },
FLOAT => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^[+-]?(?:\d+(?:\.\d*)?|\.\d+)$/o && return $T;
      &warn('NOT_A_FLOAT',$F,$_n);
      return $F;
  },
REAL => sub { # Value, varName
      my ($_v,$_n,undef) = @_;
      $$_v =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/o && return $T;
      &warn('NOT_A_REAL',$F,$_n);
      return $F;
  },
@ %def {NATURAL} {INTEGER} {FLOAT} {REAL}

<<warnings - parsing custom files>>=
NOT_A_NATURAL =>
  $Warn."\"\%s\" variable is not a positive integer.\n",
NOT_AN_INTEGER =>
  $Warn."\"\%s\" variable is NOT an integer.\n",
NOT_A_FLOAT =>
  $Warn."\"\%s\" variable is NOT a decimal number.\n",
NOT_A_REAL =>
  $Warn."\"\%s\" variable is NOT a real number (with exponent).\n",
@ %$

\subsubsctn{Looking for color names}

Available colors are shown in section~\ref{sec:CMYKcolordef}, page~\pageref{sec:CMYKcolordef}. Here we check that customization input colors match those defined colors, including 'background' and 'foreground' colors. Color names are NOT case sensitive.

<<variable value checking>>=
COLOR => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      $_l =~ /^b(ack)?g(round)?(color)?/o &&
          ($$_v = 'bg', return $T);
      $_l =~ /^f(ore)?g(round)?(color)?/o &&
          ($$_v = 'fg', return $T);
      defined($COLORS{$_l}) && ($$_v = $_l, return $T);
      &warn('NOT_A_COLOR',$F,$_l,$_n);
      return $F;
  },
@ %def {COLOR}

<<HIDE: DONE>>=
\doneitem{20011107}{Set fg/bg multiple strings to a single color name such fgcolor/bgcolor for later use in the whole program (PS code too).}
@

<<warnings - parsing custom files>>=
NOT_A_COLOR =>
  $Warn."\"\%s\" color not defined in \"\%s\" variable.\n",
@


\subsubsctn{Checking for available fonts and font-sizes}

Font names must be in first capital letter format for {\ps}. 

<<variable value checking>>=
FONT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      defined($Fonts{$_l}) && 
          ($$_v = $Fonts{$_l}, return $T);
      &warn('NOT_A_FONT',$F,$$_v,$_n);
      return $F;
  },
@ %def {FONT}

<<warnings - parsing custom files>>=
NOT_A_FONT =>
  $Warn."Sorry, \"\%s\" font is not defined for \"\%s\".\n",
@

We provide three basic fonts that are standard in most {\ps} devices (a serif, a sans-serif and a monospaced font), and four series for each one (an upright ``normal'', an italic/oblique, a bold, and a bold italic/oblique series). 
\label{sec:FontsHsh}

<<Global Vars>>=
%Fonts = (
    # serif
    times                   => 'Times-Roman',
    'times-roman'           => 'Times-Roman',
    'times-italic'          => 'Times-Italic',
    'times-bold'            => 'Times-Bold',
    'times-bolditalic'      => 'Times-BoldItalic',
    # sans serif
    helvetica               => 'Helvetica',
    'helvetica-oblique'     => 'Helvetica-Oblique',
    'helvetica-bold'        => 'Helvetica-Bold',
    'helvetica-boldoblique' => 'Helvetica-BoldOblique',
    # monospaced
    courier                 => 'Courier',
    'courier-oblique'       => 'Courier-Oblique',
    'courier-bold'          => 'Courier-Bold',
    'courier-boldoblique'   => 'Courier-BoldOblique',
    );
@ 

Font sizes can be given in points, centimeters or inches. If no units are provided, then we asume points, but always must be possitive values (look at '[[PS_UNIT]]' test definition).

<<HIDE: DONE>>=
\doneitem{20011107}{Assign the proper PS unit multiplier. Functions to convert to points/cm/inches, and a hash variable to reformat the values: [[%units]] ([[$units{pt} = ""; $units{cm} = " cm"; $units{mm} = " mm"; $units{in} = " in"]]).
It has been solved by returning a two elements array having the numeric value and the corresponding unit (setting to some default if it is not given).}
\doneitem{20011107}{Can we do the same for SEQ_UNIT ? (section~\ref{sec:DNABASE}).}
@


\subsubsctn{Verifying page-sizes}

A new page bounding-box can be passed through command-line or customization file, we process that case here.

<<variable value checking>>=
BBOX => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my @it = ();
      @it = split /,/og, $_l;
      scalar(@it) != 2 && do {
          &warn('BBOX_NOTOK',$F,$_n,$_l,$_n);
          return $F;
      }; # not enough params
      $TESTS{PS_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      $TESTS{PS_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      $$_v = [ 'userdef', @it ];
      return $T;
  },
@ %def {BBOX}

<<warnings - parsing custom files>>=
BBOX_NOTOK =>
  $Warn."CANNOT understand \"\%s\" set as \"\%s\" ...\n".
  $spw." Format must be: \"\%s=<width>,<height>\" \n",
@ 

Available page sizes are shown in section~\ref{sec:PAGEdef}, page~\pageref{sec:PAGEdef}.

<<variable value checking>>=
PAGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;            
	  defined($FORMATS{$_l}) && ($$_v = $_l, return $T);
      &warn('NOT_A_PAGE',$F,$_l,$$_v);
      return $F;
  },
@ %def {PAGE}

<<warnings - parsing custom files>>=
NOT_A_PAGE =>
  $Warn."\"\%s\" page-size is not defined for \"\%s\" variable.\n",
@

\subsubsctn{Nucleotide coords}

Those numbers relative to DNA positions may be given in bases, kilobases, megabases or gigabases, being last three ones a way to avoid any mistake when a big coord with lots of zeroes is provided. If no units are provided, then we asume bases.

\label{sec:DNABASE}
<<variable value checking>>=
SEQ_UNIT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my $q = undef;
      $_l =~ /^\.$|^\s*$/o && do {
          &warn('NOT_A_NUMBER',$F,$_n);
          return $F;
      };
      $_l =~ s/(?:\.)?
               (?:(g(?:iga)?|m(?:ega)?|k(?:ilo)?)?
               b(?:ase)?
               (?:p(?:air)?)?
               (?:s)?)$
              //ox && ($q = $1);
      defined($q) || do {
          $_l =~ /[^\d]+$/o && do {
               &warn('NOT_A_DNAUNIT',$F,$_n,$$_v);
               return $F;
          };
          $q = '';
      };
      $TESTS{FLOAT}->(\$_l,$_n,$_l) || return $F;
      ($q,undef) = split //o,$q,2;
      $q .= 'bp';
      $$_v = [ $_l, $q ];
      return $T;
  },
@ %def {SEQ_UNIT}

<<warnings - parsing custom files>>=
NOT_A_NUMBER =>
  $Warn."\"\%s\" variable needs a number (with or without units).\n",
NOT_A_DNAUNIT =>
  $Warn."\"\%s\" variable requires nucleotide units.\n".
  $spw." \"\%s\" is not valid (units must be in Gb, Mb, Kb, or bases).\n",
@


\subsubsctn{{\ps} coords}

Those numbers relative to plot positions and font sizes may be given in points, centimeters, milimeters or inches. If no units are provided, then we asume points.

\label{sec:PSCOORDS}

<<variable value checking>>=
PS_UNIT => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      my $q = undef;
      $_l =~ /^\.$|^\s*$/o && do {
          &warn('NOT_A_NUMBER',$F,$_n);
          return $F;
      };
      PSLEN: {
          $_l =~ s/m(eter(s)?)?$//o && do {
              $_l =~ s/(\.)?c(enti)?$//o   && ($q = 'cm', last PSLEN);
              $_l =~ s/(\.)?m(ili)?$//o    && ($q = 'mm', last PSLEN);
              last PSLEN;
          };
          $_l =~ s/(\.)?in(ch(es)?)?$//o   && ($q = 'in', last PSLEN);
          $_l =~ s/(\.)?(pt|point(s)?)$//o && ($q = 'pt');
      }; # PSLEN
      defined($q) || do {
          $_l =~ /[^\d]+$/o && do {
               &warn('NOT_A_PSUNIT',$F,$_n,$$_v);
               return $F;
          };
          $q = 'pt';
      };
      $TESTS{FLOAT}->(\$_l,$_n,$_l) || return $F;
      $$_v = [ $_l, $q ];
      return $T;
  },
@ %def {PS_UNIT}

<<warnings - parsing custom files>>=
NOT_A_PSUNIT =>
  $Warn."\"\%s\" variable requires PostScript units.\n".
  $spw." \"\%s\" is not valid (units must be in points, cm, mm, or inches).\n",
@


\subsubsctn{Accepting numeric ranges}

A range is a lower/upper limits pair for a given variable. One of the limits, or both, can be an asterisk ('*'), which means that the default value must be used. The result of the range related functions is an array containing two subarrays, one for the start and one for the end, having both two items within, a coord/position and a unit. We can schemmatize that as follows:

\centerline{[[ @output = ( [ start, unit ],  [ end, unit ] ) ]]} 

<<HIDE: DONE>>=
\doneitem{20011107}{Here we must check something like '*..*'.}
@

<<variable value checking>>=
RANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{FLOAT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{FLOAT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {RANGE}

<<variable value checking>>=
PSRANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{PS_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{PS_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {PSRANGE}

<<variable value checking>>=
SEQRANGE => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      <<splitting ranges - common code>>
      $it[0] eq '*' || do {
          $TESTS{SEQ_UNIT}->(\$it[0],$_n,$it[0]) || return $F;
      }; # $it[0] -> lower-value
      $it[1] eq '*' || do {
          $TESTS{SEQ_UNIT}->(\$it[1],$_n,$it[1]) || return $F;
      }; # $it[1] -> upper-value
      <<splitting ranges result - common code>>
  },
@ %def {SEQRANGE}

<<splitting ranges - common code>>=
my @it = ();
@@it = split /\.\./og, $_l;
scalar(@it) != 2 && do {
    &warn('RANGE_NOTOK',$F,$_n,$$_v,$_n);
    return $F;
}; # not enough params
@ 

<<HIDE: test>>=
perl -e 'use Data::Dumper; 
  local $Data::Dumper::Purity = 0;
  local $Data::Dumper::Deepcopy = 1;
  @it = ( "*", [ 1, "cm" ] );
  print Dumper(\@it);
  %hash = ( key1 => "+" );
  print Dumper(\%hash);
  $ref = \$hash{key1};
  $$ref = [ $it[0] eq "*" ? undef : [ @{ $it[0] } ] , [ @{ $it[1] } ], $$ref ];
  print Dumper(\%hash);' 
@ 

If any of the coords was defined with the willcard character '[[*]]', we return an undefined array element where it is needed, so this will make tests easier later.  

<<splitting ranges result - common code>>=
$$_v = [ 
     $it[0] eq '*' ? undef : [ @{ $it[0] } ],
     $it[1] eq '*' ? undef : [ @{ $it[1] } ]
    ];
return $T;
@

<<warnings - parsing custom files>>=
RANGE_NOTOK =>
  $Warn."CANNOT understand \"\%s\" set as \"\%s\" ...\n".
  $spw." Format must be: \"\%s=<lower-value>..<upper-value>\" \n",
@ 

\subsubsctn{Plot features}

<<variable value checking>>=
RIBBON => sub { # Value, varName, Lowercase
      my ($_v,$_n,$_l) = @_;
      defined($$_v) && do {
          return $$_v;
      };
      return undef;
  },
@ %def {RIBBON}

\newpage

\sctn{Customization Variables Description} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\label{sec:customvardesc}
% \subsctn{Command-line options}

<<HIDE: DONE>>=
\doneitem{20011031}{
Write a script to produce easier the appendix/descriptions tables for the manual from the options code chunks. Transforming to a fixed record formats like:\\
\shortstack[l]{ORDER: ....\\OPTION: ....\\DEFAULTS: ....\\PARAMS: ....\\ SHORT DESC: .... (for the appendix table)\\ LONG DESC: .... (for the description table)}
}
@ 
\label{todo:DDB}
<<HIDE: new defs TODO>>=
\def\todoDDB{
Set the final options/variables/parameters for the whole section.
} % todoDDB
@
<<HIDE: TODO>>=
\todoitem{\todoDDB}{todo:DDB}
@
\todo{ \item \todoDDB } % todo

\subsctn{Reporting program execution}

Two options are used for reporting how program is running. By default no messages are shown to standard error, only errors. One reports to a log file defined by user and the other shows the messages to standard error, both can be activated at the same time. A third one is needed to disable STDERR warnings.

<<command-line options prog>>=
"v|verbose"   => \$Verbose,
@ 
<<command-line help prog>>=
-v, --verbose
      Verbose mode, a full report is sent to standard error 
      (default is set to showing only WARNINGS).
@
<<DESC command-line options>>=
ORD: 3
OPT: v
LNG: verbose
SDE: Verbose mode, a full report is sent to standard error.
LDE:
By default, warnings and errors are sent to standard error. This option 
switches on process reporting messages to appear on standard error too.
###EOR###
@ 


<<command-line options prog>>=
"V|logs-filename=s"  => \$logs_filename,  # Print_Report -> LogFile
@ 
<<command-line help prog>>=
-V, --logs-filename  <filename>
      Report is written to a log file.
@
<<DESC command-line options>>=
ORD: 4
OPT: V
LNG: logs-filename
PAR: <filename>
SDE: Report is written to a log file.
LDE:
If is possible to open <filename> then such file will contain 
all the messages and warnings produced by the program even though they 
were disabled from standard error with [quiet] option.
###EOR###
@ 

<<command-line options prog>>=
"q|quiet"   => \$Quiet,
@
<<command-line help prog>>=
-q, --quiet
      Quiet mode, do not show any message/warning
      to standard error (reporting only ERRORS).
@
<<DESC command-line options>>=
ORD: 5
OPT: q
LNG: quiet
SDE: Quiet mode, messages/warnings disabled (only ERRORS shown).
LDE:
This option disables any message or warning from standard error. It does not 
disable error report because such errors are pointing a problem which can 
make {\prog} produce unexpected results. Solve the cause of such problems 
before continuing to run the program in a silent mode. 
###EOR###
@ 


\subsctn{Layout variables}

\subsubsctn{Page definition}

We do not provide a '[[format_name]]' parameter for [[page_bbox]] variable and related options because if users define a name that already was defined as a function name in the {\ps} code, plot will crash without an obvious error.

<<default layout vars values>>=
# PAGE definition
page_bbox                  => { TYPE => 'BBOX'   , VALUE => undef   },
@ %def {page_bbox}
<<command-line options>>=
"P|page-bbox"   => \$CmdLineVars{LAYOUT}{"page_bbox"},
@ 
<<command-line help>>=
-P, --page-bbox  <width,height>
      Setting a user-defined page size, <width> and
      <height> are set to points if no unit is given,
      you can use pt, mm, cm or in. This option overrides ANY
      'page-size' definition (from command-line or custom file).
@
<<DESC command-line options>>=
ORD: 6
OPT: P
LNG: page-bbox
PAR: <width,height>
EQV: [page_bbox]=<width,height>
SDE: Defining arbitrary page formats.
LDE: 
This option allows users to define an arbitrary page format, by
defining the width and height for that page ({\prog} assigns 
automatically a format name for this new page dimensions). 
See [page_bbox] customization variable on page~\pageref{sec:pagebbox} 
(section~\ref{sec:pagebbox}) for further info on this command-line option.
It overrides any [page-size] command-line option (and any related variable 
passed through custom files). <width> and <height> are set to points 
if no unit is given, now you can use pt, mm, cm or in.
###EOR###
@
<<DESC custom file variables>>=
ORD: 1
SEC: LAYOUT
SUB: PageLayout
OPT: page_bbox
PAR: <width,height>
SDE: Defining arbitrary page formats. Overrides any setting for [page_size].
LDE:
\label{sec:pagebbox}
This variable allows users to define an arbitrary page format, by
defining the width and height for that page ({\prog} assigns 
automatically a format name for this new page dimensions). 
Do not include this variable in your custom files if you are
using standard page sizes which can be set using [page_size], because
[page_bbox] overrides any further page definition by that variable. If
the variable is not set, default value forces the use of any settings
given for [page_size]. <width> and <height> are set to points if no unit is
given, now you can also use points, milimeters, centimeters or inches (pt, 
mm, cm or in, respectively). See table~\ref{tbl:PageSizes} for a reference
on already defined page sizes and their dimensions.
###EOR###
@ 

<<default layout vars values>>=
page_size                  => { TYPE => 'PAGE'   , VALUE => 'a4'    },
@ %def {page_size}
<<command-line options>>=
"p|page-size"   => \$CmdLineVars{LAYOUT}{"page_size"},
@ 
<<command-line help>>=
-p, --page-size  <format_name>
      Setting a page size among pre-defined ones
      (see below for a list of available page formats).
@
<<DESC command-line options>>=
ORD: 7
OPT: p
LNG: page-size
PAR: <format_name>
EQV: [page_size]=<format_name>
SDE: Setting a page size (see table~\ref{tbl:PageSizes}).
LDE:
<format_name> is a pre-defined page format from table~\ref{tbl:PageSizes}. 
By default is set to |a4|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 2
SEC: LAYOUT
SUB: PageLayout
OPT: page_size
DEF: |a4|
PAR: <format_name>
SDE: Sets a standard page size, available format names are listed in table~\ref{tbl:PageSizes}.
LDE:
Setting a standard page size, available values for <format_name> are 
listed in table~\ref{tbl:PageSizes}. Page width and height values are 
coded for most common paper formats.
###EOR###
@ 

\subsubsctn{Page margins}

<<default layout vars values>>=
# Page MARGINS
margin_left                => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_right               => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_top                 => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
margin_bottom              => { TYPE => 'PS_UNIT'  , VALUE => [ 1, 'cm' ] },
@ %def {margin_left} {margin_right} {margin_top} {margin_bottom}
<<command-line options>>=
"margin-left=s"         => \$CmdLineVars{LAYOUT}{"margin_left"},
"margin-right=s"        => \$CmdLineVars{LAYOUT}{"margin_right"},
"margin-top=s"          => \$CmdLineVars{LAYOUT}{"margin_top"},
"margin-bottom=s"       => \$CmdLineVars{LAYOUT}{"margin_bottom"},
@ 
<<command-line help>>=
--margin-left   <length>
--margin-right  <length>
--margin-top    <length>
--margin-bottom <length>
      Setting each page margin to <length>. If no units are provided,
      points are assumed, you can use points, milimeters, centimeters
      or inches (pt, mm, cm or in, respectively).
@
<<DESC command-line options>>=
ORD: 8
LNG: margin-left
PAR: <length>
EQV: [margin_left]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 3
SEC: LAYOUT
SUB: PageLayout
OPT: margin_left
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 9
LNG: margin-right
PAR: <length>
EQV: [margin_right]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 4
SEC: LAYOUT
SUB: PageLayout
OPT: margin_right
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 10
LNG: margin-top
PAR: <length>
EQV: [margin_top]=<length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 5
SEC: LAYOUT
SUB: PageLayout
OPT: margin_top
DEF: |1cm|
PAR: <length>
SDE: JOIN-NEXT
LDE: JOIN-NEXT
###EOR###
@ 
<<DESC command-line options>>=
ORD: 11
LNG: margin-bottom
PAR: <length>
EQV: [margin_bottom]=<length>
SDE: Setting page margins (default is 1cm each).
LDE: 
You can set page margin with those four variables. <length> can be given in 
points, milimeters, centimeters or inches (pt, mm, cm or in, respectively),
but is set to points if no units are provided.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 6
SEC: LAYOUT
SUB: PageLayout
OPT: margin_bottom
DEF: |1cm|
PAR: <length>
SDE: Setting page margins (default is 1cm each).
LDE: 
You can set page margin with those four variables. <length> can be given in 
points, milimeters, centimeters or inches (pt, mm, cm or in, respectively),
but is set to points if no units are provided.
###EOR###
@ 

\subsubsctn{Page colors}

<<default layout vars values>>=
# Page COLORS			  
background_color           => { TYPE => 'COLOR'  , VALUE => 'white' },
@ %def {background_color}
<<command-line options>>=
"B|background-color=s"  => \$CmdLineVars{LAYOUT}{"background_color"}, # BACKGROUND_COLOR
@ 
<<command-line help>>=
-B, --background-color  <color>    Background color.
@
<<DESC command-line options>>=
ORD: 12
OPT: B
LNG: background-color
PAR: <color>
EQV: [background_color]=<color>
SDE: Setting background color for the page (default is |white|).
LDE: JOIN-NEXT
###EOR###
@ 
% This option sets background color for the page ---say here filling color 
% for whole page---. Available colors are listed on table~\ref{tbl:CMYKcolor},
% default value is |white|.
<<DESC custom file variables>>=
ORD: 7
SEC: LAYOUT
SUB: PageLayout
OPT: background_color
DEF: |white|
PAR: <color>
SDE: Setting background color for the page. Available colors are listed on table~\ref{tbl:CMYKcolor}.
LDE: JOIN-NEXT
###EOR###
@ 

<<default layout vars values>>=
foreground_color           => { TYPE => 'COLOR'  , VALUE => 'black' },
@ %def {foreground_color}
<<command-line options>>=
"F|foreground-color=s"  => \$CmdLineVars{LAYOUT}{"foreground_color"}, # FOREGROUND_COLOR
@ 
<<command-line help>>=
-F, --foreground-color  <color>    Foreground color.
@
<<DESC command-line options>>=
ORD: 13
OPT: F
LNG: foreground-color
PAR: <color>
EQV: [foreground_color]=<color>
SDE: Setting foreground color for the page (default is |black|).
LDE:
You can change background ---say here page filling--- and foreground 
---say here text, outlines and tickmarks--- color for the page. 
Available colors are defined on table~\ref{tbl:CMYKcolor},
default values are |white| and |black|, for background and foreground 
respectively.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 8
SEC: LAYOUT
SUB: PageLayout
OPT: foreground_color
DEF: |black|
PAR: <color>
SDE: Setting foreground color for the page. Find available colors on table~\ref{tbl:CMYKcolor}.
LDE:
These two customization variables accept any <color> from those listed on 
table~\ref{tbl:CMYKcolor}. Default values are |white| and |black| for 
[background_color] and [foreground_color] respectively. These two variables 
also set the aliases [BGcolor] and [FGcolor], so that you can use |bgcolor| and
|bg|, or |fgcolor| and |fg|, to set any other color-related variable with the
same colors you are defining as background/foreground colors.
###EOR###
@ 

\subsubsctn{Figure labels}

<<default layout vars values>>=
# GLOBAL Labels			  
show_title                 => { TYPE => 'BOOLEAN', VALUE => $T     },
title                      => { TYPE => 'STRING' , VALUE => undef  }, # T
@ %def {show_title} {title}
<<command-line options>>=
"T|title=s"  => \$CmdLineVars{LAYOUT}{"title"}, # TITLE
@ 
<<command-line help>>=
-T, --title <string>   Definning plot title.
@
<<DESC command-line options>>=
ORD: 14
OPT: T 
LNG: title
PAR: <string>
EQV: [title]=<string>
SDE: Setting figure title to <string>.
LDE: 
Setting the main title to <string>
for the current figure, by default showing |align_name|
in the form of |sequence1_name| x |sequence2_name|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 9
SEC: LAYOUT
SUB: Labels
OPT: title
PAR: <string>
SDE: Setting figure title to <string>.
LDE: 
[title] sets the main title to <string>
for the current figure, by default showing |align_name|
in the form of |sequence1_name| x |sequence2_name|.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 10
SEC: LAYOUT
SUB: Labels
OPT: show_title
DEF: |on|
PAR: <boolean>
SDE: Switching on/off title from plot.
LDE: 
[show_title] switches on/off displaying the figure title. 
If you do not want to visualize the default title you can set this
variable to |off|, but you are not able to reuse the area of plot 
where title appears (set [title_fontsize] to |0| if you want to remove
that area from plot).
###EOR###
@ 
<<default layout vars values>>=
title_font                 => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
title_fontsize             => { TYPE => 'PS_UNIT', VALUE => [ 24, 'pt' ]  },
@ %def {title_font} {title_fontsize}
<<DESC custom file variables>>=
ORD: 11
SEC: LAYOUT
SUB: Labels
OPT: title_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets title font, see available fonts at~\ref{tbl:fontnames}.
LDE: 
###EOR###
ORD: 12
SEC: LAYOUT
SUB: Labels
OPT: title_fontsize
DEF: |24pt|
PAR: <length>
SDE: Sets title fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets title fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [title_fontsize] to |0| forces {\prog} to remove
title area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_subtitle              => { TYPE => 'BOOLEAN', VALUE => $T     },
subtitle                   => { TYPE => 'STRING' , VALUE => undef  }, # ST
@ %def {show_subtitle} {subtitle}
<<command-line options>>=
"t|subtitle=s"  => \$CmdLineVars{LAYOUT}{"subtitle"}, # SUBTITLE
@ 
<<command-line help>>=
-t, --subtitle <string>   Definning plot subtitle.
@
<<DESC command-line options>>=
ORD: 15
OPT: t 
LNG: subtitle
PAR: <string>
EQV: [subtitle]=<string>
SDE: Setting subtitle to <string>.
LDE: 
Setting <string> as the current figure subtitle, by default an empty string.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 13
SEC: LAYOUT
SUB: Labels
OPT: subtitle
PAR: <string>
SDE: Setting subtitle to <string>.
LDE: 
[subtitle] sets the current figure subtitle to <string>, by default
it is defined as an empty string.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 14
SEC: LAYOUT
SUB: Labels
OPT: show_subtitle
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_subtitle] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
subtitle_font              => { TYPE => 'FONT'   , VALUE => 'helvetica'   },
subtitle_fontsize          => { TYPE => 'PS_UNIT', VALUE => [ 16, 'pt' ]  },
@ %def {subtitle_font} {subtitle_fontsize}
<<DESC custom file variables>>=
ORD: 15
SEC: LAYOUT
SUB: Labels
OPT: subtitle_font
DEF: |helvetica|
PAR: <font>
SDE: Sets subtitle font, see available fonts at~\ref{tbl:fontnames}.
LDE: 
###EOR###
ORD: 16
SEC: LAYOUT
SUB: Labels
OPT: subtitle_fontsize
DEF: |16pt|
PAR: <length>
SDE: Sets subtitle fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets subtitle fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_x_label               => { TYPE => 'BOOLEAN', VALUE => $T     },
x_label                    => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_x_label} {x_label}
<<command-line options>>=
"X|x-label=s"  => \$CmdLineVars{LAYOUT}{"x-axis_label"}, # X-Axis_LABEL
@ 
<<command-line help>>=
-X, --x-label <string>   Defining X-axis label.
@
<<DESC command-line options>>=
ORD: 16
OPT: X 
LNG: x-label
PAR: <string>
EQV: [x_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 17
SEC: LAYOUT
SUB: Labels
OPT: x_label
PAR: <string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 18
SEC: LAYOUT
SUB: Labels
OPT: show_x_label
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_x_label] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
x_label_font               => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
x_label_fontsize           => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {x_label_font} {x_label_fontsize}
<<DESC custom file variables>>=
ORD: 19
SEC: LAYOUT
SUB: Labels
OPT: x_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets X-label font, see available fonts at~\ref{tbl:fontnames}.
LDE: 

###EOR###
ORD: 20
SEC: LAYOUT
SUB: Labels
OPT: x_label_fontsize
DEF: |12pt|
PAR: <length>
SDE: Sets X-label fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets X-label fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_y_label              => { TYPE => 'BOOLEAN', VALUE => $T     },
y_label                   => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_y_sequence_label} {y_sequence_label}
<<command-line options>>=
"Y|y-label=s"  => \$CmdLineVars{LAYOUT}{"y-axis_label"}, # Y-Axis_LABEL
@ 
<<command-line help>>=
-Y, --y-label <Y-Label>   Defining Y-axis label.
@
<<DESC command-line options>>=
ORD: 17
OPT: Y
LNG: y-label
PAR: <string>
EQV: [y_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 21
SEC: LAYOUT
SUB: Labels
OPT: y_label
PAR: <string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 22
SEC: LAYOUT
SUB: Labels
OPT: show_y_label
DEF: |on|
PAR: <boolean>
SDE: Switching on/off subtitle from plot.
LDE: 
[show_x_label] switches on/off displaying the subtitle text. 
If you do not want to visualize the default subtitle you can set this
variable to |off|, as with [show_title] you are not able to reuse the area 
of plot where subtitle appears (so set [subtitle_fontsize] to |0| if you 
want to remove that area from plot too).
###EOR###
@ 
<<default layout vars values>>=
y_label_font               => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
y_label_fontsize           => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {y_label_font} {y_label_fontsize}
<<DESC custom file variables>>=
ORD: 23
SEC: LAYOUT
SUB: Labels
OPT: y_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets Y-label font, see available fonts at~\ref{tbl:fontnames}.
LDE: 

###EOR###
ORD: 24
SEC: LAYOUT
SUB: Labels
OPT: y_label_fontsize
DEF: |12pt|
PAR: <length>
SDE: Sets Y-label fontsize, <length> can be in pt, mm, cm or in (default is points if no units are given).
LDE:
Sets Y-label fontsize, <length> can be in pt, mm, cm or in 
(default is points if no units are given).
Setting [subtitle_fontsize] to |0| forces {\prog} to remove
subtitle area from plot, so no space is left for it.
###EOR###
@ 


<<default layout vars values>>=
show_percent_box_label     => { TYPE => 'BOOLEAN', VALUE => $T     },
percent_box_label          => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_percent_box_label} {percent_box_label}
<<command-line options>>=
"L|percent-box-label=s"  => \$CmdLineVars{LAYOUT}{"percent_box_label"},
@ 
<<command-line help>>=
-L, --percent-box-label <string>   Defining percent-box label.
@
<<DESC command-line options>>=
ORD: 18
OPT: L
LNG: percent-box-label
PAR: <string>
EQV: [percent_box_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 25
SEC: LAYOUT
SUB: Labels
OPT: show_percent_box_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 26
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
percent_box_label_font     => { TYPE => 'FONT'   , VALUE => 'helvetica-bold' },
percent_box_label_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 12, 'pt' ]  },
@ %def {percent_box_label_font} {percent_box_label_fontsize}
<<DESC custom file variables>>=
ORD: 27
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets percent-box main label font.
LDE:

###EOR###
ORD: 28
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets percent-box main label fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_percent_box_sublabel  => { TYPE => 'BOOLEAN', VALUE => $T     },
percent_box_sublabel       => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_percent_box_sublabel} {percent_box_sublabel}
<<DESC custom file variables>>=
ORD: 29
SEC: LAYOUT
SUB: Labels
OPT: show_percent_box_sublabel
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 30
SEC: LAYOUT
SUB: Labels
OPT: percent_box_sublabel
DEF: 
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
percent_box_sublabel_font     => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
percent_box_sublabel_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {percent_box_sublabel_font} {percent_box_sublabel_fontsize}
<<DESC custom file variables>>=
ORD: 31
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets percent-box sublabel font.
LDE:

###EOR###
ORD: 32
SEC: LAYOUT
SUB: Labels
OPT: percent_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets percent-box sublabel fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_extra_box_label       => { TYPE => 'BOOLEAN', VALUE => $T     },
extra_box_label            => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_extra_box_label} {extra_box_label}
<<command-line options>>=
"l|extra-box-label=s"  => \$CmdLineVars{LAYOUT}{"extra_box_label"},
@ 
<<command-line help>>=
-l, --extra-box-label <XBox-Label>   Definning Extra-Box Label.
@
<<DESC command-line options>>=
ORD: 19
OPT: l
LNG: extra-box-label
PAR: <string>
EQV: [extra_box_label]=<string>
SDE: <string>.
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 33
SEC: LAYOUT
SUB: Labels
OPT: show_extra_box_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 34
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
extra_box_label_font       => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
extra_box_label_fontsize   => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {extra_box_label_font} {extra_box_label_fontsize}
<<DESC custom file variables>>=
ORD: 35
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets extra-box main label font.
LDE:

###EOR###
ORD: 36
SEC: LAYOUT
SUB: Labels
OPT: extra_box_label_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets extra-box main label fontsize.
LDE:

###EOR###
@ 


<<default layout vars values>>=
show_extra_box_sublabel    => { TYPE => 'BOOLEAN', VALUE => $T     },
extra_box_sublabel         => { TYPE => 'STRING' , VALUE => undef  },
@ %def {show_extra_box_sublabel} {extra_box_sublabel}
<<DESC custom file variables>>=
ORD: 37
SEC: LAYOUT
SUB: Labels
OPT: show_extra_box_sublabel
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 38
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel
PAR: <string>
SDE: 
LDE:

###EOR###
@ 
<<default layout vars values>>=
extra_box_sublabel_font     => { TYPE => 'FONT'   , VALUE => 'helvetica'  },
extra_box_sublabel_fontsize => { TYPE => 'PS_UNIT', VALUE => [ 9, 'pt' ]  },
@ %def {extra_box_sublabel_font} {extra_box_sublabel_fontsize}
<<DESC custom file variables>>=
ORD: 39
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel_font
DEF: |helvetica-bold|
PAR: <font>
SDE: Sets extra-box sublabel font.
LDE:

###EOR###
ORD: 40
SEC: LAYOUT
SUB: Labels
OPT: extra_box_sublabel_fontsize
DEF: |9pt|
PAR: <length>
SDE: Sets extra-box sublabel fontsize.
LDE:

###EOR###
@ 


\subsubsctn{Zoom in, zoom out}

The following variables define the boundary/clipping coordinates for each sequence, so you can select a region to be displayed in the {\ps} output.

<<default layout vars values>>=
x_sequence_coords          => { TYPE => 'SEQRANGE', VALUE => undef  },
x_sequence_start           => { TYPE => 'SEQ_UNIT', VALUE => undef  },
x_sequence_end             => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {x_sequence_coords} {x_sequence_start} {x_sequence_end}
<<command-line options>>=
"x|x-sequence-coords=s" => \$CmdLineVars{LAYOUT}{"x_sequence_coords"},
"S|start-x-sequence=i"  => \$CmdLineVars{LAYOUT}{"x_sequence_start"}, # SEQUENCE1_ORIGIN # Zoom_SEQUENCE1_ORIGIN
"E|end-x-sequence=i"    => \$CmdLineVars{LAYOUT}{"x_sequence_end"}, # SEQUENCE1_END    # Zoom_SEQUENCE1_END
@ 
<<command-line help>>=
-x, --x-sequence-coords <pos..pos> 
-S, --start-x-sequence <pos>  Sets X-sequence first nucleotide.
-E, --end-x-sequence <pos>    Sets X-sequence last nucleotide.
@
<<DESC command-line options>>=
ORD: 61
OPT: x
LNG: x-sequence-coords
PAR: <pos..pos>
EQV: [x_sequence_coords]=<pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 62
OPT: S
LNG: start-x-sequence
PAR: <pos>
EQV: [x_sequence_start]=<pos>
SDE: 
LDE: 

###EOR###
ORD: 63
OPT: E
LNG: end-x-sequence
PAR: <pos>
EQV: [x_sequence_end]=<pos>
SDE: 
LDE: 

###EOR###
@ 

[[x_sequence_coords]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 61
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_coords
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 62
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 63
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@
 

<<default layout vars values>>=
y_sequence_coords          => { TYPE => 'SEQRANGE', VALUE => undef  },
y_sequence_start           => { TYPE => 'SEQ_UNIT', VALUE => undef  },
y_sequence_end             => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {y_sequence_coords} {y_sequence_start} {y_sequence_end}
<<command-line options>>=
"y|y-sequence-coords=s" => \$CmdLineVars{LAYOUT}{"y_sequence_coords"},
"s|start-y-sequence=i"  => \$CmdLineVars{LAYOUT}{"y_sequence_start"}, # SEQUENCE2_ORIGIN # Zoom_SEQUENCE2_ORIGIN
"e|end-y-sequence=i"    => \$CmdLineVars{LAYOUT}{"y_sequence_end"}, # SEQUENCE2_END    # Zoom_SEQUENCE2_END
@ 
<<command-line help>>=
-y, --y-sequence-coords <pos..pos> 
-s, --start-y-sequence <pos>  Sets Y-sequence first nucleotide.
-e, --end-y-sequence <pos>    Sets Y-sequence last nucleotide.
@
<<DESC command-line options>>=
ORD: 64
OPT: y
LNG: y-sequence-coords
PAR: <pos..pos>
EQV: [y_sequence_coords]=<pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 65
OPT: s
LNG: start-y-sequence
PAR: <pos>
EQV: [y_sequence_start]=<pos>
SDE: 
LDE: 

###EOR###
ORD: 66
OPT: e
LNG: end-y-sequence
PAR: <pos>
EQV: [y_sequence_end]=<pos>
SDE: 
LDE: 

###EOR###
@ 

[[y_sequence_coords]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 64
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_coords
DEF: |*..*|
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 65
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 66
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
x_sequence_zoom            => { TYPE => 'SEQRANGE', VALUE => undef  },
x_sequence_zoom_start      => { TYPE => 'SEQ_UNIT', VALUE => undef  },
x_sequence_zoom_end        => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {x_sequence_zoom} {x_sequence_zoom_start} {x_sequence_zoom_end}
<<command-line options>>=
"x-sequence-zoom=s"         => \$CmdLineVars{LAYOUT}{"x_sequence_zoom"},
@ 
<<command-line help>>=
--x-sequence-zoom <pos..pos> 
@
<<DESC command-line options>>=
ORD: 67
LNG: x-sequence-zoom
PAR: <pos..pos>
EQV: [x_sequence_zoom]=<pos..pos>
SDE: 
LDE: 

###EOR###
@
% CLO-ORD 69

[[x_sequence_zoom]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]). % DEF: |*..*|

<<DESC custom file variables>>=
ORD: 67
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 68
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 69
SEC: LAYOUT
SUB: Zoom
OPT: x_sequence_zoom_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
y_sequence_zoom            => { TYPE => 'SEQRANGE', VALUE => undef  },
y_sequence_zoom_start      => { TYPE => 'SEQ_UNIT', VALUE => undef  },
y_sequence_zoom_end        => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {y_sequence_zoom} {y_sequence_zoom_start} {y_sequence_zoom_end}
<<command-line options>>=
"y-sequence-zoom=s"         => \$CmdLineVars{LAYOUT}{"y_sequence_zoom"},
@ 
<<command-line help>>=
--y-sequence-zoom <pos..pos> 
@
<<DESC command-line options>>=
ORD: 70
LNG: y-sequence-zoom
PAR: <pos..pos>
EQV: [y_sequence_zoom]=<pos..pos>
SDE: 
LDE: 

###EOR###
@ 

[[y_sequence_zoom]] must not be defined by default (see [[<<setting boundaries - is zoom area ON>>]]).

<<DESC custom file variables>>=
ORD: 70
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom
PAR: <pos..pos>
SDE: 
LDE: 

###EOR###
ORD: 71
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom_start
PAR: <pos>
SDE: 
LDE: 

###EOR###
ORD: 72
SEC: LAYOUT
SUB: Zoom
OPT: y_sequence_zoom_end
PAR: <pos>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
zoom                       => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_area                  => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_marks                 => { TYPE => 'BOOLEAN', VALUE => $F     },
zoom_area_mark_width       => { TYPE => 'PS_UNIT', VALUE => [ 2, 'pt' ]  },
zoom_area_mark_color       => { TYPE => 'COLOR'  , VALUE => 'lightred' },
zoom_area_fill_color       => { TYPE => 'COLOR'  , VALUE => undef  },
@ %def {zoom} {zoom_area} {zoom_marks} {zoom_area_mark_color}
<<command-line options>>=
"Z|zoom"                 => \$CmdLineVars{LAYOUT}{"zoom"},
"z|zoom-area"            => \$CmdLineVars{LAYOUT}{"zoom_area"},
@ 
<<command-line help>>=
-Z, --zoom [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ]
               This option zooms an area you have selected
               with -S,-E,-s,-e (all 4 are optional).
-z, --zoom-area [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ]
               This option marks a zoom area on your plot,
               but does not make a zoom.
@
<<DESC command-line options>>=
ORD: 73
OPT: Z
LNG: zoom
EQV: [zoom]=|on|
SDE: 
LDE: 

###EOR###
ORD: 74
OPT: z
LNG: zoom-area
EQV: [zoom_area]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 73
SEC: LAYOUT
SUB: Zoom
OPT: zoom
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 74
SEC: LAYOUT
SUB: Zoom
OPT: zoom-area
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 75
SEC: LAYOUT
SUB: Zoom
OPT: zoom_marks
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 77
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_mark_width
DEF: |2pt|
PAR: <length>
SDE: 
LDE: 

###EOR###
ORD: 78
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_mark_color
DEF: |lightred|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 78
SEC: LAYOUT
SUB: Zoom
OPT: zoom_area_fill_color
PAR: <color>
SDE: 
LDE: 

###EOR###
@


\subsubsctn{The aplot layout}

<<default layout vars values>>=
alignment_name            => { TYPE => 'STRING', VALUE => undef     },
x_sequence_name           => { TYPE => 'STRING', VALUE => undef     },
y_sequence_name           => { TYPE => 'STRING', VALUE => undef     },
@ %def {alignment_name} {x_sequence_name} {y_sequence_name}
<<command-line options>>=
"A|alignment-name=s"   => \$CmdLineVars{LAYOUT}{"alignment_name"}, # Align_NAME
"N|x-sequence-name=s"  => \$CmdLineVars{LAYOUT}{"x_sequence_name"}, # X-Sequence_NAME
"n|y-sequence-name=s"  => \$CmdLineVars{LAYOUT}{"y_sequence_name"}, # Y-Sequence_NAME
@ 
<<command-line help>>=
-A, --alignment-name <SeqXName:SeqYName>
     Defining which alignment is going to be plotted 
     if you have more than one alignment in your gff input.
-N, --x-sequence-name <SeqXName>
     Defining which sequence is going to be plotted at X-axis.
-n, --y-sequence-name <SeqYName>
     Defining which sequence is going to be plotted at Y-axis.
@
<<DESC command-line options>>=
ORD: 80
OPT: A
LNG: alignment-name
PAR: <seqXname:seqYname>
EQV: [alignment_name]=<seqXname:seqYname>
SDE: Selects <seqXname:seqYname> alignment.
LDE: 
When you are providing several alignments from input, you can select which one
to be plotted. By default program uses first alignment found in the input 
stream if [x_sequence_name] and [y_sequence_name] were also not defined, else
it will try combining those variables if they are set by user or relying on 
their default values. See [alignment_name] customization variable description
on section~\ref{sec:seqXseqY}, page~\pageref{sec:seqXseqY}, for further info.
It is also explained there but remember that you should take care of unexpected
side effects when setting different sequence names to this command-line option
and its siblings, [x-sequence-name] and [y_sequence_name], if you set one of 
them in a custom file and the others on command-line or viceversa.
###EOR###
ORD: 81
OPT: N
LNG: x-sequence-name
PAR: <seqXname>
EQV: [x_sequence_name]=<seqXname>
SDE: Selects which sequence to plot on X-axis.
LDE: 
You can choose the sequence that is going to be drawn along X-axis, or what
is equivalent, which annotation will appear on that axis. See [alignment-name] 
description to know more about these variables.
###EOR###
ORD: 82
OPT: n
LNG: y-sequence-name
PAR: <seqYname>
EQV: [y_sequence_name]=<seqYname>
SDE: Selects which sequence to plot on Y-axis.
LDE: 
Here you will define which sequence is drawn on Y-axis. Take a look to 
[alignment-name] to get more info about the interactions between these variables.
###EOR###
@ 
<<DESC custom file variables>>=
ORD: 80
SEC: LAYOUT
SUB: Aplot
OPT: alignment_name
PAR: <seqXname:seqYname>
SDE: Selects <seqXname:seqYname> alignment (useful when input contain many alignments).
LDE: 
\label{sec:seqXseqY}
When you are providing several alignments from input, you can select which one
to be plotted. By default program uses first alignment found in the input 
stream if [x_sequence_name] and [y_sequence_name] were also not defined, else
it will try combining those variables if they are set by user or relying on 
their default values. The precedence of those variables is the following:
\centerline{<seqXname:seqYname> $\gg$ <seqXname>:<seqYname> $\gg$ <defaults>}
Where <seqXname>:<seqYname> stands for the combination of the values set for
[x_sequence_name] and [y_sequence_name] variables.
If you set [alignment_name] and <seqXname:seqYname> is not found in the list
of read alignments, program tries to find the reverse, <seqYname:seqXname>, 
else no alignment will be drawn. \\
Remember that if you set this variable on 
command-line and the other two in a customization file or viceversa, you will 
get a plot in which sequence annotation along the axes does not correlate to
the alignment shown, so that make sure that you are using all three in a 
coordinated way (although you are looking for that uncorrelated effect, but 
then it will be your fault, do not blame on {\prog}). This can seem a drawback,
but think that it will be very useful if you are parsing GFF input and the 
alignment name was set with different sequence names: say here you have |SeqA|
and |SeqB|, and the alignment sequence name from filtered output after running
those sequences through your alignment program was set to |my_a:my_b| instead
of |SeqA:SeqB|, so you do not have to reformat the GFF records for the 
alignment or the annotation. Following with that example, if nothing else is 
defined, |SeqA| will be drawn on X-axis and |SeqB| on Y-axis. If happens that
|my_a:my_b| (neither in case you already have |SeqA:SeqB|) does not appear on
GFF input, but program finds an alignment named as |my_b:my_a|, then 
annotations will swap on axes, having |SeqA| along Y-axis and |SeqB| on X-axis.
###EOR###
ORD: 81
SEC: LAYOUT
SUB: Aplot
OPT: x_sequence_name
PAR: <seqXname>
SDE: Selects which sequence annotation is going to be plotted on X-axis.
LDE: 
We define which sequence annotation is going to be drawn on X-axis,
having two or more sequences from GFF input.
By default, the program will use the first sequence id from that input (unless
 you have set something different on [alignment_name] or from command-line).
<seqXname> will be the same as <seqYname> (but then you must define both 
variables, [x_sequence_name] and [y_sequence_name]), this is useful when 
comparing a sequence against itself to find repeated elements, but take care 
not doing that when you are trying to compare different sequences because the 
program cannot guess that you do not want to do that.
###EOR###
ORD: 82
SEC: LAYOUT
SUB: Aplot
OPT: y_sequence_name
PAR: <seqYname>
SDE: Selects which sequence annotation is going to be plotted on Y-axis.
LDE: 
This variable allows you to define which sequence is going to be drawn along
the Y-axis. Take a look to [alignment_name] and [x_sequence_name] variables 
descriptions for a deeper explanation of their settings and behaviour. 
###EOR###
@


<<default layout vars values>>=
aplot_xy_same_length       => { TYPE => 'BOOLEAN', VALUE => $T     },
aplot_xy_scale             => { TYPE => 'FLOAT',   VALUE => 1      },
@ %def {aplot_xy_same_length} {aplot_xy_scale}
<<command-line options>>=
"r|aplot-xy-noteq"     => sub { $CmdLineVars{LAYOUT}{"aplot_xy_same_length"} = $F },
"R|aplot-xy-scale=f"   => \$CmdLineVars{LAYOUT}{"aplot_xy_scale"}, 
@ 
<<command-line help>>=
-r, --aplot-xy-noteq
      By default X and Y axes have same length, this option 
      disables such behaviour, so X and Y sequence will have
      axes-lengths proportional to their nucleotide lengths.
-R, --xy-axes-scale  <X/Y ratio>
      This option allows to set a different scale between X
      and Y axes lengths (by default is '1'). Below 1 values
      make Y larger than X, and larger than 1 result in getting
      X larger than Y. # Must be explained better.
@ 
<<DESC command-line options>>=
ORD: 83
OPT: r
LNG: aplot-xy-noteq
EQV: [aplot_xy_same_length]=|off|
SDE: 
LDE: 

###EOR###
ORD: 84
OPT: R
LNG: xy-axes-scale
PAR: <X/Y ratio>
EQV: [aplot_xy_scale]=<X/Y ratio>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 83
SEC: LAYOUT
SUB: Aplot
OPT: aplot_xy_same_length
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 84
SEC: LAYOUT
SUB: Aplot
OPT: xy-axes-scale
DEF: |1|
PAR: <X/Y ratio>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
alignment_scale_width      => { TYPE => 'BOOLEAN', VALUE => $F     },
alignment_scale_color      => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {alignment_scale_width} {alignment_scale_color}
<<command-line options>>=
"W|aln-scale-width"    => \$CmdLineVars{LAYOUT}{"alignment_scale_width"}, # APlotLine_ScaleWidth; APlotLine_GroupScore
"w|aln-scale-color"    => \$CmdLineVars{LAYOUT}{"alignment_scale_color"}, # APlotLine_ScaleGrey; APlotLine_GroupScore
@ 
<<command-line help>>=
-W, --aln-scale-width   Scaling score on width for Aplot lines.
-w, --aln-scale-color   Scaling score on color for Aplot lines.
@
<<DESC command-line options>>=
ORD: 85
OPT: W
LNG: aln-scale-width
EQV: [alignment_scale_width]=|on|
SDE: 
LDE: 

###EOR###
ORD: 86
OPT: w
LNG: aln-scale-color
EQV: [alignment_scale_color]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 85
SEC: LAYOUT
SUB: Aplot
OPT: alignment_scale_width
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 86
SEC: LAYOUT
SUB: Aplot
OPT: alignment_scale_color
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
show_ribbons               => { TYPE => 'BOOLEAN', VALUE => $F     },
ribbons_style              => { TYPE => 'RIBBON',  VALUE => undef  },
show_grid                  => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_ribbons} {show_grid}
<<command-line options>>=
"K|show-ribbons=s"   => \$CmdLineVars{LAYOUT}{"ribbons_style"}, # Show_Ribbons (NLRB)
"G|show-grid"        => \$CmdLineVars{LAYOUT}{"show_grid"}, # Display_GRID
# "g"    => \$CmdLineVars{LAYOUT}{""}, # Display_GRID
@ 
<<command-line help>>=
-K, --show-ribbons <ribbon_type>
      Force Ribbons for all features on axes to be:
         (N)one, (L)ines, (R)ibbons, (B)oth.
-G, --show-grid   Switches 'on' grid (default is 'off').
@
<<DESC command-line options>>=
ORD: 87
OPT: K
LNG: show-ribbons
PAR: <ribbon-type>
EQV: [show_ribbons]=<ribbon-type>
SDE: 
LDE: 

###EOR###
ORD: 88
OPT: G
LNG: show-grid
EQV: [show_grid]=|on|
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 87
SEC: LAYOUT
SUB: Aplot
OPT: show_ribbons
PAR: <ribbon-type>
SDE: 
LDE: 

###EOR###
ORD: 88
SEC: LAYOUT
SUB: Aplot
OPT: show-grid
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
show_percent_box           => { TYPE => 'BOOLEAN', VALUE => $F     },
show_extra_box             => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_percent_box} {show_extra_box}
<<command-line options>>=
"I|show-percent-box"   => \$CmdLineVars{LAYOUT}{"show_percent_box"}, # Display_PERCENT-BOX
"i|hide-percent-box"   => sub { $CmdLineVars{LAYOUT}{"show_percent_box"} = $F }, # Display_PERCENT-BOX
"O|show-extra-box"     => \$CmdLineVars{LAYOUT}{"show_extra_box"}, # Display_EXTRA-BOX
"o|hide-extra-box"     => sub { $CmdLineVars{LAYOUT}{"show_extra_box"} = $F }, # Display_EXTRA-BOX
@ 
<<command-line help>>=
-I, --show-percent-box
      Switches 'on' Percent box (default is 'off').
-i, --hide-percent-box
      Switches 'off' Percent box (if set to 'on' on custom files).
-O, --show-extra-box
      Switches 'on' Extra box (default is 'off').
-o, --hide-extra-box
      Switches 'off' Extra box (if set to 'on' on custom files).
@
<<DESC command-line options>>=
ORD: 89
OPT: I
LNG: show-percent-box
EQV: [show_percent_box]=|on|
SDE: 
LDE: 

###EOR###
ORD: 90
OPT: i
LNG: hide-percent-box
EQV: [show_percent_box]=|off|
SDE: 
LDE: 

###EOR###
ORD: 91
OPT: O
LNG: show-extra-box
EQV: [show_extra_box]=<on>
SDE: 
LDE: 

###EOR###
ORD: 92
OPT: o
LNG: hide-extra-box
EQV: [show_extra_box]=<off>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 91
SEC: LAYOUT
SUB: Aplot
OPT: show_percent_box
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 92
SEC: LAYOUT
SUB: Aplot
OPT: show_extra_box
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@


<<default layout vars values>>=
aplot_box_bgcolor          => { TYPE => 'COLOR'  , VALUE => 'bg'   },
percent_box_bgcolor        => { TYPE => 'COLOR'  , VALUE => 'bg'   },
extra_box_bgcolor          => { TYPE => 'COLOR'  , VALUE => 'bg'   },
@ %def {aplot_box_bgcolor} {percent_box_bgcolor} {extra_box_bgcolor}
<<command-line options>>=
"D|aplot-box-color=s"    => \$CmdLineVars{LAYOUT}{"aplot_box_color"}, # APlotBox_BqGCOLOR
"d|percent-box-color=s"  => \$CmdLineVars{LAYOUT}{"percent_box_color"}, # PercentBox_BGCOLOR
"b|extra-box-color=s"    => \$CmdLineVars{LAYOUT}{"extra_box_color"}, # ExtraBox_BGCOLOR
@ 
<<command-line help>>=
-D, --aplot-box-color <color>   Aplot main box background color.
-d, --percent-box-color <color>   Percent box background color.
-b, --extra-box-color <color>   Extra box background color.
@
<<DESC command-line options>>=
ORD: 93
OPT: D
LNG: aplot-box-color
PAR: <color>
EQV: [aplot_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
ORD: 94
OPT: d
LNG: percent-box-color
PAR: <color>
EQV: [percent_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
ORD: 95
OPT: b
LNG: extra-box-color
PAR: <color>
EQV: [extra_box_bgcolor]=<color>
SDE: 
LDE: 

###EOR###
@ 
<<DESC custom file variables>>=
ORD: 93
SEC: LAYOUT
SUB: Aplot
OPT: aplot_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 94
SEC: LAYOUT
SUB: Aplot
OPT: percent_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
ORD: 95
SEC: LAYOUT
SUB: Aplot
OPT: extra_box_bgcolor
DEF: |bg|
PAR: <color>
SDE: 
LDE: 

###EOR###
@


\subsubsctn{Tickmarks customization}

<<default layout vars values>>=
show_tickmark_label        => { TYPE => 'BOOLEAN', VALUE => $T     },
show_only_bottom_ticks     => { TYPE => 'BOOLEAN', VALUE => $F     },
@ %def {show_tickmark_label} {show_only_bottom_ticks}
<<DESC custom file variables>>=
ORD: 100
SEC: LAYOUT
SUB: Tickmarks
OPT: show_tickmark_label
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 101
SEC: LAYOUT
SUB: Tickmarks
OPT: show_only_bottom_ticks
DEF: |off|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_aplot_x_ticks         => { TYPE => 'BOOLEAN', VALUE => $T     },
show_aplot_y_ticks         => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_aplot_x_ticks} {show_aplot_y_ticks}
<<DESC custom file variables>>=
ORD: 102
SEC: LAYOUT
SUB: Tickmarks
OPT: show_aplot_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 103
SEC: LAYOUT
SUB: Tickmarks
OPT: show_aplot_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_percent_x_ticks       => { TYPE => 'BOOLEAN', VALUE => $T     },
show_percent_y_ticks       => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_percent_x_ticks} {show_percent_y_ticks}
<<DESC custom file variables>>=
ORD: 104
SEC: LAYOUT
SUB: Tickmarks
OPT: show_percent_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 105
SEC: LAYOUT
SUB: Tickmarks
OPT: show_percent_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
show_extrabox_x_ticks      => { TYPE => 'BOOLEAN', VALUE => $T     },
show_extrabox_y_ticks      => { TYPE => 'BOOLEAN', VALUE => $T     },
@ %def {show_extrabox_x_ticks} {show_extrabox_y_ticks}
<<DESC custom file variables>>=
ORD: 106
SEC: LAYOUT
SUB: Tickmarks
OPT: show_extrabox_x_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
ORD: 107
SEC: LAYOUT
SUB: Tickmarks
OPT: show_extrabox_y_ticks
DEF: |on|
PAR: <boolean>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
aplot_major_tickmark       => { TYPE => 'INTEGER', VALUE => undef  },
aplot_minor_tickmark       => { TYPE => 'INTEGER', VALUE => 5      },
aplot_score_range          => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {aplot_major_tickmark} {aplot_minor_tickmark} {aplot_score_range}
<<DESC custom file variables>>=
ORD: 108
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_major_tickmark
DEF: |2|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 109
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 110
SEC: LAYOUT
SUB: Tickmarks
OPT: aplot_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
percent_major_tickmark     => { TYPE => 'INTEGER', VALUE => 5      },
percent_minor_tickmark     => { TYPE => 'INTEGER', VALUE => 5      },
percent_box_score_range    => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {percent_major_tickmark} {percent_minor_tickmark} {percent_box_score_range}
<<DESC custom file variables>>=
ORD: 111
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_major_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 112
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 113
SEC: LAYOUT
SUB: Tickmarks
OPT: percent_box_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@

<<default layout vars values>>=
extra_major_tickmark       => { TYPE => 'INTEGER', VALUE => 2      },
extra_minor_tickmark       => { TYPE => 'INTEGER', VALUE => 5      },
extra_box_score_range      => { TYPE => 'RANGE'  , VALUE => undef  },
@ %def {extra_major_tickmark} {extra_minor_tickmark} {extra_box_score_range}
<<DESC custom file variables>>=
ORD: 114
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_major_tickmark
DEF: |2|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 115
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_minor_tickmark
DEF: |5|
PAR: <integer>
SDE: 
LDE: 

###EOR###
ORD: 116
SEC: LAYOUT
SUB: Tickmarks
OPT: extra_box_score_range
PAR: <score..score>
SDE: 
LDE: 

###EOR###
@ 

<<default layout vars values>>=
major_tickmark_nucleotide  => { TYPE => 'SEQ_UNIT', VALUE => undef  },
minor_tickmark_nucleotide  => { TYPE => 'SEQ_UNIT', VALUE => undef  },
@ %def {major_tickmark_nucleotide} {minor_tickmark_nucleotide}
<<DESC custom file variables>>=
ORD: 117
SEC: LAYOUT
SUB: Tickmarks
OPT: major_tickmark_nucleotide
PAR: <nucleotides>
SDE: 
LDE: 

###EOR###
ORD: 118
SEC: LAYOUT
SUB: Tickmarks
OPT: minor_tickmark_nucleotide
PAR: <nucleotides>
SDE: 
LDE: 

###EOR###
@ 


\subsubsctn{Global settings}

The following variables must be set to undef for layout defaults or not (Depending on what rules out the global layout settings or the feature attributes). 
% VAR-ORD 41-60 : CLO-ORD 20-60

<<default layout vars values>>=
show_feature_label         => { TYPE => 'BOOLEAN', VALUE => $T     }, 
feature_x_label_angle      => { TYPE => 'INTEGER', VALUE => 0      },
feature_y_label_angle      => { TYPE => 'INTEGER', VALUE => 0      },
feature_label_length       => { TYPE => 'INTEGER', VALUE => 0      },
feature_label_rotate       => { TYPE => 'BOOLEAN', VALUE => $F      },
feature_label_font         => { TYPE => 'FONT'   , VALUE => 'helvetica' },
feature_label_fontsize     => { TYPE => 'PS_UNIT', VALUE => [ 5, 'pt' ]  },
@ %def {show_feature_label}

<<default layout vars values>>=
show_group_label           => { TYPE => 'BOOLEAN', VALUE => $T     }, 
group_x_label_angle        => { TYPE => 'INTEGER', VALUE => 0      },
group_y_label_angle        => { TYPE => 'INTEGER', VALUE => 0      },
group_label_length         => { TYPE => 'INTEGER', VALUE => 0      },
group_label_rotate         => { TYPE => 'BOOLEAN', VALUE => $F      },
group_label_font           => { TYPE => 'FONT'   , VALUE => 'helvetica' },
group_label_fontsize       => { TYPE => 'PS_UNIT', VALUE => [ 5, 'pt' ]  },
@ %def {show_group_label}

<<default layout vars values>>=
hide_credits               => { TYPE => 'BOOLEAN', VALUE => $F      },
@ %def {hide_credits}
<<command-line options>>=
"a|hide-credits"   => \$CmdLineVars{LAYOUT}{"hide_credits"}, # Show_Credits
@ 
<<command-line help>>=
-a, --hide-credits
      Switch off $PROGRAM credits line on plot.
@
<<DESC command-line options>>=
ORD: 250
OPT: a
LNG: hide-credits
EQV: [hide_credits]=|on|
SDE: Switch off program credits line on plot.
LDE: 

###EOR###
@
<<DESC custom file variables>>=
ORD: 250
SEC: LAYOUT
SUB: General
OPT: hide_credits
DEF: |off|
PAR: <boolean>
SDE: Switch off program credits line on plot.
LDE: 

###EOR###
@

<<Changes in command-line options>>=
# "i"  => # Page_Orientation
# "F"  => \$CmdLineVars{LAYOUT}{""}, # Function_COLOR;Display_FUNCTION;Display_EXTRA-BOX
# "f"  => \$CmdLineVars{LAYOUT}{""}, # Display_FUNCTION; Display_EXTRA-BOX
# "M"  => \$CmdLineVars{LAYOUT}{""}, # Display_GFF; Display_EXTRA-BOX
# "m"  => \$CmdLineVars{LAYOUT}{""}, # Display_GFF-ReverseOrder; Display_EXTRA-BOX
@


\subsctn{Sequence variables}

<<default sequence vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Source variables}

<<default source vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Strand variables}

<<default strand vars values>>=
NIL => { TYPE => 'BOOLEAN', VALUE => $F },
@


\subsctn{Group variables}

<<default group vars values>>=
show_group_label           => { TYPE => 'BOOLEAN', VALUE => $T     }, 
show_group_rule            => { TYPE => 'BOOLEAN', VALUE => $T     },
show_group_arrow           => { TYPE => 'BOOLEAN', VALUE => $T     },
feature_arrows_color       => { TYPE => 'COLOR'  , VALUE => 'fg'   },
Show_JOINS                 => { TYPE => 'BOOLEAN', VALUE => $T     },
Join_Lines_COLOR           => { TYPE => 'COLOR'  , VALUE => 'fg'   },
@


\subsctn{Feature variables}

<<default feature vars values>>=
Show_HalfHeightBOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
HalfSizeBox_BGCOLOR        => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_FullHeightBOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
FullSizeBox_BGCOLOR        => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_BOX_LABEL             => { TYPE => 'BOOLEAN', VALUE => $T     },
Show_UserDef_BOX_LABEL     => { TYPE => 'BOOLEAN', VALUE => $T     },
Show_RIBBON                => { TYPE => 'BOOLEAN', VALUE => $T     },
Ribbon_BGCOLOR             => { TYPE => 'COLOR'  , VALUE => 'DEFAULT' },
Show_GFF                   => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_GFF_ReverseOrder      => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_FUNCTION              => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_GroupScore       => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_ScaleWidth       => { TYPE => 'BOOLEAN', VALUE => $F     },
APlotLine_ScaleGrey        => { TYPE => 'BOOLEAN', VALUE => $F     },
Show_SELECTION_BOX         => { TYPE => 'BOOLEAN', VALUE => $T     },
SelectionBox_BGCOLOR       => { TYPE => 'COLOR'  , VALUE => 'grey' },
Function_COLOR             => { TYPE => 'COLOR'  , VALUE => 'red'  },
@

\begin{comment}
## ## 
## XTR (bin): Force those <features> for which XTR is switched ON
##   to be displayed in the third panel, if the Plot Option 
##   "Display_EXTRA-BOX" is switched ON.
## ## 
## Box (FHN): Define the box size (FHN) for <feature>.
## ##
## Line (NLRB): Draw lines across all panels for the <feature>.
## ##
## Join (bin): Switch ON to connect elements of one group with splice symbols.
## ##
## Arrw (bin): Swicth ON to display an arrow that shows the <feature>'s strand.
## ##
## Lbl (bin): Swicth ON to display the <feature>'s label
##   (if it's defined in the .gff file).
## ##
## Color (clr): Fill <Box> with this color.
## ##
## CLine (clr): Fill Line <Ribbons> with this color.
## ##
## Wdth (HND): You can choose among three predefined LineWidths.
## ##
## Layr : Layer where is drawed each feature.
##   You must pass an integer for feature ordering (1..n),
##   put 0 to print the feature always on top. 
\end{comment}

<<Changes in custom Vars>>=
# PERCENT_ORIGIN => "50",
# PERCENT_END => "100",
Align_NAME       \
X_Sequence_NAME   >--> To be defined in SOURCE
Y_Sequence_NAME  /
### FL ## FLAGs ##
### DF ## DEFAULT VALUES ##
### OP ## OPTIONs ##
### FT ## GFF FEATUREs DEFINITION ##
  # FTcounter++,
  # FTindex[""]="",
  # FTputEXTRA[""]=OnOff(""),
  # FTBoxType[""]="",
  # FTLineType[""]="",
  # FTputJoin[""]=OnOff(""),
  # FTputArrow[""]=OnOff(""),
  # FTputLabel[""]=OnOff(""),
  # FTLineWidth[""]="",
  # FTLayer[""]="",
  # FTColor[""]=Var["BACKGROUND_COLOR"],
  # FTRbnColor[""]=Var["BACKGROUND_COLOR"],
@ 

<<Changes in custom Vars>>=
### SP ## Special gff Features ##
  # FTGeneBounds="genebounds", NOT NEEDED NOW !!!
  FTLimits="seqbounds",
  FTAPlot="align",
  FTHighLight="boxit",
  FTRectangle="rectangle",
  FTCircle="circle",
  FTText="text",
  FTExtraFunction="function",
  FTExtraDisplay="est",
@
 

\newpage

\sctn{Reading GFF records} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have to deal with two basic formats, the \textsl{standard} General Feature Format (GFF) and the derived \textsl{aplot} format, the former having two versions with some minor differences at field level. We are going to asume the record formats shown in the table~\ref{tbl:formats} for the input files.


\label{todo:EEA}\label{todo:EEB}
<<HIDE: new defs TODO>>=
\def\todoEEA{
A flow chart of the GFF record parsing process (figure~\ref{fig:parsingGFF}).
} % todoEEA
\def\todoEEB{
Move this section to a perl package: \\ suggesting [[gfftools::parser]].
} % todoEEB
@
<<HIDE: TODO>>=
\todoitem{\todoEEA}{todo:EEA}
\todoitem{\todoEEB}{todo:EEB}
@
\todo{ \item \todoEEA 
       \item \todoEEB } % todo


\begin{figure}[!t]
\begin{center}
\fbox{\parbox[c][8cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[Flow diagram of the input records parsing.]{\label{fig:parsingGFF} Flow diagram of the input records parsing showing the main function names involved in this process.}
\end{center}
\end{figure}

\begin{table}[!t]
% \newcommand{\m}[1]{\multicolumn{2}{@{}c@{}}{#1}}
\begin{center}\setlength{\fboxsep}{10pt}
\fbox{
\begin{minipage}[c]{0.95\linewidth}
\begin{center}
\footnotesize
\textbf{\normalsize Record Format}\\[1ex]
\pa{seqname} \pa{source} \pa{feature} \pa{start} \pa{end} \pa{score} \pa{strand} \pa{frame} [attributes] [comments]\\[2ex]
\renewcommand{\arraystretch}{1.5}\begin{tabular}{ccc}
\textbf{Field Name} & \textbf{GFF Version 1/Version 2} & \textbf{Aplot format} \\
\pa{seqname} & [[ [^\# ]+ ]]     & \pa{seqname1}:\pa{seqname2} \\
\pa{source}  & [[ [^\# ]+ ]]     & \pa{source}[:\pa{source}]   \\
\pa{feature} & [[ [^\# ]+ ]]     & \pa{feature}[:\pa{feature}] \\
\pa{start}   & [[ [+-]?[0-9]+ ]] & \pa{start1}:\pa{start2}     \\
\pa{end}     & [[ [+-]?[0-9]+ ]] & \pa{end1}:\pa{end2}         \\
\pa{score}   & [[ [+-]?[0-9]*[.]?[0-9]*(e[+-]?[0-9]+)? ]] & \pa{alignment\_score}       \\[-1.5ex]
  (no score) & GFFv1 [[=> 0]] / GFFv2 [[=> .]] & . \\
\pa{strand}  & [[ [+-.] ]]  & \pa{strand1}[:\pa{strand2}] \\
\pa{frame}   & [[ [.012] ]] & \pa{frame1}[:\pa{frame2}]   \\[0.5ex]
\textbf{Field Separator} & GFFv1 [[=> \s+ ]] / GFFv2 [[=> [\t]+ ]] & [[ \s+ ]] \\
\end{tabular}\\[4ex]
\textbf{\normalsize Grouping fields}\\[1ex]
\begin{tabular}{rl}
 \,[attributes]  & \hspace{0.25cm}(\textsl{GFF v1\&v2, APLOT})\\
                 & group\_name [extra\_data]\\
                 & "group\_name" [extra\_data]\\
                 & \pa{tag} "group\_name" [extra\_data]\\[1ex]
 \,[extra\_data] & \\
                 & [\,[\pa{start2} \pa{end2} [\pa{strand2}] [\pa{frame2}]\,]; \pa{tag} \pa{value} [ \ldots ; \pa{tag} \pa{value}]\,]\\[2ex]
 \,[attributes]  & \hspace{0.25cm}(\textsl{APLOT old format})\\
                 & group\_name:element\_name [extra\_data]\\[1ex]
 \,[extra\_data] & \hspace{0.25cm}(\textsl{APLOT old format})\\
                 & [\,; \pa{tag} \pa{value} [ \ldots [ ; \pa{tag} \pa{value}]\,]\,]\\
\end{tabular}\\[4ex]
\textbf{\normalsize Other definitions}\\[1ex]
\begin{tabular}{rl}
 \,[comments]    & [[# Whatever extra information about this record...]] \\
\end{tabular}
\end{center}
\end{minipage}
} %fbox
\caption{\label{tbl:formats} Input records format definition for {\prog}.}
\end{center}
\end{table}


Function '[[&parse_GFF_files]]' is only a wrapper for reporting the parsing process over GFF records. The main function call is '[[&fieldscheck]]',which processes each GFF record and loads the values in its fields to the corresponding data structure. Although that, the wrapper checks if there are enough fields (8 required at least) and removes also any comment from the input record, assuming that a white space or a tab followed by a '[[#]]' (as shown in this regular expression: '[[ /\s+\#/ ]]') is a comment mark, from there to the end of line everything is ignored.

<<Parsing Input Data>>=
sub parse_GFF_files() {
    &header("PARSING INPUT GFF RECORDS");
  LOAD: foreach $file (@data_files) {
      open(THIS,"< $file") ||
          (&warn('FILE_NO_OPEN',$T,$file), next LOAD);
      $file eq '-' && ($file = 'STANDARD INPUT');
      &report('READ_GFF_FILE',$file);
      ($n,$c) = (0,undef);
      while (<THIS>) {
          my (@line,$main);
          ($c = '.', next) if /^\#/o;
          ($c = '.', next) if /^\s*$/o;
          chomp;
          # $c = $noGFF;
          ($main,undef) = split /\s+\#/o;
          @line = split /\s+/o, $main, 9;        
          scalar(@line) < 8 &&
              (&warn('NOT_ENOUGH_FIELDS',$F,$file,$n,join(" ",@line)), next);
          $c = &GFF_format(&fieldscheck(\@line));
      } continue {
          &counter(++$n,$c) if ($Verbose && !$Quiet);
      }; # WHILE
      &counter_end($n,$c) if ($Verbose && !$Quiet);
      close(THIS);
  }; # LOAD
    print LOGFILE (Data::Dumper->Dump([ \%GFF_DATA, \%ALN_DATA  ],
                                   [ qw( *GFF_DATA   *ALN_DATA ) ]))
        if ($LogFile && $Debug);
    &footer("DATA LOADED");
} # sub parse_GFF
@ %def &parse_GFF
%$ print LOGFILE '>>> \%GFF_DATA : '.(Dumper(\%GFF_DATA))


We define the following constants, used to report which format was found in the current read record (See table~\ref{tbl:DTkeysXreport}).

\begin{table}[!t]
\begin{center}
\begin{tabular}{cc}
\fbox{
\begin{tabular}[b]{c>{\bfseries}c}
\textbf{Record TYPE} & \textbf{Symbol} \\
Empty record        & . \\
Comment             & . \\
GFF (grouped)       & X \\
GFF (ungrouped)     & x \\
GFF (alignment)     & A \\
GFF (vector)        & V \\
APLOT (grouped)     & O \\
APLOT (ungrouped)   & o \\
Unknown             & ? \\
\end{tabular}
} %fbox
&
\parbox[b]{0.4\linewidth}{
\caption[Symbols used to report record type from data files]{\label{tbl:DTkeysXreport} Symbols used to report record type when parsing input GFF files (and [[STDERR]] verbose mode is enabled with '[[-v]]' switch).}
} % parbox
\\
\end{tabular}
\end{center}
\end{table}

<<Pre-Declared Vars>>=
$GFF $GFF_NOGP $VECTOR $ALIGN $APLOT $APLOT_NOGP $noGFF
@ 
<<Global Constants>>=
($GFF,$GFF_NOGP,$VECTOR,$ALIGN,
    $APLOT,$APLOT_NOGP,$noGFF) =
    qw/ X x V A O o ? /;
@ 

<<warnings - parsing GFF files>>=
NOT_ENOUGH_FIELDS =>
  $Warn."Not enough fields in file \"\%s\", line \%s :\n\t\%s\n",
@ 

<<messages - parsing GFF files>>=
READ_GFF_FILE => 
  $sp."### Reading GFF records from \"\%s\"\n".$sp,
@

We set the character being printed in the parsing status output.

<<Parsing Input Data>>=
sub GFF_format() {
    my $gff = $_[0];
    # return "x" if $GFF == $version1;
    return $GFF        if $gff eq $GFF;        # $version2
    return $GFF_NOGP   if $gff eq $GFF_NOGP;   # $version2 (ungrouped)
    return $VECTOR     if $gff eq $VECTOR;     # VECTOR: GFFv2 particular case 
    return $ALIGN      if $gff eq $ALIGN;      # ALIGN: GFFv2 particular case
    return $APLOT      if $gff eq $APLOT;      # Old aplot format (with colons)
    return $APLOT_NOGP if $gff eq $APLOT_NOGP; # Old aplot format (ungrouped)
    return $noGFF;
} # GFF_format
@ %def &GFF_format
%$

Here we decide to parse records as they are in GFF or in APLOT format. '[[load_gff]]' and '[[load_aplot]]' do the field error checking and load the program variables '[[%GFF_DATA]]' and '[[%ALN_DATA]]'. Those variables are reset in '[[<<Main Loop>>]]'.

<<Parsing Input Data>>=
sub fieldscheck() {
    my ($list) = @_;
    my ($seqname,$start,$end) = @$list[0,3,4]; 
                              # ($list->[0],$list->[3],$list->[4]);
    (&fcolon($seqname) && &fcolon($start) && &fcolon($end)) && do {
        return &load_aplot($list);
    };
    return &load_gff($list);
} # fieldscheck
@ %def &fieldscheck

For historical reasons the program can work with APLOT format (see Table~\ref{tbl:formats}). Initial field checking determines whether the record being processed is under that alignment GFF-like format, by determining that first, fourth and fifth fields contain a colon char. Then we assume we are under APLOT format.

<<Parsing Input Data>>=
sub fcolon() { return ($_[0] =~ /.+:.+/o ? $T : $F) }
@ %def &fcolon

\subsctn{Validating fields}

The following functions checks whether some of the input GFF fields are well defined. They return '[[True]]' ('[[$T]]') if no error found and '[[False]]' ('[[$F]]') when input fields are wrong. The returned value forces '[[&load_aplot]]' or '[[&load_gff]]' functions to skip the records having format errors.

Here we test that '\pa{start}' field must be lower or equal than '\pa{end}':

\label{func:checkcoords}
<<Parsing Input Data>>=
sub check_coords() { # ((ori,end)_1,...,(ori,end)_n)
    my @ary = @_;
    for (my $j=0; $j<=$#ary; $j+=2) {
        $ary[$j] > $ary[$j+1] && do {
            &warn('ORI_GREATER_END',$F,$ary[$j],$ary[$j+1],$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_coords
@ %def &check_coords

<<warnings - parsing GFF files>>=
ORI_GREATER_END =>
  $Warn."Start greater than end \"\%s > \%s\" in file \"\%s\" line \"\%s\".\n", 
@

'\pa{strand}' field must contain only '+', '-' or '.' (for records having no strand).

<<Parsing Input Data>>=
sub check_strand() { # (str_1,...,srt_n)
    foreach my $str (@_) {
        $str !~ /[+-.]/o && do {
            &warn('STRAND_MISMATCH',$F,$str,$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_strand
@ %def &check_strand

<<warnings - parsing GFF files>>=
STRAND_MISMATCH =>
  $Warn." Strand mismatch definition \"\%s\" in file \"\%s\" line \"\%s\".\n",
@ 

Same happens to '\pa{frame}', which only '0', '1', '2' or '.' (for those records having no frame) values are allowed.

<<Parsing Input Data>>=
sub check_frame() { # (frm_1,...,frm_n)
    foreach my $frm (@_) {
        $frm !~ /[.012]/o && do {
            &warn('FRAME_MISMATCH',$F,$frm,$file,$n+1);
            return $F;
        };
    }; # foreach
    return $T;
} # check_frame
@ %def &check_frame

<<warnings - parsing GFF files>>=
FRAME_MISMATCH =>
  $Warn." Frame mismatch definition \"\%s\" in file \"\%s\" line \"\%s\".\n",
@ 


\subsctn{Parsing standard GFF format}
\label{sec:parseGFF}

'[[&check_gff_fields]]' will call to the '[[&add_gff_record]]' which loads the new record if everything is OK into '[[%GFF_DATA]]' (see section~\ref{sec:GFFhsh}, page~\pageref{sec:GFFhsh}). The first parameter for '[[&load_grouping]]' function is set to 'True' for GFF grouping definition ('False' is for APLOT grouping definition, see section~\ref{sec:parseAPLOT}). 

<<Parsing Input Data>>=
sub load_gff() { # if errors found > return $noGFF
    my ($list) = @_ ;
    my $w_gff;
    ($seqname,$source,$feature,$start,$end,
     $score,$strand,$frame) = @$list[0,1,2,3,4,5,6,7];
    $w_gff = &load_grouping($T,$list->[8]);
    &check_gff_fields($w_gff) || ($w_gff=$noGFF);
    return $w_gff;
} # load_gff
@ %def &load_gff

<<Global Vars>>=
my ($seqname,$source,$feature,$start,
    $end,$score,$strand,$frame); # GFF temporary vars
@

\subsubsctn{Checking fields and accepting GFF records}

<<Parsing Input Data>>=
sub check_gff_fields() {
    &check_coords($start,$end) || (return $F);
    &check_strand($strand) || (return $F);
    &check_frame($frame) || (return $F);
    &add_gff_record($_[0]);
    return $T; 
} # check_gff_fields
@ %def &check_gff_fields

\begin{table}[!t]
\begin{center}
\input tables/DataStructure_GFF.tex
\caption[GFF internal data structure for {\prog}]{\label{tbl:gffdata} GFF internal data structure for {\prog}. The topmost hash corresponds to '[[%GFF_DATA]]', the others are anonymous lists/hashes expanding from it.}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<HIDE: GFF DATA STRUCTURE>>= 
% DataStructure_GFF.tex
 \newcommand{\arry}[1]{@[\:#1\:]}
 \newcommand{\hash}[1]{\%\{\:#1\:\}}
 \newcommand{\aryrow}[3]{\mbox{#1}_#2 & \Rightarrow & \arry{\arry{\mbox{Counters}}_#2,\:\hash{\mbox{Properties}}_#2,\:\hash{\mbox{#3}}_#2},}
 \newcommand{\aryrowb}[3]{\mbox{#1}_#2 & \Rightarrow & \arry{\arry{\mbox{Counters}}_#2,\:\hash{\mbox{Properties}}_#2,\:\arry{\mbox{#3}}_#2},}
 \newcommand{\tbl}[2]{  
  \% \left\{
  \begin{array}{ccc}
   \aryrow{#1}{0}{#2} \\ 
       & \vdots &     \\
   \aryrow{#1}{n}{#2}  
  \end{array}
  \right\}
  } % \tbl
 \newcommand{\tblb}[2]{  
  \% \left\{
  \begin{array}{ccc}
   \aryrowb{#1}{0}{#2} \\ 
       & \vdots &      \\
   \aryrowb{#1}{n}{#2}  
  \end{array}
  \right\}
 } % \tbl
 \newcommand{\connect}[3]{
   \put(#1,#2){
    \put(0,0){\line(0,-1){0.5}}
    \put(0,-0.5){\line(-1,0){#3}\vector(-1,-2){0.35}}
   } % put
  } % connect
 %
\fbox{
\begin{minipage}[t]{0.975\linewidth}
\unitlength1cm
\begin{picture}(14,19.5)
 \put(7,17.0){\makebox(2,14)[b]{$\tbl{SEQUENCE}{SOURCES}$}}
 \connect{12.75}{16.95}{9.25}
 \put(7,14.0){\makebox(2,14)[b]{$\tbl{SOURCE}{STRANDS}$}}
 \connect{12.50}{13.95}{9.0}
 \put(7,11.0){\makebox(2,14)[b]{$\tbl{STRAND}{GROUPS}$}}
 \connect{12.50}{10.95}{9.0}
 \put(7, 8.0){\makebox(2,14)[b]{$\tblb{GROUP}{ELEMENTS}$}}
 \connect{12.40}{7.95}{9.4}
 \put(7, 5.0){\makebox(2,14)[b]{
   $ @\left[ \begin{array}{c}
   \arry{\mbox{Type},\:\hash{\mbox{Properties}},\:\mbox{GFF-Feature},\:\mbox{ID},\:\mbox{Start},\:\mbox{End},\:\mbox{Score},\:\mbox{Frame}}_0 \\
   \hfill \vdots \hfill \vdots \hfill \vdots \hfill \vdots \hfill \qquad \\
   \arry{\mbox{Type},\:\hash{\mbox{Properties}},\:\mbox{GFF-Feature},\:\mbox{ID},\:\mbox{Start},\:\mbox{End},\:\mbox{Score},\:\mbox{Frame}}_n \\
   \end{array} \right] $
  } % makebox
 } % put
 \put(2,3.75){\line(1,0){12}}
 \put(7,0.5){ \makebox(2,14)[b]{
$ \begin{array}{r@{\quad=\quad}l}
\arry{\mbox{COUNTERS}} & 
(\:\mbox{Order \#},\:\mbox{Elements \#},\:\mbox{Start},\:\mbox{End}\:) \\[2.5ex]
\hash{\mbox{PROPERTIES}} & 
\left\{
 \begin{array}{ccc}
  \mbox{VAR\_NAME}_0 & \Rightarrow & \backslash\mbox{\$VALUE}_0 \\ 
                     &    \vdots   &  \\
  \mbox{VAR\_NAME}_k & \Rightarrow & \backslash\mbox{\$VALUE}_k
 \end{array}
\right\}
\end{array} $ 
  } % makebox
 } % put
\end{picture}
\end{minipage}
} % fbox
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsctn{Parsing APLOT format}
\label{sec:parseAPLOT}

'[[&check_aplot_fields]]' will call to the '[[&add_aplot_record]]' which loads the new record if everything is OK into '[[%ALN_DATA]]' (see section~\ref{sec:APLOThsh}, page~\pageref{sec:APLOThsh}). The first parameter for '[[&load_grouping]]' function is set to 'False' is for APLOT grouping definition ('True' for GFF grouping definition, see section~\ref{sec:parseGFF}).

<<Parsing Input Data>>=
sub load_aplot() { # if errors found > return $noGFF
    my ($list) = @_;
    my $w_gff;
    ($seqname_1,$seqname_2,$source_1,$source_2,$feature_1,$feature_2,
     $start_1,$start_2,$end_1,$end_2,
     $strand_1,$strand_2,$frame_1,$frame_2) = 
     &remove_colon(@$list[0,1,2,3,4,6,7]);
    ($score_1,$score_2) = ($list->[5], undef);
    $w_gff = &load_grouping($F,$list->[8]);
    &check_aplot_fields($w_gff) || ($w_gff=$noGFF);
    return $w_gff;
} # load_aplot
@ %def &load_aplot
%$

We reserve [[$score_2]] for other scores than can be passed, we may have bit-scores in '[[score]]' field (so [[$score_1]] will be set to that) and alignment-scores in a tag-value pair found in extra data from grouping fields (we will use them to set [[$score_2]]), or viceversa. Although that could happen, we initialize [[$score_2]] to an undefined value.

<<Global Vars>>=
my ($seqname_1,$seqname_2,
    $source_1,$source_2,$feature_1,$feature_2,
    $start_1,$start_2,$end_1,$end_2,$score_1,$score_2,
    $strand_1,$strand_2,$frame_1,$frame_2); # APLOT temporary vars
my ($tag,$group,$group_id,$label,
    $group_gff_counter,$group_aplot_counter); # GROUPING temporary vars
@ 

\begin{table}[!t]
\begin{center}
\fbox{
\begin{tabular}{c@{\qquad}c}
Strand
\(
\quad\Rightarrow\quad
\left\{
\begin{array}{c@{\quad\Rightarrow\quad}c}
\mbox{[[+]]} & \mbox{[[+:+]]}\\
\mbox{[[-]]} & \mbox{[[-:-]]}\\
\mbox{[[.]]} & \mbox{[[.:.]]}\\
\end{array}
\right.
\)
 &
Frame
\(
\quad\Rightarrow\quad
\left\{
\begin{array}{c@{\quad\Rightarrow\quad}c}
\mbox{[[2]]} & \mbox{[[2:2]]}\\
\mbox{[[1]]} & \mbox{[[1:1]]}\\
\mbox{[[0]]} & \mbox{[[0:0]]}\\
\mbox{[[.]]} & \mbox{[[.:.]]}\\
\end{array}
\right.
\)
 \\
\end{tabular}
} % fbox
\parbox{0.75\linewidth}{
\caption[Retrieving second element when missing in old APLOT format]{\label{tbl:missingfields} For {\prog} old format, when in a '\pa{element1}:\pa{element2}' field pair the second element is missing, second is set to first element.}
} % parbox
\end{center}
\end{table}

When checking for colons, we assume that any element defined without colons is equal to the same value repeated twice (see Table~\ref{tbl:missingfields}). 

<<Parsing Input Data>>=
sub remove_colon() {
    my @ary_out = ();
    my ($a,$b) = (undef,undef);
	foreach my $fld (@_) {
		($a,$b) = split /:/o, $fld, 2;
        $a = '.' unless defined($a);
        $b = $a  unless defined($b);
		push @ary_out, $a, $b;
	};
	return @ary_out;
} # remove_colon
@ %def &remove_colon
%$

\subsubsctn{Checking fields and accepting APLOT records}

If records are OK, then we can append a new record to the variable defined for APLOT records (so called as '[[%ALN_DATA]]' in table~\ref{tbl:alndata}, page~\pageref{tbl:alndata}). \label{sec:APLOThsh}

<<Parsing Input Data>>=
sub check_aplot_fields() {
    &check_coords($start_1,$end_1,$start_2,$end_2) || (return $F);
    &check_strand($strand_1,$strand_2) || (return $F);
    &check_frame($frame_1,$frame_2) || (return $F);
    &add_gff_record($_[0]);
    return $T; 
} # check_aplot_fields
@ %def &check_aplot_fields

\begin{table}[!t]
\begin{center}
% \input tables/DataStructure_ALN.tex
\caption[Internal data structure to store alignments]{\label{tbl:alndata} Alignment data structure, so called '[[%ALN_DATA]]', has same structure as '[[%GFF_DATA]]' shown in table~\ref{tbl:gffdata}. Here we only show the small differences between them.}
\end{center}
\end{table}

\label{todo:ELA}
<<HIDE: new defs TODO>>=
\def\todoELA{
DATA STRUCTURE for [[%ALN_DATA]] was defined:
Include a figure if differs from [[%GFF_DATA]] definition (table~\ref{tbl:alndata}).
} % todoELA
@
<<HIDE: TODO>>=
\todoitem{\todoELA}{todo:ELA}
@
\todo{ \item \todoELA } % todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<HIDE: ALN DATA STRUCTURE>>= 
% DataStructure_ALN.tex
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsctn{Loading records to GFF/ALN hashes}

<<HIDE: DONE>>=
\doneitem{20011113}{Append a new record to the variable defined for APLOT records.}
@

Once fields checking is done, we proceed to load the data structure defined for the GFF records or for the ALIGNMENT ones, we have merged the loading functions for both record types in the current version because they shared many common structures. 

In the first case we have to add the new record into '[[%GFF_DATA]]' hash, the outline of the inner structure of that variable is shown in table~\ref{tbl:gffdata}, page~\pageref{tbl:gffdata}. \label{sec:GFFhsh}
On the other hand, ALIGMENT records need a pre-processing of some of the fields before being ready to fill '[[%ALN_DATA]]' hash, table~\ref{tbl:alndata} in page~\pageref{tbl:alndata} summarizes the differences between this record type and the GFF one. \label{sec:ALNhsh}

<<Parsing Input Data>>=
sub add_gff_record() {
    my $_gff = $_[0];
    my ($VarName,$Counter,$Type,$isaln,$myfunc,$t);
    <<select GFF or ALN settings>>
    &load_var($seqname,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = (
        \%{$VarName->{$seqname}[$_element]},
        \$$VarName{$seqname}[$_counter][$_elemNum],
        'SOURCE' );
    &load_var($source,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = ( 
        \%{$VarName->{$source}[$_element]},
        \$$VarName{$source}[$_counter][$_elemNum],
        'STRAND' );
    &load_var($strand,$VarName,$Counter,$Type,$myfunc);
    ($VarName,$Counter,$Type) = (
        \%{$VarName->{$strand}[$_element]},
        \$$VarName{$strand}[$_counter][$_elemNum],
        'GROUP' );
    &load_var($group,$VarName,$Counter,$Type,$myfunc);
    <<adding new feature elements>>
    return;
} # add_gff_record
@ %def &add_gff_record

If the standard GFF alignment format is found, we process those records as if they were aplot records, so that we have to set all the variables required to fill such data structure. We solve that by setting the same variables when loading those standard GFF alignment records as we do when loading aplot records, then they can share the same processes that are switched on by [[$isaln]].
% ('[[&add_aplot_record]]' is described in section~\ref{func:loadalnvar}, page~\pageref{func:loadalnvar})

<<select GFF or ALN settings>>=
$isaln = ($_gff =~ /$ALIGN|$APLOT|$APLOT_NOGP/o) ? $T : $F;
ISALN: {
    $isaln && do {
        $myfunc = \&load_aln_var;
        ($VarName,$Counter,$Type) = (
            \%ALN_DATA,
            \$aln_COUNT,
            'SEQUENCE' );
        $seqname = join($;, $seqname_1, $seqname_2);
        $source  = join($;, $source_1,  $source_2 );
        $strand  = join($;, $strand_1,  $strand_2 );
        $feature = join($;, $feature_1, $feature_2);
        last ISALN;
    }; # $isaln
    $myfunc = \&load_gff_var;
    ($VarName,$Counter,$Type) = (
        \%GFF_DATA,
        \$seq_COUNT,
        'SEQUENCE' );
}; # ISALN
@ 

First we load the plain GFF attributes for a given record, when such record is defining a vector we add a new element to the feature anonymous array. That element is a list of the scores provided by the '[[&load_GFF_vector]]' function defined in section~\ref{sec:loadvector}, page~\pageref{sec:loadvector}.

<<adding new feature elements>>=
LDALN: {
    $isaln && do {
        push @{$VarName->{$group}[$_element]},
            [
              'A',       # Type == ALIGNMENT
        	  {},        # Properties hash, now empty
              $feature,  # GFF feature (3rd field)
              $label,    # Record ID if exist, order# otherwise
              $start_1, $end_1, $score_1, $frame_1,
              $start_2, $end_2, $score_2, $frame_2,
            ];
        last LDALN;
    }; # $isaln
    my $first_fld = ($_gff eq $VECTOR) ? 'V' : 'G';
    push @{$VarName->{$group}[$_element]},
        [
          $first_fld,      # Type == plain GFF or vector
    	  {},              # Properties hash, now empty
          $feature,        # GFF feature (3rd field)
          $label,          # Record ID if exist, order# otherwise
          $start, $end, $score, $frame,
        ];
    $_gff eq $VECTOR && do {
    	@{$VarName->{$group}[$_element][8]} = [ @vect_ary ];
    };
}; # LDALN
$t = ++$VarName->{$group}[$_counter][$_elemNum];
&set_var_defaults('FEATURE',
                  \%{$VarName->{$group}[$_element][($t-1)][$_prop]});
@ 

We declare here auxiliary variables containing the array indexes used in the anonymous arrays defined within the main variables containing all the GFF data ([[%GFF_DATA]], that was declared in section~\ref{sec:GFFhsh}, page~\pageref{sec:GFFhsh}), and the alignment data ([[%ALN_DATA]], that was declared in section~\ref{sec:APLOThsh}, page~\pageref{sec:APLOThsh}).

<<Pre-Declared Vars>>=
$aln_COUNT $seq_COUNT
$_counter $_prop $_element
$_order $_elemNum $_ori $_end $_nori $_nend
$_fttype $_ftprop $_ftname $_ftid
         $_ftori  $_ftend  $_ftsco  $_ftfrm
         $_ftnori $_ftnend $_ftnsco $_ftnfrm
@ 

<<Global Vars>>=
($_counter,$_prop,$_element) = (0..2);
($_order,$_elemNum,$_ori,$_end,$_nori,$_nend) = (0..5);
($_fttype,$_ftprop,$_ftname,$_ftid,
 $_ftori, $_ftend, $_ftsco, $_ftfrm,
 $_ftnori,$_ftnend,$_ftnsco,$_ftnfrm) = (0..11);
@ 

<<Parsing Input Data>>=
sub load_var() {
    my ($_value,$_var,$_cnt,$_type,$_frf) = @_;
	defined($$_var{$_value}) || do {
		$$_var{$_value}[$_counter] = &$_frf(++$$_cnt);
		&set_var_defaults($_type,\%{$$_var{$_value}[$_prop]});
	};
	return;
} # load_var
@ %def &load_var
%$

\label{func:loadgffvar} \label{func:loadalnvar}
<<Parsing Input Data>>=
sub load_gff_var() { return [ $_[0], 0, 0, 0 ]; }
sub load_aln_var() { return [ $_[0], 0, 0, 0, 0, 0 ]; }
@ %def &load_gff_var &load_aln_var

We initialize properties for each new element as references to '[[%DefaultVars]]' given level corresponding values. 

<<Parsing Input Data>>=
sub set_var_defaults() {
    my ($sect,$varhash) = @_;
    <<P.I.D: set reference to all properties>>
	return;
} # set_var_defaults
@ %def &set_var_defaults

We can set default properties of GFF elements in two ways: making a reference to the default properties hash for that element, as shown in the [[<<P.I.D: set reference to all properties>>]], or reference each variable from the properties hash to a new key, as described in [[<<P.I.D: set reference for each property>>]].

\label{sec:DATAdefaultvars}
<<P.I.D: set reference to all properties>>=
# $$varhash = \%{$Defaults{$sect}};
@

<<P.I.D: set reference for each property>>=
foreach my $nm (keys %{$DefaultVars{$sect}}) {
    $$varhash{$nm} = \$DefaultVars{$sect}{$nm}{'VALUE'};
}; # foreach $nm
@

We choose the first approach, and we will replace the hash reference by the keys with references to defaults if needed when setting variables from custom parameters for a given GFF element (see section~\ref{sec:mapcustoms}, page~\pageref{sec:mapcustoms}). That choice will save memory used by the elements properties if user does not customize any of the element properties, but requires a temporary default variable (due to the special structure of the [[%DefaultVars]] hash which contains not only default variable values but also variable type), named [[%Defaults]] and defined in section~\ref{sec:tmpdefaults}, page~\pageref{sec:tmpdefaults}.


\subsctn{Parsing grouping attributes}

'[[GFF_CHOICE]]' block sets some variables depending on the record format, standard GFF or APLOT GFF-like. Once we have the attribute string from the GFF/APLOT record, we first check if it is empty, then we split by semicolons which will have or not white spaces or tabs before and/or after, as shown in this regular expression:\\
\centerline{'[[/\b\s*;\s*\b/]]'}\\
This will define tag-value pairs (and maybe some extra fields).  

<<Parsing Input Data>>=
sub load_grouping() {
    my ($_type,$attributes) = @_;
    my ($grp_string,$grp_counter,$grp_GP,$grp_NOGP,$grp_tag);
  GFF_CHOICE: {
    $_type && do { 
        $grp_string = "$seqname\_$source\_$strand";
        $grp_counter = ++$group_gff_counter;
        $grp_GP = $GFF;
        $grp_NOGP = $GFF_NOGP;
        $grp_tag = '';
        last GFF_CHOICE;
    };
    $grp_string = "$seqname_1\_$seqname_2\_$source_1\_$strand_1$strand_2";
    $grp_counter = ++$group_aplot_counter;
    $grp_GP = $APLOT;
    $grp_NOGP = $APLOT_NOGP;
    $grp_tag = $Vars{LAYOUT}{align_tag}; # %SOURCE is a temporary hash name
  };
    $label = $group_id = $grp_counter;
    defined($attributes) || do {
        $group = "$grp_string\_$group_id";
	    return $grp_NOGP;
    };
    my @grouping_list = ();
    @grouping_list = split /\b\s*;\s*\b/o, $attributes;
	<<parse grouping attributes>>
	<<parse other attributes>>
    return $grp_GP;
} # load_grouping
@ %def &load_grouping

We may find four basic grouping field structures (detailed in Table~\ref{tbl:formats}) within the first element of '[[@grouping_list]]'. We check first for double-quotes in the first or second field within that element. If second field is double-quoted, the first field is set as 'Tag' and the quoted as 'Value', else 'Tag' is set to default value (empty string for GFF records and 'target' for APLOT GFF-like ones) and 'Value' is set with the first field. Then we are looking in GFF grouping attributes for extra fields defining start, end, strand and frame (all related to the second sequence); in APLOT GFF-like format, those values are deprecated (because they must be defined in the first eight fields following the first sequence values and a colon as shown in table~\ref{tbl:formats}). 

<<parse grouping attributes>>=
my $grp_flag = 0;
my @new_group = ();
my $groupregexp = '^(.*?)(?:"(.+?)"(?:\s+\b(.*))?)?$'; #'
my $group_string = shift @grouping_list;
($group_string =~ /$groupregexp/o) && 
    (@new_group = ($1,$2,$3));
$new_group[0] =~ s/\b\s*$//o;
$new_group[0] || do {  # type 2 attributes
    $grp_flag = 1;
    $new_group[0] = $grp_tag;
};
$new_group[1] || do {  # type 1 attributes
    $grp_flag = 1;
    $new_group[1] = $new_group[0];
    $new_group[0] = $grp_tag;
};
($tag,$group) = (lc($new_group[0]),$new_group[1]);
# Here looking for colon field separator in aplot GFF-like grouping
($grp_flag && $group =~ /^(.*?):(.*?)$/o) && (($group,$label) = ($1,$2));
@ %$

Here we look for other attribute fields, those defining coords for the target sequence match in standard GFF format and those defining a scoring vector, both formats are explained more in detail in the following two subsections.

<<parse other attributes>>=
$_type && do { # GFF grouping
    $tag =~ /$Vars{LAYOUT}{align_tag}/ && do {
        &load_GFF_align;
        return $ALIGN;
    }; 
    $tag =~ /$Vars{LAYOUT}{vector_tag}/ && do {
        &load_GFF_vector;
        return $VECTOR;
	};
};
@ 

We are interested in finding 'id' tag, that defines the label for a single record, this is implemented in the '[[&load_GFF_align]]' and '[[&load_GFF_vector]]'functions but has to be parsed in plain GFF records.

<<parse other attributes>>=
scalar(@grouping_list) > 0 && do{ 
    foreach my $element (@grouping_list) {
        ($element =~ /$groupregexp/o) && (@new_group = ($1,$2,$3));
        lc($new_group[0]) =~ /$Vars{LAYOUT}{label_tag}/ && do {
            $label = $new_group[1];
            $label eq "" && do {
                (undef,$label,undef) = split /\s+/og, $new_group[0];
            };
        };
    };
};
@

\subsubsctn{Layout variables involved in grouping tags}

<<default layout vars values>>=
align_tag                  => { TYPE => 'ALPHA', VALUE => 'target'   },
vector_tag                 => { TYPE => 'ALPHA', VALUE => 'vector'   },
label_tag                  => { TYPE => 'ALPHA', VALUE => 'id'       },
@ %def {align_tag} {vector_tag} {label_tag}
<<DESC custom file variables>>=
ORD: 240
SEC: LAYOUT
SUB: General
OPT: align_tag
DEF: |target|
PAR: <tag>
SDE: 
LDE: 
[align_tag] holds the specific tag (for a grouping Tag-Value pair) to detect 
those GFF records coding for alignment data and having the following group 
structure:\\%{1ex%} \n\
\centerline{
 \shortstack%{r%}{align_tag "group_name" <seq2_start> <seq2_end> 
   %{ ; Strand <seq2_strand> \eoline\\\,%{ ; Frame <seq2_frame> %{ ; 
        E_value <score> %}\,%}\,%}\hspace{3ex}
  }
 }\\%{0.75ex%} \n\
so the program can recover the coords for the target sequence from the 
grouping fields. Remember that tags are not case-sensitive. 
###EOR###
ORD: 241
SEC: LAYOUT
SUB: General
OPT: vector_tag
DEF: |vector|
PAR: <tag>
SDE: 
LDE: 
[vector_tag] sets the specific tag (for a grouping Tag-Value pair) to detect 
scoring vector GFF records, which have the following group structure:
\\%{1ex%} \n\
\centerline{
 \shortstack%{r%}{vector_tag "group_name" <vector_type> %{ ;
   Window <window_length> \eoline\\\, %{ ; Step <step_length> %}\,%} ;
   Scores <score$%-0$> ... <score$%-n$>\hspace{3ex}
  }
  }\\%{0.75ex%} \n\
so the program can parse the list of single scores from the grouping fields. 
Remember that tags are not case-sensitive.
###EOR###
ORD: 242
SEC: LAYOUT
SUB: General
OPT: label_tag
DEF: |id|
PAR: <tag>
SDE: 
LDE: 
[label_tag] sets the specific tag (for a grouping Tag-Value pair) that allows 
to identify a single record. The program looks for the grouping Tag-Value pair 
for which the tag matches [label_tag] and takes <value> as the specific record 
label. You must have an attribute like this within the grouping attribute list:
\\%{0.75ex%} \n\
\centerline{
  \ldots ; label_tag "element_label" %{ ; \ldots %}
  }\\%{0.5ex%} \n\
Using this attribute makes easy to set specific properties for one or more 
elements. Remember that tags are not case-sensitive.
###EOR###
@


The following record formats share the field structure of a GFF standard record, but there are special tags in the grouping fields containing data that will be used by {\prog}. Both formats require a fixed tag string (by default 'Vector' for the scoring vectors and 'Target' for the alignment data), which can be redefined by users from custom files.

<<HIDE: DONE>>=
\doneitem{20011113}{[[%SOURCE]] is a \textbf{provisional varname} that must be replaced by the corresponding [[$DefaultVars{LAYOUT}]], [[$CustomVars{LAYOUT}]] or [[$CmdLineVars{LAYOUT}]]. Those 'LAYOUT' variables must be set before reading GFF input files because some settings are used by parser functions.}
@

\subsubsctn{Parsing alignment records}

\label{todo:ERA}
<<HIDE: new defs TODO>>=
\def\todoERA{
Parsing alignment records:\\
\centerline{[[aln_tag "value" target_ori target_end target_frame target_strand (...)]]}
} % todoERA
@
<<HIDE: TODO>>=
\todoitem{\todoERA}{todo:ERA}
@
\todo{ \item \todoERA } % todo

<<Parsing Input Data>>=
sub load_GFF_align() {

} # load_GFF_align
@ %def &load_GFF_align

\subsubsctn{Parsing scoring vectors} \label{sec:loadvector}

\label{todo:EVA}
<<HIDE: new defs TODO>>=
\def\todoEVA{
Parsing scoring vectors:\\
\centerline{[[vector_tag "value" vector_type; step value; window value; scores sco ... sco]]}
} % todoEVA
@
<<HIDE: TODO>>=
\todoitem{\todoEVA}{todo:EVA}
@
\todo{ \item \todoEVA } % todo

<<Parsing Input Data>>=
sub load_GFF_vector() {
	@vect_ary = ();
} # load_GFF_vector
@ %def &load_GFF_vector

<<Global Vars>>=
my @vect_ary;
@ 


\newpage

\sctn{Mapping custom features to figure elements} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<HIDE: DONE>>=
\doneitem{20011113}{Set variable mapping for [[%ALN_DATA]] elements.}
@

\subsctn{Mapping customization variables to working variable}

We define here [[&merge_custom_vars]] to combine customization
parameters from [[%CmdLineVars]] and [[%CustomVars]] into [[%Vars]]
before start parsing GFF input files. The main reason to do this
variable mapping at this point is that there are some LAYOUT variables
that are used when parsing the GFF records (basically
[[align_tag]],[[vector_tag]] and [[label_tag]]). Another reason is
that from now on, we only have to take care of a single variable,
which summarizes all the settings from different inputs, say here the
program built-in defaults, the custom files and the command-line
options. The values set on command-line override those from custom
files and those set from custom files override defaults. We are going
to concatenate each element-value pairs for each variable (not for the
layout variables but for all the rest), so that we will have a
variable name reference linked to a list of element-value pairs, which
will be used when mapping those values for a given element in the data
variables. When loading variables, defaults are set to [[%Defaults]]
(see section~\ref{sec:DATAdefaultvars},
page~\pageref{sec:DATAdefaultvars}), so we only take care here of
those values that are redefined by user (we do not use [[%DefaultVars]] because we already checked variable values and [[%Defaults]] variable has a simpler structure than it).

<<Features Setting>>=
sub merge_custom_vars() {
    &header("MAPPING CUSTOMIZATION INPUTS TO MAIN VARS");
    <<setting layout variables>>
    <<setting non-layout variables>>
    print LOGFILE (Data::Dumper->Dump([ \%Vars ],
                                   [ qw( *Vars ) ]))
        if ($LogFile && $Debug);
    &footer("VALUES SET for MAIN VARS");
} # merge_custom_vars
@ %def &merge_custom_vars

Layout variables are simpler than the rest, they are defined as a key-value pair, so that mapping is straightforward.

<<setting layout variables>>=
foreach my $var_name (keys %{ $Defaults{LAYOUT} }) {
    defined($CmdLineVars{LAYOUT}{$var_name}) && do {
        $Vars{LAYOUT}{$var_name} = $CmdLineVars{LAYOUT}{$var_name};
        next;
    };
    defined($CustomVars{LAYOUT}{$var_name}) && do {
        $Vars{LAYOUT}{$var_name} = $CustomVars{LAYOUT}{$var_name};
        next;
    };
    $Vars{LAYOUT}{$var_name} = $Defaults{LAYOUT}{$var_name};
}; # foreach $var_name
@ 

For the rest of variable classes (SEQUENCE, SOURCE, STRAND, GROUP and
FEATURE), which are defined as an element-key-value triad, we can have
more than one element and with a different value settings, for each
key (say here variable name). We store that information in a list. We
know that every three values of the list we have a variable definition
for a given element and if it is a negation or not (i.e., see
section~\ref{sec:DATAtriadarray}, page~\pageref{sec:DATAtriadarray},
for its definition in [[%CustomVars]]). The structure of that subset
of the list is squetched here:\\

\centerline{\ldots , 'negate regexp flag', 'element regular expression', 'variable value' , \ldots}

<<setting non-layout variables>>=
foreach my $_sec (keys %Defaults) {
    $_sec eq 'LAYOUT' && next; # skip layout variables
    foreach my $_var (keys %{$Defaults{$_sec}}) {
        defined($CustomVars{$_sec}{$_var}) && do {
            push @{ $Vars{$_sec}{$_var} }, @{ $CustomVars{$_sec}{$_var} };
        }; # defined($CustomVars{$_sec}{$_var})
        defined($CmdLineVars{$_sec}{$_var}) && do {
            push @{ $Vars{$_sec}{$_var} }, @{ $CmdLineVars{$_sec}{$_var} };
        }; # defined($CustomVars{$_sec}{$_var})        
	}; # foreach $vnm
}; # foreach $sct
@ 

Here we load the custom files definitions before the command-line ones, because for those variables in [[%Vars]] ordering is important, and later definitions in the array will override previous ones. 

\subsctn{Mapping customization to GFF elements}

Once we have set the variables from different sources as we did in the previous section, and once we loaded the GFF data from input files, we have to assign the corresponding settings to each GFF element. Defaults were already set as a reference to [[%Defaults]] hash (see section~\ref{sec:DATAdefaultvars}, page~\pageref{sec:DATAdefaultvars}). Perhaps this will be the most time consuming function of the program as we have to traverse all the variables for each class (if they are set in [[%Vars]], which will save much of that time if they are not defined) throught all the GFF elements.
\label{sec:mapcustoms}

<<Features Setting>>=
sub map_vars_data() {
    &header("SETTING CUSTOM VALUES TO GFF ELEMENTS");
    foreach my $v_sec (keys %Vars) {
        $v_sec eq 'LAYOUT' && next; # skip layout variables
        foreach my $v_var (keys %{$Vars{$v_sec}}) {
            my @v_values = @{ $Vars{$v_sec}{$v_var} };
            for (my $foo = 0; $foo < $#v_values; $foo+=4) {
                my @tl = @v_values[$foo..($foo + 3)];
                &map_vars_to_GFF(\%GFF_DATA,$v_sec,$v_var,@tl);
                &map_vars_to_GFF(\%ALN_DATA,$v_sec,$v_var,@tl);
            }; # for $foo
	    }; # foreach $vnm
    }; # foreach $sct
    print LOGFILE (Data::Dumper->Dump([ \%GFF_DATA, \%ALN_DATA ], 
                                   [ qw( *GFF_DATA   *ALN_DATA ) ]))
        if ($LogFile && $Debug);
    &footer("VALUES SET for GFF ELEMENTS");
} # map_vars_data
@ %def &map_vars_data

We have to set the properties hash corresponding to the GFF elements present in the current section (say here SEQUENCE, SOURCE, STRAND, GROUP or FEATURE). To do that we have to define a reference to that anonymous hash and also retrieve the element string ([[$element]]) to check if it match to the regular expression ([[$reg_exp]]) which determines if the variable of that element is re-assigned to the current value ([[$the_value]]).

<<Features Setting>>=
sub map_vars_to_GFF() {
    my ($mainref,  $v_sec,   $v_var,
        $neg_flg, $id_flg, $reg_exp, $the_value, $name_test) = @_;
    $name_test = $neg_flg ? \&match_regexp_neg : \&match_regexp;
    foreach my $seq (keys %{ $mainref }) {
        my $seq_ref = \@{ $mainref->{$seq} };
        $v_sec eq 'SEQUENCE' && do {
            &does_feat_match($name_test,$seq,$reg_exp,$seq_ref,
                             $_prop,$v_sec,$v_var,$the_value);
            next;
        };
        <<set reference to GFF data: SOURCES>>
    }; # foreach my $seq
    return;
} # map_vars_to_GFF
@ %def &map_vars_to_GFF

<<set reference to GFF data: SOURCES>>=
foreach my $src (keys %{ $seq_ref->[$_element] }) {
    my $src_ref = \@{ $seq_ref->[$_element]{$src} };
    $v_sec eq 'SOURCE' && do {
        &does_feat_match($name_test,$src,$reg_exp,$src_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: STRANDS>>
}; # foreach my $src
@ 

<<set reference to GFF data: STRANDS>>=
foreach my $str (keys %{ $src_ref->[$_element] }) {
    my $str_ref = \@{ $src_ref->[$_element]{$str} };
    $v_sec eq 'STRAND' && do {
        &does_feat_match($name_test,$str,$reg_exp,$str_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: GROUPS>>
}; # foreach my $str
@ 

<<set reference to GFF data: GROUPS>>=
foreach my $grp (keys %{ $str_ref->[$_element] }) {
    my $grp_ref = \@{ $str_ref->[$_element]{$grp} };
    $v_sec eq 'GROUP' && do {
        &does_feat_match($name_test,$grp,$reg_exp,$grp_ref,
                         $_prop,$v_sec,$v_var,$the_value);
        next;
    };
    <<set reference to GFF data: FEATURES>>
}; # foreach my $grp
@ 

<<set reference to GFF data: FEATURES>>=
foreach my $feat (0..$#{ $grp_ref->[$_element] }) {
    my ($feat_ref, $ft_name, $ft_id, $ft_vars);
    $feat_ref = \@{ $grp_ref->[$_element][$feat] };
    ($ft_name, $ft_id) = ($feat_ref->[$_ftname],$feat_ref->[$_ftid]);
    # check ID
    defined($id_flg) && do {
        $ft_id =~ /^$id_flg$/o && do {
            &does_feat_match($name_test,$ft_name,$reg_exp,$feat_ref,
                             $_ftprop,$v_sec,$v_var,$the_value);
        }; # $ft_id =~ /^$id_flg$/o
        next;
    }; # $id_flg ne $NULL
    # check regexp
    &does_feat_match($name_test,$ft_name,$reg_exp,$feat_ref,
                     $_ftprop,$v_sec,$v_var,$the_value);
}; # foreach my $feat
@

<<Features Setting>>=
sub does_feat_match() {
    my ($thetest,$name,$rexp,$gffref,$prop,$sct,$var,$value) = @_;
    &$thetest($name,$rexp) && do {
        (ref($gffref->[$prop]) eq 'REF') &&
            &set_all_defaults($gffref, $sct);
        $gffref->[$prop]{$var} = $value;
    };
} # does_feat_match
@ %def &does_feat_match

The following two functions are checking if a GFF element match or not a given regular expression (minimal expression consists in a GFF element string). They return a true/flase result that decides if a variable is set or not for a given GFF element.

<<Features Setting>>=
sub match_regexp() {
    $_[0] =~ /$_[1]/o && return $T;
    return $F;
} # match_regexp
sub match_regexp_neg() {
    $_[0] !~ /$_[1]/o && return $T;
    return $F;
} # match_regexp_neg
@ %def &match_regexp &match_regexp_neg

<<Features Setting>>=
sub set_all_defaults() {
    my ($the_hash,$the_sec) = @_;
    $the_hash->[$_prop] = ();
    foreach my $vnm (keys %{$Defaults{$the_sec}}) {
        $the_hash->[$_prop]{$vnm} = \$Defaults{$the_sec}{$vnm};
    }; # foreach $nm
} # set_all_defaults
@ %def &set_all_defaults


\newpage

\sctn{Sorting GFF features} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We need to sort the GFF elements by acceptor, it is more or less easy to sort them because they were defined in [[%GFF_DATA]] or [[%ALN_DATA]]
as arrays (it is implemented with the [[map]]/[[sort]]/[[map]] technique as it can be appreciated in [[<<sorting group elements>>]] code chunk). But we also need to sort groups by their coordinates and to sort sequences and sources by their input order (as they were read from input file I mean). This will be difficult to do on the original hashes because coords and order were placed in a subarray for a given group/source/sequence key name (that key point to an anonymous array containing that counters as you can see in table~\ref{tbl:gffdata}, page~\pageref{tbl:gffdata}). As we are looking for the GFF elements that belong to a group, which is related to a given strand of a source within a sequence, we can build an auxiliary variable that holds the proper ordering at each level as we go deep in the [[%GFF_DATA]]/[[%ALN_DATA]] variables hierarchy.
At the same time we can fill the [[$_ori]] and [[$_end]] fields we left set to zero for the counters array in [[&load_gff_var]] (see function definition in page~\pageref{func:loadgffvar}).

<<HIDE: DONE>>=
\doneitem{20011120}{Set ordering for [[%ALN_DATA]].}
@

<<Sorting Features>>=
sub sort_elements() {
    &header("SORTING ELEMENTS BY ACCEPTOR (START)");
    %Order = ();
    # sorting %GFF_DATA contents 
    scalar(%GFF_DATA) && do {
        &report('SORT_GFF','*- ','ANNOTATION DATA');
        &sort_elements_loop(\%GFF_DATA,'GFF');
    }; # scalar(%GFF_DATA) > 0
    # sorting %ALN_DATA contents 
    scalar(%ALN_DATA) && do {
        &report('SORT_GFF','*- ','ALIGNMENT DATA');
        &sort_elements_loop(\%ALN_DATA,'ALN');
    }; # scalar(%ALN_DATA) > 0
    print LOGFILE (Data::Dumper->Dump([ \%Order ],
                                   [ qw( *Order ) ]))
        if ($LogFile && $Debug);
    &footer("ELEMENTS SORTED");
} # sort_elements
@ %def &sort_elements

<<Sorting Features>>=
sub sort_elements_loop() {
    my ($s_ref,$ktr) = @_;
    my ($v_max,$v_min);
    my $sq_ord = \@{ $Order{$ktr} } ;
    @{ $sq_ord } = ();
    foreach my $s_seq (keys %{ $s_ref }) {
        <<sorting sequences>>
    }; # foreach $s_seq
    &sort_by_inputorder($sq_ord);
    return;
} #sort_elements_loop
@ %def &sort_elements_loop

Once we get into [[&sort_elements]] function we initialize the arrays within the [[%Order]] hash as we are requiring them. \label{sec:ORDERhsh}

<<messages - sorting GFF data>>=
SORT_GFF => "\%sSorting \%s\n",
@

\subsctn{Descending from sequences to groups}

<<sorting sequences>>=
&report('SORT_SEQ','|  *- ',$s_seq);
my @sc_coords = ();
push @{ $sq_ord },
        [ $s_seq,
          $s_ref->{$s_seq}[$_counter][$_order],
          () ];
my $sc_ord = \@{ $sq_ord->[ $#{$sq_ord} ][2] };
my $ss_ref = \%{ $s_ref->{$s_seq}[$_element] };
foreach my $s_src (keys %{ $ss_ref }) {
    <<sorting sources>>
}; # foreach $s_src
&sort_by_inputorder($sc_ord);
<<set sequence elements boundaries>>
@ 

<<sorting sources>>=
&report('SORT_SRC',(('|  ' x 2).'*- '),$s_src);
my @sr_coords = ();
push @{ $sc_ord },
        [ $s_src,
          $ss_ref->{$s_src}[$_counter][$_order],
          () ];
my $sr_ord = \@{ $sc_ord->[ $#{$sc_ord} ][2] };
my $sc_ref = \%{ $ss_ref->{$s_src}[$_element] };
foreach my $s_str (keys %{ $sc_ref }) {
    <<sorting GFF groups>>
}; # foreach $s_str
<<set source elements boundaries>>
@

<<messages - sorting GFF data>>=
SORT_SEQ => "\%sSequence: \%s\n",
SORT_SRC => "\%sSource: \%s\n",
@ 

\subsctn{Sorting features for groups}

<<sorting GFF groups>>=
&report('SORT_STR',(('|  ' x 3).'*- '),$s_str);
my @ft_coords = ();
push @{ $sr_ord },
        [ $s_str,
          # $sc_ref->{$s_str}[$_counter][$_order],
          () ]; # if uncomment '$sc_ref' set next to [2] instead of [1].
my $st_ord = \@{ $sr_ord->[ $#{$sr_ord} ][1] };
my $sr_ref = \%{ $sc_ref->{$s_str}[$_element] };
<<set forward/reverse sorting functon>>
my $s_elem;
foreach my $s_grp (keys %{ $sr_ref }) {
    <<sorting group elements>>
}; # foreach $s_grp
<<sorting group coords by acceptor>>
@ 

<<messages - sorting GFF data>>=
SORT_STR => "\%sStrand: \%s\n",
@

The main difference between this piece of code and the previous three ones is that we also find the boundaries of the groups here ([[$ft_min]]/[[$ft_max]] variables). This make possible to sort them and to know the first and the last coords that we can find in a strand/source/sequence (as we do in the last lines of the following piece of code, and in the next one [[<<sorting group coords by acceptor>>]]).

<<sorting group elements>>=
&report('SORT_GRP',(('|  ' x 4).'*- '),$s_grp);
my $sg_ref = \@{ $sr_ref->{$s_grp}[$_element] };
$s_elem = $sr_ref->{$s_grp}[$_counter][$_elemNum];
$s_elem > 1 && do {
    @{ $sg_ref } = map { $_->[2] }
                   sort { &$sortfunct }
                   map { [ $_->[4],
                           $_->[5],
                           $_ ] } @{ $sg_ref }; # maps 'start 'end 'arrayelement
}; # $s_elem > 1
@ft_coords = ( map { $_->[4], $_->[5] } @{ $sg_ref } );
$v_min = &min(@ft_coords);
$v_max = &max(@ft_coords);
$sr_ref->{$s_grp}[$_counter][$_ori] = $v_min;
$sr_ref->{$s_grp}[$_counter][$_end] = $v_max;
push @{ $st_ord }, [ $s_grp, $v_min, $v_max ];
&report('SORT_FTR',('|  ' x 5),$s_elem);
@

Something that really boost the ordering, if we compare to the old [[gawk]] version of {\prog}, is that we are performing the sort only on those groups that have more that one element, and we are also ordering short sets of GFF elements instead of sorting the whole input records first and then sort the groups we found in those records.

<<messages - sorting GFF data>>=
SORT_GRP => "\%sGroup: \%s\n",
SORT_FTR => "\%s       Sorted \%s elements.\n",
@ 

\subsctn{Sorting groups by coords and upper features by input order}

Here we take advantage of having the group coords in a list of lists ([[@{ $st_ord }]]) instead of having it as a list within a key/value hash of lists.

<<sorting group coords by acceptor>>=
@ft_coords = ( map { $_->[1], $_->[2] } @{ $st_ord } );
$v_min = &min(@ft_coords);
$v_max = &max(@ft_coords);
$sc_ref->{$s_str}[$_counter][$_ori] = $v_min;
$sc_ref->{$s_str}[$_counter][$_end] = $v_max;
push @sr_coords, $v_min, $v_max;
#
@{ $st_ord } = map { $_->[2] }
               sort { &$sortfunct }
               map { [ $_->[1], $_->[2], $_->[0] ] } @{ $st_ord };
$s_elem = $sc_ref->{$s_str}[$_counter][$_elemNum];
&report('SORT_GPN',('|  ' x 4),$s_elem);
@ 

We reduced the group order subarray just to contain the group names sorted (their coords were saved in the corresponding variable within )

<<messages - sorting GFF data>>=
SORT_GPN => "\%s\`Sorted \%s groups.\n",
@ 

We are going to skip the strand sorting, because the program will process always strands in a fixed order, that is: '+', '.' and '-' (so forward features first, followed by those features that does not have a defined strand, and finally reverse features).

<<set source elements boundaries>>=
$v_min = &min(@sr_coords);
$v_max = &max(@sr_coords);
$ss_ref->{$s_src}[$_counter][$_ori] = $v_min;
$ss_ref->{$s_src}[$_counter][$_end] = $v_max;
push @sc_coords, $v_min, $v_max;
@ 

<<set sequence elements boundaries>>=
$s_ref ->{$s_seq}[$_counter][$_ori] = &min(@sc_coords);
$s_ref ->{$s_seq}[$_counter][$_end] = &max(@sc_coords);
@ 

<<Sorting Features>>=
sub sort_by_inputorder() {
    my $ref = $_[0];
    @{ $ref } = map { [ $_->[0], $_->[2] ] }
                sort { $a->[1] <=> $b->[1] }
                map { [ $_->[0], $_->[1], $_->[2] ] } @{ $ref };
} # sort_by_inputorder
@ %def &sort_by_inputorder

\subsctn{Sorting forward/reverse strands}

As we are saving feature boundaries always in forward coords (meaning that feature start is always smaller than feature end, this was already checked by [[&check_coords]] which is defined in page~\pageref{func:checkcoords}), we need two sort functions, one for sorting forward features that is slightly different than the one used for sorting reverse ones. The main reason is that we want to avoid feature overlapping upstream (so that an element that ends downstream a previous element but starts within the boundaries of this one do not hide it ), this works from left to right for forward features, but must be done counterclockwise (say here from right to left) on reverse features.

<<Sorting Features>>=
sub sort_forward {
    $a->[0] <=> $b->[0]  # sorting by start
             or
    $b->[1] <=> $a->[1]; # reverse sorting by end if same start
} # sort_forward
#
sub sort_reverse {
    $b->[1] <=> $a->[1] # reverse sorting by end
             or
    $a->[0] <=> $b->[0];  # sorting by start if same end
} # sort_forward
@ %def &sort_forward &sort_forward

We choose between those two functions (both defining which fields to order and the direction --ascending/descending--), assigning by reference to [[$sortfunct]] variable which is de-referenced within the [[sort]] functions.

<<set forward/reverse sorting functon>>=
my $sortfunct = ($s_str eq '-') ? \&sort_reverse : \&sort_forward;
@
%$

\newpage

\sctn{Setting page layout variables} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:LAYOUTsec}

From now on, we are going to work internally with {\ps} points lengths. '[[%Vars]]' keys set to '[[_*]]' represent variables that are only visible within the program and cannot be configured by user.

<<Layout Settings>>=
sub set_page_vars() {
    &header("SETTING PAGE LAYOUT");
    my $var = \%{ $Vars{LAYOUT} };
    &set_page_size($var);
    &set_page_axes($var);
    &set_seq_boundaries($var);
    &set_tickmark_vars($var);
    &set_page_labels($var);
    &footer("PAGE LAYOUT SET for CURRENT PLOT");
} # set_page_vars
@ %def &set_page_vars

\subsctn{Page dimensions}

We compute the whole page dimensions, width and height, those are the most outer boundaries in the {\ps} figure.  

<<Layout Settings>>=
sub set_page_size() {
    my ($vrf) = @_;
    PSIZES: {
        defined($vrf->{page_bbox}) && do {
            $vrf->{_page_width}  = &get_units(\@{ $vrf->{page_bbox}[1] });
            $vrf->{_page_height} = &get_units(\@{ $vrf->{page_bbox}[2] });
            $FORMATS{$vrf->{page_bbox}[0]} = 
                [ ++$formats, $vrf->{_page_width}, $vrf->{_page_height} ];
            $vrf->{page_size} = $vrf->{page_bbox}[0];
            last PSIZES;
        };
        ($vrf->{_page_width},
         $vrf->{_page_height}) = @{ $FORMATS{$vrf->{page_size}} }[1,2];
    }; # PSIZES
    &report('SETPAGESIZE',$vrf->{page_size},
            "$vrf->{_page_width} x $vrf->{_page_height}");
    return;
} # set_page_size
@ %def &set_page_size {_page_width} {_page_height}

<<messages - input/output>>=
SETPAGESIZE =>
  "###---> Page size set to \"\%s\" ( \%s )...\n",
@

Not sure if the following function will be required, or better to pass values to PS code and compute layout there.

<<HIDE: Layout Settings>>=
#   &set_page_margins($var);
@ 
<<Layout Settings>>=
sub set_page_margins() {
    my ($vrf) = @_;
    $vrf->{_page_margins} = [
        &get_units(\@{ $vrf->{margin_left}[0]   }),
        &get_units(\@{ $vrf->{margin_right}[0]  }),
        &get_units(\@{ $vrf->{margin_top}[0]    }),
        &get_units(\@{ $vrf->{margin_bottom}[0] })
        ];
    $vrf->{_page_clip_width}  = $vrf->{_page_width} - 
         ($vrf->{_page_margins}[0] + $vrf->{_page_margins}[1]); 
    $vrf->{_page_clip_height} = $vrf->{_page_height} - 
         ($vrf->{_page_margins}[2] + $vrf->{_page_margins}[3]); 
    return;
} # set_page_margins
@ %def &set_page_margins {_page_margins} {_page_clip_width} {_page_clip_height}


\subsctn{Choosing which alignment and annotation to show}

Now, we should choose which alignment and which annotations will appear on the plot, by default the first ones read from input files. This process is done in three steps: 

\begin{enumerate}
\item First we should look for customization variables sequence names if defined ([[alignment_name]], [[x_sequence_name]] and [[y_sequence_name]] variables and their corresponding command-line options, see section~\ref{sec:customvardesc} on page~\pageref{sec:customvardesc} for further info).

<<setting axes - step 1>>=
$vrf->{_x_sequence_name} = defined($vrf->{x_sequence_name})
    ? $vrf->{x_sequence_name} : '.+';
$vrf->{_y_sequence_name} = defined($vrf->{y_sequence_name})
    ? $vrf->{y_sequence_name} : '.+';
defined($vrf->{alignment_name}) && do {
    $vrf->{_x_sequence_name} = $vrf->{alignment_name}[0];
    $vrf->{_y_sequence_name} = $vrf->{alignment_name}[1];
}; # defined($vrf->{alignment_name})
$vrf->{_alignment_name} = 
    [ $vrf->{_x_sequence_name}, $vrf->{_y_sequence_name} ];
@  %def {_alignment_name}

\item Then we must find if the resulting alignment has been loaded, searching on [[@{$Order{ALN}}]], and setting X and Y sequences accordingly. [[&search_alnname]] will return the final X-Y sequence names by modifying [[@{ $vrf->{_alignment_name} }]]. We do not swap sequence names on [[$vrf->{_alignment_name}]] at [[$vrf->{_swap_aln}]] test because it is already swapped within that function.

<<setting axes - step 2>>=
($vrf->{_plot_aln}, $vrf->{_swap_aln}) = 
    &search_alnname(\@{ $vrf->{_alignment_name} }, \@{ $Order{ALN} });
$vrf->{_swap_aln} && do {
    ($vrf->{x_sequence_name},$vrf->{y_sequence_name}) =
        ($vrf->{y_sequence_name},$vrf->{x_sequence_name});
}; # $vrf->{_swap_aln} 
$vrf->{_plot_aln} && do {
    $vrf->{_x_sequence_name} = defined($vrf->{x_sequence_name})
        ? $vrf->{x_sequence_name} : $vrf->{_alignment_name}[0];
    $vrf->{_y_sequence_name} = defined($vrf->{y_sequence_name})
        ? $vrf->{y_sequence_name} : $vrf->{_alignment_name}[1];
}; # $vrf->{_plot_aln}
@ %def {_plot_aln} {_swap_aln}

\item Finally we grep those X and Y sequences from [[@{$Order{GFF}}]], so we sholud know if they are present there or not. This depends on what we have found in [[@{$Order{ALN}}]] but also on [[$Vars{LAYOUT}{x_sequence_name}]] and [[$Vars{LAYOUT}{y_sequence_name}]] settings.

<<setting axes - step 3>>=
$vrf->{_alignment_name} = join($;, @{ $vrf->{_alignment_name} });
$vrf->{_plot_x_sequence} =
    &search_seqname(\$$vrf{_x_sequence_name}, undef, \@{ $Order{GFF} });
$vrf->{_plot_y_sequence} =
    &search_seqname(\$$vrf{_y_sequence_name}, $vrf->{_x_sequence_name}, 
                    \@{ $Order{GFF} });
@ %def {_plot_x_sequence} {_plot_y_sequence}
\end{enumerate}

While following those points, we will set also three variables that tell {\prog} if it is worth to plot alignments, x and y sequence ([[_plot_aln]], [[_plot_x_sequence]] and [[_plot_y_sequence]] respectively).

<<Layout Settings>>=
sub set_page_axes() {
    my ($vrf) = @_;
    <<setting axes - step 1>>
    <<setting axes - step 2>>
    <<setting axes - step 3>>
    ($vrf->{alignment_name} = $vrf->{_alignment_name}) =~ s/$;/ : /o;
    my ($yf,$nf) = ('was found. PLOTTING IT...','NOT found. NOT PLOTTED...');
    &report('SETPAGEAXES',
             ( "ALIGNMENT \"$vrf->{alignment_name}\" ".
               ( $vrf->{_plot_aln} ? $yf : $nf ).
               ( $vrf->{_swap_aln} ?
                 "\n###     The alignment found makes program".
                          " to swap X-Y annotations..." : "" )
               ),
             ( "X-SEQUENCE \"$vrf->{_x_sequence_name}\" ".
               ( $vrf->{_plot_x_sequence} ? $yf : $nf ) ),
             ( "Y-SEQUENCE \"$vrf->{_y_sequence_name}\" ".
               ( $vrf->{_plot_y_sequence} ? $yf : $nf ) )
            );
    return;
} # set_page_axes
@ %def &set_page_axes

<<messages - input/output>>=
SETPAGEAXES =>
  "###---> Setting plot AXES: \n###     \%s\n###     \%s\n###     \%s\n",
@

We need two auxiliarly functions to grep alignment and sequences names on [[@{$Order{ALN}}]] and [[@{$Order{GFF}}]] respectively. Remember that '[[$;]]' correspond to '[[SUBSET]]' in AWK.

<<Layout Settings>>=
sub search_alnname() {
    my ($_ra,$_ro) = @_;
    my ($sq_a,$sq_b,$naln,$nm_a,$nm_b);
    #
    ($sq_a,$sq_b) = @$_ra;
    foreach $naln (@$_ro) {
        ($nm_a,$nm_b) = split /$;/o, $naln->[0]; 
        ($nm_a =~ /^$sq_a$/ && $nm_b =~ /^$sq_b$/) && do {
            @$_ra = ($nm_a,$nm_b);
            return ($T, $F);
        };
    }; # foreach $naln
    # swapping
    foreach $naln (@$_ro) {
        ($nm_a,$nm_b) = split /$;/o, $naln->[0]; 
        ($nm_a =~ /^$sq_b$/ && $nm_b =~ /^$sq_a$/) && do {
            @$_ra = ($nm_b,$nm_a);
            # @$_ra = reverse @$_ra;
            return ($T, $T);
        };
    }; # foreach $naln
    #
    return ($F, $F);
} # search_alnname
@ %def &search_alnname

<<Layout Settings>>=
sub search_seqname() {
    my ($sq_a,$sq_b,$_ro) = @_;
    my ($a_found,$naln);
    foreach $naln (@$_ro) {
        ($$sq_a eq '.+' && defined($sq_b) && $naln->[0] eq $sq_b) && next;
        $naln->[0] =~ /^$sq_a$/ && do {
            $$sq_a = $naln->[0];
            return $T;
        };
    }; # foreach $naln
    return $F;
} # search_seqname
@ %def &search_seqname


\subsctn{Getting sequence coords limits to set axes boundaries}

In order to compute coordinates limits that we will need later when calculating tickmarks and other variables, we follow these steps

\begin{enumerate}
\item We must take as defaults the starting and ending coordinates found in the GFF input records. If none is defined, because you have been playing with a not defined alingment or sequences names, program uses 0 as start and 1000 as end so it does not die on an empty plot.

<<setting boundaries - initialize>>=
%tcrds = ();
($a, $x, $y) = (
    $vrf->{_alignment_name}, 
    $vrf->{_x_sequence_name},
    $vrf->{_y_sequence_name}
    );
$vrf->{_plot_aln} && do {
    $rrf = \@{ $ALN_DATA{$a}[$_counter] };
    push @{ $tcrds{xs} }, $rrf->[$_ori] ;
    push @{ $tcrds{xe} }, $rrf->[$_end] ;
    push @{ $tcrds{ys} }, $rrf->[$_nori] ;
    push @{ $tcrds{ye} }, $rrf->[$_nend] ;
};
$vrf->{_plot_x_sequence} && do {
    $rrf = \@{ $GFF_DATA{$x}[$_counter] };
    push @{ $tcrds{xs} }, $rrf->[$_ori] ;
    push @{ $tcrds{xe} }, $rrf->[$_end] ;
};
$vrf->{_plot_y_sequence} && do {
    $rrf = \@{ $GFF_DATA{$y}[$_counter] };
    push @{ $tcrds{ys} }, $rrf->[$_ori] ;
    push @{ $tcrds{ye} }, $rrf->[$_end] ;
};
#
$vrf->{_x_start} = [ scalar(@{ $tcrds{xs} }) > 0 ?
                        min(@{ $tcrds{xs} }) :    0, 'bp' ];
$vrf->{_x_end}   = [ scalar(@{ $tcrds{xe} }) > 0 ? 
                        max(@{ $tcrds{xe} }) : 1000, 'bp' ];
$vrf->{_y_start} = [ scalar(@{ $tcrds{ys} }) > 0 ? 
                        min(@{ $tcrds{ys} }) :    0, 'bp' ];
$vrf->{_y_end}   = [ scalar(@{ $tcrds{ye} }) > 0 ? 
                        max(@{ $tcrds{ye} }) : 1000, 'bp' ];
#
@ %def {_x_start} {_x_end} {_y_start} {_y_end}

\item Now we look for user defined values, we build an array of possible values for each x and y start-end pairs, leaving an element undefined if the corresponding variable was not set. Then we can recover from those arrays the zoom-area clip, the normal zoom clip and the plot limits.

<<setting boundaries - initialize customs>>=
%tcrds = (
    xs => [
        defined($vrf->{x_sequence_zoom}) ?
                $vrf->{x_sequence_zoom}[0] : undef,
        defined($vrf->{x_sequence_zoom_start}) ?
                $vrf->{x_sequence_zoom_start} : undef,
        defined($vrf->{x_sequence_coords}) ?
                $vrf->{x_sequence_coords}[0] : undef,
        defined($vrf->{x_sequence_start}) ?
                $vrf->{x_sequence_start} : undef,
        $vrf->{_x_start}
        ],
    xe => [
        defined($vrf->{x_sequence_zoom}) ?
                $vrf->{x_sequence_zoom}[1] : undef,
        defined($vrf->{x_sequence_zoom_end}) ?
                $vrf->{x_sequence_zoom_end} : undef,
        defined($vrf->{x_sequence_coords}) ?
                $vrf->{x_sequence_coords}[1] : undef,
        defined($vrf->{x_sequence_end}) ?
                $vrf->{x_sequence_end} : undef,
        $vrf->{_x_end}
        ],
    ys => [
        defined($vrf->{y_sequence_zoom}) ?
                $vrf->{y_sequence_zoom}[0] : undef,
        defined($vrf->{y_sequence_zoom_start}) ?
                $vrf->{y_sequence_zoom_start} : undef,
        defined($vrf->{y_sequence_coords}) ?
                $vrf->{y_sequence_coords}[0] : undef,
        defined($vrf->{y_sequence_start}) ?
                $vrf->{y_sequence_start} : undef,
        $vrf->{_y_start}
        ],
    ye => [
        defined($vrf->{y_sequence_zoom}) ?
                $vrf->{y_sequence_zoom}[1] : undef,
        defined($vrf->{y_sequence_zoom_end}) ?
                $vrf->{y_sequence_zoom_end} : undef,
        defined($vrf->{y_sequence_coords}) ?
                $vrf->{y_sequence_coords}[1] : undef,
        defined($vrf->{y_sequence_end}) ?
                $vrf->{y_sequence_end} : undef,
        $vrf->{_y_end}
        ],
   ); # %tcrds
#
$vrf->{_x_start} = &get_units(\@{ $vrf->{_x_start} });
$vrf->{_x_end}   = &get_units(\@{ $vrf->{_x_end} });
$vrf->{_y_start} = &get_units(\@{ $vrf->{_y_start} });
$vrf->{_y_end}   = &get_units(\@{ $vrf->{_y_end} });
@

\item Once sequence defaults has been set, we check if [[zoom_area]] is switched on and, after that, we look for [[zoom]] switch. This will allow users to define a zoom area within an already zoomed plot (that feature was not available on old gawk version of {\prog}). Here we look for the zoom area coords, when they are same than sequence boundaries, [[zoom_area]] flag is disabled but also is [[zoom]] (because there are no sequence coords for any zoom defined by user and this way we can skip the corresponding test that will be unnecessary).
 
<<setting boundaries - is zoom area ON>>=
$vrf->{zoom_area} && do {
  $cc = 0;
  $vrf->{_x_zoomarea_start} = &get_first_coord(\@{ $tcrds{xs} },\$cc);
  $vrf->{_x_zoomarea_end}   = &get_first_coord(\@{ $tcrds{xe} },\$cc);
  $vrf->{_y_zoomarea_start} = &get_first_coord(\@{ $tcrds{ys} },\$cc);
  $vrf->{_y_zoomarea_end}   = &get_first_coord(\@{ $tcrds{ye} },\$cc);
  $cc == 4 && ($vrf->{zoom_area} = $F, $vrf->{zoom} = $F);
}; # zoom_area
@ %def {_x_zoomarea_start} {_x_zoomarea_end} {_y_zoomarea_start} {_y_zoomarea_end}

Here we are looking for the zoom coordinates. If those coords are the same as sequence boundaries the zoom is disabled, else current plot sequence boundaries are set to zoom ones.

<<setting boundaries - is zoom ON>>=
$vrf->{zoom} && do {
  $cc = 0;
  $vrf->{_x_zoom_start} = &get_first_coord(\@{ $tcrds{xs} },\$cc);
  $vrf->{_x_zoom_end}   = &get_first_coord(\@{ $tcrds{xe} },\$cc);
  $vrf->{_y_zoom_start} = &get_first_coord(\@{ $tcrds{ys} },\$cc);
  $vrf->{_y_zoom_end}   = &get_first_coord(\@{ $tcrds{ye} },\$cc);
  $cc == 4 && ($vrf->{zoom} = $F);
  $vrf->{zoom} && do {
      $vrf->{_x_start} = $vrf->{_x_zoom_start};
      $vrf->{_x_end}   = $vrf->{_x_zoom_end};
      $vrf->{_y_start} = $vrf->{_y_zoom_start};
      $vrf->{_y_end}   = $vrf->{_y_zoom_end};
  }; # zoom...
}; # zoom
@ %def {_x_zoom_start} {_x_zoom_end} {_y_zoom_start} {_y_zoom_end}

We do need an auxiliarly function to decide which is the first defined value starting from left in each [[%tcrds]] subarray:

<<Layout Settings>>=
sub get_first_coord() {
    my ($ary,$cct) = @_;
    my ($thelast,$cur,$tht);
    $thelast = $#{ $ary };
    for ( $cur = 0; $cur < $thelast; $cur++ ) {
        defined($ary->[$cur]) && do {
            ($tht, $ary->[$cur]) = ($ary->[$cur], undef);
            return &get_units(\@$tht);
        }; # defined($ary[$cur])
    }; # for $cur
    $$cct++;
    return &get_units(\@{ $ary->[$thelast] });
} # get_first_coord
@ %def &get_first_coord

\end{enumerate}

So that, the [[&set_seq_boundaries]] function is set as:

<<Layout Settings>>=
sub set_seq_boundaries() {
    my ($vrf) = @_;
    my ($a, $x, $y, $rrf, %tcrds, $cc);
    <<setting boundaries - initialize>>
    <<setting boundaries - initialize customs>>
    <<setting boundaries - is zoom area ON>>
    <<setting boundaries - is zoom ON>>
    &report('PLOTLIMITS', "X : $vrf->{_x_start} to $vrf->{_x_end}",
                          "Y : $vrf->{_y_start} to $vrf->{_y_end}");
    &report(( $vrf->{zoom_area}
             ? ('ONZOOM',
                "X : $vrf->{_x_zoom_start} to $vrf->{_x_zoom_end}",
                "Y : $vrf->{_y_zoom_start} to $vrf->{_y_zoom_end}" )
             : 'NOZOOM' ));
    &report(( $vrf->{zoom_area}
             ? ('ONZOOMAREA',
                "X : $vrf->{_x_zoomarea_start} to $vrf->{_x_zoomarea_end}",
                "Y : $vrf->{_y_zoomarea_start} to $vrf->{_y_zoomarea_end}" )
             : 'NOZOOMAREA' ));
    return;
} # set_seq_boundaries
@ %def &set_seq_boundaries

<<messages - input/output>>=
PLOTLIMITS =>
  "###---> SEQUENCE BOUNDARIES selected for this plot:\n".
  "###      \%s\n###      \%s\n",
ONZOOM =>
  "###---> SEQUENCE ZOOM that has been choosen:\n".
  "###      \%s\n###      \%s\n",
NOZOOM =>
  "###     SEQUENCE ZOOM is not enabled for this plot...\n",
ONZOOMAREA =>
  "###---> ZOOM AREA that is going to be highlighted:\n".
  "###      \%s\n###      \%s\n",
NOZOOMAREA =>
  "###     NO ZOOM AREA was selected for this plot... \n",
@


\subsctn{Setting tickmark variables}

<<Layout Settings>>=
sub set_tickmark_vars() {
    my ($vrf) = @_;
    my (@tary,$lx,$ly,$stplen);
    <<set tickmarks - bottom one>>
    <<set tickmarks - steps for shorter edge>>
    &report('TICKDONE');
    return;
} # set_tickmark_vars
@ %def &set_tickmark_vars {}

<<messages - input/output>>=
TICKDONE =>
  "###---> TICKMARKS were set: \n",
@

We have to switch on the bottomest scale that appears on plot (it depends on [[show_percent_box]] and [[show_extra_box]]) when [[show_only_bottom_ticks]] is on.

<<set tickmarks - bottom one>>=
$vrf->{show_only_bottom_ticks} && do {
    WHATICK: {
        $vrf->{show_extra_box}   && (@tary = ($F,$F,$T), last WHATICK);
        $vrf->{show_percent_box} && (@tary = ($F,$T,$F), last WHATICK);
        @tary = ($T,$F,$F);
    }; # WHATICK
    ( $vrf->{show_aplot_x_ticks},
      $vrf->{show_percent_x_ticks},
      $vrf->{show_extrabox_x_ticks} ) = @tary;
};
@ 

Now we compute the tickmark steps for the nucleotide scale of the shortest edge (taken as the shortest sequence coords from alignment and or sequence annotations), it is required if user does not define a nucleotide scale (either if she sets major/minor tickmark steps). Major tickmarks steps are now calculated within the perl script, not by {\ps} code, using the following formula:

\[
\begin{array}{rcl}
\mbox{step} & = &
 \mbox{\Large 10}^{
  \left[
    \mathrm{int}( 
      \log_{10}{( \min{ \Delta_{\mathrm{seqX}} , \Delta_{\mathrm{seqY}} )} }
      \;-\; \lambda
    )
  \right]
 } \;, \\[1ex]
\mbox{where} & \quad &
             \Delta_{\mathrm{seq}} = \mathrm{end}_{\mathrm{seq}}
                                   - \mathrm{start}_{\mathrm{seq}} + 1 \;,\\
             & \quad &
             \min{ \Delta_{\mathrm{seqX}} , \Delta_{\mathrm{seqY}} } > 0 \;,\\
             & \quad &
             \mathrm{int}(x) \quad \mbox{is the integer part of} \quad x \;,\\
\mbox{and}   & \quad & 0 < \lambda < 1 \;. \\
\end{array}
\]

We explored several values of $\lambda$ and found that the most appropriate for the current implementation was $\lambda\,=\,0.175$ .

<<set tickmarks - steps for shorter edge>>=
$lx = $vrf->{_x_end} - $vrf->{_x_start} + 1;
$ly = $vrf->{_y_end} - $vrf->{_y_start} + 1;
if ( defined($vrf->{aplot_major_tickmark}) && 
    !defined($vrf->{major_tickmark_nucleotide}) ) {
    $stplen = 10**( int( &logdec( &min($lx,$ly) ) ) + 1 ) / 
              $vrf->{aplot_major_tickmark};
} else {
    $stplen = 10**( int( &logdec( &min($lx,$ly) ) - 0.175 ) );
};
defined($vrf->{major_tickmark_nucleotide}) || do {
    $vrf->{major_tickmark_nucleotide} = $stplen;
}; # defined($vrf->{major_tickmark_nucleotide})
defined($vrf->{minor_tickmark_nucleotide}) || do {
    $vrf->{minor_tickmark_nucleotide} = 
        $vrf->{major_tickmark_nucleotide} / $vrf->{aplot_minor_tickmark};
}; # defined($vrf->{minor_tickmark_nucleotide})
@

We do not want to use the module [[POSIX]] just to have the logarithm in base 10 as a built-in function when it is so easy to implement with the default natural logarithm implemented in perl, as shown here:
% log_10(x) = ( log_e(x)/log_e(10) );

<<Common Routines>>=
sub logdec() { return (log($_[0])/log(10)); }
@ %def &logdec

\subsctn{Setting whole figure labels}

When setting some of the plot labels, we must check if they are defined or not, but also we use them as warning reporters if any of the main draw elements was not found, say here alignment and/or X/Y sequence annotations.

<<Layout Settings>>=
sub set_page_labels() {
    my ($vrf) = @_;
    defined($vrf->{title})    || do {
        ($vrf->{title} = $vrf->{_alignment_name}) =~ s/$;/ x /o;
        $vrf->{_plot_aln} || 
            ($vrf->{subtitle} = 
              'This alignment sequence was not found on GFF input records.\n'.
              '...Please, check your command-line and/or data...');
    };
    defined($vrf->{subtitle}) || ($vrf->{subtitle} = "");
    defined($vrf->{x_label})  || do {
        $vrf->{x_label} = $vrf->{_x_sequence_name};
        $vrf->{_plot_x_sequence} ||
            ($vrf->{x_label} .= " (Annotation NOT FOUND)");
    };
    defined($vrf->{y_label})  || do {
        $vrf->{y_label} = $vrf->{_y_sequence_name};
        $vrf->{_plot_y_sequence} ||
            ($vrf->{y_label} .= " (Annotation NOT FOUND)");
    };
    defined($vrf->{percent_box_label})    || ($vrf->{percent_box_label} = '');
    defined($vrf->{percent_box_sublabel}) || ($vrf->{percent_box_sublabel} = '');
    defined($vrf->{extra_box_label})      || ($vrf->{extra_box_label} = '');
    defined($vrf->{extra_box_sublabel})   || ($vrf->{extra_box_sublabel} = '');
    return;
} # set_page_labels
@ %def &set_page_labels


\newpage

\sctn{Obtaining {\ps} output} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	In this section we are going to implement those perl functions that are processing the data to produce a {\ps} plot (although we are writting some {\ps} code on it too), next section will focus in the {\ps} code that is included literally in those functions and which is really processing our data to get the figure. 

\label{todo:IAA}
<<HIDE: new defs TODO>>=
\def\todoIAA{
Description of Document Structuring Convention (DSC) and sketch PS file structure on figure~\ref{fig:PSdsc}.
} % todoIAA
@
<<HIDE: TODO>>=
\todoitem{\todoIAA}{todo:IAA}
@
\todo{ \item \todoIAA } % todo

\begin{figure}[!ht]
\begin{center}
\fbox{\parbox[c][6cm][c]{\linewidth}{\hfill}}
% \includegraphics[]{}
\caption[{\ps} Document Structuring Convention for {\prog} output.]{\label{fig:PSdsc} Document Structuring Convention for {\prog} {\ps} output.}
\end{center}
\end{figure}

<<Making PS Figures>>=
sub make_plot() {
    &header("WRITING POSTSCRIPT TO STDOUT");

    &ps_header;
    &ps_colors;
    &ps_page_formats;
    &ps_variables;
    &ps_main;

    &ps_plot; 

    &ps_trailer;

    &footer("WRITING POSTSCRIPT FINISHED");
} # make_plot
@ %def &make_plot

<<PostScript CODE Chunks>>=
<<PostScript PLOT>>
<<PostScript HEADER>>
<<PostScript COLORS>>
<<PostScript FORMATS>>
<<PostScript VARS>>
<<PostScript MAIN>>
<<Postscript OPEN PAGE>>
<<Postscript CLOSE PAGE>>
<<Postscript TRAILER>>
@

\subsctn{Header comments and constants definition}
 
<<PostScript HEADER>>=
sub ps_header() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++HEADER+++";
%!PS-Adobe-3.0
%%Title: title
%%Creator: $PROGRAM
%%Version: $VERSION
%%CreationDate: $DATE
%%For: $USER
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 $vr->{_page_width} $vr->{_page_height}
%%EndComments
%
<<GNU License PostScript>>
%
% $LAST_UPDATE
%
% Report BUGS to: jabril\@imim.es 
%
%%BeginProlog
%
<<POSTSCRIPT shortnames>>
<<POSTSCRIPT constants>>
+++HEADER+++
    &report('PSHEADER');
} # ps_header
@ %def &ps_header

<<messages - input/output>>=
PSHEADER =>
  "###---> PostScript Header DONE...\n",
@

\subsctn{Filling up the CMYK colors hash} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CMYKcolordef}

% \subsctn{CMYK color definition}
This is the function that fills up the {\ps} colors array:

<<PostScript COLORS>>=
sub ps_colors() {
    my %tmp = ();
    print STDOUT "%% Fixed Color Variables (CMYK)\n";
    print STDOUT "/colordict ".($colors + 28)." dict D colordict begin %% ".
                 $colors." colors + 28 definitions\n";
    foreach my $key (keys %COLORS) { $tmp{$COLORS{$key}->[0]} = $key };
    for (my $j = 1; $j <= $colors; $j++) { 
        my $name = $tmp{$j};
        my $ref = \$COLORS{$name};
        my $cmyk = "$$ref->[1] $$ref->[2] $$ref->[3] $$ref->[4]";
        print STDOUT "/".(&fill_right($name,20," "))."{ $cmyk } D\n";
        };
    print STDOUT "end %% colordict\n";
    &report('PSCOLORS');
} # ps_colors
@ %def &ps_colors colordict

<<messages - input/output>>=
PSCOLORS =>
  "###---> PostScript Colors Table SET...\n",
@

<<Global Vars>>=
$colors = 0;
%COLORS = (    # [ ColorNUMBER, qw/ CYAN MAGENTA YELLOW BLACK / ]
  <<cmyk colors perl definition>>
  ); # %COLORS
@ %def COLORS

\label{todo:JAA}
<<HIDE: new defs TODO>>=
\def\todoJAA{
Move this section to a perl package: \\ suggesting [[gfftools::PostScript::colors]].
} % todoJAA
@
<<HIDE: TODO>>=
\todoitem{\todoJAA}{todo:JAA}
@
\todo{ \item \todoJAA } % todo

To avoid mistakes when working with three separate files, we define here CMYK color names used by this perl program, then the corresponding chunks are processedby [[colors2tex.pl]] to obtain the definitions {\LaTeX} file ('[[AplotColorDefs.tex]]') and the table summarizing them for the manual ('[[AplotColorTbl.tex]]').See appendix~\ref{sec:COLORprg} on page~\pageref{sec:COLORprg} to look at that script implementation. % outlined in page~\pageref{sec:cmykfiles}.

\label{sec:ColorsHsh}

\subsubsctn{Black and White}

\newcommand{\clrtbl}[5]{\vskip -2.95ex \noindent\hrulefill\cln{#1}\cln{#2}\cln{#3}\cln{#4}\cln{#5}}
\newcommand{\clrtblg}[7]{\vskip -2.95ex \noindent\hrulefill\cln{#1}\cln{#2}\cln{#3}\cln{#4}\cln{#5}\cln{#6}\cln{#7}}

\clrtblg{black}{verydarkgrey}{darkgrey}{grey}{lightgrey}{verylightgrey}{white}

<<cmyk colors perl definition>>=
# black+grey+white
black              => [ ++$colors, qw/ 0.00 0.00 0.00 1.00 / ],
verydarkgrey       => [ ++$colors, qw/ 0.00 0.00 0.00 0.80 / ],
darkgrey           => [ ++$colors, qw/ 0.00 0.00 0.00 0.60 / ],
grey               => [ ++$colors, qw/ 0.00 0.00 0.00 0.40 / ],
lightgrey          => [ ++$colors, qw/ 0.00 0.00 0.00 0.20 / ],
verylightgrey      => [ ++$colors, qw/ 0.00 0.00 0.00 0.10 / ],
white              => [ ++$colors, qw/ 0.00 0.00 0.00 0.00 / ],
@

\subsubsctn{Magenta}

\clrtbl{verydarkmagenta}{darkmagenta}{magenta}{lightmagenta}{verylightmagenta}

<<cmyk colors perl definition>>=
# magenta				  
verydarkmagenta    => [ ++$colors, qw/ 0.00 1.00 0.00 0.30 / ],
darkmagenta        => [ ++$colors, qw/ 0.00 0.80 0.00 0.05 / ],
magenta            => [ ++$colors, qw/ 0.00 0.60 0.00 0.00 / ],
lightmagenta       => [ ++$colors, qw/ 0.00 0.40 0.00 0.00 / ],
verylightmagenta   => [ ++$colors, qw/ 0.00 0.20 0.00 0.00 / ],
@

\subsubsctn{Violet}

\clrtbl{verydarkviolet}{darkviolet}{violet}{lightviolet}{verylightviolet}

<<cmyk colors perl definition>>=
# violet				  
verydarkviolet     => [ ++$colors, qw/ 0.45 0.85 0.00 0.00 / ],
darkviolet         => [ ++$colors, qw/ 0.30 0.65 0.00 0.00 / ],
violet             => [ ++$colors, qw/ 0.22 0.55 0.00 0.00 / ],
lightviolet        => [ ++$colors, qw/ 0.15 0.40 0.00 0.00 / ],
verylightviolet    => [ ++$colors, qw/ 0.10 0.20 0.00 0.00 / ],
@

\subsubsctn{Blue}

\clrtbl{verydarkblue}{darkblue}{blue}{lightblue}{verylightblue}

<<cmyk colors perl definition>>=
# blue				  
verydarkblue       => [ ++$colors, qw/ 1.00 1.00 0.00 0.20 / ],
darkblue           => [ ++$colors, qw/ 0.90 0.90 0.00 0.00 / ],
blue               => [ ++$colors, qw/ 0.75 0.75 0.00 0.00 / ],
lightblue          => [ ++$colors, qw/ 0.50 0.50 0.00 0.00 / ],
verylightblue      => [ ++$colors, qw/ 0.30 0.30 0.00 0.00 / ],
@

\subsubsctn{Skyblue}

\clrtbl{verydarkskyblue}{darkskyblue}{skyblue}{lightskyblue}{verylightskyblue}

<<cmyk colors perl definition>>=
# skyblue				  
verydarkskyblue    => [ ++$colors, qw/ 0.90 0.50 0.00 0.15 / ],
darkskyblue        => [ ++$colors, qw/ 0.75 0.45 0.00 0.00 / ],
skyblue            => [ ++$colors, qw/ 0.60 0.38 0.00 0.00 / ],
lightskyblue       => [ ++$colors, qw/ 0.45 0.25 0.00 0.00 / ],
verylightskyblue   => [ ++$colors, qw/ 0.30 0.15 0.00 0.00 / ],
@

\subsubsctn{Cyan}

\clrtbl{verydarkcyan}{darkcyan}{cyan}{lightcyan}{verylightcyan}

<<cmyk colors perl definition>>=
# cyan				  
verydarkcyan       => [ ++$colors, qw/ 1.00 0.00 0.00 0.10 / ],
darkcyan           => [ ++$colors, qw/ 0.80 0.00 0.00 0.00 / ],
cyan               => [ ++$colors, qw/ 0.60 0.00 0.00 0.00 / ],
lightcyan          => [ ++$colors, qw/ 0.40 0.00 0.00 0.00 / ],
verylightcyan      => [ ++$colors, qw/ 0.20 0.00 0.00 0.00 / ],
@

\subsubsctn{Seagreen}

\clrtbl{verydarkseagreen}{darkseagreen}{seagreen}{lightseagreen}{verylightseagreen}

<<cmyk colors perl definition>>=
# seagreen			  
verydarkseagreen   => [ ++$colors, qw/ 0.75 0.00 0.45 0.00 / ],
darkseagreen       => [ ++$colors, qw/ 0.62 0.00 0.38 0.00 / ],
seagreen           => [ ++$colors, qw/ 0.50 0.00 0.30 0.00 / ],
lightseagreen      => [ ++$colors, qw/ 0.38 0.00 0.22 0.00 / ],
verylightseagreen  => [ ++$colors, qw/ 0.25 0.00 0.15 0.00 / ],
@

\subsubsctn{Green}

\clrtbl{verydarkgreen}{darkgreen}{green}{lightgreen}{verylightgreen}

<<cmyk colors perl definition>>=
# green				  
verydarkgreen      => [ ++$colors, qw/ 1.00 0.00 1.00 0.25 / ],
darkgreen          => [ ++$colors, qw/ 0.80 0.00 0.80 0.00 / ],
green              => [ ++$colors, qw/ 0.60 0.00 0.60 0.00 / ],
lightgreen         => [ ++$colors, qw/ 0.40 0.00 0.40 0.00 / ],
verylightgreen     => [ ++$colors, qw/ 0.20 0.00 0.20 0.00 / ],
@

\subsubsctn{Limegreen}

\clrtbl{verydarklimegreen}{darklimegreen}{limegreen}{lightlimegreen}{verylightlimegreen}

<<cmyk colors perl definition>>=
# limegreen			  
verydarklimegreen  => [ ++$colors, qw/ 0.50 0.00 1.00 0.10 / ],
darklimegreen      => [ ++$colors, qw/ 0.40 0.00 0.95 0.00 / ],
limegreen          => [ ++$colors, qw/ 0.30 0.00 0.80 0.00 / ],
lightlimegreen     => [ ++$colors, qw/ 0.20 0.00 0.65 0.00 / ],
verylightlimegreen => [ ++$colors, qw/ 0.10 0.00 0.50 0.00 / ],
@

\subsubsctn{Yellow}

\clrtbl{verydarkyellow}{darkyellow}{yellow}{lightyellow}{verylightyellow}

<<cmyk colors perl definition>>=
# yellow				  
verydarkyellow     => [ ++$colors, qw/ 0.00 0.00 1.00 0.25 / ],
darkyellow         => [ ++$colors, qw/ 0.00 0.00 1.00 0.10 / ],
yellow             => [ ++$colors, qw/ 0.00 0.00 1.00 0.00 / ],
lightyellow        => [ ++$colors, qw/ 0.00 0.00 0.50 0.00 / ],
verylightyellow    => [ ++$colors, qw/ 0.00 0.00 0.25 0.00 / ],
@

\subsubsctn{Orange}

\clrtbl{verydarkorange}{darkorange}{orange}{lightorange}{verylightorange}

<<cmyk colors perl definition>>=
# orange				  
verydarkorange     => [ ++$colors, qw/ 0.00 0.50 0.80 0.10 / ],
darkorange         => [ ++$colors, qw/ 0.00 0.40 0.80 0.00 / ],
orange             => [ ++$colors, qw/ 0.00 0.30 0.80 0.00 / ],
lightorange        => [ ++$colors, qw/ 0.00 0.20 0.75 0.00 / ],
verylightorange    => [ ++$colors, qw/ 0.00 0.15 0.70 0.00 / ],
@

\subsubsctn{Red}

\clrtbl{verydarkred}{darkred}{red}{lightred}{verylightred}

<<cmyk colors perl definition>>=
# red					  
verydarkred        => [ ++$colors, qw/ 0.00 1.00 1.00 0.15 / ],
darkred            => [ ++$colors, qw/ 0.00 0.80 0.80 0.00 / ],
red                => [ ++$colors, qw/ 0.00 0.60 0.60 0.00 / ],
lightred           => [ ++$colors, qw/ 0.00 0.40 0.40 0.00 / ],
verylightred       => [ ++$colors, qw/ 0.00 0.20 0.20 0.00 / ],
@

\subsubsctn{Brown}

\clrtbl{verydarkbrown}{darkbrown}{brown}{lightbrown}{verylightbrown}

<<cmyk colors perl definition>>=
# brown				  
verydarkbrown      => [ ++$colors, qw/ 0.35 0.85 1.00 0.40 / ],
darkbrown          => [ ++$colors, qw/ 0.30 0.70 1.00 0.35 / ],
brown              => [ ++$colors, qw/ 0.25 0.75 1.00 0.25 / ],
lightbrown         => [ ++$colors, qw/ 0.20 0.60 0.70 0.15 / ],
verylightbrown     => [ ++$colors, qw/ 0.15 0.45 0.55 0.00 / ],
@ 

\subsubsctn{Colors Help}

<<colors help>>=
Those are the colors defined in $PROGRAM:
+ Basic Colors: black white.
+ Variable Colors: 
      grey magenta violet blue skyblue cyan seagreen
         green limegreen yellow orange red brown
  You can get five color shades from Variable Colors with
  \"verydark\", \"dark\", \"light\" and \"verylight\" prefixes,
  as example: 
    verydarkblue, darkblue, blue, lightblue and verylightblue.
@


\subsctn{Filling up the page formats hash} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsctn{Page formats definition}

Now we have to fill the page formats {\ps} array:

\label{sec:PAGEdef}

<<PostScript FORMATS>>=
sub ps_page_formats() {
    my %tmp = ();
    print STDOUT "%% Paper Sizes (in points)\n";
    print STDOUT "/pagedict ".($formats + 2)." dict D pagedict begin %% ".
                 $formats." formats + 2 definitions\n";
    foreach my $key (keys %FORMATS) { $tmp{$FORMATS{$key}->[0]} = $key };
    for (my $j = 1; $j <= $formats; $j++) { 
        my $name = $tmp{$j};
        my $ref = \$FORMATS{$name};
        my $pgsz = &fill_left($$ref->[1],4," ").&fill_left($$ref->[2],5," ");
        print STDOUT "/pg".(&fill_right($name,10," "))."{ $pgsz } D\n";
        };
    print STDOUT "end %% pagedict\n";
    &report('PSFORMATS');
} # ps_page_formats
@ %def &ps_page_formats pagedict

<<messages - input/output>>=
PSFORMATS =>
  "###---> PostScript Page-formats Table SET...\n",
@

<<Global Vars>>=
$formats = 0;
%FORMATS = (   # [ FormatNUMBER, X(short edge), Y(long edge) ]
  <<page sizes perl definition>>
  ); # %FORMATS
@ %def FORMATS


\label{todo:JAB}
<<HIDE: new defs TODO>>=
\def\todoJAB{
Move this section to a perl package: \\ suggesting [[gfftools::PostScript::formats]].
} % todoJAB
@
<<HIDE: TODO>>=
\todoitem{\todoJAB}{todo:JAB}
@
\todo{ \item \todoJAB } % todo


\label{sec:FormatsHsh}

\subsubsctn{ISO standard page sizes: A series}

<<page sizes perl definition>>=
  # A Series
  a0        => [ ++$formats, 2384, 3370 ],
  a1        => [ ++$formats, 1684, 2384 ],
  a2        => [ ++$formats, 1190, 1684 ],
  a3        => [ ++$formats,  842, 1190 ],
  a4        => [ ++$formats,  595,  842 ],
  a5        => [ ++$formats,  420,  595 ],
  a6        => [ ++$formats,  297,  420 ],
  a7        => [ ++$formats,  210,  297 ],
  a8        => [ ++$formats,  148,  210 ],
  a9        => [ ++$formats,  105,  148 ],
  a10       => [ ++$formats,   73,  105 ],
@

\subsubsctn{ISO standard page sizes: B series}

<<page sizes perl definition>>=
  # B Series
  b0        => [ ++$formats, 2920, 4127 ],
  b1        => [ ++$formats, 2064, 2920 ],
  b2        => [ ++$formats, 1460, 2064 ],
  b3        => [ ++$formats, 1032, 1460 ],
  b4        => [ ++$formats,  729, 1032 ],
  b5        => [ ++$formats,  516,  729 ],
  b6        => [ ++$formats,  363,  516 ],
  b7        => [ ++$formats,  258,  363 ],
  b8        => [ ++$formats,  181,  258 ],
  b9        => [ ++$formats,  127,  181 ],
  b10       => [ ++$formats,   91,  127 ],
@

\subsubsctn{US standard page sizes}

<<page sizes perl definition>>=
  # USA Formats
  executive => [ ++$formats,  540,  720 ],
  folio     => [ ++$formats,  612,  936 ],
  legal     => [ ++$formats,  612, 1008 ],
  letter    => [ ++$formats,  612,  792 ],
  quarto    => [ ++$formats,  610,  780 ],
  statement => [ ++$formats,  396,  612 ],
 '10x14'    => [ ++$formats,  720, 1008 ],
  ledger    => [ ++$formats, 1224,  792 ],
  tabloid   => [ ++$formats,  792, 1224 ],
@

\subsubsctn{Page sizes help}

<<pages help>>=
The following page sizes are available: from A0 to A10, 
from B0 to B10, 10x14, executive, folio, ledger, legal, 
letter, quarto, statement and tabloid.
@


\subsctn{Setting up {\ps} variables}

<<HIDE: DONE>>=
\doneitem{20011113}{Setting up PostScript variables}
@

<<PostScript VARS>>=
sub ps_variables() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++PSVARS+++";
%%BeginProcSet: Setting_Vars 1.0 0
%
<<PSVariables - layout>>
<<PSVariables - tickmarks>>
<<PSVariables - labels>>
%
%%EndProcSet:   Setting_Vars 1.0 0
+++PSVARS+++
    &report('PSVARS');
} # ps_variables
@ %def &ps_variables

<<messages - input/output>>=
PSVARS =>
  "###---> PostScript Variables SET...\n",
@

<<PSVariables - layout>>=
%% Layout
/flglscape @{[ &tobool($F) ]} D      %:% landscape mode not implemented yet
 %:%
/flgcrd @{[ &tobool($vr->{hide_credits}) ]} D
 %:%
/Dpage {                %-> Dpage -> page_width page_height
  pagedict begin        %-> recovering from pagedict dictionary
    pg$vr->{page_size}  %->          this page width and height        
    flglscape {         %-> if flglscape is true 
      exch              %->    exchanges width and height
    } if                %->
  end                   %-> close pagedict
} B                     %:%
@ %def flglscape flgcrd Dpage

<<PSVariables - layout>>=
%% Margins                       %:% Margins are XY independent.
/MT @{ $vr->{margin_top} } D     %-% Top margin
/MB @{ $vr->{margin_bottom} } D  %-% Bottom margin
/ML @{ $vr->{margin_left} } D    %-% Left margin
/MR @{ $vr->{margin_right} } D   %:% Right margin
@ %def MT MB ML MR

<<PSVariables - layout>>=
%% Background Colors
/bg {                       %-> bg -> c m y k 
  colordict begin           %-> recovering from colordict dictionary
    $vr->{background_color} %->               this color cmyk values
  end                       %-> close colordict
} D                         %-% 
/fg {                       %-> fg -> c m y k 
  colordict begin           %-> recovering from colordict dictionary
    $vr->{foreground_color} %->               this color cmyk values
  end                       %-> close colordict
} D                         %-% 
/ABc { $vr->{aplot_box_bgcolor} } D   %-% 
/PBc { $vr->{percent_box_bgcolor} } D %-% 
/QBc { $vr->{extra_box_bgcolor} } D   %:% 
@ %def bg fg ABc PBc QBc 

<<PSVariables - layout>>=
%% Limits
/XO $vr->{_x_start} D  %-% X-sequence first nucleotide coord
/XE $vr->{_x_end} D    %-% X-sequence last  nucleotide coord
/YO $vr->{_y_start} D  %-% Y-sequence first nucleotide coord
/YE $vr->{_y_end} D    %:% Y-sequence last  nucleotide coord
/axesp @{[ &tobool($vr->{aplot_xy_same_length}) ]} D  %-%
% /xyratio $vr->{aplot_xy_scale} D                    %-%
/Zmarks @{[ &tobool($vr->{zoom_marks}) ]} D           %:%
@ %def XO XE YO YE axesp xyratio Zmarks

<<PSVariables - tickmarks>>=
%% Tickmarks
/KGb @{[ &tobool($vr->{show_grid}) ]} D            %-% 
/KLb @{[ &tobool($vr->{show_tickmark_label}) ]} D  %:% tickmark labels == coords
/KAXb @{[ &tobool($vr->{show_aplot_x_ticks}) ]} D    %-% Aplot X ticKmarks flg
/KAYb @{[ &tobool($vr->{show_aplot_y_ticks}) ]} D    %-% Aplot Y ticKmarks flg
/KPXb @{[ &tobool($vr->{show_percent_x_ticks}) ]} D  %-% Percent X ticKmarks flg
/KPYb @{[ &tobool($vr->{show_percent_y_ticks}) ]} D  %-% Percent Y ticKmarks flg
/KQXb @{[ &tobool($vr->{show_extrabox_x_ticks}) ]} D %-% extra-Q X ticKmarks flg
/KQYb @{[ &tobool($vr->{show_extrabox_y_ticks}) ]} D %:% extra-Q X ticKmarks flg
@ %def KGb KLb KAXb KAYb KPXb KPYb KQXb KQYb

<<PSVariables - tickmarks>>=
/KASm $vr->{major_tickmark_nucleotide} D
/KASn $vr->{minor_tickmark_nucleotide} D
% % /maxtck $vr->{aplot_major_tickmark} D
% % /mintck $vr->{aplot_minor_tickmark} D
% /KPSm $vr->{percent_major_tickmark_step} D
% /KPSn $vr->{percent_minor_tickmark_step} D
% % /pctmxt $vr->{percent_major_tickmark} D
% % /pctmnt $vr->{percent_minor_tickmark} D
% /KQSm $vr->{extra_major_tickmark_step} D
% /KQSn $vr->{extra_minor_tickmark_step} D
% % /xtrmxt $vr->{extra_major_tickmark} D
% % /xtrmnt $vr->{extra_minor_tickmark} D
@ %def KASm KASn KPSm KPSn KQSm KQSn

<<PSVariables - labels>>=
%% Labels
/TTLb @{[ &tobool($vr->{show_title}) ]} D      %-%
/TTLl @{[ &tostring($vr->{title}) ]} D         %-%
/TTLz @{ $vr->{title_fontsize} } D             %-%
/TTLf { TTLz $Fonts{$vr->{title_font}} } D     %-%
/TTlb @{[ &tobool($vr->{show_subtitle}) ]} D   %-%
/TTll @{[ &tostring($vr->{subtitle}) ]} D      %-%
/TTlz @{ $vr->{subtitle_fontsize} } D          %-%
/TTlf { TTlz $Fonts{$vr->{subtitle_font}} } D  %:%
@ %def TTLb TTLl TTLz TTLf TTlb TTll TTlz TTlf

<<PSVariables - labels>>=
/XSLb @{[ &tobool($vr->{show_x_sequence_label}) ]} D  %-%
/XSLl @{[ &tostring($vr->{x_sequence_label}) ]} D     %-%
/XSLz @{ $vr->{x_label_fontsize} } D                  %-%
/XSLf { XSLz $Fonts{$vr->{x_label_font}} } D          %-%
/YSLb @{[ &tobool($vr->{show_y_sequence_label}) ]} D  %-%
/YSLl @{[ &tostring($vr->{y_sequence_label}) ]} D     %-%
/YSLz @{ $vr->{y_label_fontsize} } D                  %-%
/YSLf { YSLz $Fonts{$vr->{y_label_font}} } D          %:%
@ %def XSLb XSLl XSLz XSLf YSLb YSLl YSLz YSLf

<<PSVariables - labels>>=
/PBLb @{[ &tobool($vr->{show_percent_box_sublabel}) ]} D      %-%
/PBLl @{[ &tostring($vr->{percent_box_label}) ]} D            %-%
/PBLz @{ $vr->{percent_box_label_fontsize} } D                %-%
/PBLf { SBoxLabfsz $Fonts{$vr->{percent_box_label_font}} } D  %-%
/PBlb @{[ &tobool($vr->{show_percent_box_sublabel}) ]} D      %-%
/PBll @{[ &tostring($vr->{percent_box_sublabel}) ]} D         %-%
/PBlz @{ $vr->{percent_box_sublabel_fontsize} } D             %-%
/PBlf { SBoxSLabfsz $Fonts{$vr->{percent_box_sublabel_font}} } D  %:%
@ %def PBLb PBLl PBLz PBLf PBlb PBll PBlz PBlf

<<PSVariables - labels>>=
/QBLb @{[ &tobool($vr->{show_extra_box_label}) ]} D         %-%
/QBLl @{[ &tostring($vr->{extra_box_label}) ]} D            %-%
/QBLz @{ $vr->{extra_box_label_fontsize} } D                %-%
/QBLf { XBoxLabfsz $Fonts{$vr->{extra_box_label_font}} } D  %-%
/QBlb @{[ &tobool($vr->{show_extra_box_sublabel}) ]} D      %-%
/QBll @{[ &tostring($vr->{extra_box_sublabel}) ]} D         %-%
/QBlz @{ $vr->{extra_box_sublabel_fontsize} } D             %-%
/QBlf { XBoxSLabfsz $Fonts{$vr->{extra_box_sublabel_font}} } D  %:%
@ %def QBLb QBLl QBLz QBLf QBlb QBll QBlz QBlf

<<PSVariables - labels>>=
%
%  /FTXangle  D % Var["FEATURE_X-LABELS_ANGLE"];
%  /GPXangle  D % Var["GROUP_X-LABELS_ANGLE"];
%  /FTYangle  D % Var["FEATURE_Y-LABELS_ANGLE"];
%  /GPYangle  D % Var["GROUP_Y-LABELS_ANGLE"];
%  /FTLbsc    D % Var["FEATURE_LABELS_FONTSIZE"];
%  /GPLbsc    D % Var["GROUP_LABELS_FONTSIZE"];
%  /MxFtLBL   D % MxFtLBL;
%  /MxGpLBL   D % MxGpLBL;
%  /putExon   D % tmpflag;
%  /putExLbl  D % OnOff(Var["Display_BOX_LABEL"]);
%  /putGnLbl  D % OnOff(Var["Display_GENE_LABEL"]);
@


\subsctn{Main {\ps} functions}

\label{todo:IAC}
<<HIDE: new defs TODO>>=
\def\todoIAC{
Page layout must be redefined (taking into account page size too).
} % todoIAC
@
<<HIDE: TODO>>=
\todoitem{\todoIAC}{todo:IAC}
@
\todo{ \item \todoIAC } % todo

<<PostScript MAIN>>=
sub ps_main() {
    print STDOUT << '+++MAINProcs+++';
<<POSTSCRIPT layout>>
<<POSTSCRIPT text functions>>
<<POSTSCRIPT aplotdict>>
<<POSTSCRIPT main function calls>>
%
%%EndProlog
%
<<PostScript SETUP>>
%
+++MAINProcs+++
    &report('PSCODE');
} # ps_main
@ %def &ps_main

<<messages - input/output>>=
PSCODE =>
  "###---> PostScript Functions SET...\n",
@

<<PostScript SETUP>>=
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
@


\subsctn{Plotting data into the figure}

We are going to translate data and their settings into {\ps} code, passing those elements to the {\ps} execution stack from where they can be taken as parameters of the built-in {\ps} functions (see section~\ref{sec:PSONLY}, page~\pageref{sec:PSONLY}, to get into the {\ps} functions implementation). {\prog} produces a single page figure, so that [[&ps_plot]] routine has been developed as a linear design.

\label{todo:IAD}
<<HIDE: new defs TODO>>=
\def\todoIAD{
Plotting data into the figure
} % todoIAD
@
<<HIDE: TODO>>=
\todoitem{\todoIAD}{todo:IAD}
@
\todo{ \item \todoIAD } % todo

<<PostScript PLOT>>=
sub ps_plot(){
    &report('PSPLOT');
    #
    &ps_open_page;
    #
    &ps_block_aplot;
    #
    $Vars{LAYOUT}{show_percent_box} && &ps_block_percent;
    #
    $Vars{LAYOUT}{show_extra_box}   && &ps_block_extra;
    #
    &ps_close_page;
    #
    &report('PSPLOTDONE');
} # ps_plot
@ %def &ps_plot

<<messages - input/output>>=
PSPLOT =>
  "###---> Writting PostScript Page:\n",
PSPLOTDONE =>
  "###---> PostScript Page FINISHED...\n",
BLOCKRB =>
  "###     + APLOT-BOX drawing \%s ribbons...\n",
BLOCKXY =>
  "###     + APLOT-BOX drawing \%s annotation...\n",
BLOCKA =>
  "###     + APLOT-BOX drawing alignment features...\n",
BLOCKFX =>
  "###     + APLOT-BOX extra features from custom files...\n",
BLOCKDONE =>
  "###     + \%s section DONE...\n",
@

\subsubsctn{Producing main aplot box}

<<PostScript PLOT>>=
sub ps_block_aplot() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << '+++MAINProcs+++';
%
%%%% Figure Initialization
%
DoTitle
%
%%%%%%%% ALIGNMENT PLOT - BOX
%
begindata
+++MAINProcs+++
    # feature ribbons
    $vlr->{show_ribbons} && do {
        $vlr->{_plot_x_sequence} && do { # horizontal
            &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        }; # _plot_x_sequence
        $vlr->{_plot_y_sequence} && do { # vertical
            &ps_plot_ribbons($vlr->{_y_sequence_name},$F);
        }; # _plot_y_sequence
        # nice ribbon lines finishing
        &ps_plot_outlines;
    }; # show_ribbons
    # tag definitions: Box,Join,Arrow,Banner;
    $vlr->{_plot_x_sequence} && do { # horizontal
        &ps_plot_features($vlr->{_x_sequence_name},$T);
    }; # _plot_x_sequence
    $vlr->{_plot_y_sequence} && do { # vertical
        &ps_plot_features($vlr->{_y_sequence_name},$F);
    }; # _plot_y_sequence
    $vlr->{_plot_aln} && do {
        &ps_plot_aln($vlr->{_alignment_name});
    }; # _plot_aln
    $vlr->{_plot_addons} && do {
        &ps_plot_addons; # PLOTREMARKS(seqname,flag)
    }; # _plot_addons
    $vlr->{zoom_area} && do {
        my $kt = defined($vlr->{zoom_area_fill_color}) 
                 ? "$vlr->{zoom_area_fill_color} ".&tobool($T)
                 : &tobool($F);
        printf STDOUT "%s %s %s %s %s %s %s Msquare\n",
            $vlr->{zoom_area_mark_width}, $vlr->{zoom_area_mark_color}, $kt,
            &max($vlr->{_x_zoomarea_start}, $vlr->{_x_start}),
            &min($vlr->{_x_zoomarea_end},   $vlr->{_x_end}),
            &max($vlr->{_y_zoomarea_start}, $vlr->{_y_start}),
            &min($vlr->{_y_zoomarea_end},   $vlr->{_y_end});
    }; # zoom_area
    print STDOUT "\%\nenddata\n\%\n";
    &report('BLOCKDONE','APLOT-BOX  ');
} # ps_block_aplot
@ %def &ps_block_aplot

<<PostScript PLOT>>=
sub ps_plot_ribbons() {
    my ($seq,$flg) = @_;
    my $what = $flg ? 'X-sequence' : 'Y-sequence';
    print STDOUT "\%\n\%\%\%\% $what Ribbons\n\%\n"; 
    &report('BLOCKRB',$what);

} # ps_plot_ribbons
@ %def &ps_plot_ribbons

<<PostScript PLOT>>=
sub ps_plot_outlines() {

} # ps_plot_outlines
@ %def &ps_plot_outlines

<<PostScript PLOT>>=
sub ps_plot_features() {
    my ($seq,$flg) = @_;
    my $what = $flg ? 'X-sequence' : 'Y-sequence';
    print STDOUT "\%\n\%\%\%\% DATA ---> $what Annotations\n\%\n"; 
    &report('BLOCKXY',$what);

} # ps_plot_features
@ %def &ps_plot_features

<<PostScript PLOT>>=
sub ps_plot_aln() {
    my ($aln) = @_;
    print STDOUT "\%\n\%\%\%\% DATA ---> Alignment\n\%\n"; 
    &report('BLOCKA');
 
} # ps_plot_aln
@ %def &ps_plot_aln

<<PostScript PLOT>>=
sub ps_plot_addons() {
    print STDOUT "\%\n\%\%\%\% Extra features from custom files...\n\%\n"; 
    &report('BLOCKFX');
 
} # ps_plot_addons
@ %def &ps_plot_addons


\subsubsctn{Generating percent box}

% Get the scores limits for the sequence 
% (taking into account $vlr->{percent_box_score_range} )
%
% $vlr->{_aln_lower_sco} $vlr->{_aln_upper_sco}
% $vlr->{_alignment_name}

<<PostScript PLOT>>=
sub ps_block_percent() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << '+++MAINProcs+++';
%
%%%%%%%% MATCHES PERCENT - BOX
%
% lowerpct upperpct
$vlr->{_aln_lower_sco} $vlr->{_aln_upper_sco} beginmatches
%
+++MAINProcs+++
    ($vlr->{show_ribbons} && $vlr->{_plot_x_sequence}) && do { # horizontal
        &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        &ps_plot_outlines;
    }; # show_ribbons && _plot_x_sequence
    print STDOUT "\%\nvertical\n\%\npctmarks\n";
    $vlr->{_plot_aln} && do {
        &ps_plot_pctaln($vlr->{_alignment_name});
    }; # _plot_aln
    print STDOUT "\%\nendmaches\n\%\n";
    &report('BLOCKDONE','PERCENT-BOX');
} # ps_block_percent
@ %def &ps_block_percent

<<PostScript PLOT>>=
sub ps_plot_pctaln() {
    my ($aln) = @_;
    print STDOUT "\%\n\%\%\%\% DATA ---> Alignment\n\%\n"; 
    &report('BLOCKA');
 
} # ps_plot_pctaln
@ %def &ps_plot_pctaln


\subsubsctn{Generating lower auxiliarly box}

<<PostScript PLOT>>=
sub ps_block_extra() {
    my $vlr = \%{ $Vars{LAYOUT} };
    print STDOUT << '+++MAINProcs+++';
%
%%%%%%%% EXTRA DATA - BOX
%
% numlines
$vlr->{_x_sequence_sources} beginextra % NGROUPS
%
+++MAINProcs+++
    ($vlr->{show_ribbons} && $vlr->{_plot_x_sequence}) && do { # horizontal
        &ps_plot_ribbons($vlr->{_x_sequence_name},$T);
        &ps_plot_outlines;
    }; # show_ribbons && _plot_x_sequence

    print STDOUT "\%\nendextra\n\%\n";
    &report('BLOCKDONE','EXTRA-BOX  ');
} # ps_block_extra
@ %def &ps_block_extra


\subsctn{{\ps} code chunks}

\subsubsctn{Page boundaries}

<<Postscript OPEN PAGE>>=
sub ps_open_page() {
    print STDOUT << '+++OPEN+++';
%%Page: 1 1
%%BeginPageSetup
%
% Saving current page settings
/pgsave save D
% Setting BGcolor for sheet
Dpage 0 0 bbox S BGcolor scmyk fill R clip newpath
% Setting page-size scale
1 CSF dup F
%%EndPageSetup
%
+++OPEN+++
} # ps_open_page
@ %def &ps_open_page

<<Postscript CLOSE PAGE>>=
sub ps_close_page() {
    print STDOUT << '+++CLOSE+++';
%
flgcrd { s_credits } if
grestoreall
pgsave restore
showpage
%
%%PageEND: 1 1
%
+++CLOSE+++
} # ps_close_page
@ %def &ps_close_page

\subsubsctn{{\ps} end of file}

<<Postscript TRAILER>>=
sub ps_trailer() {
    my $vr = \%{ $Vars{LAYOUT} };
    print STDOUT << "+++EOF+++";
%%Trailer
%
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 $vr->{_page_width} $vr->{_page_height}
%%EOF
+++EOF+++
} # ps_trailer
@ %def &ps_trailer

\newpage

\sctn{{\ps} main program and routines} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:PSONLY}

This section is mainly focused on the {\ps} functions that are executed on the {\ps} device to produce the figures.
We have implemented a perl script that is used as a [[noweb]] filter (see appendix~\ref{sec:PSnowebfilter}, page~\pageref{sec:PSnowebfilter}), that removes from {\ps} ocde chunks a special set of comments ('[[%-%]]' and '[[%->]]'). That makes such code more compact within executable {\prog} version, while preserving full readability in this document, as example by showing stack contents for functions and so on.
 
<<HIDE: DONE>>=
\doneitem{20011114}{Enhance PostScript code readability, including special comments that should be stripped out when tangling code, making final PS code more compact while preserving full explanations in this document.}
@

\subsctn{Abbreviated function names}

<<POSTSCRIPT shortnames>>=
%%BeginProcSet: Short_names 1.0 0
%
/tflg false def %-% test flag
%
/B { bind def } bind def       %-%
/X { exch def } B              %-%
/D { def      } B              %:%
%
/S { gsave     } B             %-%
/R { grestore  } B             %-%
/F { scale     } B             %-%
/T { translate } B             %:%
%
/m  { moveto  } B              %-%
/rm { rmoveto } B              %-%
/l  { lineto  } B              %-%
/rl { rlineto } B              %-%
/K  { stroke  } B              %:%
%
/scmyk { setcmykcolor } B      %-%
/slw { setlinewidth } B        %-%
/dotted { [ 1 ] 0 setdash } D  %:%
%
/pt   {           } B          %-%
/cm   { 28.35 mul } B          %-%
/ivcm { 28.35 div } B          %-%
/in   { 72    mul } B          %:%
%
<<PSFunctions - bbox>>
%
%%EndProcSet:   Short_names 1.0 0
%
@

\begin{figure}[!h]
\begin{center}
\begin{tabular}{c@{}c}
\begin{minipage}[c]{0.65\linewidth}
\begin{center}
\hspace{1cm}
<<PSFunctions - bbox>>=
/bbox {      %-> llx lly urx ury bbox
  4 copy     %-> llx lly urx ury llx lly urx ury
  3 1 roll   %-> llx lly urx ury llx ury lly urx
  exch       %-> llx lly urx ury llx ury urx lly
  6 2 roll   %-> llx lly urx lly urx ury llx ury
  8 -2 roll  %-> urx lly urx ury llx ury llx lly
  m l l l    %->
  closepath  %->
} B          %:%
@ %def bbox
\end{center}
\end{minipage}
&
\fbox{
\begin{minipage}[c]{0.3\linewidth}
\begin{center}
\setlength{\unitlength}{0.5cm}
\begin{picture}(6,4.5)\small
 \put(0.5,0.5){\makebox(0,0){(llx,lly)}} \put(0.5,3.5){\makebox(0,0){(llx,ury)}}
 \put(5.5,0.5){\makebox(0,0){(urx,lly)}} \put(5.5,3.5){\makebox(0,0){(urx,ury)}}
 \thinlines
 \put(0.5,1){\vector(0,1){2}}  \put(2,3.5){\vector(1,0){2}}
 \put(5.5,3){\vector(0,-1){2}} \multiput(4,0.5)(-0.25,0){9}{\line(-1,0){0.1}}
\end{picture}
\vskip 1ex
\caption[PS functions: \texttt{bbox}]{\\[1ex]
\parbox{\linewidth}{\hfill\parbox{0.9\linewidth}{PS function [[bbox]], dashed line represents [[closepath]].}}
 } % caption
\end{center}
\end{minipage}
} %fbox
\\
\end{tabular}
\end{center}
\end{figure}

\subsctn{Defining PS constants}

<<POSTSCRIPT constants>>=
%%BeginProcSet: Constants 1.0 0
%
% Printing Offset
/OST 0.25 cm D  % offset defines non printable
/OSB 0.25 cm D  % paper area for pages (printer outlimits).
/OSL 0.25 cm D
/OSR 0.25 cm D
%
%%EndProcSet:   Constants 1.0 0
%
@

\subsctn{Page layout}

<<POSTSCRIPT layout>>=
%%BeginProcSet: Page_Layout 1.0 0
%
/Xmarg  5.0 cm D       % Starting Point (upper left corner)
/Ymarg  842 2 cm sub D
/Y Ymarg D
/PlotWidth  14 cm D    % Blocks Size
/Spacer   1.00 cm D    % BBox relative to dotplot
/BBoxX  PlotWidth D    % SBox relative to percent box
/BBoxY   14.00 cm D    % XBox relative to extra box
/SBoxX  PlotWidth D
/SBoxY    2.25 cm D
/XBoxX  PlotWidth D
/XBoxY    3.00 cm D
/WBox     0.50 cm D    % TagBox Size
/HWBox WBox 2 div    D
/Warw  WBox 0.75 mul D
/HWarw Warw 2 div    D
/htag   0 D
%
/TitleFont    { 24 /Times-Bold  } D
/SubTtFont    { 16 /Times-Roman } D
/ElmFont      { 12 FTLbsc mul /Times-Roman } D
/TagFont      { 14 GPLbsc mul /Times-Roman } D
/TagLabelFont { 16 /Times-Bold  } D
/TickFont     { 10 /Helvetica } D
%
/xBDspl  1.8 putExon add putExLbl add putGnLbl add D % 1.25
/xGLDspl 1.0 putExon add putExLbl add D              % 0.85
/xGDspl  0.75 putExon add putExLbl add D
/FBDspl 0.60 D % For example, for mRNA.
%
/vertical   { /htag 0 D } B
/horizontal { /htag 1 D } B
%
/FSF 4 D % Point size for Credits for A4
/CSF { pagedict begin pga4 pop end Dpage pop exch div mul } B
%
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS D } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS D } if
 LtM VDnOS lt { /LtM VDnOS D } if
 RtM VUpOS lt { /RtM VUpOS D } if
 } {
  UpM VUpOS lt { /UpM VUpOS D } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS D } if
  LtM HLtOS lt { /LtM HLtOS D } if
  RtM HRtOS lt { /RtM HRtOS D } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } D
% Defining starting point on page.
/XORI LtM D
/YORI UpM D
%
%%EndProcSet:   Page_Layout 1.0 0
%
@

\subsctn{Text related functions}

<<POSTSCRIPT text functions>>=
%%BeginProcSet: text_functions 1.0 0
%
<<PSFunctions - sfont>>
<<PSFunctions - tshow>>
<<PSFunctions - ctshow>>
<<PSFunctions - ltshow>>
<<PSFunctions - chrh>>
<<PSFunctions - strh>>
<<PSFunctions - ttxt>>
%
/Title { S 0 Xmarg Y TitleFont FGcolor tshow R /Y Y 0.75 cm sub D } B 
/SubTitle { S 0 Xmarg Y SubTtFont FGcolor tshow R /Y Y 2.5 cm sub D } B 
%
%%EndProcSet:   text_functions 1.0 0
%
@

<<PSFunctions - sfont>>=
/sfont {     %-> font_size font_name sfont
  findfont   %-> font_size <font>
  exch       %-> <font> font_size
  scalefont  %-> <scaled_font>
  setfont    %-> 
} B
@ %def sfont

<<PSFunctions - tshow>>=
/tshow {     %-> (string) angle x y font_def c m y k tshow
  S          %->
  scmyk      %-> (string) angle x y font_def
  sfont      %-> (string) angle x y
  m          %-> (string) angle
  rotate     %-> (string)
  show       %-> 
  R          %-> 
} B
@ %def tshow

<<PSFunctions - ctshow>>=
/ctshow {       %-> ctshow
  10 -1 roll    %->
  dup           %->
  11 1 roll     %->
  7 -2 roll     %->
  2 copy        %->
  9 2 roll      %->
  S             %->
    sfont       %->
    stringwidth %->
    pop         %->
  R             %->
  2 div         %->
  htag 1 eq {   %->
    9 -1 roll   %->
    exch        %->
    sub         %->
    8 1 roll    %->
  } {           %->
    8 -1 roll   %->
    exch        %->
    sub         %->
    7 1 roll    %->
  } ifelse      %->
  tshow         %->
} B
@ %def ctshow

<<PSFunctions - ltshow>>=
/ltshow {       %->
  10 -1 roll    %->
  dup           %->
  11 1 roll     %->
  7 -2 roll     %->
  2 copy        %->
  9 2 roll      %->
  S             %->
    sfont       %->
    stringwidth %->
    pop         %->
  R             %->
  htag 1 eq {   %->
    9 -1 roll   %->
    exch        %->
    sub         %->
    8 1 roll    %->
  } {           %->
    8 -1 roll   %->
    exch        %->
    sub         %->
    7 1 roll    %->
  } ifelse      %->
  tshow         %->
} B
@ %def ltshow

<<PSFunctions - chrh>>=
/chrh {            %->
  S                %->
    newpath        %->
    0 0 m          %->
    false charpath %->
    flattenpath    %->
    pathbbox       %->
    exch           %->
    pop            %->
    3 -1 roll      %->
    pop            %->
  R                %->
} B
@ %def chrh

<<PSFunctions - strh>>=
/strh {         %->
  2 dict begin  %->
    /lly 0.0 D  %->
    /ury 0.0 D  %->
    {     	    %->
      ( )       %->
      dup       %->
      0    	    %->
      4 -1 roll %->
      put       %->
      chrh     	%->
      dup       %->
      ury gt {  %->
        /ury X  %->
      } {       %->
        pop     %->
      } ifelse  %->
      dup       %->
      lly lt {  %->
        /lly X  %->
      } {       %->
        pop     %->
      } ifelse  %->
    } forall    %->
    ury    	    %->
  end           %->
} B
@ %def strh

<<PSFunctions - ttxt>>=
% X Y angle string valign halign fnt color ttxt
 % valign : tv (top)  cv (middle) bv (bottom)
 % halign : lh (left) ch (center) rh (right)
/ttxt {             %->
  S                 %->
    scmyk           %->
    sfont           %->
    8 dict begin    %->
      /h X          %->
      /v X          %->
      /lbl X        %->
      /angle X      %->
      /y X          %->
      /x X          %->
      /hs           %->
        lbl         %->
        stringwidth %->
        pop         %->
        neg         %->
        D           %->
      /vs           %->
        lbl         %->
        strh        %->
        neg         %->
        D           %->
      x y T         %->
      angle rotate  %->
      h (rh) eq {   %->
        hs          %->
      } {           %->
        h (ch) eq { %->
          hs 2 div  %->
        } {         %->
          0         %->
        } ifelse    %->
      } ifelse      %->
      v (tv) eq {   %->
        vs          %->
      } {           %->
        v (cv) eq { %->
          vs 2 div  %->
        } {         %->
          0         %->
        } ifelse    %->
      } ifelse      %->
      m             %->
      lbl show      %->
    end             %->
  R                 %->
} B
@ %def ttxt

\subsctn{The APLOT dictionary}

<<POSTSCRIPT aplotdict>>=
%
%%BeginProcSet: aplotdict 1.0 0
%
/aplot 120 dict D aplot begin
  <<PSFunctions - min max>>
  <<PSFunctions - Xscm Xscme>>
  <<PSFunctions - Yscm Yscme>>
  <<PSFunctions - fmt flt>>
  <<PSFunctions - line>>
  <<PSFunctions - uline>>
  <<PSFunctions - ZoomTicks>>
  <<PSFunctions - Line>>
  <<PSFunctions - Xline>>
  <<PSFunctions - Bline>>
  <<PSFunctions - Bsquare>>
  <<PSFunctions - Msquare>>
  <<PSFunctions - Mcircle>>
  <<PSFunctions - Join>>
  <<PSFunctions - Arrow>>
  <<PSFunctions - FBox>>
  <<PSFunctions - FTalgn>>
  <<PSFunctions - GPalgn>>
  <<PSFunctions - Box>>
  <<PSFunctions - GDmore>>
  <<PSFunctions - BDmore>>
  <<PSFunctions - GnBanner>>
  <<PSFunctions - SbBanner>>
  <<PSFunctions - Banner>>
  %
  /tckdict 15 dict D tckdict begin
    <<PSFunctions - mkmxt>>
    <<PSFunctions - mwmod>>
    <<PSFunctions - isltone>>
  end % tckdict
  %
  <<PSFunctions - htick>>
  <<PSFunctions - vtick>>
  <<PSFunctions - nucltick>>
  <<PSFunctions - pctmarks>>
  <<PSFunctions - beginfunct>>
  <<PSFunctions - endfunct>>
end % aplot dict
%
%%EndProcSet:   aplotdict 1.0 0
%
@


<<PSFunctions - min max>>=
/min {  %->
  2 copy  %->
  gt {  %->
    exch  %->
  } if  %->
  pop  %->
} B   %->
/max {  %->
  2 copy  %->
  lt {  %->
    exch  %->
  } if  %->
  pop  %->
} B
@  %def min max

<<PSFunctions - Xscm Xscme>>=
/Xscm {  %->
  Xscale mul  %->
} B  %->
/Xscme {  %->
  Xscm exch  %->
} B
@  %def Xscm Xscme

<<PSFunctions - Yscm Yscme>>=
/Yscm {  %->
  Yscale mul  %->
} B  %->
/Yscme {  %->
  Yscm exch  %->
} B
@  %def Yscm Yscme

<<PSFunctions - fmt flt>>=
/fmt {  %->
  Yscme  %->
  Xscme  %->
  m  %->
} B  %->
/flt {  %->
  Yscme  %->
  Xscme  %->
  l  %->
} B
@  %def fmt flt

<<PSFunctions - line>>=
/line {  %->
  scmyk  %->
  slw  %->
  m  %->
  l  %->
  K  %->
} B
@  %def line

<<PSFunctions - uline>>=
/uline {  %->
  scmyk  %->
  slw  %->
  m  %->
  S  %->
    htag 1 eq {  %->
      0 -0.1 cm  %->
    } {  %->
      0.1 cm 0  %->
    } ifelse  %->
    rl  %->
    K  %->
  R  %->
  l  %->
  S  %->
    htag 1 eq {  %->
      0 -0.1 cm  %->
    } {  %->
      0.1 cm 0  %->
    } ifelse  %->
    rl  %->
    K  %->
  R  %->
  K  %->
} B
@  %def uline

<<PSFunctions - ZoomTicks>>=
/ZoomTicks {  %->
  /zmdict 3 dict D  %->
  zmdict begin  %->
    /r {  %->
      TxWB  %->
      BDspl  %->
      mul  %->
      Xscm  %->
    } D  %->
    /s {  %->
      TyWB  %->
      BDspl  %->
      mul  %->
      Yscm  %->
    } D  %->
    /corner {  %->
      S  %->
        10 -2 roll  %->
        m   %->
        2 {  %->
          rl  %->
          S  %->
            BGcolor scmyk  %->
            .4 slw  %->
            K  %->
          R  %->
          rl  %->
          S  %->
            FGcolor scmyk  %->
            2 slw  %->
            [1 3] 0 setdash  %->
            K  %->
          R  %->
        } repeat  %->
      R   %->
    } D  %->
    4 copy  %->
    3 1 roll  %->
    exch  %->
    0 s 0 s neg  %->
      r neg 0 r 0 corner  %->
    0 s neg 0 s  %->
      r 0 r neg 0 corner  %->
    0 s neg 0 s  %->
      r neg 0 r 0 corner  %->
    0 s 0 s neg  %->
      r 0 r neg 0 corner  %->
  end  %->
} D
@  %def ZoomTicks

<<PSFunctions - Line>>=
%%  x0 y0 x1 y1 lwidth lcolor Line
/Line {  %->
  S  %->
    9 5 roll   %->
    2 {  %->
      Yscm  %->
      4 1 roll  %->
      Xscm  %->
      4 1 roll  %->
    } repeat  %->
    9 4 roll  %->
    line  %->
  R  %->
} B
@  %def Line

<<PSFunctions - Xline>>=
/Xline {   %->
  S  %->
    3 1 roll  %->
    Xscme  %->
    Xscme  %->
    3 -1 roll  %->
    Yscm  %->
    xwdt sub  %->
    dup  %->
    3 1 roll  %->
    xwdt  %->
    9 -4 roll  %->
    line  %->
  R  %->
} B
@  %def Xline

<<PSFunctions - Bline>>=
%% lwidth lcolor bcol ori end Bline
/Bline {  %->
  S  %->
    htag 1 eq {  %->
      Xscme  %->
      Xscme  %->
      y0 Yscme  %->
      y1 Yscm  %->
      bbox  %->
    } {  %->
      Yscme  %->
      Yscme  %->
      X0 Xscm  %->
      3 1 roll  %->
      X1 Xscme  %->
      bbox  %->
    } ifelse  %->
    S  %->
      scmyk  %->
      fill   %->
    R  %->
    scmyk  %->
    slw  %->
    K  %->
  R  %->
} B
@  %def Bline

<<PSFunctions - Bsquare>>=
/Bsquare {  %->
  S  %->
    Yscme  %->
    Yscme  %->
    4 2 roll  %->
    Xscme  %->
    Xscme  %->
    4 1 roll  %->
    exch  %->
    bbox   %->
    S  %->
      scmyk  %->
      fill   %->
    R  %->
    scmyk  %->
    slw  %->
    K  %->
  R  %->
} B
@  %def Bsquare

<<PSFunctions - Msquare>>=
/Msquare {  %->
  S  %->
    Yscme  %->
    Yscme  %->
    4 2 roll  %->
    Xscme  %->
    Xscme  %->
    4 1 roll  %->
    exch  %->
    bbox  %->
    scmyk  %->
    slw  %->
    K  %->
  R  %->
} B
@  %def Msquare

<<PSFunctions - Mcircle>>=
/Mcircle {  %->
  S  %->
    Yscme  %->
    Xscme  %->
    3 -1 roll  %->
    Xscm  %->
    0 360 arc  %->
    closepath  %->
    scmyk  %->
    slw  %->
    K  %->
  R  %->
} B
@  %def Mcircle

<<PSFunctions - Join>>=
/Join {  %->
  S  %->
    2 copy  %->
    2 copy  %->
    pop  %->
    sub  %->
    2 div  %->
    add  %->
    exch  %->
    htag 1 eq {  %->
      y1 TyWB add  %->
      dup  %->
      dup  %->
      TyWB 0.75 mul  %->
      add  %->
      4 1 roll  %->
      5 1 roll  %->
    } {  %->
      X0 TxWB sub  %->
      dup  %->
      dup  %->
      TxWB 0.75 mul  %->
      sub  %->
      5 1 roll  %->
      6 1 roll  %->
      exch  %->
    } ifelse  %->
    3 {  %->
      Yscme  %->
      Xscme  %->
      6 2 roll  %->
    } repeat  %->
    m  %->
    l  %->
    l  %->
    0.25 slw  %->
    scmyk  %->
    K  %->
  R  %->
} B
@  %def Join

<<PSFunctions - Arrow>>=
/Arrow {  %->
  /acol
    [
      9 -4 roll
    ]
  D
  /acolor {
    acol
    aload
    pop
  } D
  S
    1 eq {
      exch
      /sn {
        1 mul
      } D
    } {
      /sn {
        1 neg
        mul
      } D
    } ifelse
    htag 1 eq {
      Xscm
      dup
      y1 Yscm
      HWBox add
      m
      HWarw
      sn
      HWarw
      rl
      0
      Warw neg
      rl
      HWarw neg
      sn
      HWarw
      rl
      closepath
      S
        acolor scmyk
        fill
      R
      y1 Yscm
      HWBox add
      m
      Xscm
      y1 Yscm
      HWBox add
      l
      acolor scmyk
      1 slw
      K
    } {
      Yscm
      dup
      X0 Xscm
      HWBox sub
      exch
      m
      HWarw neg
      HWarw
      sn
      rl
      Warw 0 rl
      HWarw neg
      HWarw neg
      sn
      rl
      closepath
      S
        acolor scmyk
        fill
      R
      X0 Xscm
      HWBox sub
      exch
      m
      Yscm
      X0 Xscm
      HWBox sub
      exch
      l
      acolor scmyk
      1 slw
      K
    } ifelse
  R
} B
@  %def Arrow

<<PSFunctions - FBox>>=
/FBox {  %->
  htag 1 eq {
    Xscme
    Xscme
    y1 Yscme
    y1
    TyWB
    FBDspl mul
    add
    Yscm
    bbox
  } {
    Yscme
    Yscme
    X0 Xscm
    3 1 roll
    X0
    TxWB
    FBDspl mul
    sub
    Xscme
    bbox
  } ifelse
  S
    scmyk
    fill
  R
  FGcolor scmyk
  1 slw
  K
} B
@  %def FBox

<<PSFunctions - FTalgn>>=
/FTalgn {  %->
  htag 1 eq {
    FTXangle 0 eq {
      (bv) (ch)
    } {
      (cv) (lh)
    } ifelse
  } {
    FTYangle 0 eq {
      (cv) (rh)
    } {
      (bv) (rh)
    } ifelse
  } ifelse
} B
@  %def FTalgn

<<PSFunctions - GPalgn>>=
/GPalgn {  %->
  htag 1 eq {
    GPXangle 0 eq {
      (bv) (ch)
    } {
      (cv) (lh)
    } ifelse
  } {
    GPYangle 0 eq {
      (cv) (rh)
    } {
      (bv) (rh)
    } ifelse
  } ifelse
} B
@  %def GPalgn

<<PSFunctions - Box>>=
/Box {  %->
  2 copy
  2 copy
  pop
  sub
  2 div
  add
  7 1 roll
  S
    htag 1 eq {
      Xscme
      Xscme
      y1 Yscme
      y1
      TyWB add
      Yscm
      bbox
    } {
      Yscme
      Yscme
      X0 Xscm
      3 1 roll
      X0
      TxWB sub
      Xscme
      bbox
    } ifelse
    S
      scmyk
      fill
    R
    FGcolor scmyk
    1 slw
    K
    htag 1 eq {
      Xscm
      y1
      TyWB 1.75 mul
      add
      Yscm
      FTXangle
    } {
      Yscm
      X0
      TxWB 1.75 mul
      sub
      Xscme
      FTYangle
    } ifelse
    6 -1 roll
    FTalgn
    8 -2 roll
    FGcolor
    ttxt
  R
} B
@  %def Box

<<PSFunctions - GDmore>>=
/GDmore {  %->
  MxFtLBL
  S
    ElmFont sfont
    (M) stringwidth
    pop
  R
  mul
  htag 1 eq {
    FTXangle sin
  } {
    FTYangle cos
  } ifelse
  abs
  mul
  ivcm
  add
} B
@  %def GDmore

<<PSFunctions - BDmore>>=
/BDmore {  %->
  MxGpLBL
  S
    TagFont sfont
    (M) stringwidth
    pop
  R
  mul
  htag 1 eq {
    GPXangle sin
  } {
    GPYangle cos
  } ifelse
  abs
  mul
  ivcm
  add
} B
@  %def BDmore

<<PSFunctions - GnBanner>>=
/GnBanner{  %->
  S
    1 eq {
      2 copy
      htag 1 eq {
        Xscme
        Xscme
        y1
        TyWB GDspl mul
        add
        dup
        Yscme
        Yscm
        3 1 roll
      } {
        Yscme
        Yscme
        X0
        TxWB GDspl mul
        sub
        dup
        Xscme
        Xscme
        4 1 roll
        exch
      } ifelse
      0.5 FGcolor uline
    } if
    2 copy
    pop
    sub
    2 div
    add
    htag 1 eq {
      Xscm
      y1
      TyWB GLDspl mul
      add
      Yscm
      GPXangle
    } {
      Yscm
      X0
      TxWB GLDspl mul
      sub
      Xscme
      GPYangle
    } ifelse
    6 -1 roll
    GPalgn
    8 -2 roll
    FGcolor
    ttxt
  R
} B
@  %def GnBanner

<<PSFunctions - SbBanner>>=
/SbBanner {  %->
  S
    htag 1 eq {
      0 X0
      X1 X0 sub
      2 div
      add
      Xscm
      y1
      TyWB
      GDspl
      mul
      add
      Yscm
    } {
      90 X0
      TxWB
      GDspl
      mul
      sub
      Xscm
      y0
      y1 y0 sub
      2 div
      add
      Yscm
    } ifelse
    5 -2 roll
    FGcolor
    ctshow
  R
} B
@  %def SbBanner

<<PSFunctions - Banner>>=
/Banner {  %->
  S
    htag 1 eq {
      0  X0
      X1 X0 sub
      2 div
      add
      Xscm
      y1
      TyWB
      BDspl
      mul
      add
      Yscm
    } {
      90 X0
      TxWB
      BDspl
      mul
      sub
      Xscm
      y0
      y1 y0 sub
      2 div
      add
      Yscm
    } ifelse
    5 -2 roll
    FGcolor
    ctshow
  R
} B
@  %def Banner

% tckdict begin
<<PSFunctions - mkmxt>>=
/mkmxt {  %->
  dup 0 lt {
    neg
  } if
  dup 10 lt {
    10 mul
    log
    round
    10 exch
    exp
    cvi
  } {
    log
    round
    10 exch
    exp
    cvi
  } ifelse
} D
@  %def mkmxt

<<PSFunctions - mwmod>>=
/nwmod {  %->
  dup 1 le {
    100 mul
    cvi
    exch
    100 mul
    cvi
    exch
    mod
    100 div
  } {
    exch
    dup
    1 le {
      100 mul
      cvi
      exch
      100 mul
      cvi
      mod
      100 div
    } {
      cvi
      exch
      cvi
      mod
    } ifelse
  } ifelse
} D
@  %def mwmod

<<PSFunctions - isltone>>=
/isltone {  %->
  dup  %->
  1 lt {  %->
    100 mul  %->
    cvi  %->
    100 div  %->
  } if  %->
} D
@  %def isltone

<<PSFunctions - htick>>=
% mxt mnt xp yp ori end htick
/htick {   %->
  S tckdict begin horizontal 
    /yp exch Yscm D /xp exch Xscm D /xend X /xori X
    /nmnt exch cvi D /nmxt exch cvi D
    /mxt exch dup 0 lt { pop xend xori sub mkmxt } if D
    /mnt exch dup 0 lt { pop mxt nmnt div } if D
    /lori xori dup mnt nwmod sub mnt add D
    /lend xend dup mnt nwmod sub mnt sub D
    xp yp T
    lori mnt lend {
      isltone dup dup xori gt exch xend lt and {
        dup Xscm 0 m dup dup Xscme
        mxt nwmod 0 eq { 7.5 } { 4 } ifelse neg l
        1 slw FGcolor scmyk K
        GridON 1 eq {
          S 0 y0 Yscm neg T dup Xscm dup y0 Yscm m y1 Yscm l
          0.1 slw verylightgrey scmyk K R
          } if
        dup mxt nwmod 0 eq {
          dup xend mnt sub exch ge {
            dup dup 1 ge { cvi } if
            10 string cvs 0 3 -1 roll Xscm -18 TickFont FGcolor ctshow
            } if
          } {
            pop
          } ifelse
        } if
      } for
    xori Xscm dup 0 m 7.5 neg l 2 slw FGcolor scmyk K
    xori 10 string cvs 0 xori Xscm ZoomON 1 eq { 4 sub } if
    -18 TickFont FGcolor ZoomON 0 eq { ctshow } { ltshow } ifelse
    xend Xscm dup 0 m 7.5 neg l 2 slw FGcolor scmyk K
    xend 10 string cvs 0 xend Xscm ZoomON 1 eq { 4 add } if
    -18 TickFont FGcolor ZoomON 0 eq { ctshow } { tshow } ifelse
  end R
} D
@  %def htick

<<PSFunctions - vtick>>=
/vtick {  %->
  S tckdict begin vertical
    /yp exch Yscm D /xp exch Xscm D /xend X /xori X
    /nmnt exch cvi D /nmxt exch cvi D
    /mxt exch dup 0 lt { pop xend xori sub mkmxt } if D
    /mnt exch dup 0 lt { pop mxt nmnt div } if D
    /lori xori dup mnt nwmod sub mnt add D
    /lend xend dup mnt nwmod sub mnt sub D
    xp yp T
    lori mnt lend {
      isltone dup dup xori gt exch xend lt and {
        dup Yscm 0 exch m dup dup Yscme
        mxt nwmod 0 eq { 7.5 } { 4 } ifelse exch l
        1 slw FGcolor scmyk K
        GridON 1 eq {
          S X0 Xscm 0 T dup Yscm dup X0 neg Xscme m
          X1 neg Xscme l 0.1 slw verylightgrey scmyk K R
          } if
        dup 0 eq {
          S dup dup X0 Xscme Yscm m X1 neg Xscme Yscm l
          0.1 slw FGcolor scmyk K R
          } if
        dup mxt nwmod 0 eq {
          dup xend mnt sub exch ge {
            dup dup 1 ge { cvi } if
            10 string cvs 0 10 4 -1 roll Yscm 2.5 sub TickFont FGcolor tshow
            } if
          } {
            pop
          } ifelse
        } if
      } for
    7.5 xori Yscm dup 0 exch m l 2 slw FGcolor scmyk K
    xori 10 string cvs 0 10 xori Yscm
    ZoomON 0 eq { 2.5 sub } { 2.5 add } ifelse
    TickFont FGcolor tshow 7.5 xend Yscm dup 0 exch m l
    2 slw FGcolor scmyk K xend 10 string cvs 0 10 xend Yscm
    ZoomON 0 eq { 2.5 sub } { 2.5 add } ifelse
    TickFont FGcolor tshow end
  R
} D
@  %def vtick

<<PSFunctions - nucltick>>=
/nucltick {  %->
  tickmn  %->
  tickmx  %->
  maxtck  %->
  mintck  %->
  X0  %->
  X1  %->
  0  %->
  y0  %->
  htick  %->
} D
@  %def nucltick

<<PSFunctions - pctmarks>>=
/pctmarks {  %->
  S  %->
    y0 10 y1 {  %->
      Yscm  %->
      dup  %->
      X0 Xscm  %->
      X1 Xscm  %->
      3 1 roll  %->
      4 1 roll  %->
      0.5  %->
      FGcolor  %->
      line  %->
    } for  %->
  R  %->
} B
@  %def pctmarks

<<PSFunctions - beginfunct>>=
/beginfunct {  %->
      R  %->
      S  %->
        3 dict begin  %->
          /maxx  %->
            exch  %->
            ceiling  %->
          D  %->
          /minx  %->
            exch  %->
            floor  %->
          D  %->
          /Yscale  %->
            XBoxY  %->
            maxx minx sub  %->
            div  %->
          D  %->
          minx 0 lt {  %->
            0 minx neg Yscm T  %->
          } if  %->
          S  %->
            XBYtickflg 1 eq {  %->
              -1 -1  %->
              xtrmxt xtrmnt  %->
              minx maxx  %->
              X1 0  %->
              vtick  %->
              S  %->
                X0 Xscm  %->
                0  %->
                m  %->
                X1 Xscm  %->
                0  %->
                l  %->
                dotted  %->
                FGcolor scmyk  %->
                K  %->
              R  %->
            } if  %->
          R  %->
} D
@  %def beginfunct

<<PSFunctions - endfunct>>=
/endfunct {  %->
        end  %->
      R  %->
} D
@  %def endfunct


\subsctn{Main functions definition}

<<POSTSCRIPT main function calls>>=
%%BeginProcSet: main_function_calls 1.0 0
%
<<PSFunctions - scredits>>
%
<<PSFunctions - estlbl>>
%
<<PSFunctions - GsclonX>>
% ALIGNMENT PLOT BOX
<<PSFunctions - begindata>>
<<PSFunctions - enddata>>
% MATCHES PERCENT BOX
<<PSFunctions - beginmatches>>
<<PSFunctions - endmatches>>
% EXTRA FEATURES BOX
<<PSFunctions - beginextra>>
<<PSFunctions - endextra>>
%
%%EndProcSet:   main_function_calls 1.0 0
%
@

<<PSFunctions - scredits>>=
/s_credits {  %->
  S  %->
    1 dict begin  %->
      /fs_cd FSF D  %->
      pagedict begin  %->
        pga4 pop  %->
      end  %->
      1 cm sub  %->
      DnM T  %->
      0 0 0  
(This plot has been obtained using GFF2APLOT.\ 
 The most recent version of GFF2APLOT is freely\ 
 available at \042http:\/\/www1.imim.es/software/gfftools/APLOT.html\042.\ 
 Copyright      1999 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO)
      (cv) (rh)  %->
      fs_cd  %->
      /Times-Roman  %->
      FGcolor  %->
      ttxt  %->
      S  %->
        fs_cd  %->
        /Times-Roman sfont  %->
        (   1999 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO)  %->
        stringwidth  %->
        pop  %->
        neg  %->
      R  %->
      0 0  %->
      (\343)  %->
      (cv) (ch)  %->
      fs_cd  %->
      /Symbol  %->
      FGcolor  %->
      ttxt  %->
    end  %->
  R
} B
@ %def s_credits

<<PSFunctions - estlbl>>=
/estlbl {  %->
  S  %->
    3 dict begin  %->
      /lbl X  %->
      /ypos X  %->
      /xpos X  %->
      horizontal  %->
      0 Xlwdt 4 div neg T  %->
      lbl 0  %->
      xpos Xscm  %->
      ypos Yscm  %->
      5 /Helvetica  %->
      black  %->
      ctshow  %->
      vertical  %->
    end  %->
  R  %->
} B
@ %def estlbl

<<PSFunctions - GsclonX>>=
/GsclonX {  %->
  /Y  %->
    exch  %->
    Y  %->
    Spacer sub  %->
    exch  %->
    sub  %->
  D  %->
  Xmarg Y T  %->
  axesp 0 eq {  %->
    /Xscale {  %->
      BBoxX  %->
      X1 X0 sub  %->
      Y1 Y0 sub  %->
      max  %->
      div  %->
    } D  %->
  } {  %->
    /Xscale {  %->
      BBoxX  %->
      X1 X0 sub  %->
      div  %->
    } D  %->
  } ifelse  %->
} B
@ %def GsclonX

<<PSFunctions - begindata>>=
/begindata {  %->
  aplot begin  %->
    S  %->
      /y1 Y1 D  %->
      /y0 Y0 D  %->
      BBoxY GsclonX  %->
      axesp 0 eq {  %->
        /Yscale Xscale D  %->
      } {  %->
        /Yscale {  %->
          BBoxY  %->
          y1 y0 sub  %->
          div  %->
        } D  %->
      } ifelse  %->
      /TxWB {  %->
        WBox Xscale div  %->
      } D  %->
      /TyWB {  %->
        WBox Yscale div  %->
      } D  %->
      /GDspl {  %->
        xGDspl  %->
        GDmore  %->
      } D  %->
      /GLDspl {  %->
        xGLDspl  %->
        GDmore  %->
      } D  %->
      /BDspl {  %->
        xBDspl  %->
        GDmore  %->
        BDmore  %->
        } D  %->
      X0 Xscm neg  %->
      y0 Yscm neg  %->
      T  %->
      S  %->
        X0 Xscm  %->
        y0 Yscm  %->
        X1 Xscm  %->
        y1 Yscm  %->
        bbox  %->
        BBoxcol scmyk  %->
        fill  %->
      R  %->
      S  %->
        X0 Xscm  %->
        y0 Yscm  %->
        X1 Xscm  %->
        y1 Yscm  %->
        ZoomON 1 eq {  %->
          4 copy  %->
          ZoomTicks  %->
        } if  %->
        bbox  %->
        2 slw  %->
        FGcolor scmyk  %->
        K  %->
      R  %->
      S  %->
        BBXtickflg 1 eq {  %->
          nucltick  %->
          /Spacer 1 cm D  %->
        } {  %->
          /Spacer 0.5 cm D  %->
        } ifelse  %->
        BBYtickflg 1 eq {  %->
          tickmn tickmx  %->
          maxtck mintck  %->
          y0 y1 X1 0  %->
          vtick  %->
        } if  %->
      R  %->
      newpath  %->
} D
@ %def begindata

<<PSFunctions - enddata>>=
/enddata {  %->
    R  %->
    /GDspl  xGDspl  D  %->
    /GLDspl xGLDspl D  %->
    /BDspl  xBDspl  D  %->
  end  %->
} D
@ %def enddata

<<PSFunctions - beginmatches>>=
/beginmatches {  %->
  aplot begin   %->
    /ZoomON 0 D  %->
    S  %->
      /y1 X  %->
      /y0 X  %->
      SBoxY GsclonX  %->
      /Yscale  %->
        SBoxY  %->
        y1 y0 sub  %->
        div  %->
      D  %->
      X0 Xscm neg  %->
      y0 Yscm neg  %->
      T  %->
      S  %->
        X0 Xscm  %->
        y0 Yscm  %->
        X1 Xscm  %->
        y1 Yscm  %->
        bbox  %->
        S  %->
          S  %->
            SBoxcol scmyk  %->
            fill  %->
          R  %->
          S  %->
            SBoxLab  %->
            TagLabelFont  %->
            Banner  %->
            SBoxSLab  %->
            TagFont  %->
            SbBanner  %->
            SBXtickflg 1 eq {  %->
              nucltick  %->
              /Spacer 1 cm D  %->
            } {  %->
              /Spacer 0.5 cm D  %->
            } ifelse  %->
          R  %->
          S  %->
            SBYtickflg 1 eq {  %->
              -1 -1 pctmxt pctmnt  %->
              y0 y1 X1 0  %->
              vtick  %->
            } if  %->
          R  %->
          S  %->
            X0 Xscm  %->
            y0 Yscm  %->
            X1 Xscm  %->
            y1 Yscm  %->
            bbox  %->
            2 slw  %->
            FGcolor scmyk  %->
            K  %->
          R  %->
        R  %->
        clip  %->
        newpath  %->
} D
@ %def beginmatches

<<PSFunctions - endmatches>>=
/endmatches {  %->
      R  %->
    R  %->
  end  %->
} D
@ %def endmatches

<<PSFunctions - beginextra>>=
/beginextra {  %->
  aplot begin  %->
    S  %->
      /nlines X  %->
      /y0 0 D  %->
      XBoxY GsclonX  %->
      /Yscale  %->
        XBoxY  %->
        nlines 1 add  %->
        div  %->
      D  %->
      /Xlwdt  %->
        Yscale 0.75 mul  %->
      D   %->
      /xwdt  %->
        Yscale 2 div  %->
      D  %->
      /y1  %->
        XBoxY Yscale div  %->
      D  %->
      X0 Xscm neg 0 T  %->
      S  %->
        X0 Xscm  %->
        y0 Yscm  %->
        X1 Xscm  %->
        y1 Yscm  %->
        bbox  %->
        S  %->
          XBoxcol scmyk  %->
          fill  %->
        R  %->
        S  %->
          XBoxLab  %->
          TagLabelFont  %->
          Banner  %->
          XBoxSLab  %->
          TagFont  %->
          SbBanner  %->
          XBXtickflg 1 eq {  %->
            nucltick  %->
          } if  %->
        R  %->
        newpath  %->
} D
@ %def beginextra

<<PSFunctions - endextra>>=
/endextra {  %->
        /Yscale  %->
          XBoxY  %->
          nlines 1 add  %->
          div  %->
        D  %->
        X0 Xscm  %->
        y0 Yscm  %->
        X1 Xscm  %->
        y1 Yscm  %->
        bbox  %->
        2 slw  %->
        FGcolor scmyk  %->
        K  %->
      R  %->
    R  %->
  end  %->
} D
@ %def endextra


\newpage

\sctn{Reporting Program Execution} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Signal trapping}

In this version of {\prog} we are trapping signals, to exit from this program but reporting that was a user action, not a program error. We will close '[[LOGFILE]]' if opened. 

<<Trapping signals>>=
$SIG{HUP}  = \&trap_signals_prog;
$SIG{ABRT} = \&trap_signals;
$SIG{INT}  = \&trap_signals;
$SIG{QUIT} = \&trap_signals;
$SIG{TERM} = \&trap_signals;
$SIG{KILL} = \&trap_signals;
$SIG{CHLD} = 'IGNORE';
@ 

<<Common Routines>>=
sub trap_signals() {
    &prt_to_logfile($Messages{'USER_HALT'});
    &close_logfile();
    die($Messages{'USER_HALT'});
} # trap_signals
@ %def &trap_signals

<<Common Routines>>=
sub trap_signals_prog() {
    &prt_to_logfile($Messages{'PROCESS_HALT'});
    &close_logfile();
    die($Messages{'PROCESS_HALT'});
} # trap_signals_prog
@ %def &trap_signals_prog

<<warnings - input/output>>=
USER_HALT =>
  $spl.$Warn."$PROGRAM has been stopped by user !!!\n".
  $spl.$Warn."---------- Exiting NOW !!! ----------\n".$spl,
PROCESS_HALT =>
  $spl.$Warn."------- $PROGRAM is down !!! -------\n".
  $spl.$Warn."---------- Exiting NOW !!! ----------\n".$spl,
@

\subsctn{Dumping complex data structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them. We include also a command-line switch to enable this feature, but it requires a log file definition with '[[-V]]' option.

<<Use Modules>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 

<<perl requires help>>=
"Data::Dumper" - pretty printing data structures for debugging (*).
@

<<command-line options>>=
"debug"  => \$Debug, # Dumps Vars -> LogFile
@ 
<<command-line help>>=
--debug
    Reporting variable contents when testing the program.
    Requires that log report file option was also activated.
@

\subsctn{Reporting program status}

\label{sec:MessagesHsh}

<<Global Vars>>=
# Program status strings.
%Messages = (
    # ERROR MESSAGES
    <<warnings - input/output>>
    <<warnings - parsing command-line options>>
    <<warnings - parsing custom files>>
    <<warnings - parsing GFF files>>
    # WORKING MESSAGES
    <<messages - input/output>>
    <<messages - parsing command-line options>>
    <<messages - parsing custom files>>
    <<messages - parsing GFF files>>
    <<messages - sorting GFF data>>
   ); # %Messages
@

\subsubsctn{Reporting errors and warnings}

<<Global Constants>>=
my $Error = "\<\<\<  ERROR  \>\>\> ";
my $Warn  = "\<\<\< WARNING \>\>\> ";
my $spl   = "\<\<\<\-\-\-\-\-\-\-\-\-\>\>\>\n";
my $spw   = "\<\<\<         \>\>\> ";
@ 

<<Common Routines>>=
sub warn() {
    my $type = shift @_;
    my $screen_flg = shift @_;
    my $comment = sprintf($Messages{$type}, @_);
    # ALWAYS to STDERR if $screen_flg==$T unless $Quiet==$T
    $screen_flg && ($Quiet || print STDERR $comment); 
    &prt_to_logfile($comment);
} # warn
@ %def &warn

<<Common Routines>>=
sub prt_to_logfile() { $LogFile && (print LOGFILE $_[0]) }
sub prt_to_stderr()  { $Verbose && ($Quiet || print STDERR $_[0]) }
@ %def &prt_to_logfile &prt_to_stderr

\subsctn{Reporting messages}

<<Global Constants>>=
my $line = ("#" x 80)."\n";
my $sp = "###\n";
@ 

<<Common Routines>>=
sub report() {
    my $type = shift @_;
    my $comment = sprintf($Messages{$type},@_);
    &prt_to_stderr($comment);
    &prt_to_logfile($comment);
} # report
@ %def &report

<<Common Routines>>=
sub header() {
    my $comment = $line;
    foreach my $ln (@_) { 
        $comment .= "### ".&fill_mid("$ln",72," ")." ###\n";
        };
    $comment .= $line;
    &prt_to_stderr($comment);
    &prt_to_logfile($comment);
} # header
sub footer() {
    $total_time = &timing($F);
    &header(@_,$total_time);
    &prt_to_stderr("###\n");
    &prt_to_logfile("###\n");
} # footer
@ %def &header &footer

\subsctn{Timing procedures}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules>>=
use Benchmark;
  <<Timer ON>>
@ 

<<perl requires help>>=
"Benchmark" - checking and comparing running times of code.
@

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common Routines>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ %def &timing

We also set here the date when the script is running and who is the user running it.

<<Global Vars>>=
my $total_time = 0;
my $DATE = localtime;
my $USER = defined($ENV{USER}) ? $ENV{USER} : 'Child Process';
@ 

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\appendix

\newpage

\sctn{Supplementary scripts} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{[[parameter2tex.pl]]: formatting variable definitions for manual.}

The main reason for writing this script was the idea to keep sincronized any changes in the program with the \textbf{``User's Manual''}. The main problem we had to face was to keep updated any change or include any new definition of customization variables and command-line options. The way we are trying to solve is to have each variable description in a code chunk that follows each variable definition on the program in a structured record format that will be easy to parse later and to convert it into {\LaTeX} files. Those {\LaTeX} files are going to be read by the main document of the manual. This solution also reduces redundancy and keeps variable definition free of formatting changes that can be applied here, when translating those definitions into {\LaTeX}. Automatizing the whole process avoids not only to miss features in the manual but also human errors when updating and formatting that information (by keeping all the relevant information close to the related code).%'

\subsubsctn{Extracting and running [[parameter2tex.pl]]}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"parameter2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/parameter2tex.pl ;
chmod a+x $BIN/parameter2tex.pl ;
#
@ 

<<tangling complementary LaTeX files for manual>>=
# Preparing variables and options descriptions for User's manual #'
echo "Extracting VARS/OPTIONS definitions for LaTeX files..." 1>&2 ;
notangle -R"parameter2tex - LaTeX" $WORK/$nwfile.nw | \
         cpif $DOCS/tabledefs.tex ;
echo "Extracting COMMAND-LINE options for LaTeX files..." 1>&2 ;
notangle -R"DESC command-line options" $WORK/$nwfile.nw | \
         $BIN/parameter2tex.pl -c -o $DOCS/tables/AplotCLopts.tex -- - ;
echo "Extracting CUSTOM-FILE variables for LaTeX files..." 1>&2 ;
notangle -R"DESC custom file variables" $WORK/$nwfile.nw | \
         $BIN/parameter2tex.pl -v -o $DOCS/tables/AplotCFvars.tex -- - ;
#
@ 

<<HIDE: new LaTeX commands>>=
\input tabledefs.tex
@

\subsubsctn{[[parameter2tex.pl]] implementation}

<<parameter2tex.pl>>=
<<PERL shebang>>
# 
# parameter2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
use Getopt::Std;
use File::Basename;
#
<<parameter2tex - global vars>>
#
# MAIN
&getcmdlineopts;
&$parseinput;
exit(0);
#
# SUBS
<<parameter2tex - functions>>
<<Common Routines: text fill>>
@
 
By default, if no command-line option is given, input records must be in custom-file vars record format:

<<parameter2tex - global vars>>=
my $USAGE = << "+++EOU+++";
################################################################################
###
#### $0
###
####\t\t@{[ (localtime)." : ".(defined($ENV{USER})?$ENV{USER}:"nouser") ]} 
###
#### USAGE:
###
###    parameter2tex [options] -o <output_file> -- <input_files>
###
###    -h              prints this help.
###    -v              process custom-file vars input.
###    -c              process command-line options input.
###    -o <path+file>  output base name for the whole path/file (required).
###
################################################################################
+++EOU+++
#
my %VARS = ();
my ($base_dir,$base_file,$base_ext) = ('./','out','.tex');
my $parseinput = \&parseVars;
@

We use [[Getopt::Std]] because we only need to set two boolean variables that define which main parsing function must be applied to input records (remember that [[fileparse]] function returns file name, leading path and file extension, in that order):

<<parameter2tex - functions>>=
sub getcmdlineopts() {
    our($opt_v,$opt_c,$opt_o,$opt_h);
    getopts('vco:h');
    $opt_h && do {
        print STDERR $USAGE;
        exit(1);
    }; # $opt_h
    $opt_v && ($parseinput = \&parseVars);
    $opt_c && ($parseinput = \&parseOpts);
    ($base_file,$base_dir,$base_ext) = fileparse($opt_o, '\..*');
    # print STDERR "::$base_dir\::$base_file\::$base_ext\::\n";
    (-d $base_dir) ||
        die("##\n## ERROR ## OUTPUT DIRECTORY DOES NOT EXIST... $!\n##\n"); 
    $base_file eq '' && ($base_file = 'out');
	$base_ext eq '' && ($base_ext = '.tex');
    #
    @files = ();
    scalar(@ARGV) > 0 && do {
        foreach my $fl (@ARGV) {
            $fl eq '-' && do {
                push @files, "-";
                next;
            };
            -e $fl || do {
                print STDERR "### FILE $fl DOES NOT EXIST, SKIPPING... $!\n";
                next;
            };
            push @files, $fl;
		}; # foreach $fl
        return;
    }; # scalar(@ARGV) > 0
    push @files, "-";
} # getcmdlineopts
@

<<parameter2tex - global vars>>=
my @files;
@ 

\subsubsctn{Common functions between variable and option processing}

This function is common for both, customization variables and command-line options definitions, because record structure is similar. Record separator is '[[###EOR###]]' and field separator is '[[\n]]' (except for last field which starts when '[[LDE:]]' tag appears and ends when the record does). '[[ORD:]]' must be the first field on each record, 

<<parameter2tex - functions>>=
sub parseinput() {
    print STDERR "### Parsing input records...\n";
    my $char;
    my $c = 0;
    my $extra = 1000;
    foreach my $fl (@files) {
        my ($a,$b,$lstelm,$order);
        open(IFILE,"< $fl");
        $lstelm = 0;
        $order = undef;
        while (<IFILE>) {
            next if /^\s*$/o;
            chomp;
            $_ =~ s/\s*$//o;
            $char = '.';
            <<parameter2tex - loading Long DEscription>>
            <<parameter2tex - loading other fields>>
		} continue {
            print STDERR $char; # &counter(++$c,$char);
        }; # while read $fl
        close(IFILE);
    }; # foreach $fl
    print STDERR "\#\n";        # &counter_end($c,$char);
} # parseinput
@ 

<<parameter2tex - loading Long DEscription>>=
$lstelm && do {
    $_ =~ /^\#\#\#EOR\#\#\#/o && do {
        $lstelm = 0;
        $order = undef;
        print STDERR "\#\n";
        $char = ''; # $char = '#';
        next;
    }; # ###EOR###
    $_ =~ s/^\s*//o;
    $char = ':'; 
    $VARS{$order}{LDE} .= " $_";
    next;
};
$_ =~ /^LDE/o && do {
    $_ =~ /JOIN-NEXT\s*$/o && ($VARS{$order}{JOIN} = 1);
    $lstelm = 1;
    next;
}; # LDE
$_ =~ /^SDE/o && do {
    $_ =~ /JOIN-NEXT\s*$/o && ($VARS{$order}{JOIN_SHORT} = 1);
}; # SDE
@ 

[[$VARS{$order}{JOIN}]] takes care if the program must concatenate variable/option items that share a common description.

<<parameter2tex - loading other fields>>=
($a,$b) = split /:\s*/o, $_, 2;
defined($order) || do {
    CHECK: {
      $a =~ /^ORD/o && do {
          $order = (defined($b) && $b ne '') ? $b : ++$extra;
          $char = 'O';
          last CHECK;
      }; # ORD
      $order = ++$extra;
      $char = 'X';
    }; # CHECK
    $order = &fill_left($order,4,'0');
    %{ $VARS{$order} } = ();        
    $VARS{$order}{JOIN} = 0;
    $VARS{$order}{JOIN_SHORT} = 0;
    print STDERR &fill_left(++$c,3,'0')." ";
    next; 
}; # $order
(defined($b) && $b ne '') && do {
    $VARS{$order}{$a} = $b;
}; # $b
@

The following functions replace the special tags we use in the description fields to homogenize formats among option names, parameters and values.

<<parameter2tex - functions>>=
sub rep_varop()  { $_[0] =~ s/\[(.+?)\]/\\op\{$1\}/og;     return $_[0]; } 
# sub repq_varop() { $_[0] =~ s/\[(.+?)\]/\'\\op\{$1\}\'/og; return $_[0]; } 
sub repq_varop() { $_[0] =~ s/\[(.+?)\]/\\op\{$1\}/og;     return $_[0]; } 
@

<<parameter2tex - functions>>=
sub rep_param()  { $_[0] =~ s/<(.+?)>/\\pp\{$1\}/og;     return $_[0]; }
# sub repq_param() { $_[0] =~ s/<(.+?)>/\'\\pp\{$1\}\'/og; return $_[0]; }
sub repq_param() { $_[0] =~ s/<(.+?)>/\\pp\{$1\}/og;     return $_[0]; }
@

<<parameter2tex - functions>>=
sub rep_value()  { $_[0] =~ s/\|(.+?)\|/\\vp\{$1\}/og;     return $_[0]; }
# sub repq_value() { $_[0] =~ s/\|(.+?)\|/\'\\vp\{$1\}\'/og; return $_[0]; }
sub repq_value() { $_[0] =~ s/\|(.+?)\|/\\vp\{$1\}/og;     return $_[0]; }
@

<<parameter2tex - functions>>=
sub rep_chars()  { 
    $_[0] =~ s/\%\{/\[/og;  # to recover LaTeX []
    $_[0] =~ s/\%\}/\]/og;  # 
    $_[0] =~ s/\\n\\/\n/og; # to recover LaTeX newline
    return $_[0];
} # rep_chars
@

<<parameter2tex - functions>>=
sub tex_header() {
    my ($a,$b) = @_;
    $a =~ m{/([^/]*)$}o && ($a = $1);
    return "\%\n\% $a\n\%\n\% $b\n\%\n\%".
           ' $Id: gff2aplot.nw,v 1.24 2001-11-23 19:28:49 jabril Exp $ '.
           "\n\%\n"; 
} # tex_header
@

\subsubsctn{Parsing descriptions for customization variables}

Record tags available for customization vars definition file are: [[ORD]], [[SEC]], [[SUB]], [[OPT]], [[DEF]], [[PAR]], [[SDE]] and [[LDE]]. Here is a short description of each:

\hfill\parbox{0.95\linewidth}{
\begin{description}\small\setlength{\itemsep}{0ex}\setlength{\parsep}{0ex}
\item[ [[ORD]] ] Order when printing it out, if this variable is not defined then description is moved to end of output.
\item[ [[SEC]] ] To which section file has to be saved current variable description.
\item[ [[SUB]] ] Subsection on customization variables table.
\item[ [[OPT]] ] Customization variable name.
\item[ [[DEF]] ] Default value, if not defined it is not used by the program unless the variable is set to a valid parameter.
\item[ [[PAR]] ] Parameters required (optional).
\item[ [[SDE]] ] Short description for customization variables table. '[[JOIN-NEXT]]' enforces the current variable to be joined with the following because both they share a description.
\item[ [[LDE]] ] Long description for the corresponding manual section. '[[JOIN-NEXT]]' behaves here as in the previous item.
\end{description}
} %parbox
\hfill

<<parameter2tex - functions>>=
sub parseVars() {
    my ($k,$c);
    print STDERR "###\n### PARSING CUSTOM-FILE VARS DEFINITIONS\n###\n";
    &parseinput;
    print STDERR "### Opening Files ${base_dir}${base_file}\_\*${base_ext}\n";
    &open_varfiles;
    $c = 0;
    foreach $k (sort keys %VARS) {
        print STDERR "$k".((++$c % 10) ? ".." : "\n");
        ((defined($VARS{$k}{SEC}) && $VARS{$k}{SEC} ne '')
                                  &&
         (defined($VARS{$k}{SUB}) && $VARS{$k}{SUB} ne '')) || do {
             print STDERR "\n##\n## ERROR ## SECTION/SUBSECTION ".
                          "NOT DEFINED ON INPUT for $k ... $!\n##\n";
             next;
         }; # SEC/SUB NOT DEFINED ON INPUT
        my ($sec,$subsec, 
            $tmpdsc,$strdsc,$tmptbl,$strtbl,$par,$vareq,$vareqj);
        ($sec,$subsec) = ($VARS{$k}{SEC}, "$VARS{$k}{SEC}$VARS{$k}{SUB}");
        (defined($varO{$sec}) && defined($varO{$subsec})) || do {
             print STDERR "\n##\n## ERROR ## SECTION/SUBSECTION ".
                          "NOT DEFINED ON PROGRAM for $k ... $!\n##\n";
             next;
         }; # SEC/SUB NOT DEFINED ON PROGRAM
        if (defined($VARS{$k}{PAR}) && $VARS{$k}{PAR} ne '') {
            $par = &rep_param($VARS{$k}{PAR});
        } else {
            $par = '';
        }; # PAR
        (defined($VARS{$k}{OPT}) && $VARS{$k}{OPT} ne '') || do {
             print STDERR "\n##\n## ERROR ## VARIABLE NAME ".
                          "NOT DEFINED for $k ... $!\n##\n";
             next;         
        }; # DEFINED OPT
        #
        $tmpdsc = '\op{'.$VARS{$k}{OPT}.'} $\,=\,$ '.$par;
        $tmptbl = '\op{'.$VARS{$k}{OPT}.'}';
        #
        $vareqj = ' \hfill ';
        if (defined($VARS{$k}{DEF})) {
            $vareq  = (&rep_varop(&rep_param(&rep_value($VARS{$k}{DEF}))));
        } else {
            $vareq  = '\bydef';
        }; # DEF
        defined($VARS{$k}{SDE}) || ($VARS{$k}{SDE} = '{\tbdef}');
        defined($VARS{$k}{LDE}) || ($VARS{$k}{LDE} = ' {\tbdef}');
        if ($VARS{$k}{JOIN_SHORT}) {
            $strtbl = '\rvjoin{'.$tmptbl.'}{'.$vareq.'}'."\n\%\n";
        } else {
            $strtbl = '\rvdesc{'.$tmptbl.'}{'.$vareq.'}'."\n".'   { '.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{SDE}))))).' }'.
                "\n\%\n";
        }; # JOIN_SHORT
        if ($VARS{$k}{JOIN}) {
            $strdsc = '\ijoin{'.$tmpdsc.$vareqj.'[ '.$vareq.' ]}'."\n\%\n";
        } else {
            $strdsc = '\idesc{'.$tmpdsc.$vareqj.'[ '.$vareq.' ]}'."\n".'   {'.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{LDE}))))).' }'.
                "\n\%\n";
        }; # JOIN
        #
        $strdsc =~ s/(_|\%\-)/\\_/og;
        $strtbl =~ s/(_|\%\-)/\\_/og;
        print { $varO{$sec}[0] }    $strdsc;
        print { $varO{$subsec}[0] } $strtbl;
    }; # foreach keys %VARS
    ($c % 10) && print STDERR "\#\#\#\#\n";
    print STDERR "\#\#\#\n";
    &close_varfiles;
} # parseVars
@

Here we define the available values for the '[[SEC]]'/'[[SUB]]' fields:

<<parameter2tex - global vars>>=
local (*LAYa,*LAYb,*LAYc,*LAYd,*LAYe,*LAYf,*LAYg,
       *SEQa,*SEQb,*SRCa,*SRCb,*STRa,*STRb,*GRPa,*GRPb,*FEAa,*FEAb);
my %varO = (
    #                    [ HANDLE, EXTENSION, LABEL                     ]
    LAYOUT            => [ \*LAYa, 'Layout'                             ],
    LAYOUTPageLayout  => [ \*LAYb, 'playout', 'Page Layout'             ],
    LAYOUTZoom        => [ \*LAYc, 'zoom',    'Zoom Options'            ],
    LAYOUTLabels      => [ \*LAYd, 'label',   'Labels'                  ],
    LAYOUTTickmarks   => [ \*LAYe, 'ticks',   'Tick Marks'              ],
    LAYOUTAplot       => [ \*LAYf, 'aplot',   'Aplot Layout'            ],
    LAYOUTGeneral     => [ \*LAYg, 'general', 'General Definitions'     ],
    #
    SEQUENCE          => [ \*SEQa, 'Sequence'                           ],
    SEQUENCESequences => [ \*SEQb, 'seq',     'GFF-Sequence Attributes' ],
    #
    SOURCE            => [ \*SRCa, 'Source'                             ],
    SOURCESources     => [ \*SRCb, 'src',     'GFF-Source Attributes'   ],
    #
    STRAND            => [ \*STRa, 'Strand'                             ],
    STRANDStrands     => [ \*STRb, 'str',     'GFF-Strand Attributes'   ],
    #
    GROUP             => [ \*GRPa, 'Group'                              ],
    GROUPGroups       => [ \*GRPb, 'grp',     'GFF-Group Attributes'    ],
    #
    FEATURE           => [ \*FEAa, 'Feature'                            ],
    FEATUREFeatures   => [ \*FEAb, 'feat',    'GFF-Feature Attributes'  ],
    );
my @varMain = qw / LAYOUT SEQUENCE SOURCE STRAND GROUP FEATURE /;
my @varSub  = qw /
                   LAYOUTPageLayout  LAYOUTZoom      LAYOUTLabels 
                   LAYOUTTickmarks   LAYOUTAplot     LAYOUTGeneral
                   SEQUENCESequences SOURCESources   STRANDStrands
                   GROUPGroups       FEATUREFeatures
                 /;
@

<<HIDE: testing variables set as FILEHANDLES>>=
perl -e '$a="SEC";open(*{$a},"> kkkk"); print $a "HEYYYY"; close(*{$a})' 
perl -e 'use strict;
         my $a=\*SEC;
         open($a,"> kkkk");
         print { $a } "HEYYYY";
         close($a)'  # Works OK with USE STRICT pragma...
@ 

<<parameter2tex - functions>>=
sub open_varfiles() {
    my ($flh,$vlh,$mf);
    foreach $flh (@varMain) {
        $vlh = "_dsc".$varO{$flh}[1];
        $mf = "${base_dir}${base_file}${vlh}${base_ext}";
        open($varO{$flh}[0],"> $mf");
        print { $varO{$flh}[0] } 
              &tex_header($mf,"Description items for $flh");
	}; # foreach $flh
    foreach $flh (@varSub) {
        $vlh = "_tbl".$varO{$flh}[1];
        $mf = "${base_dir}${base_file}${vlh}${base_ext}";
        open($varO{$flh}[0],"> $mf");
        print { $varO{$flh}[0] } 
              &tex_header($mf,"Summary table for $flh: $varO{$flh}[2]");
        print { $varO{$flh}[0] } "\%\n".'\begin{tabular}{p{5cm}p{3cm}p{15cm}}';
        print { $varO{$flh}[0] } "\n\%\n".'\rvdef{'.$varO{$flh}[2].'}'."\n\%\n";
	}; # foreach $flh
} # open_varfiles
sub close_varfiles() {
    my $flh;
    foreach $flh (@varMain) {
        close($varO{$flh}[0]);
	}; # foreach $flh
    foreach $flh (@varSub) {
        print { $varO{$flh}[0] } '\end{tabular}'."\n";
        close($varO{$flh}[0]);
	}; # foreach $flh
} # close_varfiles
@ 

\subsubsctn{Parsing descriptions for command-line options}

Record tags available for command-line options definition file are: [[ORD]], [[OPT]], [[LNG]], [[PAR]], [[EQV]], [[SDE]] and [[LDE]]. Here is a short description of each:

\hfill\parbox{0.95\linewidth}{
\begin{description}\small\setlength{\itemsep}{0ex}\setlength{\parsep}{0ex}
\item[ [[ORD]] ] Order when printing it out, if this variable is not defined then description is moved to end of output.
\item[ [[OPT]] ] Short command-line option, a single char (optional).
\item[ [[LNG]] ] Long command-line option (words are ALWAYS joined with hypens, '-'). This field is mandatory (all command-line options has a long name while the opposite is not true).
\item[ [[PAR]] ] Parameters required (optional).
\item[ [[EQV]] ] Customization variable equivalence if it is appropriate and does exist (optional).
\item[ [[SDE]] ] Short description for command-line options table. '[[JOIN-NEXT]]' senforces the current option to be joined with the following because both they share a description.
\item[ [[LDE]] ] Long description for the corresponding manual section. '[[JOIN-NEXT]]' behaves here as in the previous item.
\end{description}
} %parbox
\hfill

<<parameter2tex - functions>>=
sub parseOpts() {
    my ($k,$c);
    print STDERR "###\n### PARSING CMD-LINE OPTIONS DEFINITIONS\n###\n";
    &parseinput;
    print STDERR "### Writing to ${base_dir}${base_file}\_\*${base_ext}\n";
    open(FDSC,"> ${base_dir}${base_file}\_dsc${base_ext}");
    open(FTBL,"> ${base_dir}${base_file}\_tbl${base_ext}");
    $c = 0;
    print FTBL '\begin{tabular}{rl}'."\n\%\n";
    foreach $k (sort keys %VARS) {
        print STDERR "$k".((++$c % 10) ? ".." : "\n");
        my ($tmpdsc,$strdsc,$tmptbl,$strtbl,$par,$varlng,$varsht,$vareq);
        if (defined($VARS{$k}{PAR}) && $VARS{$k}{PAR} ne '') {
            $par = &rep_param($VARS{$k}{PAR});
        } else {
            $par = '';
        }; # PAR
        (defined($VARS{$k}{LNG}) && $VARS{$k}{LNG} ne '') || do { 
             print STDERR "\n##\n## ERROR ## LONG OPTION NAME ".
                          "NOT DEFINED for $k ... $!\n##\n";
             next;
        }; # LONG OPTION NOT DEFINED
        $varlng = '\op{-\/-'.$VARS{$k}{LNG}.'} '.$par;
        if (defined($VARS{$k}{OPT}) && $VARS{$k}{OPT} ne '') { 
            $varsht  = '\op{-'.$VARS{$k}{OPT}.'}';
            $tmptbl  = $varsht.'{\x}'.$varlng;
            $varsht .= " $par";
            $tmpdsc  = '\shortstack[l]{\ '.$varsht.' \\\\ '.$varlng.'}';
        } else {
            $tmpdsc = $varlng;
            $tmptbl = $varlng;
        }; # OPT
        $vareq = ' \hfill ';
        (defined($VARS{$k}{EQV})) && 
            ( $vareq .= (&rep_varop(&rep_param(&rep_value($VARS{$k}{EQV})))) );
        defined($VARS{$k}{SDE}) ||
            ($VARS{$k}{SDE} = '{\tbdef}');
        defined($VARS{$k}{LDE}) ||
            ($VARS{$k}{LDE} = ' {\tbdef}');
        if ($VARS{$k}{JOIN_SHORT}) {
            $strtbl = '\rjoin{'.$tmptbl.'}'."\n\%\n";
        } else {
            $strtbl = '\rdesc{'.$tmptbl.'}'."\n".'   { '.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{SDE}))))).' }'.
                "\n\%\n";
        }; # JOIN_SHORT
        if ($VARS{$k}{JOIN}) {
            $strdsc = '\ijoin{'.$tmpdsc.$vareq.'}'."\n\%\n";
        } else {
            $strdsc = '\idesc{'.$tmpdsc.$vareq.'}'."\n".'   {'.
                (&rep_chars(&repq_varop(
                     &repq_param(&repq_value($VARS{$k}{LDE}))))).' }'.
                "\n\%\n";
        }; # JOIN
        #
        $strdsc =~ s/(_|\%\-)/\\_/og;
        $strtbl =~ s/(_|\%\-)/\\_/og;
        print FDSC $strdsc;
        print FTBL $strtbl;
    }; # foreach keys %VARS
    ($c % 10) && print STDERR "\#\#\#\#\n";
    print STDERR "\#\#\#\n";
    print FTBL '\end{tabular}'."\n";
    close(FDSC);
    close(FTBL);
} # parseOpts
@

\subsubsctn{{\LaTeX} definitions}

<<parameter2tex - LaTeX>>=
%
% Definitions for variables and options description
%
\newcommand{\x}{\textmd{,\,}}
% \newcommand{\hd}{\textbf{\textsf{\textsc{Default}} $\,=\,$}}
\newcommand{\bydef}{\textbf{\textsl{\textsf{undef\ }}}}
\newcommand{\tbdef}{\textbf{\large TO BE DEFINED !!!}}
%
\newcommand{\op}[1]{\textbf{\textsf{#1}}}
\newcommand{\pp}[1]{\textmd{\textsf{{\footnotesize$<$}#1{\footnotesize$>$}}}}
\newcommand{\vp}[1]{\textbf{\textsf{ #1}}}
%
\newcommand{\idesc}[2]{\item #1 \\ #2 }
\newcommand{\ijoin}[1]{\item #1 \\[-5ex]}
%
\newcommand{\rdesc}[2]{ #1 & #2 \\}
\newcommand{\rjoin}[1]{ #1 &    \\[-0.75ex]}
%
\newcommand{\rvdef}[1]{
\multicolumn{3}{l}{
 \vspace{2ex}                        % \begin{flushright}
  \hrulefill
  \raisebox{-0.5ex}[0pt]{
    \psframebox[framearc=1,framesep=0.75ex,linestyle=solid,
                linecolor=black,fillcolor=white,fillstyle=solid]{
                   \textbf{\textsc{#1}}
                } % psframebox
    } % raisebox                     % \end{flushright}
} \\[1.5ex] % multicolumn
} % rvdef
\newcommand{\rvdesc}[3]{ \hfill #1 \hfill & \centering #2 & #3 \\}
\newcommand{\rvjoin}[2]{ \hfill #1 \hfill & \centering #2 &    \\[-0.75ex]}
%
@ 

\newpage

\subsctn{[[colors2tex.pl]]: formatting color definitions for manual.} %%%%%%%%%
\label{sec:COLORprg}

\subsubsctn{Extracting and running [[colors2tex.pl]]}
\label{sec:cmykfiles}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"colors2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/colors2tex.pl ;
notangle -R"colors2tex.pl" $WORK/$nwfile.nw | cpif $BIN/colors2tex.pl ;
chmod a+x $BIN/colors2tex.pl ;
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting color tables for the User's Manual #'
echo "Extracting \"$DOCS/AplotColorDefs.tex\"..." 1>&2 ;
notangle -R"cmyk colors perl definition" $WORK/$nwfile.nw  | \
    $BIN/colors2tex.pl -d - | cpif $DOCS/tables/AplotColorDefs.tex ;
echo "Extracting \"$DOCS/AplotColorTbl.tex\"..." 1>&2 ;
notangle -R"cmyk colors perl definition" $WORK/$nwfile.nw  | \
    $BIN/colors2tex.pl -t "seagreen" - | cpif $DOCS/tables/AplotColorTbl.tex ;
@ 

\subsubsctn{[[colors2tex.pl]] implementation}

<<colors2tex.pl>>=
<<PERL shebang>>
# 
# colors2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
use Getopt::Std;
#
<<colors2tex - global vars>>
#
# MAIN
&getcmdlineopts;
&parseinput;

exit(0);
#
# SUBS
<<colors2tex - functions>>
@

Input records have always the same format, but we need to produce two output files formatted differently, one of them will contain a set of colors definitions ([[-d]] option) and the other one will make a {\LaTeX} table to show the colors that were defined in the ``User's Manual''. %'
So that, we only need a single loop to read data from input stream, and a set functions called with a boolean flag to choose between one format or the other.

<<colors2tex - global vars>>=
my $USAGE = << "+++EOU+++";
################################################################################
###
#### $0
###
####\t\t@{[ (localtime)." : ".(defined($ENV{USER})?$ENV{USER}:"nouser") ]} 
###
#### USAGE:
###
###    colors2tex.pl [options]  < STDIN  > STDOUT
###
###    -h          prints this help.
###    -d          output is set to colors CMYK definition.
###    -t "color"  output is set to colors LaTeX table.
###                In this mode, a color name (defined on input)
###                is required to choose which color starts 
###                a new column in final LaTeX table.
###
################################################################################
+++EOU+++
#
my $tblflg = 0;
my $splitcolor = '';
@

We use [[Getopt::Std]] because we only need to set a boolean and a single parameter variables (with such parameter being optional), having any of those will set the output function, by deafult set to [[&output_defs]].

<<colors2tex - functions>>=
sub getcmdlineopts() {
    our($opt_d,$opt_t,$opt_h);
    getopts('dt:h');
    $opt_h && do {
        print STDERR $USAGE;
        exit(1);
    }; # $opt_h
    $opt_d && ($tblflg = 0);
    defined($opt_t)
           && ($splitcolor = $opt_t, $tblflg = 1);
} # getcmdlineopts
@

<<colors2tex - functions>>=
sub parseinput() {
    my @rec;
    &print_prologue($tblflg);
    while (<STDIN>) {
        next if /^\s*$/o;
        chomp;
        $_ =~ s/^\s*//o;
        @rec = split /\s+/og, $_;
        $rec[0] eq '#' && do {
            defined($rec[1]) || next;
            &print_color_name($tblflg, $rec[1]);
            next;
        }; # set color header
        (defined($rec[1]) && $rec[1] eq '=>') && do {
            &print_color_row($tblflg, @rec[0,5..8]);
        }; # set color line
    }; # while
    &print_trailer($tblflg);
} # parseinput
@

As the {\LaTeX} color definition is done also in the CMYK color space, we have not to recompute any of the values assigned to each color.

<<colors2tex - functions>>=
sub print_prologue() {
    my ($flg) = @_;  
    $flg || do {
        print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors defs: open>>
+++EOP+++
        return;
    }; # !$flg
    print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors table: open>>
+++EOP+++
    return;
} # print_prologue
@ 

<<colors2tex - functions>>=
sub print_color_name() {
    my ($flg,$name) = @_;    
    $flg || do {
        <<colors2tex - LaTeX colors defs: name>>
        return;
    }; # !$flg
    <<colors2tex - LaTeX colors table: name>>
    return;
} # print_color_name
@ 

<<colors2tex - functions>>=
sub print_new_col() {
    print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors table: split>>
+++EOP+++
} # print_new_col
@ 

<<colors2tex - functions>>=
sub print_color_row() {
    my ($flg,$name,$cyan,$magenta,$yellow,$black) = @_; # CMYK   
    $flg || do {
        <<colors2tex - LaTeX colors defs: row>>
        return;
    }; # !$flg
    <<colors2tex - LaTeX colors table: row>>
    return;
} # print_color_row
@ 

<<colors2tex - functions>>=
sub print_trailer() {
    my ($flg) = @_;    
    $flg || do {
        print STDOUT << '+++EOP+++';
<<colors2tex - LaTeX colors defs: close>>
+++EOP+++
        return;
    }; # !$flg
    print STDOUT << '+++EOP+++';   
<<colors2tex - LaTeX colors table: close>>
+++EOP+++
    return;
} # print_trailer
@ 


<<HIDE: DONE>>=
\doneitem{20011113}{Automatize color table and definition file, and page sizes table, using a script which include the perl code for those colors and page sizes and a '\_\_\_DATA\_\_\_' trailer. This approach will allow to synchronize definitions with the manual without manual revision.}


\subsubsctn{{\LaTeX} code for CMYK color definitions}

Building the color definition file used by this file to produce the CMYK color definitions used in this document and the ``{\prog} User's Manual''.
% Table~\ref{tbl:CMYKcolor}.

<<colors2tex - LaTeX colors defs: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotColorDefs.tex
%
% Color CMYK definition used in "gff2aplot".
%
% <<Version Control Id Tag>>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

<<colors2tex - LaTeX colors defs: name>>=
print STDOUT '% '."$name\n";
@

<<colors2tex - LaTeX colors defs: row>>=
print STDOUT '\definecolor{'.$name.'}'.(" " x (20 - length($name))).
             '{cmyk}{'."$cyan,$magenta,$yellow,$black".'}'."\n";
@

<<colors2tex - LaTeX colors defs: close>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

\subsubsctn{{\LaTeX} code for CMYK color table}

Building the CMYK color table for the ``{\prog} User's Manual''.
% Table~\ref{tbl:CMYKcolor} \LaTeX{} file.

<<colors2tex - LaTeX colors table: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotColorTbl.tex
%
% Colors used in "gff2aplot": CMYK values table.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\label{sec:colortable}
\newcommand{\clrow}[1]{
  \fcolorbox{black}{#1}{
    \textcolor{#1}{\rule[-.3ex]{1cm}{1.8ex}}
    } % fcolorbox
  & #1
  } % newcommand
%
\newcommand{\clspc}{&&&&&\\}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\begin{table}[!ht]
%\setlength{\parindent}{-0.5cm}
\begin{center}
\begin{scriptsize}
\begin{tabular}{c@{\quad}c}
    \begin{tabular}{|c|c|cccc|} \hline
@

<<colors2tex - LaTeX colors table: name>>=
$name eq $splitcolor && &print_new_col;
print STDOUT '% '."$name\n".'\clspc'."\n";
@

<<colors2tex - LaTeX colors table: row>>=
print STDOUT '\clrow{'.$name.'}'.(" " x (24 - length($name))).
             "& $cyan & $magenta & $yellow & $black \\\\\n";
@

<<colors2tex - LaTeX colors table: split>>=
      \clspc
      \hline
    \end{tabular} 
   &
    \begin{tabular}{|c|c|cccc|} \hline
@

<<colors2tex - LaTeX colors table: close>>=
      \clspc
      \hline
    \end{tabular}
   \\
  \end{tabular}
\end{scriptsize}
%\begin{center}
  \caption{\label{tbl:CMYKcolor}
    {\prog} CMYK color definition table and Color Names.
    } % caption
  %\refstepcounter{table}
  %\addcontentsline{lot}{section}{
  %   \thetable\hspace{1em}{\prog}\ CMYK color definition table.
  %   }
\end{center}
\end{table}
\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@


\newpage

\subsctn{[[pagebbox2tex.pl]]: formatting page sizes for manual.} %%%%%%%%%%%%%%
\label{sec:PBBOXprg}

\subsubsctn{Extracting and running [[pagebbox2tex.pl]]}

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"pagebbox2tex.pl" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/pagebbox2tex.pl ;
notangle -R"pagebbox2tex.pl" $WORK/$nwfile.nw | cpif $BIN/pagebbox2tex.pl ;
chmod a+x $BIN/pagebbox2tex.pl ;
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting page-size tables for the User's Manual #'
echo "Extracting \"$DOCS/AplotPageSizeTbl.tex\"..." 1>&2 ;
notangle -R"page sizes perl definition" $WORK/$nwfile.nw | \
    $BIN/pagebbox2tex.pl - | cpif $DOCS/tables/AplotPageSizeTbl.tex ;
@

\subsubsctn{[[pagebbox2tex.pl]] implementation}

<<pagebbox2tex.pl>>=
<<PERL shebang>>
# 
# pagebbox2tex.pl
#
<<Version Control Id Tag>>
#
use strict;
#
<<pagebbox2tex - global vars>>
#
# MAIN
&parseinput;
exit(0);
#
# SUBS
<<pagebbox2tex - functions>>
<<Common Routines: text fill>>
@

<<pagebbox2tex - global vars>>=
my $USAGE = "###  pagebbox2tex  <STDINPUT  >STDOUTPUT \n";
@

<<pagebbox2tex - functions>>=
sub parseinput() {
    my @rec;
    &print_prologue;
    while (<STDIN>) {
        next if /^\s*$/o;
        chomp;
        $_ =~ s/^\s*//o;
        $_ =~ s/["',]//og; #'"
        @rec = split /\s+/og, $_;
        $rec[0] eq '#' && do {
            <<pagebbox2tex - LaTeX formats table: spacer>>
            next;
        }; # set color header
        (defined($rec[1]) && $rec[1] eq '=>') && do {
            <<pagebbox2tex - LaTeX formats table: row>>
        }; # set color line
    }; # while
    &print_trailer;    
} # parseinput
@

<<pagebbox2tex - functions>>=
sub print_prologue() {
    print STDOUT << '+++EOP+++';
<<pagebbox2tex - LaTeX formats table: open>>
+++EOP+++
} # print_prologue
@

<<pagebbox2tex - functions>>=
sub print_trailer() {
    print STDOUT << '+++EOP+++';
<<pagebbox2tex - LaTeX formats table: close>>
+++EOP+++
} # print_trailer
@


\subsubsctn{{\LaTeX} wrappers for available page sizes}

<<pagebbox2tex - LaTeX formats table: open>>=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% AplotPageSizeTbl.tex
%
% Page Sizes used in "gff2aplot".
%
% <<Version Control Id Tag>>
%
\label{sec:pagesizes}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\begin{table}[!ht]
\begin{center}
\setlength{\fboxsep}{2pt}
%\setlength{\arrayrulewidth}{1pt}
\fbox{
 \begin{tabular}{|c||r|r||r|r||r|r|} \hline
  \raisebox{-0.5ex}[0pt]{ PAGE } &
    \multicolumn{6}{c|}{ PAGE SIZE }\\ \cline{2-7}
  \raisebox{0.25ex}[0pt]{ FORMAT } &
    \multicolumn{2}{c||}{ (in points) } &
    \multicolumn{2}{c||}{ (in cms) } &
    \multicolumn{2}{c|}{ (in inches) } \\
@

<<pagebbox2tex - LaTeX formats table: spacer>>=
print STDOUT '\hline\hline'."\n";
print STDOUT '%                  points    -  centimeters  -     inches'."\n";
@

<<pagebbox2tex - LaTeX formats table: row>>=
print STDOUT (&fill_right($rec[0],12," ")).
             (&get_sizes(@rec[4,5]))." \\\\\n";
@

<<pagebbox2tex - functions>>=
sub get_sizes() {
    my ($w,$h) = @_;
    my $str = '';
    $str  = ' &'.(&fill_left($w,6," ")).       ' &'.(&fill_left($h,6," "));
    $str .= ' &'.(&fill_left(&tocm($w),6," ")).' &'.(&fill_left(&tocm($h),6," "));
    $str .= ' &'.(&fill_left(&toin($w),6," ")).' &'.(&fill_left(&toin($h),6," "));
    return $str;
} # get_sizes
@

<<pagebbox2tex - functions>>=
# to cm:   28.35 pts == 1 cm
sub tocm() { return sprintf("%.1f", ($_[0] / 28.35)); }
# to inch:    72 pts == 1 inch
sub toin() { return sprintf("%.1f", ($_[0] / 72.00)); }
@

<<pagebbox2tex - LaTeX formats table: close>>=
  \hline\hline
 \end{tabular}
} % fbox
\caption{\label{tbl:PageSizes}Page Sizes defined in {\prog}.}\hspace{1cm}
\vskip 1ex
\fbox{
\begin{tabular}{c@{\quad$\equiv$\quad}c}
28.35 pt & 1 cm   \\
72.00 pt & 1 inch \\
\end{tabular}
} % fbox
  %\refstepcounter{table}
  %\addcontentsline{lot}{section}{
  %   \thetable\hspace{1em}Page Sizes available at {\prog}.}
\end{center}
\end{table}
\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

\newpage

\subsctn{Compacting {\ps} code with [[PScompactnw.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:PSnowebfilter}

\subsubsctn{Extracting and running [[PScompactnw.pl]]}

<<tangling>>=
# PostScript code flattening
notangle -R"PScompactnw.pl" $WORK/$nwfile.nw | cpif $BIN/PScompactnw.pl ;
chmod a+x $BIN/PScompactnw.pl ;
#
notangle -R"flt.sh" $WORK/$nwfile.nw | cpif $BIN/flt.sh ;
chmod a+x $BIN/flt.sh ;
#
@ 

<<tests on PScompactnw.pl script>>=
notangle -R"APLOT" -filter '$BIN/flt.sh ./kkk1 ./kkk2' \
    $WORK/$nwfile.nw > ./kkk ;
@ 

<<flt.sh>>=
#!/bin/bash

toerr () {
  perl -e '
    $cdon=0;
    while (<STDIN>) {
      $_ =~ /^@(begin|end) code/o && do {
        $cdon = 1 - $cdon;
        print STDERR $_ unless $cdon;
      };
      $cdon && do { print STDERR $_ };
      print STDOUT $_;
    };
  ' $1 2> $2;
}

toerr - $1 |
  $BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables" - | \
  toerr - $2 ; 
#
@ 

<<HIDE: tests on PScompact script>>=
#
# first command-line draft
notangle -R'POSTSCRIPT shortnames' $nwfile.nw | \
  perl -ne 'BEGIN{$clflg=0;$ln=0};
    chomp; $clflg && ($_ =~ s/^\s*//o);
    $clflg = ($_ =~ s/\s+\%\-\%.*$//og) ? 1 : 0 ; 
    $_ =~ s/\s+/ /og; $lnw=length($_); 
    $_ =~ /^\%/o && do { $clflg && ($_ = "\n$_"); };
    $ln>25 && do { $clflg && ($_ = "  $_"); 
    $_ = ($_ =~ /^[\n]/o ? "" : "\n").$_; $ln=0; };
    $ln+=$lnw; print STDERR "$ln : $_\n"; 
    ($_ =~ /\n$/o || !$clflg) && ($ln = 0); 
    print $_.($clflg ? " " : "\n")' 2> kkkk | more ;    
#
# perl version tests
@ 


\subsubsctn{[[PScompactnw.pl]] implementation}

<<PScompactnw.pl>>=
<<PERL shebang>>
# 
# USAGE:  PScompactnw.pl "regexp" <STDIN >STDOUT
#
<<Version Control Id Tag>>
#
use strict;
# my $MaxLen = 80; # Not Used now
my ($clflg,$ln,$cln,$go) = (0,0,0,0);

my $regexp = shift @ARGV;
my $thori = '@defn';
my $colin = '@text';
my $nw    = '@nl';
my $nwlin = "$nw\n";
my $uslin = '@use';
my $idxln = '@index';
my $thend = '@end code';

(defined($regexp) && $regexp ne '') || do {
    while (<STDIN>) {
        print STDOUT $_;
    };
    exit(0);
};

while (<STDIN>) {
    <<PScompactnw - looking for code chunks>>
    <<PScompactnw - skipping the rest of the notangle output>>
    <<PScompactnw - processing code>>
}; # while

exit(0);
@

We do not proces the whole file only those chunks of code which name starts with the command-line given regular expression.

<<PScompactnw - looking for code chunks>>=
$_ =~ /^$thori\s+($regexp)/o && do {
    $go = 1;
    print STDOUT "$_$nwlin";
    next;
};
$_ =~ /^$thend/o && do {
    $go = 0;
    print STDOUT ($clflg ? "\n$nwlin$_" : "$_");
    next;
};
@ 

Anything else is just printed as it comes from input stream.

<<PScompactnw - skipping the rest of the notangle output>>=
$go || do {
    print STDOUT $_;
    next;
}; # !$go
@

<<PScompactnw - processing code>>=
<<PScompactnw - processing '@nl'>>
chomp;
<<PScompactnw - processing '@use'>>
<<PScompactnw - processing '@text'>>
@ 

[[noweb]] newlines code is skipped directly, we will print out them where needed.

<<PScompactnw - processing '@nl'>>=
$_ =~ /^$nw/o && next;
@ 

[[@use]] is printed as is, without changes, it defines a link to another code chunk in the noweb intermediate file.

<<PScompactnw - processing '@use'>>=
$_ =~ /^$uslin/o && do {
    print STDOUT ($clflg ? "\n$nwlin" : "")."$_\n$colin \n$nwlin";
    $clflg = 0;
    next;        
}; # $_ =~ /^$uslin/
$_ =~ /^$idxln/o && do {
    print STDOUT ($clflg ? "\n$nwlin" : '')."$_\n";
    $clflg = 0;
    next;        
}; # $_ =~ /^$idxln/
@ 

<<PScompactnw - processing '@text'>>=
$_ =~ /^$colin/o && do {
    <<PScompactnw - remove '@text'>>
    <<PScompactnw - raw comments to output>>
    <<PScompactnw - remove initial spaces>>
    <<PScompactnw - special tag types>>
    <<PScompactnw - checking lengths>>
    <<PScompactnw - printing output>>
}; # $_ =~ /^$colin/
@

<<PScompactnw - remove '@text'>>=
$_ =~ s/^$colin //o;
@

Comments are printed without the 'extra' comments (all three types are explained later on this section but have no differences when filtering comments).

<<PScompactnw - raw comments to output>>=
$_ =~ /^\%/o && do { # raw comments are thrown to output directly...
    $_ =~ s/\s\%(\:|\-)(\%|\>).*$//og;
    print STDOUT ($clflg ? "\n$nwlin" : '')."$colin $_\n$nwlin";
    $clflg = $ln = 0;
    next;
}; # $_ =~ /^\%/o
@

We clean up of extra white spaces.

<<PScompactnw - remove initial spaces>>=
$_ =~ s/\s+/ /og;
$clflg && ($_ =~ s/^\s//o);
@

Now we are looking for three different tags:

\begin{description}
\item{[[%:%]]} A comment that is replaced by a newline.
\item{[[%-%]]} A comment that joins next line to current one.
\item{[[%->]]} Also joins next line to current one, we use it to distinguish between simple comments and stack/functions description, [[%-%]] and [[%->]] respectively.
\end{description}

<<PScompactnw - special tag types>>= 
TYPE: {
    ($_ =~ s/\s\%\:\%.*$//og)     && do {
        $clflg && do { 
            $_ .= "\n$nwlin";
        };
        $clflg = 0;
        last TYPE;
    };
    ($_ =~ s/\s\%\-(\>|\%).*$//og) && do {
        $_ .= " ";
        $clflg = 1;
        last TYPE;
    };
    $ln = length($_);
    $_ .= "\n$nwlin";
    $clflg = 0;
}; # TYPE
@

What we are going to do now is to join each new line that was preceeded by one of the 'join' tags, or leave as is. If an empty line is found is just removed. After that, we prepend the [[noweb]] text line header if we are starting a new code line.

<<PScompactnw - checking lengths>>=
$cln = length($_);
$cln > 0 || next;
$_ =~ /^\s*$/o && next;
SIZES: {
    $ln == 0 && ( $_ = "$colin $_" );
    $clflg || ( $ln = 0, last SIZES );
#   $clflg && ( $_ = "\n$nwlin$colin $_" );
    $ln += $cln + $clflg;
}; # SIZES
@

And finally, we return the processed output to [[noweb]] pipeline:

<<PScompactnw - printing output>>=
# $_ .= $clflg ? " " : "\n$nwlin";
print STDOUT "$_";
# print STDERR "$cln ($ln) : \n$_\n";
@


<<HIDE: PScompact.pl>>=
<<PERL shebang>>
##################################################################
# 
# PScompact.pl
#
<<Version Control Id Tag>>
#
use strict;
my ($MaxLen,$clflg,$fnflg,$ln,$cln) = (25,0,0,0,0);

while (<STDIN>) {
    my $tt;
    chomp;
    $_ =~ /^\%/o && do { # raw commentss are thrown to output directly...
        $tt = $clflg ? "\n" : '';
        $fnflg = $clflg = $ln = 0;
        print STDOUT "$tt$_\n";
        next;
    }; 
    $_ =~ s/\s+/ /og;
    $clflg && ($_ =~ s/^\s//o);
  TYPE: {
      ($_ =~ s/\s\%\-\>.*$//og) && do {
          $fnflg = $clflg = 1;
          last TYPE;
      };
      $fnflg = 0;
      $clflg = ($_ =~ s/\s\%\-\%.*$//og) ? 1 : 0;
  }; # TYPE
    $cln = length($_);
    $ln > $MaxLen && do {
        $fnflg && ($_ = "  $_"); # indenting opened functions
        $_ = "\n$_";
        $ln = 0;
    };
    $ln += $cln;
    print STDERR "$cln ($ln) : $_\n";
    $tt = $clflg ? " " : "\n";
    print STDOUT "$_$tt";
}; # while

exit(0);
@
<<HIDE: PScompactnw - processing '@text'>>=
# We tryed to get less than 80 chars columns,
# now each function in a single line (see previous code chunk) 
$_ =~ /^$colin/o && do {
    $_ =~ s/^$colin //o;
    $_ =~ /^\%/o && do { # raw commentss are thrown to output directly...
        $_ =~ s/\s\%\:\%.*$//og;
        $tt = $clflg ? "\n$nwlin" : '';
        $fnflg = $clflg = $ln = 0;
        print STDOUT "$tt$colin $_\n$nwlin";
      # print STDERR "$tt$colin $_\n$nwlin";
        next;
    }; 
    $_ =~ s/\s+/ /og;
    $clflg && ($_ =~ s/^\s*//o);
  TYPE: {
      $jmflg = 0;
      ($_ =~ s/\s\%\:\%.*$//og) && do {
          $jmflg = 1;
          last TYPE;
      };
      ($_ =~ s/\s\%\-\>.*$//og) && do {
          $fnflg = $clflg = 1;
          last TYPE;
      };
      $fnflg = 0;
      $clflg = ($_ =~ s/\s\%\-\%.*$//og) ? 1 : 0;
  }; # TYPE
    $cln = length($_);
  SIZES: {
    ($ln == 0 && $cln > 0) && do {
        $_ = "$colin $_";
    }; 
    $clflg || do {
        $ln = 0;
        last SIZES;
    };
    $tln = 0;
    $clflg && do {
      for (my $j = 0; $j < $cln; $j++) {
        substr($_,$j,1) =~ /\s/o && do {
            my $pp = $j + 1;
            $pp = $ln + $pp;
            $pp < $MaxLen && ($tln = $j, next);
            $tln > $cln && last;
            substr($_,$tln,0) = "\n$nwlin$colin ";
            $tln = $cln - $tln + 1;
            $cln = $tln;
            $ln = 0;
            last;
        }; # substr($_,$j,1)
      }; # for
    }; # $clflg 
    $ln += $cln + $clflg + $fnflg;
    $ln >= $MaxLen && do {
        $fnflg && ($_ = " $_"); # indenting opened functions
        $_ = ($clflg ? "\n$nwlin" : "")."$colin $_";
        $ln = $tln;
    };
  }; # SIZES
    # print STDERR "$cln ($ln) : $_\n";
    $tt = $clflg ? " " : "\n$nwlin";
print STDERR "$cln : $tln : ($ln) : \n$_\n";
    print STDOUT "$_$tt";
}; # $_ ~ @text
@


\newpage

\subsctn{Making tests with [[aplottester.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{todo:TAA}
<<HIDE: new defs TODO>>=
\def\todoTAA{
Implement a perl script to test {\prog} functions.
} % todoTAA
@
<<HIDE: TODO>>=
\todoitem{\todoTAA}{todo:TAA}
@
\todo{ \item \todoTAA } % todo

\subsubsctn{[[aplottester.pl]] implementation}

<<aplottester.pl>>=
<<PERL shebang>>
# 
# aplottester.pl
#
<<Version Control Id Tag>>
#
use strict;
use Test;
#
BEGIN { plan tests => 14, todo => [3,4] } # set to approiate values
#
#################
use gff2aplot.pl;
#################
#
<<aplottester - global vars>>
#
# MAIN

exit(0);
#
# SUBS
<<aplottester - functions>>
@ 

\subsubsctn{Tests to be implemented}

<<testing regular expressions for element@id>>=
The following does not work pretty well:

$string =~ /^(.*)(?:@(.*?))?$/ && (($tmpstr, $tmpid) = ($1,$2));

As we can see in the perl script below, reversing the regular expression is a good choice: 

perl -ne ' 
    chomp;
    $a=$b=undef;
    (reverse($_) =~ /^([^\/]*?)(?:\@)(?!\\)(.*)$/o) && 
        ($a=reverse($2),$b=reverse($1));
    defined($b) && 
        (print ">>> \"$a\" \@ \"".($b?$b:"NIL")."\"\n") ||
            (print ">>> \"$_\"\n"); '
jhkjfhgkjdf@one # feature string and ID, both defined
>>> "jhkjfhgkjdf" @ "one"
/.*@@.*/        # only feature regexp, no ID
>>> "/.*@@.*/"
ffgdg           # only feature string, no ID
>>> "ffgdg"
jhkjfhgkjdf@    # only feature string, but an empty ID field ? 
>>> "jhkjfhgkjdf" @ "NIL"
jhkjfhgkjdf\@   # use "\" to preserve "@" if feat ends with "@" (most unlikely)
>>> "jhkjfhgkjdf\@"
/.*@@.*/@kk     # feature regexp and ID, both defined
>>> "/.*@@.*/" @ "kk"
*@yoyo          # feature pseudo-regexp ("*" ~ "/.*/") and ID, both defined
>>> "*" @ "yoyo"
!@@@@@lio       # a very extrange test, isn't it ? ... ;^D
>>> "!@@@@" @ "lio"
@ %$


<<testing regexes: regexptester.pl>>=
BEGIN { ($NULL,$T,$F) = ("+@+NULL+@+",1,0); }
    chomp;
    s{^:::\s+}{}o;
    print ">>> $_ \n";
    ($a,$b) = split /\s+:::\s+/o, $_, 2;
    @results = &find_regexp($a);
    @results_mod = (($results[0] ? "TRUE" : "FALSE"),
                    ($results[1] ? "TRUE" : "FALSE"),
                    (defined($results[2]) ? $results[2] : "FALSE"),
                    "$results[3]");
    printf ">>> IS_OK::%s::  IS_NEG::%s::  GET_ID::%s::  GET_STRING::%s::\n",
           @results_mod;
    !$results[1] &&
         print ">>> ".
             (  ( (eval { $b =~ m{$results[3]}; 1 } || 0) ?
                         ($b =~ m{$results[3]}) : 0 ) ? 
                     "\"$b\" MATCHES \/$results[3]\/ " : 
                     "\"$b\" DOES NOT MATCH \/$results[3]\/ ")."\n\n";
    $results[1] &&
         print ">>> ".
             (!(( (eval { $b =~ m{$results[3]}; 1 } || 0) ?
                         ($b =~ m{$results[3]}) : 0 )) ? 
                       "\"$b\"  MATCHES !\/$results[3]\/ " : 
                       "\"$b\" DOES NOT MATCH !\/$results[3]\/ ")."\n\n";
sub find_regexp() {
    my $string = $_[0];
    my ($isOK_flg,$not_flg,$id_flg,$tmpstr,$tmpid);
    $isOK_flg = $T;
    $not_flg = $F;
    $id_flg = undef;
    $string =~ s{^!}{}o && ($not_flg = $T); # not_regexp is true
    $string =~ s{(\\@)$}{@@}o;
    $string = &escape_input($string);
    ($tmpstr, $tmpid) = (undef, undef);
    ( reverse($string) =~ m{^([^\/@]*?)(?:@){1}(.*)$}o ) && do {
        $tmpstr = reverse($2);
        $tmpid  = reverse($1);
    };
  REGEXPS: {
      print ">>> STRING($tmpstr) ID($tmpid)\n";
      (defined($tmpid) && $tmpid ne "") && ($id_flg = $tmpid);
      (defined($tmpstr) && $tmpstr ne "") || do {
          $string eq '@' && ($string="", $isOK_flg=$F);
          $tmpstr = $string;
      };
      $tmpstr eq '*' && do {
          $string = '^.*$';
          last REGEXPS;
      };
      $tmpstr =~ m{^/(.*)/$}o && do {    
          ($string, $isOK_flg) = &eval_regexp($1);
          last REGEXPS;
      }; # $tmpstr is a regexp
      $string = '^'.(quotemeta($tmpstr)).'$';
    }; # REGEXPS
    return ($isOK_flg, $not_flg, $id_flg, $string);
} # find_regexp
sub eval_regexp() {
    my $str = $_[0];
    my $flag;
    # $str =~ s{^[^\\]*?/+}{}o;
    # $str =~ s{/+.*?$}{}o;
    eval { "" =~ m{$str}; $flag = $T; } || ($flag = $F);
    return ($str, $flag);
} # eval_regexp
sub escape_input() {
  $_[0] =~ s{([;<>&!{}'`"])}{\\$1}og; # "`'
  return $_[0];
} # escape_input
@

<<HIDE: testing regexes: regexes.test>>=
::: @ ::: @
::: \@ ::: @
::: @@ ::: @
::: element ::: element
::: element ::: any
::: !element ::: element
::: !element ::: any
::: element@id ::: element
::: !element@id ::: element
::: /.*any.*/ ::: chooseanyfeat
::: /; system(" echo \"I have found your name: \$USER ... X.D\" "); / ::: any
::: /; `echo "I have found your name: \$USER ... X.D"`; / ::: any
::: / @{[ system("echo \"I have found your name: \$USER ... X.D\"") ]} / ::: any
::: / @{[ system('echo "I have found your name: $USER ... X.D"') ]} / ::: any
::: / @{ \( system("echo \"I have found your name: \$USER ... X.D\"") ) } / ::: any
::: / @{ \( exec "echo \"I have found your name: \$USER ... X.D\"" ) } / ::: any
::: /(a)+ny/ ::: any
::: /(a)+ny/ ::: aany
::: /^(a)+ny/ ::: any
::: /^a?ny/ ::: any
::: /^a?ny/ ::: aany
::: /^a?ny/@id ::: any
::: /^a?ny/@id ::: onyony
::: /^a?ny/@id ::: nyony
::: !/^a?ny/ ::: any
::: !/^a?ny/ ::: aany
::: !/^a?ny/ ::: ony
::: 5'cds ::: 5'cds
::: /^5'.*$/ ::: 5'utr
::: /^a.*?y$/ ::: annnnny
::: /^a.*?y$/ ::: anyany
::: /^a[^y]*y$/ ::: annnnny
::: /^a[^y]*y$/ ::: anyany
::: /a.+?y/ ::: annnnny
::: /a.+?y/ ::: ayyyyyy
::: /y{6}/ ::: ayyyyyy
@

<<test file for the previous regexp tester>>=
notangle -L -R'testing regexes: regexptester.pl' $WORK/$nwfile.nw | \
         cpif $BIN/regexptester.pl ;
notangle -R'HIDE: testing regexes: regexes.test' $WORK/$nwfile.nw | \
         cpif $TEST/regexes.test ;
perl -n $BIN/regexptester.pl < $TEST/regexes.test > $TEST/regexes.report ;
@ 


<<testing regular expressions for SEQ\_UNIT>>=
perl -ne '$q = undef; chomp;
          $a = $_;
          ($_ =~ /^\.$|^\s*$/o) && do {
               print "$a ::: Wrong VALUE... !!!\n";
               next;
          };
          $_ =~ s/(?:\.)?
                  (?:(g(?:iga)?|m(?:ega)?|k(?:ilo)?)?
                  b(?:ase)?
                  (?:p(?:air)?)?
                  (?:s)?)$
                 //ox && ($q = $1);
          defined($q) || do {
              $_ =~ /[^\d]+$/o && do {
                   print "$a ::: Wrong UNITS !!!\n";
                   next;
              };
          };
          (defined($_) && $_ ne "") ||  do {
               print "$a ::: Wrong VALUE !!!\n";
               next;
          };
          ($q,undef) = split //o,$q,2;
          $q .= 'bp';
          print "$a ::: $_ $q\n"; ' << 'EOF'
10kbp
10kilobp
10gigabp
11.33kk
-1kb
0.5bp
.

0.bp
0
10+e15bp
EOF

The results are the following:

10kbp ::: 10 kbp
10kilobp ::: 10 kbp
10gigabp ::: 10 gbp
11.33kk ::: Wrong UNITS !!!
-1kb ::: -1 kbp
0.5bp ::: 0.5 bp
. ::: Wrong VALUE... !!!
 ::: Wrong VALUE !!!
0.bp ::: 0 bp
0 ::: 0 bp
10+e15bp ::: 10+e15 bp
@ 


<<testing regular expressions for PS\_UNIT>>=
perl -ne '$q = undef; chomp;
          $a = $_;
          ($_ =~ /^\.$|^\s*$/o) && do {
               print "$a ::: Wrong VALUE... !!!\n";
               next;
          };
          PSLEN: {
              $_ =~ s/m(eter(s)?)?$//o && do {
                  $_ =~ s/(\.)?c(enti)?$//o && ($q = "cm", last PSLEN);
                  $_ =~ s/(\.)?m(ili)?$//o  && ($q = "mm", last PSLEN);
                  last PSLEN;
              };
              $_ =~ s/(\.)?in(ch(es)?)?$//o && ($q = "in", last PSLEN);
              $_ =~ s/(\.)?(pt|point(s)?)$//o    && ($q = "pt");
          }; # PSLEN
          defined($q) || do {
              $_ =~ /[^\d]+$/o && do {
                   print "$a ::: Wrong UNITS !!!\n";
                   next;
              };
              $q = "pt";
          };
          (defined($_) && $_ ne "") ||  do {
               print "$a ::: Wrong VALUE !!!\n";
               next;
          };
          print "$a ::: $_ $q\n"; ' << 'EOF'
10cm
10centimeters
10mmeters
11.33kk
-1in
0.5pt
100inches
1inch
.

0.points
0
10+e15pts
EOF

The results are the following:

10cm ::: 10 cm
10centimeters ::: 10 cm
10mmeters ::: 10 mm
11.33kk ::: Wrong UNITS !!!
-1in ::: -1 in
0.5pt ::: 0.5 pt
100inches ::: 100 in
1inch ::: 1 in
. ::: Wrong VALUE... !!!
 ::: Wrong VALUE... !!!
0.points ::: 0 pt
0 ::: 0 pt
10+e15pts ::: Wrong UNITS !!!
@ 


\newpage

\sctn{Common code blocks} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/local/bin/perl -w
# This is perl, v5.6.1 built for i686-linux
# /usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
@ 

The 'shebang' line can be emulated in several ways. Those systems that do not support '[[#!]]' will emulate it with:

<<PERL shebang emulation>>=
#!/usr/bin/perl -w
eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}' if $running_under_some_shell;
@ 

Another way to emulate the 'shebang' line is the following devious construct that will work under any of csh, sh, or perl system.

<<PERL shebang general emulation>>=
eval '{exit $?0}' && 
  eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}' &&
    eval 'exec /usr/bin/perl -w -S $0 $argv:q' 
      if 0;
@

We also include a copy of the GNU-GPL as a comment at first lines on the program, and the version control tag.

<<Program Info>>=
#
<<GNU License PERL>>
#
<<Version Control Id Tag>>
#
@

We are using here [[perl -w]] to show all warnings when running the script. We also [[use strict]] to force all variable names to be declared.

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common Routines>>=
<<Common Routines: min-max>>
<<Common Routines: text fill>>
<<Common Routines: counter>>
@

<<Common Routines: min-max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common Routines: text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

<<Common Routines: counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR " [".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR " [".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script closure>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: gff2aplot.nw,v 1.24 2001-11-23 19:28:49 jabril Exp $
@ 

\subsctn{GNU General Public License}

<<GNU License PERL>>=
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# %                          GFF2APLOT                               %
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# 
#    Converting alignments in GFF format to PostScript dotplots.
# 
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                  Thomas WIEHE                   
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ 

<<GNU License PostScript>>=
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %                          GFF2APLOT                               %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
%    Converting alignments in GFF format to PostScript dotplots.
% 
%     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                  Thomas WIEHE                   
%                                 Roderic GUIGO SERRA       
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@ 

\newpage

\sctn{Extracting code blocks from this document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracting Script code chunks from the [[noweb]] file} % \\[-0.5ex]

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"APLOT" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' - | cpif $BIN/gff2aplot.pl ;
# we remove here the comments within "use vars qw/ ... /",
# numbers may change if noweb doc is changed
notangle -L -R"APLOT" $WORK/$nwfile.nw | \
    perl -ne '( $.>1 &&
                $_ !~ /^\#line (455|465|474|1194|1289|1463|4344|4644|443)/o
               ) && print' - | cpif $BIN/gff2aplot.pl ;
#
chmod a+x $BIN/gff2aplot.pl ;
#
@ 

<<HIDE: new LaTeX urls>>=
\def\perltidy{
 \htmladdnormallinkfoot{\texttt{perltidy}}
                   {\url|http://perltidy.sourceforge.net/|}
 } % def perltidy
@
We use {\perltidy} to reformat final versions of perl scripts (without line numbering comments, correct indentations, etc...) and to pretty-print in html format.

<<tangling>>=
# reformating program with perltidy
notangle -R"APLOT" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/$nwfile.pl ;
# html pretty-printing program with perltidy
notangle -R"APLOT" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/$nwfile.html ;
#
@

<<tangling>>=
############################
# FLATTENING of PS CODE...
#
notangle -L -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perl -ne '$.>1 && print' - | cpif $BIN/gff2aplot.pl ;
#
notangle -L -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | \
      perl -ne '( $.>1 &&
                  $_ !~ /^\#line (467|477|486|1212|1308|1482|4308|4769|455)/o
                 ) && print' - | perltidy - | cpif $BIN/gff2aplot.pl ;
# reformating program with perltidy
notangle -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perltidy - | cpif $BIN/$nwfile.pl ;
# html pretty-printing program with perltidy
notangle -R"APLOT" \
    -filter '$BIN/PScompactnw.pl "POSTSCRIPT|PSFunction|PSVariables"' \
    $WORK/$nwfile.nw | perltidy -html - | cpif $DOCS/html/$nwfile.html ;
#
@ 


\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
@

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
# extracting main document processors
notangle -R"weaving"    $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -R"LaTeXing"   $WORK/$nwfile.nw | cpif $WORK/ltx ;
notangle -R"The Manual" $WORK/$nwfile.nw | cpif $WORK/mkdoc ;
#
@

[[cpif]] is an auxiliary tool for use with [[notangle]] and [[make]]. [[cpif]] compares its standard input to each of the named files, overwriting the file if the comparison succeeds or if the named file does not exist.

<<tangling complementary LaTeX files>>=
# extracting complementary material 
echo "Extracting \"$DOCS/defs.tex\"..." 1>&2 ;
notangle -R"HIDE: LaTeX aplot new definitions" $WORK/$nwfile.nw | \
         noweave -v -t4 -delay - | cpif $DOCS/defs.tex ;
echo "Extracting \"$DOCS/todo.tex\"..." 1>&2 ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | \
         noweave -v -t4 -delay - | cpif $DOCS/todo.tex ;
echo "Extracting \"$DOCS/localrefs.bib\"..." 1>&2 ;
notangle -R"HIDE: BiBTeX references" $WORK/$nwfile.nw | \
         cpif $DOCS/localrefs.bib ;
#
@ 

<<tangling complementary LaTeX files for manual>>=
# extracting tables for the documentation
echo "Extracting \"$DOCS/DataStructure_GFF.tex\"..." 1>&2 ;
notangle -R"HIDE: GFF DATA STRUCTURE" $WORK/$nwfile.nw | \
         cpif $DOCS/tables/DataStructure_GFF.tex ;
#
@ 

[[noweave]] options:

\begin{tabular}{>{\bfseries}rp{14cm}}\hline
[[-v]] & be verbose. \\
[[-t4]] & tabs are made of 4 spaces. \\
[[-delay]] & putting file-name and other information into the output before the first chunk of the  program, enabling a user to put a specialized \LaTeX [[\documentclass]] command and other preamble material in the first documentation chunk. It also forces trailing cross-referencing information to be emitted just before the final chunk, instead of at the end of the document; the final chunk is expected to contain [[\end{document}]]. Also implies [[-n]] option, meanning not to wrap the output with a \LaTeX header/trailer. \\
\multicolumn{2}{l}{[[-filter 'elide "HIDE: *"']]} \\
 & this filter removes those code chunks we define in the pattern, in this case those starting with `[[HIDE: *]]'. \\
[[-index]] & \\\hline
\end{tabular}

<<weaving>>=
<<BASH shebang>>
#
### weaving and LaTeXing
#
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
# extracting main documentation
echo "Weaving \"$DOCS/$nwfile.tex\"..." ;
noweave -v -t4 -delay -index -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# LaTeXing 
echo "LaTeXing \"$DOCS/$nwfile.tex\"..." ;
pushd $DOCS/ ;
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
popd;
<<BASH script closure>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
#
### only LaTeXing
#
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
# ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script closure>>
@ %$

<<The Manual>>=
<<BASH shebang>>
#
### weaving and LaTeXing DOCUMENTATION
#
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
<<tangling complementary LaTeX files for manual>>
#
MANUAL="GFF2APLOT_MANUAL";
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $MANUAL.tex" 1>&2 ;
latex $MANUAL.tex ; 
latex $MANUAL.tex ; 
latex $MANUAL.tex ;
dvips $MANUAL.dvi -o $MANUAL.ps -t a4 ;
#
# echo "### CONVERTING PS to PDF: $MANUAL" 1>&2 ;
# ps2pdf $MANUAL.ps $MANUAL.pdf ;
#
popd ;
<<BASH script closure>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
# Global Variables
WORK="$HOME/development/softjabril/gfftools/gff2aplot" ;
BIN="$WORK/bin" ;
PARAM="$BIN/param" ;
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
nwfile="gff2aplot" ;
export WORK BIN PARAM DOCS DATA TEST nwfile ;
@ 

<<tangling>>=
#
# BASH Environment Variables
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
source $WORK/.bash_VARS ;
#
@

\newpage

\sctn{Code chunks list}

\nowebchunks

\end{document}
