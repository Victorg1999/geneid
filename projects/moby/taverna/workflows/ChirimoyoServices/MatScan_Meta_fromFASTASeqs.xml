<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:9BP7U5ZD7B29" author="" title="" />
  <s:processor name="map2" boring="true">
    <s:stringconstant>map2</s:stringconstant>
  </s:processor>
  <s:processor name="map1" boring="true">
    <s:stringconstant>map1</s:stringconstant>
  </s:processor>
  <s:processor name="MobyChangeArticleName">
    <s:beanshell>
      <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(input));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");

NodeList[] globalS={nodelist1an,nodelist1a};
NodeList[] globalC={nodelist1bn,nodelist1b,nodelist1cn,nodelist1c};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	if(globalS[gi].getLength()&gt;0) {
		Node found=globalS[gi].item(0);
		// Skipping Simples inside collections
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		Node changed=docsalida.importNode(found,true);
		changed.setAttribute("articleName",articleName);
		comienzo.appendChild(changed);
		break;
	}
}

if(gi==maxgi) {
	for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
		if(globalC[gi].getLength()&gt;0) {
			Node found=globalC[gi].item(0);
			// Skipping Simples inside collections
			Node changed=docsalida.importNode(found,true);
			changed.setAttribute("articleName",articleName);
			comienzo.appendChild(changed);
			break;
		}
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

output = OutObj;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/xml'">input</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/xml'">output</s:beanshelloutput>
      </s:beanshelloutputlist>
    </s:beanshell>
  </s:processor>
  <s:processor name="ChangeMatScanArticleName_1">
    <s:beanshell>
      <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(input));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");

NodeList[] globalS={nodelist1an,nodelist1a};
NodeList[] globalC={nodelist1bn,nodelist1b,nodelist1cn,nodelist1c};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	if(globalS[gi].getLength()&gt;0) {
		Node found=globalS[gi].item(0);
		// Skipping Simples inside collections
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		Node changed=docsalida.importNode(found,true);
		changed.setAttribute("articleName",articleName);
		comienzo.appendChild(changed);
		break;
	}
}

if(gi==maxgi) {
	for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
		if(globalC[gi].getLength()&gt;0) {
			Node found=globalC[gi].item(0);
			// Skipping Simples inside collections
			Node changed=docsalida.importNode(found,true);
			changed.setAttribute("articleName",articleName);
			comienzo.appendChild(changed);
			break;
		}
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

output = OutObj;</s:scriptvalue>
      <s:beanshellinputlist>
        <s:beanshellinput s:syntactictype="'text/xml'">input</s:beanshellinput>
        <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
      </s:beanshellinputlist>
      <s:beanshelloutputlist>
        <s:beanshelloutput s:syntactictype="'text/xml'">output</s:beanshelloutput>
      </s:beanshelloutputlist>
    </s:beanshell>
  </s:processor>
  <s:processor name="Create_fasta_object_1">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.CreateMobyData</s:local>
  </s:processor>
  <s:processor name="create_fasta_object_2">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.CreateMobyData</s:local>
  </s:processor>
  <s:processor name="runMatScanGFF_2">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. You can search for example the Transfac database, but also MEME or jaspar matrices. This service only accepts a simple DNASequence object and returns a simple GFF object</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFF</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="fromFASTAtoGenericSequence_1">
    <s:description>Converts a sequence in Fasta format into a GenericSequence object</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>fromFASTAtoGenericSequence</s:serviceName>
      <s:authorityName>www.pcm.uam.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="fromFASTAtoGenericSequence_2">
    <s:description>Converts a sequence in Fasta format into a GenericSequence object</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>fromFASTAtoGenericSequence</s:serviceName>
      <s:authorityName>www.pcm.uam.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMetaAlignment">
    <s:description>Promoter regions analysis program. Meta-alignment produces alignments of sequences of TF binding sites. Use runMatScanGFF to produce the input GFF files</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMetaAlignment</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMatScanGFF_1">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. You can search for example the Transfac database, but also MEME or jaspar matrices. This service only accepts a simple DNASequence object and returns a simple GFF object</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://chirimoyo.ac.uma.es/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFF</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:link source="id_1" sink="Create_fasta_object_1:id" />
  <s:link source="id_2" sink="create_fasta_object_2:id" />
  <s:link source="namespace" sink="Create_fasta_object_1:namespace" />
  <s:link source="namespace" sink="create_fasta_object_2:namespace" />
  <s:link source="sequence_fasta_1" sink="Create_fasta_object_1:stringvalue" />
  <s:link source="sequence_fasta_2" sink="create_fasta_object_2:stringvalue" />
  <s:link source="ChangeMatScanArticleName_1:output" sink="MatScan_Moby_1" />
  <s:link source="ChangeMatScanArticleName_1:output" sink="runMetaAlignment:GFF(map1)" />
  <s:link source="Create_fasta_object_1:mobydata" sink="fromFASTAtoGenericSequence_1:FASTA(_ANON_)" />
  <s:link source="MobyChangeArticleName:output" sink="MatScan_Moby_2" />
  <s:link source="MobyChangeArticleName:output" sink="runMetaAlignment:GFF(map2)" />
  <s:link source="create_fasta_object_2:mobydata" sink="fromFASTAtoGenericSequence_2:FASTA(_ANON_)" />
  <s:link source="fromFASTAtoGenericSequence_1:GenericSequence(_ANON_)" sink="runMatScanGFF_1:DNASequence(upstream_sequences)" />
  <s:link source="fromFASTAtoGenericSequence_2:GenericSequence(_ANON_)" sink="runMatScanGFF_2:DNASequence(upstream_sequences)" />
  <s:link source="map1:value" sink="ChangeMatScanArticleName_1:articleName" />
  <s:link source="map2:value" sink="MobyChangeArticleName:articleName" />
  <s:link source="runMatScanGFF_1:GFF(matscan_predictions)" sink="ChangeMatScanArticleName_1:input" />
  <s:link source="runMatScanGFF_2:GFF(matscan_predictions)" sink="MobyChangeArticleName:input" />
  <s:link source="runMetaAlignment:output" sink="Meta_Moby_output" />
  <s:source name="id_1" />
  <s:source name="id_2" />
  <s:source name="namespace" />
  <s:source name="sequence_fasta_1" />
  <s:source name="sequence_fasta_2" />
  <s:sink name="Meta_Moby_output" />
  <s:sink name="MatScan_Moby_1" />
  <s:sink name="MatScan_Moby_2" />
</s:scufl>


