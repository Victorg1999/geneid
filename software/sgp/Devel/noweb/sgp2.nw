% -*- mode: Noweb; noweb-code-mode: perl-mode -*-
\documentclass[10pt]{article}
% 
% I'm trying to learn Literate Programming. I will use sgp2 as an LP exercise.
%
% The same document contains the code which will be generated with the proper filter:
%
%   pqtangle -L sgp2.tex
%
% The project documentation is also available from the same file:
%
%   latex sgp2.tex; dvips sgp2.dvi -o sgp2.ps  # to obtain the PS version 
%
%   pdflatex sgp2.tex;                         # to obtain the PS version
%
% $Id: sgp2.nw,v 1.3 2000-10-11 19:10:27 jabril Exp $
%  
\usepackage{noweb,multicol}
\usepackage[offset={0pt,0pt},hmargin={2.5cm,2cm},vmargin={1cm,0.25cm}]{geometry}
\noweboptions{smallcode}
% relax page breaking scheme
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\par

\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}

\newcommand{\cd}[1]{\texttt{\textbf{#1}}} % program<code> font style definition
\newcommand{\cv}[1]{\texttt{\textsl{#1}}} % program<vars> font style definition
\newcommand{\cp}[1]{\textit{#1}} % program<vars> font style definition

\newcommand{\sgp}{[[sgp2]]} % PROGRAM alias

% TITLE
\title{Sintenic Gene Prediction Tool}
\author{Josep F. Abril\\Roderic Guig\'o} %'

\begin{document}

\maketitle

\begin{center}
{\Large\sgp}\\[1ex]
{\large\verb+$Id: sgp2.nw,v 1.3 2000-10-11 19:10:27 jabril Exp $+}\\[2ex]
\end{center}

\begin{abstract}
The initial goal for Josep F. Abril will be to implement a \cd{perl} version of \sgp{}, which works like the current shell implementation. Secondary goals are to introduce myself into CVS (Concurrent Version Control) project management and Literate Programming (this document will serve as example).
\end{abstract}

\tableofcontents

\newpage

\sctn{Program Basic Outline}

Our initial program outline (our root chunk) looks like:\\[1ex]

<<sgp2.pl>>=
<<shebang>>
<<version control>>
<<declare uses>>

### VARS ###

<<declare variables>>
<<define defaults>>

### SUBS ###

<<global subroutines>>
<<get options>>

### MAIN SUBS ###

<<run blast>>
<<extract HSPs>>
<<run geneid>>
<<graphical output>>

### MAIN LOOP ###

<<Main Loop>>

### EOF ###

<<POD man page trailer>>
@ % 

<<shebang>>=
#!/usr/bin/perl -w
<<copyleft>>
my $Start = time;
@  %def $Start

'\cd{perl -w}' prints all sorts of useful and interesting warning messages at compile time.

[[$Start]] %$
contains program starting time (seconds since \textsc{Unix} ``epoch''), which will be used by timing function to calculate for how long was running our program.

<<version control>>=
my $PROGRAM = "sgp2";
my @tmp_ver = split / +/, ' $Id: sgp2.nw,v 1.3 2000-10-11 19:10:27 jabril Exp $ ';
my $VERSION = "v$tmp_ver[3] [$tmp_ver[4] $tmp_ver[5] $tmp_ver[7]]";
@ %def $PROGRAM $VERSION @tmp_ver

Take into account that here is shown [[sgp2.nw]] versions, but once the perl script is extracted ([[noweb]]) and commited (CVS) then it follows [[sgp2.pl]] version numbering.

<<declare uses>>=
use strict;
@

``\cd{use strict;}'' restricts unsafe constructs, like attempting to use missed symbolic references ('\cv{refs}'), undeclared variables ('\cv{vars}') or not predeclared subroutine ('\cv{subs}').

\sctn{Main Program Loop}

<<Main Loop>>=
# get options
&Which_Options();
# main external program calls
&Run_Blast()   if $blast_flg;
&Extract_HSP() if $hsps_flg;
&Run_geneid()  if $geneid_flg;
&Make_Plots()  if $plots_flg; 
# timing
&get_exec_time(time);
# removing temporary files and exit
&clean_tmp();
exit(1);
@

\subsctn{Default values setting}

<<define defaults>>=
# some defaults
my $file_number = 0;
my $S_CUTOFF = 50;
my $SCF = 12; # substract to tblastx scores S_CUTOFF - SCF;
@ %def $NF $S_CUTOFF $SCF

[[$file_number]] used later to check whether the user provided two sequences or not. [[$S_CUTOFF]] and [[$SCF]] are used when the program parses [[tblastx]] output to rescore HSPs by subtracting [[$S_CUTOFF]] - [[$SCF]] to HSP scores.

<<define defaults>>=
# setting paths
my $SGP2   = '';
my $SGP2bin = "$SGP2/bin";
my $SGP2param = "$SGP2bin/param";
my $TMP    = '/tmp';
my $SGPTMP = "$TMP/sgp2_$$";
<<trap temporary files>>
@ %def $SGP2 $SGP2bin $SGP2param $TMP $SGPTMP
%$

[[$NF]] %$ 
is the number of input files.
[[$SGP2]] %$
defines main path to {\sgp} binaries, scripts and params.
[[$TMP]] %$ 
is the temporary working directory, and [[$SGPTMP]] %$ 
contains the prefix for temporal files that is set different by adding the process ID ([[$$]] in plain [[perl]], if ``[[use English;]]'' is given it can also be defined as [[$PROCESS_ID]] or [[$PID]]).

<<trap temporary files>>=
$SIG{INT}  = \&trap_signals;
$SIG{QUIT} = \&trap_signals;
$SIG{TERM} = \&trap_signals;
$SIG{CHLD} = 'IGNORE';
sub trap_signals() {
    # opendir(TDIR, $TMP) or die "Can't open directory $TMP: $!";
    # while (defined(my $file = readdir(TDIR)))
    &clean_tmp();
    die "WARNING !!! $PROGRAM has been stopped by user.";
}
@ %$

The following signals are trapped by our signal handler routine:
\begin{itemize}
\item [[SIGINT]] is normally triggered by Ctrl-C, requesting that a process interrupt what it's doing.%'
\item [[SIGQUIT]] is also generated by a terminal, usually Ctrl-$\backslash$, generating a core dump.
\item [[SIGTERM]] is sent by [[kill]] shell command when no signal name is explicitly given (think of it as a polite request for a process to die). 
\end{itemize}

\subsctn{Parsing Command-line Options}

<<declare uses>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling pass_through /;
@ 

\begin{description}
\desc{\cd{use Getopt::Long;}} This module implements an extended getopt function called \cd{GetOptions()}. This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options having long names instead of single letters are introduced with a double dash "\-\-". 

\desc{\cd{Getopt::Long::Configure qw(} \cv{bundling} \cv{pass\_through} \cd{);}} \cd{GetOptions} can be configured by calling subroutine \cd{Getopt::Long::Configure}. This subroutine takes a list of quoted strings, each specifying a configuration option to be set. Options can be reset by prefixing with \cv{no\_}. 

 \begin{description}
 \desc{\cv{bundling}} Support for bundling of command line options, as was the case with the more traditional single-letter approach (introduced with a single dash "-"), is provided but not enabled by default. 

 \desc{\cv{pass\_through}} Unknown options are passed through in \cd{@ARGV} instead of being flagged as errors. This makes it possible to write wrapper scripts that process only part of the user supplied options, and passes the remaining options to some other program.
 \end{description}
\end{description}

<<declare variables>>=
# GetOptions Variables
my ( $seq1, $seq2, $geneid_opt, $geneid_param, 
     $blast_opt, $score_cutoff, $shrink, $tbx,
     $hsp, $ofn, $ps_output, $verbose_flg, $help_flg );
@ %def $seq1 $seq2 $geneid_opt $geneid_param $blast_opt $score_cutoff $shrink $tbx $hsp $ofn $ps_output $verbose_flg $help_flg

Those variables will receive the values passed from command-line options in [[Which_Options()]] function.

<<declare variables>>=
my ($blast_flg, $hsps_flg, $geneid_flg, $plots_flg) = (1, 1, 1, 1);
@ %def $blast_flg $hsps_flg $geneid_flg $plots_flg

We initialize those flag variables to '1' in order to pass by default by all the main subroutines called from main loop. They will be modified by [[Which_Options()]] function.

<<get options>>=
# Parsing command-line options and processing its parameters.
<<getopts subs>>
sub Which_Options() {
    GetOptions( 
                "1=s"      => \$seq1         , # seqfile_1
                "2=s"      => \$seq2         , # seqfile_2
                "g"        => \$geneid_opt   , # geneid options      
                "P"        => \$geneid_param , # geneid parameter file 
                "o"        => \$blast_opt    , # tblastx options 
                "c"        => \$score_cutoff , # tblastx score cutoff 
                "s"        => \$shrink       , # shrink hsp's by
                "t"        => \$tbx          , # read tblastx from file
                "f"        => \$hsp          , # read HSP files in directory
                "k"        => \$ofn          , # intermediate filename
                "p"        => \$ps_output    , # postscript output 
                "v"        => \$verbose_flg  , # verbose    
                "h|help|?" => \$help_flg     , # print help
                );
    &prt_Help if $help_flg;
    <<set flags>>
}; # sub Which_Options
@ %def &Which_Options 

<<getopts subs>>=
# Checking input sequence files
sub exits_file() {
    my @files = @_;
    my ($n, $r) = ('', 0);
    foreach $n @files {
        $r++ if (-f $n && -T _);
    };
    return $r;
}
@

<<set flags>>=
$file_number = &exits_file($seq1, $seq2);
die "FATAL ERROR!!! Two sequences are needed (-1 and -2 options are mandatory): $!"
    unless $file_number == 2; 
$blast_flg  = 0;
$hsps_flg   = 0;
$geneid_flg = 0;
$plots_flg  = 0;
@


\subsctn{Printing help: [[prt_Help()]]}

<<declare uses>>=
use Pod::Text;
@

\cd{use Pod::Text;} This module converts POD data to formatted ASCII text. This defines the single function \cd{pod2text([\cv{-a},] [\cv{-width}\cp{N},] \cp{inputfile})}, that can take the following options: '\cv{-a}' for an alternative output format, '\cv{-width}' to set max terminal width. '\cp{inputfile}' must have POD format.

<<global subroutines>>=
# Prints help 
sub prt_Help() {
    my $tmp_pod_file = "$TMP/sgp.pod";
    open(KI, "> $tmp_pod_file");
    while (<DATA>) {
        s/\$PROGRAM/$PROGRAM/g ;
        s/\$VERSION/$tmp_ver[3]/g ;
        print KI $_ ;
    };
    close(KI);
    pod2text($tmp_pod_file);
    unlink($tmp_pod_file) or die "Can't delete $tmp_pod_file: $!\n";
    exit(1);
}
@ %def &prt_Help
%$

\cd{unlink()} This command deletes a list of files. Returns the number of files successfully deleted.

\subsctn{Some general subroutines}

<<declare uses>>=
<<declare variables>>=
<<global subroutines>>=
# Deleting temporary files on TMP
sub clean_tmp() {
    my @files = glob($SGPTMP."*");
    unlink(@files) or warn "Can't unlink @files : $? $!";
}
@ 
%$
The [[glob()]] function provides globbing (get a list of filenames using wildcards) with the \textsc{Unix} C-shell semantics.

<<global subroutines>>=
# Reporting IN/OUT progress.
sub prt_progress() {
    $verbose_flg && do {
        print STDERR ".";
        (($_[0] % 50) == 0) && print STDERR "[".&fill_left($_[0],6,"0")."]\n";
    };
}
#
sub prt_foeprg() {
    $verbose_flg && ((($_[0] % 50) != 0) && print STDERR "[".&fill_left($_[0],6,"0")."]\n" );
}
# Get a fixed length string from a given string and filling char/s.
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
# returns the max value from input array
sub max() { my ($z) = shift @_; my $l; foreach $l (@_) { $z = $l if $l > $z ; }; $z; } 
@ %def &prt_progress &prt_foeprg &fill_right &fill_left &max

\begin{description}
\desc{\cv{prt\_progress()}}
\desc{\cv{prt\_foeprg()}}
\desc{\cv{fill\_right()}}
\desc{\cv{fill\_left()}}
\desc{\cv{max()}}
\end{description}

<<global subroutines>>=
# Timing.
sub get_exec_time() {
    $verbose_flg && do {
        my $End = $_[0];
        my ($c,$s,$m,$h,$r);
        $r = $End - $Start;
        $s = $r % 60;
        $r = ($r - $s) / 60;
        $m = $r % 60;
        $r = ($r - $m) / 60;
        $h = $r % 24;
        ($s,$m,$h) = (&fill_left($s,2,"0"),&fill_left($m,2,"0"),&fill_left($h,2,"0"));
print STDERR <<EOF;
##
##########################################################
## \"$PROGRAM\"  Execution Time:  $h:$m:$s
##########################################################
EOF
    };
}
@ %def &get_exec_time
%$

[[get_exec_time()]]

\sctn{Running [[blast]] on sequences}

<<declare variables>>=
# Processes
my $status
# Blast 
my $BlastProgram = "tblastx";
my $PressdbProgram = "pressdb";
my $BlosumMatrix = "$SGP2param/blosum62mod"; 
my $BlastOptions = "-matrix $BlosumMatrix -hspmax=10000 -nogap";
my @pressdb = ( "$PressdbProgram" );
my @blast = ( "$BlastProgram" "$BlastOptions" );
@ %def $status $BlastProgram $PressdbProgram $BlosumMatrix $BlastOptions @pressdb $pressdb @blast $blast
%$

[[$BlastProgram]] %$
is set to [[tblastx]] because we are going to compare two nucleotide sequences at aminoacid level. [[tblastx]] first generates six frame translations for each sequence.
[[$PressDB]] %$
is the program to build a [[blast]] database from a given set of sequences in fasta format.

We will run [[blast]] with the following parameters which are set in [[$BlastOptions]]:%$
\begin{description}
\desc{\cv{-matrix} \cp{\$BlosumMatrix}} [[blosum62mod]] defined in [[$BlosumMatrix]] %$
is a blosum matrix where stop codon score has been modified to forbide stop codons within HSP alignments.
\desc{\cv{-hspmax=}\cp{value}} Here ``\cp{value}'' is set to 10000, to allow finding as much HSPs as possible.
\desc{\cv{-nogap}} This option forces [[blast]] to avoid any gap within the HSP alignment.
\end{description}

[[@blast]] is a multivalued list that is interpreted by [[system]] function in a safe way (safe from expanding wildcards or splitting up words with whitespace in them) as an indirect object. 

<<run blast>>=
# Runnig blast
sub Run_Blast() {
    $status = system { $pressdb[0] } @pressdb;
    die "FATAL ERROR !!! $? $!\n  Unsuccessful PRESSDB command : @pressdb \n" unless $status == 0;
    $status = system { $blast[0] } @blast;
    die "FATAL ERROR !!! $? $!\n  Unsuccessful BLAST command : @blast \n" unless $status == 0;
} # END_SUB: Run_Blast
@ %def &Run_Blast
%$

\sctn{Processing HSPs from [[blast]]}

<<extract HSPs>>=
# Extracting HSPs
sub Extract_HSP() {
} # END_SUB: Extract_HSP
@ %def &Extract_HSP

\sctn{Running [[geneid]] on SRs}

<<declare variables>>=
# geneid
my $GeneidProgram = "$SGP2bin/geneid.v1.0-sgp/bin/geneid";
my $GeneidParam   = "$SGP2bin/geneid.v1.0-sgp/param/human3iso.param";
my $GeneidOptions = "-GP $GeneidParam";
my @geneid = ( "$GeneidProgram" "$GeneidOptions" );
@ %def $GeneidProgram $GeneidParam $GeneidOptions @geneid $geneid

[[$GeneidParam]] %$
is set to [[human3iso.param]]. This parameter file defines three Markov models for three differnt isochores of G+C content. A Markov chain of order two for defining the start sites, another one of order one for the acceptors and a Position Weight Matrix (PWM) donors. The gene model used by [[geneid]] to assemble predicted exons into the best solution, is also defined within that parameter file. 

We will run [[geneid]] with the following parameters which are set in [[$GeneidOptions]] %$
\begin{description}
\desc{\cv{-G}} Print output predictions in GFF-format.
\desc{\cv{-P} \cp{param\_file}} Read parameters from \cp{param\_file}
\desc{\cv{-S} \cp{similarity\_file}} Run [[geneid]] predictions with similarity regions file.
\end{description}

<<run geneid>>=
# Running geneid
sub Run_geneid() {
    $status = system { $geneid[0] } @geneid;
    die "FATAL ERROR !!! $? $!\nUnsuccessfull GENEID command : @geneid \n" unless $status == 0;
} # END_SUB: Run_geneid
@ %def &Run_geneid

\sctn{Obtaining figures}

<<declare variables>>=
# gff2ps and aplot
@ %def 
<<graphical output>>=
# Running gff2ps and aplot
sub Make_Plots() {
    $status = system { $gff2ps[0] } @gff2ps;
    die "FATAL ERROR !!! $? $!\nUnsuccessfull GFF2PS command : @gff2ps \n" unless $status == 0;
    $status = system { $aplot[0] } @aplot;
    die "FATAL ERROR !!! $? $!\nUnsuccessfull APLOT command : @aplot \n" unless $status == 0;
} # END_SUB: Make_Plots
@ %def &Make_Plots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%APPENDIX

\newpage
\appendix

\sctn{Literate Programming}\vspace{2ex}

\begin{small}
\begin{quote}\slshape
I believe that the time is ripe for significantly better documentation
of programs, and that we can best achieve this by considering programs
to be works of literature. Hence, my title: "Literate Programming."
Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
*computer* what to do, let us concentrate rather on explaining to
*human beings* what we want a computer to do.
\upshape\flushright --- \textbf{Donald Knuth}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
Without wanting to be elitist, the thing that will prevent Literate
Programming from becoming a mainstream method is that it requires
thought and discipline. The mainstream is established by people who
want fast results while using roughly the same methods that everyone
else seems to be using, and Literate Programming is never going to
have that kind of appeal. This doesn't take away from its usefulness
as an approach.
\upshape\flushright --- \textbf{Patrick TJ McPhee}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
A basic principle of data processing teaches the folly of trying to
maintain independent files in synchronism. It is far better to combine
them into one file with each record containing all the information
both files held concerning a given key.  Yet our practice in
programming documentation violates our own teaching. We typically
attempt to maintain a machine-readable form of a program and an
independent set of human-readable documents, consisting of prose and
flow charts. The results in fact confirm our teachings about the folly
of separate files.  Program documentation is notoriously poor, and its
maintenance is worse.  Changes made in the program do not promptly,
accurately, and invariably appear in the paper. The solution, I think,
is to merge the files, to incorporate the documentation in the source
program. This is at once a powerful incentive toward proper
maintenance, and an insurance that the documentation will always be
handy to the program user. Such programs are called
self-documenting...  
\upshape\flushright --- \textbf{Frederick Brooks}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
Top-down design and successive refinement attack a programming task by
specifying it in the most general terms, then expanding these into
more and more specific and detailed actions, until the whole program
is complete. Structured design is the process of controlling the
overall design of a system or program so the pieces fit together
neatly, yet remain sufficiently decoupled that they may be
independently modified.  ... Each of these disciplines can materially
improve programmer productivity and the quality of code produced.
\upshape\flushright --- \textbf{Kernighan and Plauger}
\end{quote}\vspace{4ex}
\end{small}

We shall call our program \sgp{}, we are developing a parallel branch
for Sintenic Gene-Prediction, the other branch is developed by Thomas
Wiehe. Our new version is written as a [[noweb]] file named
[[sgp2.nw]]. From that file we can obtain both the code and the
documentation. A short script named [[aol]] converts the '[[.nw]]' to
'[[.tex]]' ---the \LaTeX{} documentation--- and '[[.pl]]' ---the real
program--- (Wow!!!). What [[aol]] does is:

\begin{enumerate}
\item Extracts program code from the [[noweb]] file:\\[1ex]
[[notangle -L -Rsgp2.pl sgp2.nw > sgp2.tmp]]
\item Swaps first line ([[#line]]) with second ([[#!/]]\ldots) to make it runnable:\\[1ex]
[[perl -ne '$. > 2  && do { print; next }; 
          $. == 1 && do { split / /, $_, 3; $n = "$_[0] ".(++$_[1])." $_[2]"};
          $. == 2 && ( print "$_$n" );
         ' sgp2.tmp > sgp2.pl]]
\item Extracts program documentation and \LaTeX{}'ing it:\\[1ex]
[[noweave -x sgp2.nw > sgp2.tex]]\\[1ex]
[[latex sgp2.tex ; dvips sgp2.dvi -o sgp2.ps]]
\end{enumerate}

\newpage

\sctn{License Terms}

This program is distributed under GNU General Public License as described below:\\[2ex]

<<copyleft>>=
######################################################################
#                               sgp2                                 #
######################################################################
#
#     Sinteny based Gene Prediction tool.
#
#     Copyright (C) 2000 - Josep Francesc ABRIL FERRANDO
#                                 Roderic GUIGO SERRA
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
@

\newpage

\sctn{Man Pages}

The documentation for [[perl]] programs is written in a simple markup language called POD (Plain Old Documentation). Translators exist for [[pod2man]], [[pod2text]], [[pod2html]], [[pod2latex]], and [[pod2fm]]. 

The idea is to have the online documentation included with the source. That is possible with [[__DATA__]] tag, which defines a chunk of data within the same file.
%% TODO: define POD tags and which style was used for building up this man. 

<<POD man page trailer>>=
__DATA__
=head1 NAME

    
$PROGRAM ($VERSION) - Improving Gene Prediction with Sinteny.

=head1 SYNOPSIS

    
    $PROGRAM [-hv] [-o 'options'] [-g 'options'] \
      [-P filename] [-p filename] [-k filename] \
      [-c value] [-s value] -1 seqfile_1 -2 seqfile_2

=head1 DESCRIPTION

=head1 OPTIONS

    

=over 4

=item B<-1> I<seqfile_1>

input file for first species.

=item B<-2> I<seqfile_2>

input file for second species.

=item B<-g>

geneid options

=item B<-o>

tblastx options

=item B<-c> I<value>

tblastx score cuttof

=item B<-s> I<value>

shrink hsp\'s by value

=item B<-t> I<filename>

read tblastx file

=item B<-f> I<prefix>

read hsp gff files with in directory prefix and extension .hsp-rs

=item B<-k> I<prefix>

keep intermediate files with prefix

=item B<-p> I<filename>

ps output in filename file 

=item B<-P> I<filename>

geneid parameter file

=item B<-v>

verbose mode

=item B<-h>

produces this message

=back

=head1 FILES

=head1 DIAGNOSTICS

=head1 REQUIRES

=head1 BUGS

    
Report any problem to: B<jabril@imim.es>

=head1 AUTHOR

    
Roderic Guigo   : B<rguigo@imim.es>

Josep F. Abril  : B<jabril@imim.es>

B<$PROGRAM> is under GNU-GPL (C) 2000
@ %$

\end{document}


