#
# $Id: boxplots.readme,v 1.1 2002-08-09 14:49:03 jabril Exp $
#

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
## bxp(z, notch = FALSE, width = NULL, varwidth = FALSE, notch.frac = 0.5,
##     border = par("fg"), col = NULL, log = "", pars = NULL, ...)
> body(bxp) ## 
{
    bplt <- function(x, wid, stats, out, conf, notch, border,
        col) ## bplt
    {
        ## Draw single box plot.
        # from bxp(...).
        pars <- c(pars, list(...))
        if (!any(is.na(stats))) {
            ## stats = +/- Inf:  polygon & segments should handle
            wid <- wid/2
            if (notch) {
                xx <- x + wid * c(-1, 1, 1, notch.frac, 1, 1,
                  -1, -1, -notch.frac, -1)
                yy <- c(stats[c(2, 2)], conf[1], stats[3], conf[2],
                  stats[c(4, 4)], conf[2], stats[3], conf[1])
                polygon(xx, yy, col = col, border = border)
                segments(x - wid/2, stats[3], x + wid/2, stats[3],
                  col = border)
            }
            else {
                xx <- x + wid * c(-1, 1, 1, -1)
                yy <- stats[c(2, 2, 4, 4)]
                polygon(xx, yy, col = col, border = border)
                segments(x - wid, stats[3], x + wid, stats[3],
                  col = border)
            }
            segments(rep(x, 2), stats[c(1, 5)], rep(x, 2), stats[c(2,
                4)], lty = "dashed", col = border)
            segments(rep(x - wid/2, 2), stats[c(1, 5)], rep(x +
                wid/2, 2), stats[c(1, 5)], col = border)
            points(rep(x, length(out)), out, col = border)
            if (any(inf <- !is.finite(out))) {
                ## FIXME: should MARK on plot !! (S-plus doesn't either)
                warning(paste("Outlier (", paste(unique(out[inf]),
                  collapse = ", "), ") in ", paste(x, c("st",
                  "nd", "rd", "th")[pmin(4, x)], sep = ""), " boxplot are NOT drawn",
                  sep = ""))
            }
        }
    } # bplt
    if (!is.list(z) || 0 == (n <- length(z)))
        stop("invalid first argument")
    limits <- numeric(0)
    nmax <- 0
    for (i in 1:n) {
        nmax <- max(nmax, z[[i]]$n)
        limits <- range(limits, z[[i]]$stats[is.finite(z[[i]]$stats)],
            z[[i]]$out[is.finite(z[[i]]$out)])
    }
    width <- if (!is.null(width)) {
        if (length(width) != n | any(is.na(width)) | any(width <=
            0))
            stop("invalid boxplot widths")
        0.8 * width/max(width)
    }
    else if (varwidth)
        0.8 * sqrt(unlist(lapply(z, "[[", "n"))/nmax)
    else if (n == 1)
        0.4
    else rep(0.8, n)
    if (is.null(pars$ylim))
        ylim <- limits
    else {
        ylim <- pars$ylim
        pars$ylim <- NULL
    }
    if (missing(border) || length(border) == 0)
        border <- par("fg")
    plot.new()
    plot.window(xlim = c(0.5, n + 0.5), ylim = ylim, log = log)
    for (i in 1:n) bplt(i, wid = width[i], stats = z[[i]]$stats,
        out = z[[i]]$out, conf = z[[i]]$conf, notch = notch,
        border = border[(i - 1)%%length(border) + 1], col = if (is.null(col))
            col
        else col[(i - 1)%%length(col) + 1])
    axes <- is.null(pars$axes)
    if (!axes) {
        axes <- pars$axes
        pars$axes <- NULL
    }
    if (axes) {
        if (n > 1)
            axis(1, at = 1:n, labels = names(z))
        axis(2)
    }
    do.call("title", pars)
    box()
    invisible(1:n)
}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
## boxplot.stats(x, coef = 1.5, do.conf=TRUE, do.out=TRUE)
> body("boxplot.stats")
{
    nna <- !is.na(x)
    # including +/- Inf
    n <- length(nna)
    stats <- fivenum(x, na.rm = TRUE)
    iqr <- diff(stats[c(2, 4)])
    out <- x < (stats[2] - coef * iqr) | x > (stats[4] + coef *
        iqr)
    if (coef > 0)
        stats[c(1, 5)] <- range(x[!out], na.rm = TRUE)
    conf <- if (do.conf)
        stats[3] + c(-1.58, 1.58) * diff(stats[c(2, 4)])/sqrt(n)
    list(stats = stats, n = n, conf = conf, out = if (do.out) x[out &
        nna] else numeric(0))
}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
## boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE,
##         notch = FALSE, names.x, data = sys.frame(sys.parent()),
##         plot = TRUE, border = par("fg"), col = NULL, log = "",
##         pars = NULL)
> body("boxplot.default")
{
    args <- list(x, ...)
    namedargs <- if (!is.null(attributes(args)$names))
        attributes(args)$names != ""
    else rep(FALSE, length = length(args))
    pars <- c(args[namedargs], pars)
    groups <- if (is.language(x)) {
        if (inherits(x, "formula") && length(x) == 3) {
            groups <- eval(x[[3]], data, sys.frame(sys.parent()))
            x <- eval(x[[2]], data, sys.frame(sys.parent()))
            split(x, groups)
        }
    }
    else {
        groups <- args[!namedargs]
        if (length(groups) == 1 && is.list(x))
            x
        else groups
    }
    if (0 == (n <- length(groups)))
        stop("invalid first argument")
    if (length(class(groups)))
        groups <- unclass(groups)
    if (!missing(names.x))
        attr(groups, "names") <- names.x
    else if (is.null(attr(groups, "names")))
        attr(groups, "names") <- 1:n
    # do.conf=notch)
    for (i in 1:n) groups[i] <- list(boxplot.stats(groups[[i]],
        range))
    if (plot) {
        bxp(groups, width, varwidth = varwidth, notch = notch,
            border = border, col = col, log = log, pars = pars)
        invisible(groups)
    }
    else groups
}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
> data(insects)
> boxplot(count ~ spray, data = insects, col = "lightgray")
> x <- c(1:100, 1000)
> str(boxplot.stats(x))
List of 4
 $ stats: num [1:5] 1 26 51 76 100
 $ n    : int 101
 $ conf : num [1:2] 43.1 58.9
 $ out  : num 1000

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
BOXPLOT.STATS - Usage

boxplot.stats(x, coef = 1.5, do.conf=TRUE, do.out=TRUE)

Arguments

 x 
                 a numeric vector for which the boxplot will be constructed (NAs and NaNs are allowed and omitted). 

 coef 
                 this determines how far the plot ``whiskers'' extend out from the box. If coef is positive, the whiskers extend to the most extreme data point which is no more than coef times the interquartile coef from the box. A value of zero causes the whiskers to extend to the data extremes. 

 do.conf,do.out 
                 logicals; if FALSE, the conf or out component respectively will be empty in the result. 


Description

This function is typically is called by boxplot to gather the statistics necessary for producing box plots, but may be invoked separately.

Value

List with named components as follows: 

 stats 
        a vector of length 5, containing the extreme of the lower whisker, the lower ``hinge'', the median, the upper ``hinge'' and the extreme of the upper whisker. 

 n 
        the number of of non-NA observations in the sample. 

 conf 
        the lower and upper extremes of the ``notch''. 

 out 
        the values of any data points which lie beyond the extremes of the whiskers. 


Note that $stats and $conf are sorted increasingly, contrary to S, and that $n and $out include any +- Inf values.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
BXP - Usage

bxp(z, notch = FALSE, width = NULL, varwidth = FALSE, notch.frac = 0.5,
    border = par("fg"), col = NULL, log = "", pars = NULL, ...)

Arguments

 z 
             a list containing data summaries to be used in constructing the plots. These are usually the result of a call to boxplot, but can be generated in any fashion. 

 notch 
             if notch is TRUE, a notch is drawn in each side of the boxes. If the notches of two plots do not overlap then the medians are significantly different at the 5 percent level. 

 width 
             a vector giving the relative widths of the boxes making up the plot. 

 varwidth 
             if varwidth is TRUE, the boxes are drawn with widths proportional to the square-roots of the number of observations in the groups. 

 notch.frac 
             numeric in (0,1). When notch=TRUE, the fraction of the box width that the notches should use. 

 border 
             character, the color of the box borders. Is recycled for multiple boxes. 

 col 
             character; the color within the box. Is recycled for multiple boxes 

 log 
             character, indicating if any axis should be drawn in logarithmic scale, as in plot.default. 

 pars,... 
             Graphical parameters can be passed as arguments to this function, either as a list (pars) or normally(...). 


Description

bxp(..) draws box plots based on the given summaries in z. It is usually called from within boxplot(..), but can be invoked directly.

Value

An invisible vector with the x-coordinates of box centers, useful for adding to the plot.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
BOXPLOT - Usage

boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE,
        notch = FALSE, names.x, data = sys.frame(sys.parent()),
        plot = TRUE, border = par("fg"), col = NULL, log = "",
        pars = NULL)

Arguments

 x, ... 
            the data from which the boxplots are to be produced. The data can be specified as separate vectors, each corresponding to a component boxplot, or as a single list containing such vectors. Alternatively a symbolic specification of the form x ~ g can be given, indicating that the observations in the vector x are to be grouped according to the levels
            of the factor g. In this case the argument data can be used to provide values for the variables in the specification. NAs are allowed in the data. 
 range 
            this determines how far the plot whiskers extend out from the box. If range is positive, the whiskers extend to the most extreme data point which is no more than range times the interquartile range from the box. A value of zero causes the whiskers to extend to the data extremes. 

 width 
            a vector giving the relative widths of the boxes making up the plot. 

 varwidth 
            if varwidth is TRUE, the boxes are drawn with widths proportional to the square-roots of the number of observations in the groups. 

 notch 
            if notch is TRUE, a notch is drawn in each side of the boxes. If the notches of two plots do not overlap then the medians are significantly different at the 5 percent level. 

 names.x 
            group labels which while be printed under each boxplot. 

 data 
            data.frame, list, or environment in which variable names are evaluated when x is a formula. 

 plot 
            if TRUE (the default) then a boxplot is produced. If not, the summaries which the boxplots are based on are returned. 

 border 
            an optional vector of colors for the outlines of the boxplots. The values in border are recycled if the length of border is less than the number of plots. 

 col 
            if col is non-null it is assumed to contain colors to be used to col the bodies of the box plots. 

 log 
            character indicating if x- or y- or both coordinates should be plotted in log scale. 

 pars, ... 
            graphical parameters can also be passed as arguments to boxplot. 


Description

Produce box-and-whisker plot(s) of the given (grouped) values.

Value

List with one component corresponding to each plot. The components are themselves lists with named components as follows: 

 stats 
        a vector containing the extreme of the lower whisker, the lower hinge, the median, the upper hinge and the extreme of the upper whisker. 

 n 
        the number of observations in the sample. 

 conf 
        the lower and upper extremes of the notch. 

 out 
        the values of any data points which lie beyond the extremes of the whiskers. 


#############################################################
Z <- data.frame(cbind(OBS       = as.character(W$SEQ),
                      FACTOR    = as.character(W$PROGRAM),
                      SUBFACTOR = as.character(W$TESTSET),
                      VAR       = (W$SP)
                      )
                )
Za <- split(Z,Z$SUBFACTOR)


K <- list(
       OBS       = cbind(ORDER    = c("a","b","c"),
                         LABEL    = c("A","B","C")
                         ),
       SUBFACTOR = cbind(ORDER    = c("1","2","3","4"),
                         LABEL    = c("I","V","X","D")
                         ),
       FACTOR    = cbind(ORDER    = c("0","1","2"),
                         LABEL    = c("Z","O","T"),
                         COLOR    = c(rainbow(3, s = 1   , v = 1)),
                         OBSCOLOR = c(rainbow(3, s = 0.50, v = 1)),
                         SUBCOLOR = c(rainbow(3, s = 0.25, v = 1))
                         )
       )
> K
$OBS
     ORDER LABEL
[1,] "a"   "A"
[2,] "b"   "B"
[3,] "c"   "C"

$SUBFACTOR
     ORDER LABEL
[1,] "1"   "I"
[2,] "2"   "V"
[3,] "3"   "X"
[4,] "4"   "D"

$FACTOR
     ORDER LABEL COLOR     OBSCOLOR  SUBCOLOR
[1,] "0"   "Z"   "#FF0000" "#FF7F7F" "#FFBFBF"
[2,] "1"   "O"   "#FFFF00" "#FFFF7F" "#FFFFBF"
[3,] "2"   "T"   "#00FFFF" "#7FFFFF" "#BFFFFF"

#############################################################
plot.new()
plot(0:20,0:20, type='n')
for (i in 1:3) rect(i*2.5, i*2.5, i*2.5+2.5, i*2.5+2.5, col=K$FACTOR[i,"COLOR"])
for (i in 1:3) rect((i)*2.5, (i+1)*2.5, (i)*2.5+2.5, (i+1)*2.5+2.5, col=K$FACTOR[i,"SUBCOLOR"])
for (i in 1:3) rect((i)*2.5, (i-1)*2.5, (i)*2.5+2.5, (i-1)*2.5+2.5, col=K$FACTOR[i,"OBSCOLOR"])

#############################################################

Q<-list()
for (i in 1:nrow(Z)) Q[paste(Z$OBS[[i]],
                             Z$FACTOR[[i]],
                             Z$SUBFACTOR[[i]],sep="::" )] <- Z$VAR[[i]]
n<-1
q <- list()
 for (i in names(Q)) {
  l <- strsplit(i,"::")[[1]];
  if ( match("ENSEMBL",l[[3]],nomatch = 0)
	 & match("GENEID",l[[2]],nomatch = 0)) {
       # print(paste(i,as.vector(Q[i]),sep=" --> "));
	   q[n]<-Q[i];
       n<-n+1;
     };
  }
q<-as.real(q)
boxplot.stats(q)
> g[1]<-list(boxplot.stats(q,1.5))
> g[2]<-list(boxplot.stats(q,1.25))
> g[3]<-list(boxplot.stats(q,1))
> g[4]<-list(boxplot.stats(q,0.75))
> g[5]<-list(boxplot.stats(q,0.5))
> g[6]<-list(boxplot.stats(q,0.25))
> g[7]<-list(boxplot.stats(q,0.1))
> g[8]<-list(boxplot.stats(q,0.01))
> g[9]<-list(boxplot.stats(q,0))
> g[10]<-list(boxplot.stats(q,-0.5))
> bxp(g,notch=TRUE,col=rgb(1,1,0))

#############################################################

IPATH <- "/projects/H.sapiens/20011222.UCSCgp/evaluations/SGP-MGSCv3+RefSeqEvids/";
FILE <- "eval.test_summary";
WFILE <- paste(IPATH,FILE,"_CHR.tbl", sep="");
TFILE <- paste(IPATH,FILE,"_TOT.tbl", sep="");
W <- read.table(WFILE, header=TRUE, sep=" ", as.is=FALSE, na.strings="nan");
w <- split(W,W$TESTSET)
#
# tests <- levels(factor(W$TESTSET))
# length(levels(factor(w$ENSEMBL$PROG)))

#
Z <- data.frame(cbind(FACTOR    = as.character(W$PROGRAM),
                      SUBFACTOR = as.character(W$TESTSET),
                      ELEMENT   = as.character(W$SEQ),
                      VAR       = (W$SP)
                      )
                )
Za <- split(Z,Z$SUBFACTOR)

#
factor.ord <- c("GENSCAN","TWINSCAN","SGP-MGSCv3")
factor.lbl <- c("GENSCAN","TWINSCAN","SGP")
factor.col <- c()
#
# subfactor.ord <- c("HSAP","MMUS")
subfactor.ord <- c("REFSEQ","ENSEMBL")
subfactor.lbl <- c("Hsap","Mmus")
subfactor.col <- c()
#
chrs.Hsap <- c("1","2","3","4","5","6","7","8","9","10",
               "11","12","13","14","15","16","17","18","19","20",
               "21","22","X","Y")
chrs.Mmus <- c("1","2","3","4","5","6","7","8","9","10",
               "11","12","13","14","15","16","17","18","19",
               "X","Y")
#
SPECIES.factor <- list(
  .prop = list(
      ELNUM = length(factor.ord),
      ORDER = factor.ord, # is.vect
      LABEL = factor.lbl, # is.vect
      COLOR = factor.col, # is.vect
      FG.COLOR = NULL,
      BG.COLOR = NULL,
      LABEL.SHOW  = TRUE,
      LABEL.COLOR = "green",
      BASELINE.SHOW  = TRUE,
      BASELINE.COLOR = "orange",
      DATA.SHOW  = TRUE,
      DATA.COLOR = NULL
      ),
  .subfactor = list(
      .prop = list(
          ELNUM = length(subfactor.ord),
          ORDER = subfactor.ord,
          LABEL = subfactor.lbl,
          COLOR = subfactor.col,
          MEANS.left    = list( shw=FALSE,
                                lbl=NULL,
                                # shp=NULL,
                                # col=NULL,
                                # exp=NULL
                              ),
          MEANS.center  = list( shw=FALSE ),
          MEANS.right   = list( shw=FALSE ),
          TOTALS.left   = list( shw=FALSE ),
          TOTALS.center = list( shw=FALSE ),
          TOTALS.right  = list( shw=FALSE )
          ),
#      HSAP.prop = list(
      REFSEQ.prop = list(
          ELNUM = length(chrs.Hsap),
          ORDER = paste("chr",chrs.Hsap,sep=""),
          LABEL = chrs.Hsap,
          COLOR = "slateblue",
          DATA.COLOR = "cyan"
          ),
#      MMUS.prop = list(
      ENSEMBL.prop = list(
          ELNUM = length(chrs.Mmus),
          ORDER = paste("chr",chrs.Mmus,sep=""),
          LABEL = chrs.Mmus,
          COLOR = "purple",
          DATA.COLOR = "magenta"
          )
      ), # .subfactor list end
  GENSCAN.prop = list(
      FG.COLOR = "red",
      BG.COLOR = "greenyellow",
      BASELINE.SHOW = FALSE
      ),
  'SGP-MGSCv3.prop' = list(
      BG.COLOR = "cyan"
      ),
  TWINSCAN.prop = list(
      BG.COLOR = "yellow",
      LABEL.SHOW  = TRUE,
      LABEL.COLOR = "navyblue",
      BASELINE.SHOW  = TRUE,
      BASELINE.COLOR = "blue"
      )
  ) # SPECIES.factor
#
bpm.conf <- SPECIES.factor

# if (!is.null(bpm.conf$.F.prop$ELNUM)) print(paste("VECTOR HAS ",bpm.conf$.F.prop$ELNUM," ELEMENTS",sep="")) else print("VECTOR IS EMPTY"); 

nf <- layout(matrix(c(1,2,3,4),2,2, byrow=TRUE),
               widths=c(lcm(15),lcm(15)),
               heights=c(lcm(12),lcm(12)), respect=TRUE) ;

source("/usr/local/molbio/share/sgp/bin/bpm.R") ; 
t <- boxplot.multi(Z,bpm.conf=SPECIES.factor,notch=TRUE) ; 
str(t) 
