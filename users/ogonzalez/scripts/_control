# aquestes linies nomes serveixen per reactivar el servidor X de picard
# quan es penja (massa sovint...). nomes cal descomentar aquestes linies,
# i en la seguent execucio de l'script el servidor X arrencara. No queda
# en bones condicions, pero permet entrar i rebotar la maquina sense
# haver de recorrer al "botonazo" ni fer telnet de root. habil, eh?
#
# ******* TORNA A COMENTAR-LES DE SEGUIDA O DONARA ERRORS!!!! *******
#
# no recordo quina de les linies cal realment. potser amb la primera ja
# hi hagi prou. redirigeix "-error" cap a un fitxer en comptes de cap
# a /dev/null si vols veure de que es queixa el sistema
#
# /usr/vue/bin/vuelogin -daemon -error /dev/null
# mv /usr/vue/bin/vuerc.canvi /usr/vue/bin/vuerc
# /usr/vue/bin/vuelogin
#
# OBVIAMENT, AIXO NO TE RES A VEURE AMB EL PROGRAMA DE LES CUES !!!







# La comanda de calcular el temps nomes ha de fer aixo: calcular el temps.
# Es guarda la informacio sense format, i es fa servir l'altre programa
# per formatejar-la quan vulguem fer-hi una ullada.


# treballo amb quatre fitxers:
#
#     "psefunix.dat": sortida "ps -ef" actual "filtrada". s'esborra en
#        acabar
#     "psefmeu.dat" : dades dels procesos actuals a les cues, incloent-hi
#        l'nqsdaemon pare actual
#     "control.act": dades dels procesos fills de l'nqsdaemon actual que
#        ja han acabat. la primera linia correspon a un proces no acabat:
#        l'nqsdaemon pare actual (que tambe es a "psefmeu.dat")
#     "control.tot": dades del nqsdaemon pares ja acabats
#
# amb "psefunix.dat" actualitzem "psefmeu.dat". aixo actualitza el temps
# de l'nqsdaemon pare, que no interessa per gaire pero que aprofito per
# guardar: es la primera linia de "control.act".
#
# quan un proces amb indent=1 acaba (es a dir, acaba un calcul a la cua),
# les seves dades son eliminades de "psefmeu.dat" i afegides AL FINAL de
# "control.act". "control.act" estara, per tant, ordenat per datas NO DE
# COMENCAMENT, SINO D'ACABAMENT dels procesos.
#
# quan un nqsdaemon pare mor, "control.act" s'afegeix AL FINAL de
# "control.tot" i es crea un nou "control.act" buit
# obviament, tambe s'ha d'afegir "psefmeu.dat" al final de "control.tot"
# i crear un nou "psefmeu.dat" buit
#
# la info sobre si un proces corre o no nomes es util a nivell intern. La
# rutina que mostra els processos emmagatzemats NO HAURIA D'IMPRIMIR-LA


# Hi ha modificacions a all.profile i batch.profile per fer les proves
# POSA'LS COM CAL QUAN TOT SIGUI DEFINITIU !!!



# Per comencar, defineixo una funcio util

# --------------------------------------------------

buscafills() {
   # imprimeixo la linia del proces entrat com a parametre
   awk -v proc=$1 '{ if ( $2 == proc ) print $0 }' <psefunix.tmp
   # i busco els seus fills recursivament
   if [ `grep -c $1 <psefunix.tmp` != 1 ]
   then # apareix mes d'una vegada ==> te fills
      set `awk -v proc=$1 '{ if ( $3 == proc ) print $2 }' <psefunix.tmp`
      while [ $# != 0 ]
      do
         buscafills $1
         shift
      done
   fi
}

# --------------------------------------------------

# a partir d'aqui ve el programa


cd /users/oscar/misc/T
chmod 777 *   # per poder treballar com a oscar, ja que tot es de root
ps -ef>psefunix.tmp


# busco el proces nqsdaemon pare (aquell que penja de PPID=1 i es de root)
#########
NQSpare=`awk '/nqsdaemon/ \
              { if ( $1 == "root" && $3 == "1") print $2 }' <psefunix.tmp`


# examino si es el darrer nqsdaemon pare emmagatzemat. si no ho es, trasllado
# a "control.tot" la informacio des de "control.act" dels seus fills acabats
# i des de "psefmeu.dat" dels fills que encara puguin quedar com a vius
#########
if [ -s control.act ]
then
   if [ `head -1 control.act | awk '{ print $2 }'` != "$NQSpare" ]
   then
      cat control.act psefmeu.dat >>control.tot
      rm control.act psefmeu.dat
      touch control.act psefmeu.dat
   fi
else
   touch control.act psefmeu.dat
fi


# miro si hi ha un nqsdaemon corrent, mirant el valor de NQSpare
# si no n'hi ha cap, aturo l'execucio: no hi ha res a revisar
# no se si a totes les maquines es comprova de la mateixa manera si una
# variable te un valor o be es una cadena buida, aixi que ho faig "a ma"
#########
if [ "XXX$NQSpare" = "XXX" ]
then
   rm psefunix.tmp
   exit
fi


# si l'nqsdaemon es viu, trobo TOTA la seva descendencia
# NOMES guardo aquesta info. la resta pertany a procesos que no m'interessen
#########
buscafills $NQSpare > psefunix.dat
rm psefunix.tmp


# faig els calculs de temps de cada proces
#########
./psef $NQSpare `date|awk '{ print $1"_"$3"_"$2"_"$6"_"$4 }'`


# actualitzo el temps de l'nqsdaemon pare emmagatzemat a "control.act" amb
# el que hi ha ara a "psefmeu.dat"
#########
awk -v PID=$NQSpare '{ if ( $2 != PID ) print $0 }' <control.act >control.tmp
head -1 psefmeu.dat >control.act
cat control.tmp >>control.act
rm control.tmp


# envio cap a "control.act" els procesos acabats de "psefmeu.dat", i els
# elimino d'aquest darrer
#########
touch psefmeu.tmp0 psefmeu.tmp1
awk 'BEGIN { corrent=1 }
     { if ( $1 == 1 && corrent == 1 ) corrent=0 }
     { if ( $5 != 0 ) corrent=1 }
     { print $0 >"psefmeu.tmp"corrent }' <psefmeu.dat
cat psefmeu.tmp0 >>control.act
mv psefmeu.tmp1 psefmeu.dat


# queda cap infractor entre els procesos actius?
#########
awk 'BEGIN { i=0 }
     { if ( i == 1 ) { { i=0 } { print $6 >"psefmeu.tmp0" } } }
     { if ( $1 == 1 && $8 != "netdaemon" ) \
          { { i=1 } { print $4" "$8 >"psefmeu.tmp1" } } }' <psefmeu.dat
paste psefmeu.tmp0 psefmeu.tmp1 >psefmeu.tmp
# preparo aixo manualment per funcionar a cues de 24 hores, pero s'ha de
# fer que TOT sigui automatic a qualsevol cua de qualsevol maquina
awk '{ if ( $2 > 87000 ) print $1" creu que ningu no veu que fa trampes a " \
          $3 " (duu "$2" segons)" }' <psefmeu.tmp >psefmeu.tmp0
if [ -s psefmeu.tmp0 ]
then
   mail oscar <psefmeu.tmp0
fi


# esborro els fitxers temporals que encara queden
#########
rm psefmeu.tmp* psefunix.dat

  