<?xml version="1.0" encoding="UTF-8"?>
<s:scufl xmlns:s="http://org.embl.ebi.escience/xscufl/0.1alpha" version="0.2" log="0">
  <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:P9SFJBEMDF9" author="Arnaud Kerhornou - akerhornou@imim.es" title="Promoter sequence of coexpressed genes analysis. The input as a set of fasta sequences. The output is a set of Transfac binding sites (MatScan output), of Meta-alignment predictions, and a score matrix that can be used for sequence clustering processing." />
  <s:processor name="Create_moby_data">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.CreateMobyData</s:local>
  </s:processor>
  <s:processor name="identifier" boring="true">
    <s:stringconstant>id</s:stringconstant>
  </s:processor>
  <s:processor name="parse_moby_matrix">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_meme_text">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_matscan">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_meme_matrices">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_meta">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="parse_moby_tree">
    <s:local>org.embl.ebi.escience.scuflworkers.biomoby.ExtractMobyData</s:local>
  </s:processor>
  <s:processor name="Decode_base64_to_byte">
    <s:local>org.embl.ebi.escience.scuflworkers.java.DecodeBase64</s:local>
  </s:processor>
  <s:processor name="inbHierarchicalCluster">
    <s:description>Hierarchical clustering server for gene expression patterns</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>inbHierarchicalCluster</s:serviceName>
      <s:authorityName>bioinfo.ochoa.fib.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="inbTreeView">
    <s:description>Viewer for Newick Trees (PNG image)</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://www.inab.org/cgi-bin/MOBY-Central.pl</s:mobyEndpoint>
      <s:serviceName>inbTreeView</s:serviceName>
      <s:authorityName>bioinfo.ochoa.fib.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMemeText">
    <s:description>MEME analyzes a set of protein or DNA sequences for similarities among them and produce a description (motif) for each pattern it discovers. The results are returned in text format</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>runMemeText</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMultiMetaAlignment">
    <s:description>Promoter regions analysis program. runMultiMetaAlignment runs Meta-alignment on a multiple mode, receiving a collection of maps, making pairs of them and, foreach pair, it produces alignments of sequences of TF binding sites. It returns the predictions in 'Meta-alignment' format. Use runMatScanGFF to produce the input GFF files</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>runMultiMetaAlignment</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="fromFASTAtoDNASequenceCollection">
    <s:description>Converts a FASTA object into a collection of DNASequence moby objects</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>fromFASTAtoDNASequenceCollection</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="parseMotifMatricesfromMEME">
    <s:description>Parse the score or probability matrices from MEME output. It reports one matrix for each predicted motif.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>parseMotifMatricesfromMEME</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="generateScoreMatrix">
    <s:description>Compute similarity data, such as meta-alignment output, to produce a sequence similarity score matrix.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>generateScoreMatrix</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="runMatScanGFFCollectionVsInputMatrix">
    <s:description>Promoter regions analysis program. Matscan is a program to search putative binding sites in genomic sequences. This service only accepts a collection of DNASequence objects and returns a collection of GFF objects (one GFF object for each DNASequence). It will run MatScan for each sequence in the colelction against the input matrix. If you want to give MatScan output to Meta-alignment program, you MUST use the 'log-likelihood matrix' mode.</s:description>
    <s:biomobywsdl>
      <s:mobyEndpoint>http://mobycentral.icapture.ubc.ca/cgi-bin/MOBY05/mobycentral.pl</s:mobyEndpoint>
      <s:serviceName>runMatScanGFFCollectionVsInputMatrix</s:serviceName>
      <s:authorityName>genome.imim.es</s:authorityName>
    </s:biomobywsdl>
  </s:processor>
  <s:processor name="addMethodSecondary">
    <s:workflow>
      <s:scufl version="0.2" log="0">
        <s:workflowdescription lsid="urn:lsid:www.mygrid.org.uk:operation:AHTHN6PNI32" author="" title="" />
        <s:processor name="CreateMOBYSecondary">
          <s:beanshell>
            <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;moby:Parameter moby:articleName=''&gt;&lt;Value&gt;EMPTY&lt;/Value&gt;&lt;/moby:Parameter&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";

DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource SourceSkel = new InputSource(new StringReader(skel));

Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:Parameter");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

comienzo.setAttribute("moby:articleName",articleName);
// As the skeleton already contains a &lt;Value&gt; with a TEXT_NODE,
// and it is its only child, we are going to reuse it!
comienzo.getFirstChild().getFirstChild().setNodeValue(value);

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

MobySecondary = OutObj;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/plain'">articleName</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/plain'">value</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/xml'">MobySecondary</s:beanshelloutput>
            </s:beanshelloutputlist>
          </s:beanshell>
        </s:processor>
        <s:processor name="method_articleName" boring="true">
          <s:stringconstant>method</s:stringconstant>
        </s:processor>
        <s:processor name="CombineMoby">
          <s:beanshell>
            <s:scriptvalue>import java.io.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.serialize.XMLSerializer;

String OutObj="";
String skel="&lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;&lt;moby:MOBY xmlns:moby='http://www.biomoby.org/moby' xmlns='http://www.biomoby.org/moby'&gt;&lt;moby:mobyContent&gt;&lt;moby:mobyData queryID='one'&gt;&lt;/moby:mobyData&gt;&lt;/moby:mobyContent&gt;&lt;/moby:MOBY&gt;";


DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();

InputSource Source1 = new InputSource(new StringReader(MobyA));
InputSource Source2 = new InputSource(new StringReader(MobyB));
InputSource SourceSkel = new InputSource(new StringReader(skel));

Document doc1=db.parse(Source1);
Document doc2=db.parse(Source2);
Document docsalida=db.parse(SourceSkel);

XMLSerializer serializer = new XMLSerializer();
StringWriter sw=new StringWriter();

// First, Simples
NodeList nodelist1an = doc1.getElementsByTagName("moby:Simple");
NodeList nodelist1a = doc1.getElementsByTagName("Simple");
NodeList nodelist2an = doc2.getElementsByTagName("moby:Simple");
NodeList nodelist2a = doc2.getElementsByTagName("Simple");
// Second, Collection
NodeList nodelist1bn = doc1.getElementsByTagName("moby:Collection");
NodeList nodelist1b = doc1.getElementsByTagName("Collection");
NodeList nodelist2bn = doc2.getElementsByTagName("moby:Collection");
NodeList nodelist2b = doc2.getElementsByTagName("Collection");
// Third, secondary Parameter
NodeList nodelist1cn = doc1.getElementsByTagName("moby:Parameter");
NodeList nodelist1c = doc1.getElementsByTagName("Parameter");
NodeList nodelist2cn = doc2.getElementsByTagName("moby:Parameter");
NodeList nodelist2c = doc2.getElementsByTagName("Parameter");

// We will iterate over these lists
NodeList[] globalS={
	nodelist1an,
	nodelist1a,
	nodelist2an,
	nodelist2a
};

NodeList[] globalC={
	nodelist1bn,
	nodelist1b,
	nodelist2bn,
	nodelist2b,
	nodelist1cn,
	nodelist1c,
	nodelist2cn,
	nodelist2c
};

NodeList nodelistfinal = docsalida.getElementsByTagName("moby:mobyData");

serializer.setOutputCharStream(sw);

Node comienzo = nodelistfinal.item(0);

// Common index variable for all this work
int gi;
int maxgi;

// We are skipping over Collected Simples
for(gi=0,maxgi=globalS.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalS[gi].getLength();i&lt;maxi;i++) {
		Node found=globalS[gi].item(i);
		String nname=found.getParentNode().getNodeName();
		if(nname.equals("moby:Collection") || nname.equals("Collection"))  next;
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

for(gi=0,maxgi=globalC.length;gi&lt;maxgi;gi++) {
	int i;
	int maxi;
	for(i=0,maxi=globalC[gi].getLength();i&lt;maxi;i++) {
		Node found=globalC[gi].item(i);
		comienzo.appendChild(docsalida.importNode(found,true));
	}
}

// Last step!!!
serializer.serialize(docsalida);
OutObj = sw.toString();

CombinedMOBY = OutObj;</s:scriptvalue>
            <s:beanshellinputlist>
              <s:beanshellinput s:syntactictype="'text/xml'">MobyA</s:beanshellinput>
              <s:beanshellinput s:syntactictype="'text/xml'">MobyB</s:beanshellinput>
            </s:beanshellinputlist>
            <s:beanshelloutputlist>
              <s:beanshelloutput s:syntactictype="'text/xml'">CombinedMOBY</s:beanshelloutput>
            </s:beanshelloutputlist>
          </s:beanshell>
        </s:processor>
        <s:link source="MobyA" sink="CombineMoby:MobyA" />
        <s:link source="method_value" sink="CreateMOBYSecondary:value" />
        <s:link source="CreateMOBYSecondary:MobySecondary" sink="CombineMoby:MobyB" />
        <s:link source="method_articleName:value" sink="CreateMOBYSecondary:articleName" />
        <s:link source="CombineMoby:CombinedMOBY" sink="MobyOutput" />
        <s:source name="method_value" />
        <s:source name="MobyA" />
        <s:sink name="MobyOutput" />
      </s:scufl>
    </s:workflow>
  </s:processor>
  <s:link source="fasta_sequences" sink="Create_moby_data:stringvalue" />
  <s:link source="method_value" sink="addMethodSecondary:method_value" />
  <s:link source="namespace" sink="Create_moby_data:namespace" />
  <s:link source="Create_moby_data:mobydata" sink="fromFASTAtoDNASequenceCollection:input" />
  <s:link source="addMethodSecondary:MobyOutput" sink="inbHierarchicalCluster:input" />
  <s:link source="fromFASTAtoDNASequenceCollection:DNASequence(Collection - 'sequences')" sink="runMatScanGFFCollectionVsInputMatrix:DNASequence(Collection - 'upstream_sequences')" />
  <s:link source="fromFASTAtoDNASequenceCollection:DNASequence(Collection - 'sequences')" sink="runMemeText:GenericSequence(Collection - 'sequences')" />
  <s:link source="generateScoreMatrix:output" sink="addMethodSecondary:MobyA" />
  <s:link source="generateScoreMatrix:output" sink="parse_moby_matrix:mobydata" />
  <s:link source="identifier:value" sink="Create_moby_data:id" />
  <s:link source="inbHierarchicalCluster:output" sink="inbTreeView:input" />
  <s:link source="inbTreeView:b64_Encoded_PNG(_ANON_)" sink="parse_moby_tree:mobydata" />
  <s:link source="parseMotifMatricesfromMEME:output" sink="runMatScanGFFCollectionVsInputMatrix:text-formatted(matrices)" />
  <s:link source="parseMotifMatricesfromMEME:text-formatted(meme_matrices)" sink="parse_moby_meme_matrices:mobydata" />
  <s:link source="Decode_base64_to_byte:bytes" sink="moby_Tree_png" />
  <s:link source="inbHierarchicalCluster:Clustering(_ANON_)" sink="Moby_Newick" />
  <s:link source="parse_moby_matrix:value" sink="Moby_Matrix" />
  <s:link source="parse_moby_matscan:value" sink="Moby_MatScan" />
  <s:link source="parse_moby_meta:value" sink="Moby_Meta" />
  <s:link source="parse_moby_tree:value" sink="Decode_base64_to_byte:base64" />
  <s:link source="runMatScanGFFCollectionVsInputMatrix:GFF(Collection - 'matscan_predictions')" sink="runMultiMetaAlignment:GFF(Collection - 'maps')" />
  <s:link source="runMatScanGFFCollectionVsInputMatrix:output" sink="parse_moby_matscan:mobydata" />
  <s:link source="runMemeText:output" sink="parseMotifMatricesfromMEME:input" />
  <s:link source="runMemeText:text-formatted(meme_predictions)" sink="parse_moby_meme_text:mobydata" />
  <s:link source="runMultiMetaAlignment:output" sink="parse_moby_meta:mobydata" />
  <s:link source="runMultiMetaAlignment:text-formatted(Collection - 'meta_predictions')" sink="generateScoreMatrix:text-formatted(Collection - 'similarity_results')" />
  <s:link source="parse_moby_meme_matrices:value" sink="Moby_MEME_Matrices" />
  <s:link source="parse_moby_meme_text:value" sink="Moby_MEME" />
  <s:source name="namespace" />
  <s:source name="fasta_sequences" />
  <s:source name="method_value">
    <s:metadata>
      <s:description>Set the value of the "method" secondary article of inbHierarchicalCluster processor

Select a value among:
* "Nearest neighbor (single linkage)" - default
* "Furthest neighbor (complete linkage)"
* "Unweighted pair-group method using arithmetic averages (UPGMA)"
* "Weighted pair-group method using arithmetic averages (WPGMA)"
* "Unweighted pair-group centroid method (UPGMC)"
* "Weighted pair-group centroid method (WPGMC)"
* "None"</s:description>
    </s:metadata>
  </s:source>
  <s:sink name="Moby_Matrix" />
  <s:sink name="Moby_Meta" />
  <s:sink name="Moby_MatScan" />
  <s:sink name="Moby_MEME" />
  <s:sink name="Moby_MEME_Matrices" />
  <s:sink name="Moby_Newick" />
  <s:sink name="moby_Tree_png">
    <s:metadata>
      <s:mimeTypes>
        <s:mimeType>image/*</s:mimeType>
      </s:mimeTypes>
    </s:metadata>
  </s:sink>
</s:scufl>


