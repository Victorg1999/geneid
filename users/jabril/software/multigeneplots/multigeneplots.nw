% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: multigeneplots.nw,v 1.2 2001-10-22 14:36:01 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}
%
<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
  \item[$\triangleright$] [\textit{Section}~\ref{#2}, 
                           \textit{page}~\pageref{#2}]\\ {#1}
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\progname{multigeneplots.pl}
\def\tit{\textsc{\progname}}
%
\def\mtjabril{
 \htmladdnormallink{\texttt{jabril@imim.es}}
                   {MAILTO:jabril@imim.es?subject=[maskedfastacoords]}
 } % def mtjabril
%
\def\authorslist{
 Josep F. Abril {\mdseries\small\dotfill \mtjabril } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF % Other authors here...
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
From a table containing gene identifiers, start and end coords, and the strand,the program loops through a set of GFF files, making the plots for each single dataset using \texttt{gff2ps}. Once the PostScript figures have been obtained, it can convert them to a bitmap graphical format (say here \textsc{jpeg} or \textsc{png}). It must compute the width of every plot according to gene length.
 } % def progdesc
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\tit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
@ 
<<HIDE: new LaTeX definitions>>=
@ 
<<HIDE: new defs TODO>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\begin{bfseries}
\begin{large}
\newlength{\lttbl}\setlength{\lttbl}{0.25\linewidth}
\newlength{\rttbl}\setlength{\rttbl}{0.70\linewidth}
%\fbox{
%\vskip 2ex
\begin{tabular}{>{\scshape}r@{\quad}l}
\rule{\lttbl}{0pt} & \rule{\rttbl}{0pt} \\[2ex]
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
Program Name: & {\Huge\progname}                       \\[3ex]
\multicolumn{2}{c}{\rule[0.5ex]{0.95\linewidth}{2pt}}\\[2ex]
      Author: & {\Large
                 \begin{minipage}[t]{0.95\rttbl}
                 \authorslist
                 \end{minipage}}                       \\[2ex]
     License: & {\license}                             \\[2ex]
 Last Update: & {\today}                               \\[2ex]
 Description: & {\large\mdseries
                 \begin{minipage}[t]{0.95\rttbl}
                 \progdesc
                 \end{minipage}}                       \\[2ex]
\\
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
\end{tabular}
%} % fbox
\end{large}
\end{bfseries}
\end{center}

\vfill

\begin{raggedleft}
\showaffiliation
\end{raggedleft}

\end{titlepage} %'

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: multigeneplots.nw,v 1.2 2001-10-22 14:36:01 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{Program description}

\subsctn{Input}

First input file must contain the gene information table which program will use to chop off the input GFF files for the single gene plots. Those GFF files may contain not only records corresponding to the genes listed in that table, other sources (vector support will be implemented later). 

\subsctn{Output}

Basic output will be a set of PostScript files containing a single gene each. It will save files for each gene GFF-records set.

% \subsctn{Comments}

\subsctn{To Do}

\begin{itemize}
 \input todo.tex
\end{itemize}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Implementation}

<<Program Info>>=
my $PROGRAM = 'multigeneplots';
my $VERSION = '0.1_alpha';
@ 
<<Prog USAGE>>=
$PROGRAM [options] < input_files > output_files
@
<<Prog DESC>>=
Making GFF2PS plots for each GFF group related to a given source.
@

<<Program Description>>=
# #----------------------------------------------------------------#
# #                          multigeneplots                         #
# #----------------------------------------------------------------#
# 
#  $PROGRAM [options] < input_files > output_files
#
#  Making GFF2PS plots for each GFF group related to a given source.
#
#
#     Copyright (C) 2001 - Josep Francesc ABRIL FERRANDO  
@ 

\subsctn{Program outline}

<<multigeneplots>>=
<<PERL shebang>>
#
# MODULES
#
<<Use Modules>>
#
# VARIABLES
#
<<Global Vars>>
#
# MAIN LOOP
#
<<Main Loop>>
#
# FUNCTIONS
#
<<Functions>>
@ 

<<Use Modules>>=
<<Use Modules - Benchmark>>
<<Use Modules - Getopt>>
@

<<Global Vars>>=
<<Boolean>>
<<Counter vars>>
<<Stderr subs vars>>
my %CmdLineVar = (
                 <<cmdline defaults - format>>
                 <<command-line defaults - GFF>>
                 );
@

<<Main Loop>>=
&main();

exit(0);
@

<<messages - program running>>=
'PROG-START'  => "$line$s\n$s Running $PROGRAM\n$s\n".
                 "$s HOST: $host\n".
                 "$s USER: $USER\n".
                 "$s DATE: $DATE\n$s\n$line$s\n" ,
'PROG-FINISH' => "$s\n$line$s\n$s $PROGRAM FINISHED\n$s\n".
                 "$s TOTAL TIME: \%s\n$line" ,
@ 

<<Functions>>=
<<Parsing command line options>>
<<Main program functions>>
<<Common PERL subs - Text fill>>
<<Common PERL subs - Counter>>
<<Common PERL subs - Min Max>>
<<Common PERL subs - Benchmark>>
<<Common PERL subs - STDERR>>
@

\sctn{Program functions}

\subsctn{Processing command-line options}

<<Use Modules - Getopt>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
@ 

<<perl requires - Getopt>>=
"Getopt::Long" - processing command-line options.
@

See '[[man Getopt::Long]]' for further info about this package.

<<Parsing command line options>>=
sub parse_cmdline() {
    <<looking for STDIN>>

    $SIG{__WARN__} = sub { &warn('UNKNOWN_CL_OPTION',$T,$_[0]) };
    GetOptions(
               <<command-line options - format>>
               <<command-line options - GFF>>
               <<command-line options with exit>>
               ) || (&warn('CMD_LINE_ERROR',$T), exit(1));
    $SIG{__WARN__} = 'DEFAULT';

    &report("PROG-START");
    @data_files = ();
    &set_input_file($cmdln_stdin);
    @ARGV = (); # ensuring that command-line ARGVs array is empty
    
} # parse_cmdline
@

<<warnings - command-line>>=
'UNKNOWN_CL_OPTION' =>
  $Warn."Error trapped while processing command-line:\n".(" "x16)."\%s\n",
'CMD_LINE_ERROR' =>
  $spl.$spw." Please, check your command-line options!!!\n".$Error."\n".
  $spw." ".("."x12)." Type \"$PROGRAM -h\" for help.\n".$spl,
@ 

To avoid errors reported when using '[[-]]' as '[[STDIN]]' mark and [[GetOptions]] to parse command-line parameters, we capture the single dash when present in the command-line arguments list. '[[$cmdln_stdin]]' will be used by '[[&set_input_file]]' function to include the '[[STDIN]]' in the correct ordering.\label{sec:stdinfix}

<<looking for STDIN>>=
my $cmdln_stdin = undef;
for (my $a = 0; $a <= $#ARGV; $a++) { 
    next unless $ARGV[$a] =~ /^-$/o;
    $cmdln_stdin = $a - $#ARGV;
    splice(@ARGV,$a,1);
};    
@ 

\subsubsctn{Testing command-line input filenames}

\label{todo:BAA}
<<HIDE: new defs TODO>>=
\def\todoBAA{Not implemented yet an option to switch on/off reporting execution to STDERR (now by default send logs there but cannot be dissabled).} % todoBAA
@
<<HIDE: TODO>>=
\todoitem{\todoBAA}{todo:BAA}
@
\todo{ \item \todoBAA } % todo

<<Parsing command line options>>=
sub set_input_file() {
    my $stdin_flg = $F;
    <<STDIN backwards compatibility>>
    &report("CHECKING_FILENAMES");
  FILECHK: foreach my $test_file (@ARGV) {
        $test_file ne '-' && do {
            -e $test_file || do {
                &warn('FILE_NO_OPEN',$T,$test_file);
                next FILECHK;
            };
            &report('READING_FILE',$test_file);
            push @data_files, $test_file;
            next FILECHK;
        };
        $stdin_flg = $T;
        push @data_files, '-';
	}; # foreach
    scalar(@data_files) == 0 && do {
        push @data_files, '-';
        $stdin_flg = $T;
    };
    $stdin_flg && &report('READING_STDIN');
} # set_input_file
@ 

<<Global Vars>>=
my @data_files = ();
@ 

<<warnings - input/output>>=
FILE_NO_OPEN =>
  $spl.$Warn."Cannot Open Current file \"\%s\" . Not used !!!\n".$spl,
@

<<messages - input/output>>=
CHECKING_FILENAMES =>
  $sp."### Validating INPUT FILENAMES\n".$sp,
READING_FILE =>
  "###---> \"\%s\" exists, including as Input File.\n",
READING_STDIN =>
  "###---> Including GFF records from standard input.\n",  
@

Here is the fix for the explained in section~\ref{sec:stdinfix} on page~\pageref{sec:stdinfix} ([[<<looking for STDIN>>]] code).

<<STDIN backwards compatibility>>=
my $chk_stdin = shift @_;
my $t = scalar(@ARGV);
defined($chk_stdin) && do {
    abs($chk_stdin) > $t && ($chk_stdin = -$t);
	$chk_stdin > 0  && ($chk_stdin = 0 );
    $t += $chk_stdin;
    splice(@ARGV,$t,0,'-');
};
@

\subsubsctn{Defining help and auxiliary code chunks}

The following command-line checkings look for those options exiting the program: '[[help]]' and '[[version]]'. Both need to output to screen without any other message/warning being displayed at the same time.

<<command-line options with exit>>=
"version"   => \&prt_version, 
"h|help|?"  => \&prt_help,
@ 
<<command-line help - help>>=
-h, --help            Shows this help.
--version             Shows current version and exits.
@

<<Parsing command line options>>=
sub prt_version() {
    &report('SHOW_VERSION',$PROGRAM,$VERSION);
    exit(1);
} # prt_version
@ 

<<messages - parsing command-line>>=
'SHOW_VERSION' => $sp."### \%s -- Version: \%s\n".$sp,
@

Printing command-line help to [[STDERR]]:

<<Parsing command line options>>=
sub prt_help() {
    print STDERR <<"+++EndOfHelp+++";
PROGRAM:
                        $PROGRAM - $VERSION

    <<Prog DESC>>

USAGE:    <<Prog USAGE>>


DESCRIPTION:

    <<Prog DESC>>


REQUIRES:

    <<perl requires help>>


COMMAND-LINE OPTIONS:

    <<command-line help>>


BUGS:    Report any problem to 'jabril\@imim.es'.

AUTHOR:  $PROGRAM is under GNU-GPL (C) 2000 - Josep F. Abril

+++EndOfHelp+++
    exit(1);
} # prt_help
@

<<perl requires help>>=
$PROGRAM needs the following Perl modules 
installed in your system, we used those available 
from the standard Perl distribution. Those that 
are not in the standard distribution are marked 
with an '(*)', in such cases make sure that you 
already have downloaded them from CPAN 
(http://www.perl.com/CPAN) and installed.

  <<perl requires - Getopt>>
  <<perl requires - Benchmark>>
@ %$

<<command-line help>>=
A double dash on itself "--" signals end of the options
and start of file names (if present). After double dash,
you can use a single dash "-" as STDIN placeholder. 
Available options and a short description are listed here:

+ General options:

  <<command-line help - help>>

  <<command-line help - format>>

+ GFF output:

  <<command-line help - GFF>>
@

\subsubsctn{Defining command-line options}

<<command-line options - format>>=
"g|genomic-coords" => sub { $CmdLineVar{GFFCOORDS} = 1 },
"i|include-groups" => \$CmdLineVar{SHOWGROUPS},
@
<<cmdline defaults - format>>=
GFFCOORDS  => 1,
SHOWGROUPS => 0,
@
<<command-line help - format>>=
-g, --genomic-coords   Output GFF coords fields (columns 4th and 5th)
                       are set as genomic coords (by default).
@

<<command-line options - GFF>>=
"s|save-gff:s"      => ,
"1|gff-version1"    => sub { $CmdLineVar{GFFVERSION} = 1 },
"2|gff-version2"    => sub { $CmdLineVar{GFFVERSION} = 2 },
@
<<command-line defaults - GFF>>=
GFFVERSION => 1,
@
<<command-line help - GFF>>=
-s, --save-gff         Save a GFF file for each group found on input file.
                       By default program creates a "./tmp" directory where
                       to put those files. You can provide another path,
                       but if program fails to find/create it then will return
                       to default behaviour.
@

\label{todo:BAA}
<<HIDE: new defs TODO>>=
\def\todoBAA{
Using GetOPTS. New options:

\begin{minipage}[c]{\linewidth}
\begin{center}
\begin{description}
\setlength{\parsep}{0ex}
\setlength{\itemsep}{-0.5ex}
\item[ --save-gff ] to save GFF-records set for each gene.
\item[ --jpeg ] to produce jpeg from PostScript output.
\item[ --png ] to produce png from PostScript output.
\item[ --pdf ] to produce pdf from PostScript output (can it be easily done???).
\item[ --proportional-length ] 
\item[ --fixed-length ] 
\item[ --log-length ]
\item[ --nucleotides-cm ]
\end{description}
\end{center}
\end{minipage}
} % todoBAA
@
<<HIDE: TODO>>=
\todoitem{\todoBAA}{todo:BAA}
@
\todo{ \item \todoBAA } % todo


\subsctn{Main program functions}

<<Main program functions>>=
sub main() {
    &parse_cmdline(); # PROG-START
    &set_output_subs();
    foreach my $lfile (@data_files) {
        &parse_input_files($lfile);
    }; # foreach $lfile
    &sort_by_acceptor();
    &output_extended_GFF();
    &report('PROG-FINISH',&timing($T));
} # main
@


\subsubsctn{Defining referenced functions}

Here we describe how we set the variables that call by reference a funcion. They point to different subroutines depending on a given command-line options set.

Groups, when shown in the output, share the same format as the other GFF fields, so that, we do not have to define a new variable containing the output format for both data types.

<<Main program functions>>=
sub set_output_subs() {
    &report("SETTING_VARS");
} # set_output_subs
@

<<Global Vars>>=
@ 
<<messages - program running>>=
SETTING_VARS => $sp."### Variable Definition Finished...\n".$sp,
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{empty appendix section}

\subsctn{empty appendix subsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
#
<<Program Description>>
#
<<GNU License>>
#
<<Version Control Id Tag>>
#
use strict;
#
<<Program Info>>
my $DATE = localtime;
my $USER = defined($ENV{USER}) ? $ENV{USER} : 'Child Process';
my $host = `hostname`;
chomp($host);
#
@

<<Boolean>>=
my (*T,*F) = (\1,\0); # for 'T'rue and 'F'alse
@


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 

<<perl requires - Benchmark>>=
"Benchmark" - checking and comparing running times of code.
@


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Counter vars>>=
my ($n,$c); # counter and char (for &counter function)
@ %def $n $c


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%Messages]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($Messages{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also uses the hash variable '[[%Messages]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($Messages{ shift @_ }, @_) }
@

Those are accessory variables for the messages strings:

<<Stderr subs vars>>=
my $line = ('#' x 80)."\n";
my $s = '### ';
my $sp = "###\n";
my $Error = "\<\<\<  ERROR  \>\>\> ";
my $Warn  = "\<\<\< WARNING \>\>\> ";
my $spl   = "\<\<\<\-\-\-\-\-\-\-\-\-\>\>\>\n";
my $spw   = "\<\<\<         \>\>\> ";
@ 

And here the main messages hash:

<<Stderr subs vars>>=
my %Messages = (
    # ERROR MESSAGES
    <<warnings - command-line>>
    <<warnings - input/output>>
    # WORKING MESSAGES
    <<messages - program running>>
    <<messages - parsing command-line>>
    <<messages - input/output>>
   ); # %Messages 
@


\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: multigeneplots.nw,v 1.2 2001-10-22 14:36:01 jabril Exp $
@ 

\subsctn{GNU General Public License}

<<GNU License>>=
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# #----------------------------------------------------------------#
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"multigeneplots" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' | cpif $BIN/multigeneplots ;
chmod a+x $BIN/multigeneplots ;
@ 

<<tangling>>=
# reformating program with perltidy
notangle -R"multigeneplots" $WORK/$nwfile.nw | \
    perltidy - | cpif $SRC/multigeneplots ;
# html pretty-printing program with perltidy
notangle -R"multigeneplots" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/multigeneplots.html ;
#
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
notangle -R"root" $WORK/$nwfile.nw | \
         cpif $DATA/root_config ;
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
chmod a+x $WORK/nw2tex $WORK/ltx;
@ 

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH shebang>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
#
# Setting Global Variables
WORK="/home/ug/jabril/development/softjabril/multigeneplots" ;
BIN="$WORK/bin" ;
PARAM="$BIN/param" ;
SRC="$WORK/src" ; # where to put the distributable files
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
nwfile="multigeneplots" ;
export WORK BIN PARAM DOCS DATA nwfile ;
#
@ 

<<tangling>>=
# 
# BASH Environment Variables
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
source $WORK/.bash_VARS ;
#
@

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
