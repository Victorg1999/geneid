% -*- mode: Noweb; noweb-code-mode: perl-mode -*-
\documentclass[10pt]{article}
% 
% I'm trying to learn Literate Programming. I will use sgp2 as an LP exercise.
%
% The same document contains the code which will be generated with the proper filter:
%
%   pqtangle -L sgp2.tex
%
% The project documentation is also available from the same file:
%
%   latex sgp2.tex; dvips sgp2.dvi -o sgp2.ps  # to obtain the PS version 
%
%   pdflatex sgp2.tex;                         # to obtain the PS version
%
% $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $
%  
\usepackage{noweb,multicol}
\usepackage[offset={0pt,0pt},hmargin={2.5cm,2cm},vmargin={1cm,0.25cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
\noweboptions{smallcode}
% relax page breaking scheme
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\par

\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}

\newcommand{\cd}[1]{\texttt{\textbf{#1}}} % program<code> font style definition
\newcommand{\cv}[1]{\texttt{\textsl{#1}}} % program<vars> font style definition
\newcommand{\cp}[1]{\textit{#1}} % program<vars> font style definition

\newcommand{\todo}[2]{
  \hspace{-1.5cm}\fbox{
   \begin{minipage}[c]{18cm}
    \textbf{TO DO} $\langle$\textsl{#1}$\rangle$\\[-3.5ex]
    \begin{itemize}\setlength{\itemsep}{-0.5ex} #2 \end{itemize}
   \end{minipage}
  }\vspace{1ex}
} % newcommand

\def\sgp{[[sgp2]]} % PROGRAM alias
\def\tbx{[[tblastx]]}
\def\bl{[[blast]]}
\def\gn{[[genscan]]}
\def\gi{[[geneid]]}
\def\sgpt{[[sgp-2]]}
\def\sgpo{[[sgp-1]]}
\def\scm{[[scimog]]}
\def\mit{[[mit]]}
\def\bi{[[bi]]}
 
% TITLE
\title{Sintenic Gene Prediction Tool}
\author{Roderic Guig\'o\\Josep F. Abril} %'

\begin{document}

\maketitle

\begin{center}
{\Large\sgp}\\[1ex]
{\large\verb+$Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $+}\\[2ex]
\end{center}

\begin{abstract}
The initial goal for Josep F. Abril will be to implement a \cd{perl} version of \sgp{}, which works like the current shell implementation. Secondary goals are to introduce myself into CVS (Concurrent Version Control) project management and Literate Programming (this document will serve as example).
\end{abstract}

\tableofcontents

\newpage

\sctn{Introduction}

\subsctn{On using comparative genomics to improve gene precition at genomic scale.}

Conservation in the genomic sequence of species at the appropiate
phylogenetic  distance may be indicative of conservation of sequence
function. We investigate here how sequence conservation may be
indicative of coding function, and develop program, SGP-2, which
integrates the results from \gi\ and \tbx\ to produce gene predictions
when comparing human/mouse sintenynic regions.
We set up a number benchmark data sets,
in which we test SGP-2 against ``ab initio'' programs, sequence
similarity based programs, and other hibrid programs. 

\subsctn{Data Sets}
So far, we used three different human/mouse data sets.
\begin{description}
\item[scimog] 39 pairs of single gene homologous sequences. Obtained by
merging the set by \cite{jarborg:1999a} and the set obtained by us at IMIM
(Sanger Center IMIM Ortologous Genes).
\item[mit] 110 pairs of single gene homologous sequences. Obtained
from the 117 pairs in \cite{batzoglou:2000a}.
\item[bi] 3 pairs of genomic pairs encoding multiple genes. Obtained
by Webb Miller/Thomas Wiehe.
\end{description}

\subsctn{Programs}
\begin{description}
\item[genscan] default parameters
\item[geneid] new released version. default parameters
\item[tblastx] WU (see summer 1999 report)
\item[rosseta] {\tt www.theory.lcs.mit.edu/crossspecies}
\end{description}
 
\subsctn{SGP-2}
Figure \ref{fig:algo2} describes the approach in algo2.  Given two
genomic sequences

\begin{enumerate}
\item mask the sequences using RepeatMasker.
\item run \tbx\ of one sequence agains the other. We run \tbx\
with the option {\tt nogap}, and using blosum62 and with score for
aligning to stop codon set to -500
\item ``project'' the similarity regions onto each sequence
\item  run \gi\ on each sequence with the projected similarity regions
given with the {\tt -S} option
\end{enumerate}

A prototype of {\sgp} already exists.

\begin{figure}
\begin{center}
\framebox{
\includegraphics[width=0.85\linewidth, trim= 10 10 20 10, clip]{../docs/figs/algo2.ps}
}
\end{center}
\caption{ }
\label{fig:algo2}
\end{figure}

\subsctn{Preliminary Results}

\subsubsctn{scimog}

\input ../docs/tables/Table-scimog.tex


\subsubsctn{mit}

\input ../docs/tables/Table-mit.tex

\subsubsctn{bi}
Only one sequence from each pair is used to report accuracy, because
doubts on the annnotation of the other in the pair

\input ../docs/tables/Table-bi.tex
 
\newpage

\sctn{Perl Implementation}

\subsctn{Program Basic Outline}

Our initial program outline (our root chunk) looks like:\\[1ex]

<<sgp2.pl>>=
<<shebang>>
<<version control>>
<<declare uses>>

### VARS ###

<<define defaults>>
<<declare variables>>

### SUBS ###

<<global subroutines>>
<<get options>>

### MAIN SUBS ###

<<run blast>>
<<extract HSPs>>
<<run geneid>>
<<graphical output>>

### MAIN LOOP ###

<<Main Loop>>

### EOF ###

<<POD man page trailer>>
@ % 

[[<<declare uses>>]] will cover all the modules (standard or not) that our program will need in the coresponding section.
[[<<declare variables>>]] will collect all the variables that need to be declared global within this program.

<<shebang>>=
#!/usr/bin/perl
# -w
<<copyleft>>
my $Start = time;
@  %def $Start

'\cd{perl -w}' prints all sorts of useful and interesting warning messages at compile time, but comment [[-w]] for stable versions. 

[[$Start]] %$
contains program starting time (seconds since \textsc{Unix} ``epoch''), which will be used by timing function to calculate for how long was running our program.

<<version control>>=
my $PROGRAM = "sgp2";
my @tmp_ver = split / +/, ' $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $ ';
my $VERSION = "v$tmp_ver[3] [$tmp_ver[4] $tmp_ver[5] $tmp_ver[7]]";
@ %def $PROGRAM $VERSION @tmp_ver

Take into account that here is shown [[sgp2.nw]] versions, but once the perl script is extracted ([[noweb]]) and commited (CVS) then it follows [[sgp2.pl]] version numbering.

<<declare uses>>=
use strict;
@

``\cd{use strict;}'' restricts unsafe constructs, like attempting to use missed symbolic references ('\cv{refs}'), undeclared variables ('\cv{vars}') or not predeclared subroutine ('\cv{subs}'). This usage is strongly recommended if you want to port a program as a module, but also when defining complex data structures (lists of lists and so on).

\subsctn{Main Program Loop}

Here, we should find all the main function calls. This approach make the program more flexible and also easier to convert from a command-line to a CGI program. External programs are called only when their flags are 'on' (by default), [[Which_Options()]] will disable those flags depending on the given command-line options.

<<Main Loop>>=
# get options
&Which_Options();
# main external program calls
DOBLAST: do {
    &Run_Blast() if $blast_flg;
    &Extract_HSP();
} if $hsps_flg;
&Run_geneid()  if $geneid_flg;
&Make_Plots()  if $plots_flg; 
# removing temporary files
&clean_tmp();
# timing and exit
&get_exec_time(time);
exit(0);
@

\subsubsctn{Default values setting}

<<define defaults>>=
# some defaults
my $S_CUTOFF = 50;
my $SCF = 12; # substract to tblastx scores S_CUTOFF - SCF;
@ %def $S_CUTOFF $SCF

[[$S_CUTOFF]] and [[$SCF]] are used when the program parses [[tblastx]] output to rescore HSPs by subtracting [[$S_CUTOFF]] - [[$SCF]] to HSP scores.

<<define defaults>>=
# setting paths
my $SGP2    = defined($ENV{'SGP'}) ? $ENV{'SGP'} : './';
my $SGP2param = "$SGP2/param";
my $TMP     = defined($ENV{'SGPTMP'}) ? $ENV{'SGPTMP'} : '/tmp';
my $TMPROOT = "sgp2_$$";
my $SGPTMP  = "$TMP/$TMPROOT";
<<trap temporary files>>
@ %def $SGP2 $SGP2param $TMP $TMPROOT $SGPTMP
%$

[[$SGP2]] %$
defines main path to {\sgp} binaries, scripts and params.
[[$TMP]] %$ 
is the temporary working directory. Both are defined from environmental variables, allowing users to change them easily to their own paths.
[[$SGPTMP]] %$ 
contains the prefix for temporal files that is set different by adding the process ID ([[$$]] in plain [[perl]], if ``[[use English;]]'' is given it can also be retrieved as [[$PROCESS_ID]] or [[$PID]]).

\todo{define defaults}{
\item Check whether environmental path variables ([[$ENV{'SGP'}]] and [[$ENV{'SGPTMP'}]]) settings does exist.
\item Create subdirectories for them if they do not exist or just 'warn and die'.
}

<<trap temporary files>>=
$SIG{INT}  = \&trap_signals;
$SIG{QUIT} = \&trap_signals;
$SIG{TERM} = \&trap_signals;
$SIG{CHLD} = 'IGNORE';
sub trap_signals() {
    # opendir(TDIR, $TMP) or &go_to_die("Can't open directory $TMP: $!");
    # while (defined(my $file = readdir(TDIR)))
    &clean_tmp();
    &go_to_die("WARNING !!! $PROGRAM has been stopped by user.");
}
@ %$

The following signals are trapped by our signal handler routine (to be precise, when assigning to [[$SIG]] the call by reference to that routine): %$
\begin{itemize}\setlength{\itemsep}{-0.5ex}
\item [[SIGINT]] is normally triggered by Ctrl-C, requesting that a process interrupt what it's doing.%'
\item [[SIGQUIT]] is also generated by a terminal, usually Ctrl-$\backslash$, generating a core dump.
\item [[SIGTERM]] is sent by [[kill]] shell command when no signal name is explicitly given (think of it as a polite request for a process to die). 
\end{itemize}

\subsubsctn{Parsing Command-line Options}

<<declare uses>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling pass_through /;
@ 

\begin{description}\setlength{\itemsep}{-0.5ex}
\desc{\cd{use Getopt::Long;}} This module implements an extended getopt function called \cd{GetOptions()}. This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options having long names instead of single letters are introduced with a double dash "-\/-". A double dash on itself signals end of the options list and start of the input 'files'.

\desc{\cd{Getopt::Long::Configure qw(} \cv{bundling} \cv{pass\_through} \cd{);}} \cd{GetOptions} can be configured by calling subroutine \cd{Getopt::Long::Configure}. This subroutine takes a list of quoted strings, each specifying a configuration option to be set. Options can be reset by prefixing with '\cv{no\_}'. 

 \begin{description}\setlength{\itemsep}{-0.5ex}
 \desc{\cv{bundling}} Support for bundling of command line options, as was the case with the more traditional single-letter approach (introduced with a single dash "-"), is provided but not enabled by default. 

 \desc{\cv{pass\_through}} Unknown options are passed through in \cd{@ARGV} instead of being flagged as errors. This makes it possible to write wrapper scripts that process only part of the user supplied options, and passes the remaining options to some other program.
 \end{description}
\end{description}

<<declare variables>>=
# GetOptions Variables
my ( $Seq1, $Seq2, $geneid_opt, $geneid_param, 
     $blast_opt, $score_cutoff, $shrink, $tbx,
     $hsp, $ofn, $ps_output, $savefiles_flg, $verbose_flg, $help_flg
     ) = ( undef, undef, undef, undef, undef, undef,
           undef, undef, undef, undef, undef, 0, 0, 0 );
@ %def $Seq1 $Seq2 $geneid_opt $geneid_param $blast_opt $score_cutoff $shrink $tbx $hsp $ofn $ps_output $savefiles_flg $verbose_flg $help_flg

Those variables will receive the values passed from command-line options in [[Which_Options()]] function. We set them as [[undef]] to check after [[Which_Options()]] if they have received any value (testing them with perl built-in [[defined()]] function).

<<get options>>=
# Parsing command-line options and processing its parameters.
<<getopts subs>>
sub Which_Options() {
    GetOptions( 
                "1=s"      => \$Seq1         , # seqfile_1
                "2=s"      => \$Seq2         , # seqfile_2
                "g=s"      => \$geneid_opt   , # geneid options      
                "P=s"      => \$geneid_param , # geneid parameter file 
                "o=s"      => \$blast_opt    , # tblastx options 
                "c=f"      => \$score_cutoff , # tblastx score cutoff
                "s=f"      => \$shrink       , # shrink hsp's by
                "t=s"      => \$tbx          , # read tblastx from file
                "f=s"      => \$hsp          , # read HSP files in directory
                "k=s"      => \$ofn          , # intermediate filename
                "p=s"      => \$ps_output    , # postscript output 
                "v"        => \$verbose_flg  , # verbose    
                "h|help|?" => \$help_flg     , # print help
                );
    &prt_Help if $help_flg;
    &prt_Header("Processsing Command-Line Options") if $verbose_flg;
    <<set flags-vars>>
} # sub Which_Options
@ %def &Which_Options 
%$

In [[GetOptions()]] function, sufixing an option with '=s' implies that it will require a mandatory string parameter, with '=f' the option must be provided with a real number. The following variables need a filename: [[$geneid_param]] [[$tbx]] [[$hsp]] [[$ofn]] [[$ps_output]].%$

\todo{get options}{
 \item [[$score_cutoff]] and [[$shrink]] still not used. 
 \item Define better how the paths/filenames are passed through those options. Remember that these variables will be defined by giving a path, but some need a prefix.
}
 
<<getopts subs>>=
# Checking input sequence files
sub exists_file() {
    my @files = @_;
    my ($n, $r) = (' ', 0);
    foreach $n (@files) {
        $r++ if (-e "$n");
    };
    return $r;
}
sub check_fasta_format() {
    my $file = $_[0];
    my ($n, $c) = (undef, 0);
    open(TMP,"< $file");
    while (<TMP>) {
        next unless /^>/;
        />(\S+)\b/ && do {
            $n = $1;
            $c++;
            next unless $c>1;
        };
        &go_to_die("FATAL ERROR !!! Multiple locus names found.\n  File \'$file\' must contain only one sequence definition.\n");
    }
    &go_to_die("FATAL ERROR !!! There is no '>' line, locus name not found.\n  Please, verify your fasta file \'$file\'\n") unless defined($n);
    return $n;
}
@ %def &exists_file &check_fasta_format
%$

[[exists_file()]] : Given a list of filenames, this function returns how many among them does exist.

[[check_fasta_format()]] : For a given file, returns the \textit{locus} name if file is in [[fasta]] format, else program dies.

<<declare uses>>=
use File::Basename;
@

This standard module contains routines to split up a filename. [[basename]] is provided for programmer compatibility with the same name \textsc{Unix} shell command.

<<declare variables>>=
# sequence files
my ($Seq1_Name, $Seq2_Name, $Loc1, $Loc2, $SGPtmp1, $SGPtmp2, $SGPtmpG);
@ %def $Seq1_Name $Seq2_Name $Loc1 $Loc2 $SGPtmp1 $SGPtmp2 $SGPtmpG

<<set flags-vars>>=
# do seq files exists
my $file_number = &exists_file($Seq1, $Seq2);
&go_to_die("FATAL ERROR!!! Two sequences are needed (-1 and -2 options are mandatory).\n")
    unless $file_number == 2; 
# extract basenames
$Seq1_Name = basename($Seq1);
$Seq2_Name = basename($Seq2);
# check if files are provided in fasta format and get locus names
$Loc1 = &check_fasta_format($Seq1);
$Loc2 = &check_fasta_format($Seq2);
&go_to_die("FATAL ERROR!!! Locus1($Loc1) have the same name as Locus2($Loc2).\n  Sequences \'$Seq1_Name\' and \'$Seq2_Name\' must have different locus names.\n")
    if $Loc1 eq $Loc2;
# tmpfiles prefix
$SGPtmp1 = "$SGPTMP.$Seq1_Name";
$SGPtmp2 = "$SGPTMP.$Seq2_Name";
$SGPtmpG = "$SGPTMP.${Loc1}_${Loc2}"; 
@

We check here whether the user provided two sequences or not, either they are given in fasta format. We extract locus names and build some base filenames from which we can derive, when needed, several temporary output filenames.

<<declare variables>>=
# file flags
my ($blast_flg, $hsps_flg, $geneid_flg, $plots_flg) = (1, 1, 1, 1);
@ %def $blast_flg $hsps_flg $geneid_flg $plots_flg

We initialize those flag variables to '1' in order to get, by default, into all the main subroutines called from main loop. They will be modified when [[Which_Options()]] function resets some of the option variables. 

<<declare uses>>=
use File::Copy;
@

The [[File::Copy]] module provides [[copy]] and [[move]] functions ([[move]] works across file-sytem boundaries, the standard [[Perl]] built-in [[rename]] ---usually--- does not).

<<global subroutines>>=
# copying files
sub copy_files() {
  	&go_to_die("FATAL ERROR!!! Couln't find \'$_[0]\' file. $!\n")
         unless &exists_file($_[0]);
    copy(@_) or &copy_error(@_);
}
sub copy_error() { &go_to_die("FATAL ERROR !!! Could not copy file \'$_[0]\' to \'$_[1]\': $!\n") }
@ %def &copy_files &copy_error

<<define defaults>>=
my $verbose_str = " -v ";
@ %def $verbose_str
<<set flags-vars>>=
do {
    &copy_files("$hsp${Loc1}_${Loc2}.srQ", "$SGPtmpG.srQ");
    &copy_files("$hsp${Loc1}_${Loc2}.srS", "$SGPtmpG.srS");
    &copy_files("$hsp${Loc1}_${Loc2}.aln", "$SGPtmpG.aln");
    $hsps_flg = 0;
} if defined($hsp);
do {
    &copy_files("$tbx", "$SGPTMP.tbx");
    $blast_flg = 0;
} if defined($tbx);
# $geneid_flg = 0;
$savefiles_flg = 1 if defined($ofn);
$plots_flg = 0 unless defined($ps_output);
# setting other variables
$GeneidOptions = "$geneid_opt"   if defined($geneid_opt);
$GeneidParam   = "$geneid_param" if defined($geneid_param);
$BlastOptions  = "$blast_opt"    if defined($blast_opt);
$verbose_str = "" if $verbose_flg;
@

[[$verbose_str]] switch off the STDERR report generation on our GFF tools by default ('[[-v]]' option). If [[$verbose_flg]] %$
is given then that variable is set to empty string (GFF tools will produce the basic report output on STDERR).
\todo{set flags-vars}{
\item When redefining [[$GeneidOptions]] and [[$BlastOptions]] the new options passed through command-line override default ones, but these options are not checked (although that, program will die as [[geneid]] or [[blast]] receive wrong options). Is this a good choice, or maybe is better to join the user defined options to the default ones. Conflicts will arise with last approach whether the same option is defined from defaults and command-line (so, at least, it is simpler to override defaults by user provided values).
}

\subsubsctn{Printing help}

<<declare uses>>=
use Pod::Text;
@

\cd{use Pod::Text;} This module converts POD data to formatted ASCII text. This defines the single function \cd{pod2text([\cv{-a},] [\cv{-width}\cp{N},] \cp{inputfile})}, that can take the following options: '\cv{-a}' for an alternative output format, '\cv{-width}' to set max terminal width. '\cp{inputfile}' must have POD format.

<<global subroutines>>=
# Prints help 
sub prt_Help() {
    my $tmp_pod_file = "$TMP/sgp.pod";
    open(KI, "> $tmp_pod_file");
    while (<DATA>) {
        s/\$PROGRAM/$PROGRAM/g ;
        s/\$VERSION/$tmp_ver[3]/g ;
        print KI $_ ;
    };
    close(KI);
    pod2text($tmp_pod_file);
    unlink($tmp_pod_file) or &go_to_die("Can't delete $tmp_pod_file: $!\n");
    exit(1);
}
@ %def &prt_Help
%$

\cd{unlink()} This command deletes a list of files. Returns the number of files successfully deleted.

\subsubsctn{Some general subroutines}

%@<<declare variables>>=
<<global subroutines>>=
# Deleting temporary files on TMP
sub clean_tmp() {
    opendir(DIR,"$TMP");
    my @files = map { "$TMP/$_" } grep { /^$TMPROOT/ } readdir(DIR);
    closedir(DIR);
    $#files and 
        ( unlink(@files)
          and &prt_Header("********* Temporary files were deleted *********")
          or &prt_Header("********* Can't unlink @files : $! *********")
        ) or 
          &prt_Header("********* There are no temporary files in $TMP *********");
}
# writing die messages to STDERR and clean_tmp before exit.
sub go_to_die() { (print STDERR "@_") && &clean_tmp(); exit(1) }
@ %def &clean_tmp &go_to_die
%$

The [[glob()]] function provides globbing (get a list of filenames using wildcards) with the \textsc{Unix} C-shell semantics. Although that, we have to work with [[opendir]]/[[readdir]].

<<global subroutines>>=
# Reporting IN/OUT progress.
sub prt_progress() {
    $verbose_flg && do {
        print STDERR ".";
        (($_[0] % 50) == 0) && print STDERR "[".&fill_left($_[0],6,"0")."]\n";
    };
}
#
sub prt_foeprg() {
    $verbose_flg && ((($_[0] % 50) != 0) && print STDERR "[".&fill_left($_[0],6,"0")."]\n" );
}
# Get a fixed length string from a given string and filling char/s.
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { my $l = length($_[0]); my $k = int(($_[1] - $l)/2); ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k))) }
# returns the max value from input array
sub max() { my ($z) = shift @_; my $l; foreach $l (@_) { $z = $l if $l > $z ; }; $z } 
# section headers to STDERR
sub prt_Header() { print STDERR ("*" x 80)."\n** ".&fill_mid("@_",74," ")." **\n".("*" x 80)."\n" }
@ %def &prt_progress &prt_foeprg &fill_right &fill_left &max

[[prt_progress(counter)]] and [[prt_foeprg(counter)]] are used for progress report on STDERR, they both need a \cv{counter} integer that is used to calculate whether a newline (including a subtotal in the former, or the total for the last) or a progress item ('.') is sent to STDERR.

[[fill_right(string,max_length,fill_char)]], [[fill_left(string,max_length,fill_char)]] and [[fill_mid(string,max_length,fill_char)]] will reformat any given \cv{string} by adding \cv{fill\_char} (blanks, dots, \ldots) to the left, right or both ends respectively, obtaining a final string with the given \cv{max\_length}. [[prt_Header(string)]] surrounds \cv{string} with a '*' frame, reporting to STDERR that we are executing a new program section.

[[max(list)]] returns the maximum value from within the elements of \cv{list}.

<<global subroutines>>=
# Timing.
sub get_exec_time() {
    $verbose_flg && do {
        my $End = $_[0];
        my ($c,$s,$m,$h,$r);
        $r = $End - $Start;
        $s = $r % 60;
        $r = ($r - $s) / 60;
        $m = $r % 60;
        $r = ($r - $m) / 60;
        $h = $r % 24;
        ($s,$m,$h) = (&fill_left($s,2,"0"),&fill_left($m,2,"0"),&fill_left($h,2,"0"));
        print STDERR "##\n";
        &prt_Header("\"$PROGRAM\"  Execution Time:  $h:$m:$s");
    };
}
@ %def &get_exec_time
%$

[[get_exec_time(time)]] returns execution time since [[$Start]].%$ 
The best choice taken until now is to provide as input the built-in perl function [[time]]. Maybe a better timming procedure will be implemented in a future if needed.
 
\subsctn{Running [[blast]] on sequences}

<<declare variables>>=
# Processes
my $status;
# Blast 
my $BlastProgram = "tblastx";
my $PressdbProgram = "pressdb";
my $BlastMatrix = "$SGP2param/blosum62mod"; 
my $BlastOptions = "-hspmax 10000 -nogap";
@ %def $status $BlastProgram $PressdbProgram $BlastMatrix $BlastOptions
%$

[[$BlastProgram]] %$
is set to [[tblastx]] because we are going to compare two nucleotide sequences at aminoacid level. [[tblastx]] first generates six frame translations for each sequence.
[[$PressDB]] %$
is the program to build a [[blast]] database from a given set of sequences in fasta format.

We will run [[blast]] with the following parameters which are set in [[$BlastOptions]]:%$
\begin{description}\setlength{\itemsep}{-0.5ex}
\desc{\cv{-matrix} \cp{\$BlastMatrix}} [[blosum62mod]] defined in [[$BlastMatrix]] %$
is a blosum matrix where stop codon score has been modified to forbide stop codons within HSP alignments.
\desc{\cv{-hspmax=}\cp{value}} Here ``\cp{value}'' is set to 10000, to allow finding as much HSPs as possible.
\desc{\cv{-nogap}} This option forces [[blast]] to avoid any gap within the HSP alignment.
\end{description}

<<run blast>>=
# Runnig blast
sub Run_Blast() {
    # building DB on SEQ1
    # convert the first fasta file to database
    &prt_Header("Compiling BLAST DB on ${Loc1}") if $verbose_flg;
    my $Seq1DB = "$SGPTMP.$Seq1_Name.DB";   #temporal name for database
    copy("$Seq1", "$Seq1DB")
        or &go_to_die("FATAL ERROR !!! Could not copy file \'$Seq1\' to \'$Seq1DB\' : $!\n");
    my $pressdb = "$PressdbProgram $Seq1DB 1>&2";
    $status = system $pressdb;
    &go_to_die("FATAL ERROR !!! $? $!\n  Unsuccessful PRESSDB command :\n  $pressdb \n")
        unless $status == 0;
    # running blast program: Seq1 as DB, Seq2 as query.
    &prt_Header("Running BLAST on ${Loc1}(DB) : ${Loc2}(Query)") if $verbose_flg;
    my ($dir, $ext);
    ($Seq1DB, $ENV{'BLASTDB'}, $ext) = fileparse($Seq1DB,'');
    ($BlastMatrix, $dir, $ext) = fileparse($BlastMatrix,'');
    ($ENV{'BLASTMAT'} = $dir) =~ s%/$%% ;
    my $blast = "$BlastProgram $Seq1DB $Seq2 -matrix $BlastMatrix $BlastOptions > $SGPTMP.tbx";
    $status = system $blast;
    &go_to_die("FATAL ERROR !!! $? $!\n  Unsuccessful BLAST command :\n  $blast \n")
        unless $status == 0;
    unlink("$ENV{'BLASTDB'}$Seq1DB");
    # saving files
    copy("$SGPTMP.tbx", "$ofn${Loc1}_${Loc2}.tbx") if $savefiles_flg;
} # END_SUB: Run_Blast
@ %def &Run_Blast $Seq1DB $ext $pressdb $blast
%$

[[@blast]] is a multivalued list that is interpreted by [[system]] function in a safe way (safe from expanding wildcards or splitting up words with whitespace in them) as an indirect object. The problem with such approach was that all the list elements are taken as input file arguments, so I have returned to a more traditional form.

We redefine the environment variables [[BLASTDB]] and [[BLASTMAT]] as follows: 
\begin{itemize}\setlength{\itemsep}{-0.5ex}
\item [[BLASTDB]] to the path in which [[blast]] program can find the user defined database (by default [[BLASTDB]] is set to '/Seq/blast' in our system).
\item [[BLASTMAT]] to the path in which [[blast]] program can find the given scoring matrix (by default [[BLASTMAT]] is set to '/usr/local/molbio/Install/wublast/matrix' in our system).
\end{itemize}

\subsctn{Processing HSPs from [[blast]]}

<<declare variables>>=
# Extract HSPs
my $GetSRsProgram = "$SGP2/GetSRsAln.pl";
@  %def $GetSRsProgram

Take care that [[GetSRsAln]] program requires [[parseblast]] filter. We are using the following [[GetSRsAln]] options:
\begin{itemize}\setlength{\itemsep}{-0.5ex}
\item [[-b]] : set GFF [[<score>]] field from HSP bit score.
\item [[-C <real_num>]] : [[<real_num>]] is a real number for lower HSP score cutoff.
\item [[-H <file_name>]] : include HSPs in output (in GFF format) and write to [[<file_name>]].
\item [[-W <file_name>]] : write output to separate files, '[[<file_name>.srQ]]' for QUERY and '[[<file_name>.srS]]' for SUBJECT.
\end{itemize}

\todo{declare variables/extract HSPs}{
\item check if paths to [[parseblast]] are correctly defined in [[GetSRsAln]]. Better if there is any way to define external program paths in a [[Install]] script.
\item In a future will be faster to implement most routines of [[parseblast]] and [[GetSRsAln]] in {\sgp}. This will increase speed by improving internal usage of the parsed data structures and by requiring less temporary files.
}

<<extract HSPs>>=
# Extracting and processing HSPs
<<extract subs>>
sub Extract_HSP() {
    &prt_Header("Extracting SRs from BLAST output") if $verbose_flg;
    #
    my $getSR = "$GetSRsProgram -bC $S_CUTOFF -H $SGPtmpG -W $SGPtmpG -- $SGPTMP.tbx";
    $status = system $getSR;
    &go_to_die("FATAL ERROR !!! $? $!\n  Unsuccessful GETSRs command :\n  $getSR \n")
        unless $status == 0;
    #
    &write_HSP_files("$SGPtmpG.srS", "$SGPtmp1.hsp-sr"); # I suposse that $SGPtmp1 is Subject
    &write_HSP_files("$SGPtmpG.srQ", "$SGPtmp2.hsp-sr"); # and $SGPtmp2 is query, else modify this lines.
    &write_HSP_files("$SGPtmpG.hsp", "$SGPtmp2.hsp", "$SGPtmp1.hsp", "$SGPtmpG.aln"); 
    # 
  SAVEFILES: do {
      copy("$SGPtmpG.srQ",    "$ofn${Loc1}_$Loc2.srQ"); # Those files have the relationships between
      copy("$SGPtmpG.srS",    "$ofn${Loc1}_$Loc2.srS");  # Query and Subject coordinates so you can
      copy("$SGPtmpG.hsp",    "$ofn${Loc1}_$Loc2.hsp");  # recover the sequence substring for both.
      copy("$SGPtmp1.hsp-sr", "$ofn$Loc1.hsp-sr");
      copy("$SGPtmp2.hsp-sr", "$ofn$Loc2.hsp-sr");
      copy("$SGPtmp1.hsp",    "$ofn$Loc1.hsp");
      copy("$SGPtmp2.hsp",    "$ofn$Loc2.hsp");
      copy("$SGPtmpG.aln",     "$ofn${Loc1}_$Loc2.aln");
    } if $savefiles_flg;
} # END_SUB: Extract_HSP
@ %def &Extract_HSP $getSR
%$

<<extract subs>>=
sub write_HSP_files() {
    my @names = @_;
    my ($DSC, $SHSP, $scnd, $thrd) = (38, 0, 0, 0);
    open(SR,"< ".(shift @names));
    open(S1,"> $names[0]");
    @names >= 2 and (open(S2,"> $names[1]"), $scnd = 1);
    @names == 3 and (open(S3,"> $names[2]"), $thrd = 1);
    while (<SR>) {
		next if /^\#/;
        next if /^[ \t]*$/;
        chomp;
        my @ln = split;
        $ln[9] =~ s/\"//go;
        print S1 "$ln[0] $ln[1] $ln[2] ".($ln[3] + $SHSP)." ".($ln[4] - $SHSP)." ".($ln[5] - $DSC)." $ln[6] $ln[7]\n";
        print S2 "$ln[9] $ln[1] $ln[2] ".($ln[10] + $SHSP)." ".($ln[11] - $SHSP)." ".($ln[5] - $DSC)." $ln[15] $ln[17]\n"
            if $scnd;
        print S3 "$ln[0]:$ln[9] $ln[1] hsp:hsp ".($ln[3] + $SHSP).":".($ln[10] + $SHSP)." ".($ln[4] - $SHSP).":".($ln[11] - $SHSP)." ".($ln[5] - $DSC)." $ln[6]:$ln[15] $ln[7]:$ln[17]\n"
            if $thrd;
    };
    close(S3) if $thrd;
    close(S2) if $scnd;
    close(S1);
    close(SR);
}
@ %def &write_HSP_files
%$

[[write_HSP_files(input_file,query_file[,subject_file[,align_file]])]] can receive a list, using the first element as input file, and the others (from one up to three) as output files. First output file ([[query_file]]) is a GFF file built from GFF fields from [[$0]] to [[$7]], second one ([[subject_file]]) is built from GFF fields from [[$9]] to [[$17]], finally, last file ([[align_file]]) generates [[gff2aplot]] suitable records.

\subsctn{Running [[geneid]] on SRs}

A number of modifications need to be made to the standard
geneid. Modifications need to be kept to a  minimum; the
goal is that sgp-2 works as geneid when in absence of sequence
conservation. % ~rguigo/research/humus/SGP2/Reports/humus.tex

\begin{enumerate}
\item geneid scores converted to {\tt log2}.
\item new scoring schema ([[ScoreExons.c]]):
$$
 scoreExons = (wS \times scoreSites) + (wM \times scoreMarkov) + (wSR
 \times scoreSR)
$$

currently, $wS = 1$, $wM =1$ and $wSR = 0.20$. In addition, there is a
penalty for the nucleotides in a predicted exon overlapping SRs, not
in an SR. If $nosr$ is the number of nucleotides not in an SR, then
we substract from $scoreSR$, $nosr \times NOSCORE$. Currently,
$NOSCORE=0.30$.

\end{enumerate}
 
<<declare variables>>=
# geneid
my $GeneidProgram = "$SGP2/geneid.v1.0-sgp/bin/geneid";
my $GeneidParam   = "$SGP2/geneid.v1.0-sgp/param/human3iso.param";
my $GeneidOptions = "-G";
@ %def $GeneidProgram $GeneidParam $GeneidOptions

[[$GeneidParam]] %$
is set to [[human3iso.param]]. This parameter file defines three Markov models for three differnt isochores of G+C content. A Markov chain of order two for defining the start sites, another one of order one for the acceptors and a Position Weight Matrix (PWM) donors. The gene model used by [[geneid]] to assemble predicted exons into the best solution, is also defined within that parameter file. 

We will run [[geneid]] with the following parameters which are set in [[$GeneidOptions]] %$
\begin{description}\setlength{\itemsep}{-0.5ex}
\desc{\cv{-G}} Print output predictions in GFF-format.
\desc{\cv{-P} \cp{param\_file}} Read parameters from \cp{param\_file}
\desc{\cv{-S} \cp{similarity\_file}} Run [[geneid]] predictions with similarity regions file.
\end{description}

<<run geneid>>=
# Running geneid
sub Run_geneid() {
	my $geneid;
    # running geneid in $Seq1 with tblastx output
    &prt_Header("Running GENEID program on $Loc1") if $verbose_flg;
    $geneid = "$GeneidProgram $verbose_str $GeneidOptions -P $GeneidParam -S  $SGPtmp1.hsp-sr $Seq1 > $SGPtmp1.sgp";
    $status = system $geneid;
    &go_to_die("FATAL ERROR !!! $? $!\nUnsuccessfull GENEID command on \'$Loc1\':\n  $geneid \n")
        unless $status == 0;
    # running geneid in $Seq2 with tblastx output
    &prt_Header("Running GENEID program on $Loc2") if $verbose_flg;
    $geneid = "$GeneidProgram $GeneidOptions -P $GeneidParam -S  $SGPtmp2.hsp-sr $Seq2 > $SGPtmp2.sgp";
    $status = system $geneid;
    &go_to_die("FATAL ERROR !!! $? $!\nUnsuccessfull GENEID command on \'$Loc2\':\n  $geneid \n")
        unless $status == 0;
  SAVEFILES: do {
      copy("$SGPtmp1.sgp", "$ofn$Loc1.sgp");
      copy("$SGPtmp2.sgp", "$ofn$Loc2.sgp");
    } if $savefiles_flg;
  ECHOFILES: do {
      system "cat $SGPtmp1.sgp $SGPtmp2.sgp"; 
    } if $verbose_flg;
} # END_SUB: Run_geneid
@ %def &Run_geneid $geneid

\subsctn{Obtaining figures}

We provide a PostScript output for {\gi} predictions and {\bl} SRs for both sequences. This is achieved by two child [[gff2ps]], one for each locus. Also, we provide the alignment view once '[.aln]' file is converted to a proper input file for [[gff2aplot]].

<<declare variables>>=
# gff2ps
my $Gff2psProgram = "$SGP2/gff2ps";
my $Gff2psParam   = "-C $SGP2param/sgp2-gff2ps.rc";
my $Gff2psOptions = "";
@ %def $Gff2psProgram $Gff2psParam $Gff2psOptions
<<graphical output>>=
# Running gff2ps and aplot
<<graphical subs>>
sub Make_Plots() {
    my ($gff2ps, $aplot);
    # predicted genes separately -- gff2ps on Loc1
    &prt_Header("Running GFF2PS program on $Loc1") if $verbose_flg;
    $gff2ps = "$Gff2psProgram $verbose_str $Gff2psOptions $Gff2psParam -- $SGPtmp1.sgp $SGPtmp1.hsp-sr > $ps_output$Loc1.ps";
    $status = system $gff2ps;
    &go_to_die("FATAL ERROR !!! $? : $!\nUnsuccessfull GFF2PS command : $gff2ps \n")
        unless $status == 256;
    # predicted genes separately -- gff2ps on Loc2
    &prt_Header("Running GFF2PS program on $Loc2") if $verbose_flg;
    $gff2ps = "$Gff2psProgram $Gff2psOptions $Gff2psParam -- $SGPtmp2.sgp $SGPtmp2.hsp-sr > $ps_output$Loc2.ps";
    $status = system $gff2ps;
    &go_to_die("FATAL ERROR !!! $? : $!\nUnsuccessfull GFF2PS command : $gff2ps \n")
        unless $status == 256;
    <<run aplot>>
} # END_SUB: Make_Plots
@ %def &Make_Plots $gff2ps

\label{status256}[[$status]] %$
is compared to 256 because this is the returned value by [[system]] from [[gff2ps]] shell script call when [[exit(0)]], normal program exit, is returned by that shell. I still do not know why [[system()]] returns that value instead of 0 (as it happens with [[blast]], [[GetSRsAln]] and [[geneid]] system calls). 

<<declare variables>>=
# aplot
my $AplotProgram  = "$SGP2/gff2aplot";
my $AplotParam    = "-O $SGP2param/sgp2-aplot.rc";
my $AplotOptions  = "";
@ %def $AplotProgram $AplotParam $AplotOptions
<<graphical subs>>=
sub load_gene_struc() {
    my $PRT = shift @_;
    my $strand;
    open(GQ,"< $_[0]");
    while (<GQ>) {
        next if /^\#/;
        next if /^[ \t]*$/;
        chomp;
        my @ln = split;
        $strand = ($ln[6] eq '+') ? 0 : 1;
        print $PRT "$ln[0] $ln[1] exon $ln[3] $ln[4] 1.00 $strand $ln[7] gene$ln[8]:\n";
    };
	close(GQ);
}    
sub build_aplot_file() {
    my (@start, @end, @strand);
    open(APLOT,"> $SGPtmpG.aplot");
    &load_gene_struc(*APLOT,"$SGPtmp1.sgp");
    &load_gene_struc(*APLOT,"$SGPtmp2.sgp");
    open(GALN,"< $SGPtmpG.aln");
    while (<GALN>) {
        next if /^\#/;
        next if /^[ \t]*$/;
        chomp;
        my @ln = split;
        @start  = split /:/, $ln[3];
        @end    = split /:/, $ln[4];
        @strand = split /:/, $ln[6];
        ($start[0], $end[0]) = ($end[0], $start[0]) if $strand[0] eq '-';
        ($start[1], $end[1]) = ($end[1], $start[1]) if $strand[1] eq '-';
        print APLOT "$ln[0] $ln[1] align $start[0]:$start[1] $end[0]:$end[1] $ln[5] . .\n";
    };
	close(GALN);
    close(APLOT);
  SAVEFILES: do {
      copy("$SGPtmpG.aplot", "$ofn${Loc1}_$Loc2.aplot");
    } if $savefiles_flg;
}
@  %def &build_aplot_file &load_gene_struc

\todo{run aplot}{
\item Reformating for [[$SGPtmpG.aln]] %$
should be avoided if we can redefine the way [[gff2aplot]] process the frames for aplot format. Take care of this issue if we modify [[gff2aplot]] to accept [[frame:frame]] fields.
}

<<run aplot>>=
# building aplot file
&build_aplot_file();
# run aplot
&prt_Header("Running APLOT program on $Loc1:$Loc2") if $verbose_flg;
$aplot = "$AplotProgram $verbose_str -T \"$Loc1 x $Loc2\" $AplotOptions $AplotParam -- $SGPtmpG.aplot > $ps_output$Loc1\_$Loc2.ps";
$status = system $aplot;
&go_to_die("FATAL ERROR !!! $? $!\nUnsuccessfull APLOT command : $aplot \n")
    unless $status == 256;
@ %def $aplot

We have the same problem that we stated from [[gff2ps]] shell script returned exit value to [[system call]] (see explanation on page~\pageref{status256}). 

\subsubsctn{[[gff2ps]] config file}

<<sgp2-gff2ps.rc>>=
# 
# sgp2-gff2ps.rc - config file for gff2ps plots on sgp2.
#
# $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $ 
#
<<gff2ps set layout>>
<<gff2ps set sources>>
<<gff2ps set groups>>
<<gff2ps set features>>
@
<<gff2ps set layout>>=
# L # Page Layout
page_size=a4
page_orientation=landscape
background_color=white
foreground_color=black
show_left_source_label=true
left_source_label_width=2cm
show_right_source_label=false
right_source_label_width=0cm
@
<<gff2ps set sources>>=
# S # Sources
*::unfold_grouped_ungrouped=off
*::unfold_grouped_line=off
*::unfold_ungrouped_line=off
Bgeneid_v1.0::source_left_label=SGP2
geneid_v1.0::source_right_label=SGP2
TBLASTX::source_left_label=TBLASTX
TBLASTX::source_right_label=TBLASTX
TBLASTX::track_spacing_scale=0
TBLASTX::keep_feature_label_space=off
TBLASTX::vert_align=bottom
@
<<gff2ps set groups>>=
# G # Groups
*::group_line=arrow
@
<<gff2ps set features>>=
# F # Features
!/hsp/::fill_shape_mode=frame-remainder
first::shape=arrow_end
terminal::shape=arrow_head
internal::shape=box
single::shape=single
hsp::shape=box
hsp::fill_color=lightviolet
hsp::fill_shape_mode=1_color
@

\subsubsctn{[[aplot]] config file}

<<sgp2-aplot.rc>>=
# 
# sgp2-aplot.rc - config file for aplot plots on sgp2.
#
# $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $ 
#
<<gff2aplot set flags>>
<<gff2aplot set defaults>>
<<gff2aplot set options>>
<<gff2aplot set features>>
<<gff2aplot set special>>
@
<<gff2aplot set flags>>=
##
FL ################# FLAGs
##
Display_TITLE             : Y
Display_SUBTITLE          : Y
Display_X-Axis_LABEL      : Y
Display_Y-Axis_LABEL      : Y
Display_Percent-Box_LABEL : Y
Display_Extra-Box_LABEL   : Y
Display_PERCENT-BOX       : Y
Display_EXTRA-BOX         : N
Display_GENE_LABEL        : Y
Display_GENE_RULE         : Y
Display_HalfHeightBOX     : Y
Display_FullHeightBOX     : Y
Display_BOX_LABEL         : Y
Display_UserDef_BOX_LABEL : Y
Display_ARROW             : Y
Display_JOINS             : Y
Display_RIBBON            : Y
Display_SELECTION-BOX     : Y
Display_GFF               : Y
Display_GFF-ReverseOrder  : Y
Display_FUNCTION          : N
APlotLine_GroupScore      : N
APlotLine_ScaleWidth      : N
APlotLine_ScaleGrey       : Y
XY_AXES_Same-SIZE         : N
Display_TickMark-LABEL    : Y
Display_APlot_X-Ticks     : Y
Display_Percent_X-Ticks   : Y
Display_ExtraBox_X-Ticks  : Y
Display_APlot_Y-Ticks     : Y
Display_Percent_Y-Ticks   : Y
Display_ExtraBox_Y-Ticks  : Y
Display_OnlyLower_X-Ticks : N
Display_GRID              : N
ZOOM_Zoom                 : N
ZOOM_Area                 : N
Zoom_Marks                : N
@
<<gff2aplot set defaults>>=
##
DF ################# DEFAULT VALUES
##
PAGE_SIZE               :  a4
FEATURE_LABELS_LENGTH   :  0
GROUP_LABELS_LENGTH     :  0
FEATURE_X-LABELS_ANGLE  :  0
GROUP_X-LABELS_ANGLE    :  0
FEATURE_Y-LABELS_ANGLE  :  0
GROUP_Y-LABELS_ANGLE    :  0
FEATURE_LABELS_FONTSIZE :  1
GROUP_LABELS_FONTSIZE   :  1
BACKGROUND_COLOR        : white
FOREGROUND_COLOR        : black
APlotBox_BGCOLOR        :  BG
PercentBox_BGCOLOR      :  BG
ExtraBox_BGCOLOR        :  BG
Strand-Arrows_COLOR     :  FG
Join-Lines_COLOR        :  FG
SelectionBox_BGCOLOR    : grey
Function_COLOR          : red
Zoom_Area_Mark_COLOR    : lightred
PERCENT_ORIGIN          :  50
PERCENT_END             : 100
ScaleMajorTICKMARK      :   5
ScaleMinorTICKMARK      :   5
PercentMajorTICKMARK    :   5
PercentMinorTICKMARK    :   5
ExtraMajorTICKMARK      :   2
ExtraMinorTICKMARK      :   5
@
<<gff2aplot set options>>=
##
OP ################# OPTIONs
##
Align_NAME            : ##DEFAULT##
X-Sequence_NAME       : ##DEFAULT##
Y-Sequence_NAME       : ##DEFAULT##
TITLE                 : ##DEFAULT##
SUBTITLE              : ##DEFAULT##
X-Axis_LABEL          : ##DEFAULT##
Y-Axis_LABEL          : ##DEFAULT##
Percent-Box_LABEL     : Identity %
Percent-Box_SUBLABEL  : ##DEFAULT##
Extra-Box_LABEL       : ##DEFAULT##
Extra-Box_SUBLABEL    : ##DEFAULT##
HalfSizeBox_BGCOLOR   : ##DEFAULT##
FullSizeBox_BGCOLOR   : ##DEFAULT##
Ribbon_BGCOLOR        : ##DEFAULT##
SEQUENCE1_ORIGIN      : ##DEFAULT##
SEQUENCE1_END         : ##DEFAULT##
SEQUENCE2_ORIGIN      : ##DEFAULT##
SEQUENCE2_END         : ##DEFAULT##
Zoom_SEQUENCE1_ORIGIN : ##DEFAULT##
Zoom_SEQUENCE1_END    : ##DEFAULT##
Zoom_SEQUENCE2_ORIGIN : ##DEFAULT##
Zoom_SEQUENCE2_END    : ##DEFAULT##
TICKMARK              : ##DEFAULT##
SMALLTICKMARK         : ##DEFAULT##
@
<<gff2aplot set features>>=
##
FT ################# GFF FEATUREs DEFINITION
##
exon   N   F   R   Y   N   N   N   3   green   lightgreen
@
<<gff2aplot set special>>=
##
SP ################# Special gff Features
##
GROUPLIMITS : genebounds
PLOTLIMITS  : seqbounds
APLOT       : align|hsp
HIGHLIGHT   : boxit
RECTANGLE   : rectangle
CIRCLE      : circle
TEXT        : text
FUNCTION    : function
EXTRABOX    : not_defined
@ 

\newpage

\sctn{Testing {\sgp}}

<<runsgp2-a.sh>>=
#
# $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $
#

SGP2="$SGP/bin/sgp2.pl";

ISEQ=$1;
ODIR=$2;
IFILE=$3;

while read gene locus1 locus2;
do
    echo $gene $locus1 $locus2;
    $SGP2 -v -1 "$ISEQ/$locus1" -2 "$ISEQ/$locus2"\
          -k "$IFILE/$gene." -p "$IFILE/$gene." > "$ODIR/$gene.sgp";
done;

exit 0;
@ 

This short script was written to test {\sgp} on Sanger Center data-set ([[scimog]]). Below are shown the steps we followed to do that test.

<<testsgp2.sh>>=
setenv SCIMOG /home1/rguigo/research/humus/data/scimog
setenv SGP /home3/jabril/development/sgp/Devel

cd $SGP/test-sets

sh $SGP/bin/runsgp2-a.sh $SCIMOG/fasta sgp-2 sgp-2/tmp < $SCIMOG/scimog
cat $SGP/test-sets/sgp-2/*.sgp | /home3/jabril/bin/evalua/evalua-1.sh $SCIMOG/scimog.length+ccds $SCIMOG/scimog.locus geneid_v1.0
@ 
%$

\subsctn{Running [[sgp1]]}

Here we will draft a shell script to obtain results from [[sgp1]] program, kindly provided by Thomas Wiehe, and compiled for \textsc{Irix} on apolo.

<<runsgp1-a.sh>>=
#
# $Id: sgp2.nw,v 1.9 2000-10-19 11:22:57 jabril Exp $
#

SGP1="$SGP_DIR/sgp-1";

ISEQ=$1;
ODIR=$2;
IFILE=$3;

while read gene locus1 locus2;
do
    echo $gene $locus1 $locus2;
    $SGP1 --sgp -d -- \
          "$IFILE/${gene}.${locus1}_${locus2}.tbx" \
          "$ISEQ/$locus1" "$ISEQ/$locus2" | \
          perl -ne 'BEGIN{$p=1} /^Predicted/ && ($p=0); print $_ if $p' - > "$ODIR/$gene.sgp1";
done;

exit 0;
@ 

<<testsgp1.sh>>=
# 
# Must run on apolo.
#
setenv SGP /home3/jabril/development/sgp/Devel
setenv SGP_DIR /home2/twiehe/SGP-1/SGP-1
setenv SCIMOG /home1/rguigo/research/humus/data/scimog

# cd $SGP/test-sets
cd $SGP_DIR

# convert tbx files obtained from sgp2 tblastx call to alignment file needed by sgp1
ls -1 sgp-2/tmp/*.tbx | while read name; do k=`basename $name`; sh tblastx2gff.2.1.awk $name > sgp-1/tmp/$k; done

# obtaining gene predictions from sgp1
sh $SGP/bin/runsgp1-a.sh $SCIMOG/fasta $SGP/test-sets/sgp-1 $SGP/test-sets/sgp-1/tmp < $SCIMOG/scimog

# remember that sgp1 output includes the protein sequences
# (-nosplit option does not work) so they are removed within runsgp1-a.sh
perl -ne 'next if /^\#/;
          next if /^[ \t]*$/;
          s/(gene)([\d]+):.+$/$1\_$2/; print;
         ' $SGP/test-sets/sgp-1/*.sgp1 | \
/home3/jabril/bin/evalua/evalua-1.sh $SCIMOG/scimog.length+ccds $SCIMOG/scimog.locus sgp # geneid_v1.0
@ 
%$

\subsctn{Comparing results}

The basic [[perl]] script yields similar results as the previous [[shell]], maybe faster. Next to improve is exon boundaries definition, to do that we should include [[GetExonAlignment.awk]] into our {\sgp} program.\\[2ex]

\begin{tabular}{cc}

\raisebox{-1.25ex}[0pt]{\shortstack{Results Rode\\(old [[sgp2]])\\{\scriptsize (Aug 2000)}}} &

  [[ 512  477  403  0.96  0.97  0.96  0.96  0.79  0.84  0.82  0.08  0.01 ]] \\[4ex]

\raisebox{-1.25ex}[0pt]{\shortstack{Results [[sgp1]]\\{\scriptsize (Oct 2000)}}} &

  [[ 512  541  318  0.81  0.92  0.85  0.85  0.62  0.59  0.60  0.12  0.12 ]] \\[4ex]

\raisebox{-1.25ex}[0pt]{\shortstack{Results [[sgp2]]\\{\scriptsize (Oct 2000)}}} &

  [[ 512  474  402  0.95  0.97  0.96  0.96  0.79  0.85  0.82  0.08  0.01 ]] \\

\end{tabular}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%APPENDIX

\newpage
\appendix

\sctn{Literate Programming}\vspace{2ex}

\begin{small}
\begin{quote}\slshape
I believe that the time is ripe for significantly better documentation
of programs, and that we can best achieve this by considering programs
to be works of literature. Hence, my title: "Literate Programming."
Let us change our traditional attitude to the construction of
programs: Instead of imagining that our main task is to instruct a
*computer* what to do, let us concentrate rather on explaining to
*human beings* what we want a computer to do.
\upshape\flushright --- \textbf{Donald Knuth}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
Without wanting to be elitist, the thing that will prevent Literate
Programming from becoming a mainstream method is that it requires
thought and discipline. The mainstream is established by people who
want fast results while using roughly the same methods that everyone
else seems to be using, and Literate Programming is never going to
have that kind of appeal. This doesn't take away from its usefulness
as an approach.
\upshape\flushright --- \textbf{Patrick TJ McPhee}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
A basic principle of data processing teaches the folly of trying to
maintain independent files in synchronism. It is far better to combine
them into one file with each record containing all the information
both files held concerning a given key.  Yet our practice in
programming documentation violates our own teaching. We typically
attempt to maintain a machine-readable form of a program and an
independent set of human-readable documents, consisting of prose and
flow charts. The results in fact confirm our teachings about the folly
of separate files.  Program documentation is notoriously poor, and its
maintenance is worse.  Changes made in the program do not promptly,
accurately, and invariably appear in the paper. The solution, I think,
is to merge the files, to incorporate the documentation in the source
program. This is at once a powerful incentive toward proper
maintenance, and an insurance that the documentation will always be
handy to the program user. Such programs are called
self-documenting...  
\upshape\flushright --- \textbf{Frederick Brooks}
\end{quote}\vspace{2ex}

\begin{quote}\slshape
Top-down design and successive refinement attack a programming task by
specifying it in the most general terms, then expanding these into
more and more specific and detailed actions, until the whole program
is complete. Structured design is the process of controlling the
overall design of a system or program so the pieces fit together
neatly, yet remain sufficiently decoupled that they may be
independently modified.  ... Each of these disciplines can materially
improve programmer productivity and the quality of code produced.
\upshape\flushright --- \textbf{Kernighan and Plauger}
\end{quote}\vspace{4ex}
\end{small}

We shall call our program \sgp{}, we are developing a parallel branch
for Sintenic Gene-Prediction, the other branch is developed by Thomas
Wiehe. Our new version is written as a [[noweb]] file named
[[sgp2.nw]]. From that file we can obtain both the code and the
documentation. A short script named [[aol]] converts the '[[.nw]]' to
'[[.tex]]' ---the \LaTeX{} documentation--- and '[[.pl]]' ---the real
program--- (Wow!!!). What [[aol]] does is:

\begin{enumerate}
\item Extracts program code from the [[noweb]] file:\\[1ex]
[[notangle -L -Rsgp2.pl sgp2.nw > sgp2.tmp]]
\item Swaps first line ([[#line]]) with second ([[#!/]]\ldots) to make it runnable:\\[1ex]
[[perl -ne '$. > 2  && do { print; next }; 
          $. == 1 && do { split / /, $_, 3; $n = "$_[0] ".(++$_[1])." $_[2]"};
          $. == 2 && ( print "$_$n" );
         ' sgp2.tmp > sgp2.pl]]
\item Extracts program documentation and \LaTeX{}'ing it:\\[1ex]
[[noweave -x sgp2.nw > sgp2.tex]]\\[1ex]
[[latex sgp2.tex ; dvips sgp2.dvi -o sgp2.ps]]
\end{enumerate}

\newpage

\sctn{License Terms}

This program is distributed under GNU General Public License as described below:\\[2ex]

<<copyleft>>=
######################################################################
#                               sgp2                                 #
######################################################################
#
#     Sinteny based Gene Prediction tool.
#
#     Copyright (C) 2000 - Josep Francesc ABRIL FERRANDO
#                                 Roderic GUIGO SERRA
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
@

\newpage

\sctn{Man Pages}

The documentation for [[perl]] programs is written in a simple markup language called POD (Plain Old Documentation). Translators exist for [[pod2man]], [[pod2text]], [[pod2html]], [[pod2latex]], and [[pod2fm]]. 

The idea is to have the online documentation included with the source. That is possible with [[__DATA__]] tag, which defines a chunk of data within the same file.
%% TODO: define POD tags and which style was used for building up this man. 

<<POD man page trailer>>=
__DATA__

=head1 NAME

    
$PROGRAM ($VERSION) - Improving Gene Prediction with Sinteny.

=head1 SYNOPSIS

    
    $PROGRAM [-hv] [-o 'options'] [-g 'options'] \
      [-P filename] [-p filename] [-k filename] \
      [-c value] [-s value] -1 seqfile_1 -2 seqfile_2

=head1 DESCRIPTION

=head1 OPTIONS

    

=over 4

=item B<-1> I<seqfile_1>

input file for first species.

=item B<-2> I<seqfile_2>

input file for second species.

=item B<-g>

geneid options

=item B<-o>

tblastx options

=item B<-c> I<value>

tblastx score cuttof

=item B<-s> I<value>

shrink hsp\'s by value

=item B<-t> I<filename>

read tblastx file

=item B<-f> I<prefix>

read hsp gff files with in directory prefix and extension .hsp-rs

=item B<-k> I<prefix>

keep intermediate files with prefix

=item B<-p> I<filename>

ps output in filename file 

=item B<-P> I<filename>

geneid parameter file

=item B<-v>

verbose mode

=item B<-h>

produces this message

=back

=head1 FILES

=head1 DIAGNOSTICS

=head1 REQUIRES

=head1 BUGS

    
Report any problem to: B<jabril@imim.es>

=head1 AUTHOR

    
Roderic Guigo   : B<rguigo@imim.es>

Josep F. Abril  : B<jabril@imim.es>

B<$PROGRAM> is under GNU-GPL (C) 2000
@ %$

\end{document}


