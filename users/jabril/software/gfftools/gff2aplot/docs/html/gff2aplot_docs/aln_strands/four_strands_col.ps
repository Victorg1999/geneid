%!PS-Adobe-3.0
%%Title: Checking Alignment Strands
%%Creator: gff2aplot
%%Version: v2.0
%%CreationDate: Fri Feb  7 20:32:11 2003
%%For: jabril
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 595 842
%%EndComments
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %                          GFF2APLOT                               %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
%    Converting alignments in GFF format to PostScript dotplots.
% 
%     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                  Thomas WIEHE                   
%                                 Roderic GUIGO SERRA       
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Id: four_strands_col.ps,v 1.2 2003-03-04 18:06:03 jabril Exp $
%
% Report BUGS to: jabril@imim.es 
%
%%BeginProlog
%
%%BeginProcSet: Short_names 1.0 0
%
/B { bind def } bind def /X { exch def } B /D { def } B /_t { true } B /_f { false } B /S { gsave } B /R { grestore } B /F { scale } B /T { translate } B /m { moveto } B /rm { rmoveto } B /l { lineto } B /rl { rlineto } B /K { stroke } B /ie { ifelse } B /cmyk { setcmykcolor } B /slw { setlinewidth } B /solid { [ ] 0 setdash } D /dotted { [ 1 ] 0 setdash } D /ldotted { [ 1 2 ] 0 setdash } D /dashed { [ 3 3 ] 0 setdash } D /ldashed { [ 6 4 ] 0 setdash } D /ddashed { [ 4 3 1 3 ] 0 setdash } D
%
%%EndProcSet:   Short_names 1.0 0
%
%%BeginProcSet: Constants 1.0 0
%
/pt { } B /cm { 28.35 mul } B /icm { 28.35 div } B /in { 72 mul } B
/OST 0.25 cm D /OSB 0.25 cm D /OSL 0.25 cm D /OSR 0.25 cm D
%
%%EndProcSet:   Constants 1.0 0
%
%%BeginProcSet: Global_functions 1.0 0
%
/vflg _f D /tflg _f D tflg { mark } if
/msg { print (\n) print flush } B /mst { print counttomark dup { dup index 20 string cvs print ( ) print 1 sub } repeat (\n) print pop flush } B /msc { mst counttomark 1 add { pop } repeat } B
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll m l l l closepath } B
/obox { 2 div dup dup dup 7 1 roll 5 1 roll 3 1 roll add 7 1 roll add 6 1 roll sub 5 1 roll sub 4 1 roll bbox } B /ibox { 2 div dup dup dup 7 1 roll 5 1 roll 3 1 roll sub 7 1 roll sub 6 1 roll add 5 1 roll add 4 1 roll bbox } B
/min { 2 copy gt { exch } if pop } B /max { 2 copy lt { exch } if pop } B
/clim { min max } B /zlim { dup 0 eq { 3 { pop } repeat 0 } { clim } ie } B
/hip { dup mul exch dup mul add sqrt } B
%
%%EndProcSet:   Global_functions 1.0 0
%
%%BeginProcSet: Text_functions 1.0 0
%
/sfnt { findfont exch scalefont setfont } B
/glblw { sfnt (X) stringwidth pop mul } B
/chrh { S newpath 0 0 m _f charpath flattenpath pathbbox exch pop 3 -1 roll pop R } B
/strh { 2 dict begin /lly 0.0 D /ury 0.0 D { ( ) dup 0 4 -1 roll put chrh dup ury gt { /ury X } { pop } ie dup lly lt { /lly X } { pop } ie } forall ury end } B
/ttshw { vflg { 9 copy 8 { pop } repeat mark exch dup length 20 gt { 0 20 getinterval (...) } if (ttshw -> ) msc } if S cmyk sfnt 8 dict begin /h X /v X /lbl X /angle X /y X /x X /hs lbl stringwidth pop D /vs lbl strh D x y T angle rotate h (rh) eq { hs } { h (ch) eq { hs 2 div } { 0 } ie } ie neg v (tv) eq { vs } { v (cv) eq { vs 2 div } { 0 } ie } ie neg m lbl show end R } B
%
%%EndProcSet:   Text_functions 1.0 0
%
%%BeginProcSet: Pseudohash_dicts 1.0 0
%
%% Fixed Color Variables (CMYK)
/colordict 37 dict D colordict begin %% using 9 colors + 28 definitions
/black { 0.00 0.00 0.00 1.00 } D /grey { 0.00 0.00 0.00 0.50 } D /verylightgrey { 0.00 0.00 0.00 0.30 } D /white { 0.00 0.00 0.00 0.00 } D /blue { 0.60 0.60 0.00 0.00 } D /green { 0.60 0.00 0.60 0.00 } D
/orange { 0.00 0.25 0.60 0.00 } D /red { 0.00 0.60 0.60 0.00 } D /lightred { 0.00 0.45 0.45 0.00 } D 
end %% colordict
%% Ribbon color mode (cmyk/pattern)
/rbxcol { cmyk } B
%% Paper Sizes (in points)
/pagedict 3 dict D pagedict begin %% 1 formats + 2 definitions
/pga4{ 595 842 } D 
end %% pagedict
%
%%EndProcSet:   Pseudohash_dicts 1.0 0
%
tflg { (%%% Basic settings and functions were defined %%%) msg } if
%
%%BeginProcSet: Setting_Vars 1.0 0
%
tflg { (%%% Setting variables %%%) msg } if
/H _t D /HT { /H _t D } B /VT { /H _f D } B /flgcrd _t D /flglscape _f D /Pb _t D /Qb _f D /axesb _t D /XYR -1 D /ZM _f D
/Dpage { pagedict begin pga4 flglscape { exch } if end } D /PPC pagedict begin pga4 end hip Dpage hip exch div D /Ch 4 pt 15 pt 4 pt PPC mul clim D
/MT 1 cm D /MB 1 cm D /ML 1 cm D /MR 1 cm D
/bg { colordict begin white end } D /fg { colordict begin black end } D /ABc { colordict begin bg end } D /PBc { colordict begin bg end } D /QBc { colordict begin bg end } D
/XO 250 D /XE 2750 D /XD XE XO sub 1 add D /YO 250 D /YE 2750 D /YD YE YO sub 1 add D /PO 0.25 D /PE 1.00 D /PD PE PO sub D
/QO 0 D /QE 1 D /QD PE PO sub D
/Ph -1 pt D /Qh -1 pt D
/KGb _f D /KLb _t D /KAXb _t D /KAYb _t D /KPXb _t D /KPYb _t D /KQXb _t D /KQYb _t D
/KASm 1000 D /KASn 200 D /KPSm 1 D /KPSn 0.25 D /KQSm 10 D /KQSn 10 D
/TTLb _t D /TTLl (Checking Alignment Strands) D /TTLz 24 pt D /TTLf { TTLz /Helvetica-Bold } D /TTLp 10 pt 25 pt TTLz 2 div zlim D /TTlb _t D /TTll (Working with four_strands.gff dataset.) D /TTlz 16 pt D /TTlf { TTlz /Helvetica } D /TTlp 10 pt 20 pt TTlz zlim D
/XSLb _t D /XSLl (Sequence on X-axes) D /XSLz 12 pt D /XSLf { XSLz /Helvetica-Bold } D /XSLp 2.5 pt 10 pt XSLz 0.25 mul zlim D /YSLb _t D /YSLl (Sequence on Y-axes) D /YSLz 12 pt D /YSLf { YSLz /Helvetica-Bold } D /YSLp 2.5 pt 10 pt YSLz 0.25 mul zlim D
/PBLb _t D /PBLl () D /PBLz 12 pt D /PBLf { PBLz /Helvetica-Bold } D /PBLp 10 pt 20 pt PBLz zlim D /PBlb _t D /PBll () D /PBlz 9 pt D /PBlf { PBlz /Helvetica } D /PBlp 10 pt 20 pt PBlz zlim D
/QBLb _t D /QBLl () D /QBLz 10 pt D /QBLf { QBLz /Helvetica-Bold } D /QBLp 10 pt 20 pt QBLz zlim D /QBlb _t D /QBll () D /QBlz 9 pt D /QBlf { QBlz /Helvetica } D /QBlp 10 pt 20 pt QBlz zlim D
/FTz 10 pt D /FTf { FTz /Helvetica } D /FTp 2 pt 10 pt FTz 0.5 mul zlim D /FTXw FTz 0 gt { 3 FTf glblw } { 0 } ie D /FTXa 0 D /FTXrb _f D /FTYw FTz 0 gt { 3 FTf glblw } { 0 } ie D /FTYa 0 D /FTYrb _t D
/GPz 0 pt D /GPf { GPz /Helvetica } D /GPp 4 pt 16 pt GPz 0.75 mul zlim D /GPpt GPp 0.25 mul D /GPXw GPz 0 gt { 17 GPf glblw } { 0 } ie D /GPXa 0 D /GPXrb _f D /GPYw GPz 0 gt { 17 GPf glblw } { 0 } ie D /GPYa 0 D /GPYrb _t D
/DRh 10 pt D /DRhb DRh 0.1 mul D /DRht DRh DRhb sub D /DRFTlh DRh FTp add D /DRGPlh DRFTlh FTz add GPp add D /DRGPlnh DRGPlh GPpt 2 mul sub D
/Blw 2 pt D /Alw 1 pt D /Clw 0.1 pt D /Clw2 Clw 2 mul D /BClw Blw Clw sub D
/KLz 8 pt D /KLf { KLz /Helvetica } D /KWx 1.5 pt D /KWn KWx 0.1 mul D /KHx KLz 0.75 mul D /KHn KLz 0.50 mul D /KHt KLz 1.0 mul D /KLp KLz 0.5 mul D /KLh KHt KLz add KLp add D /KLw 4 KLf glblw D
%
%%EndProcSet:   Setting_Vars 1.0 0
%
%%BeginProcSet: Page_layout 1.0 0
%
tflg { (%%% Computing page layout %%%) msg } if
/MT MT OST max D /MB MB OSB max D /ML ML OSL max D /MR MR OSR max D
/FL { Dpage MT MB add flgcrd { Ch add } if sub exch ML MR add sub exch } D /FXO ML D /FYO Dpage exch pop MT sub D
/getXt { dup sin 0 eq { pop (ch) } { 90 sub cos 0 ge { (lh) } { (rh) } ie } ie } B /getYt { dup cos 0 eq { pop (cv) } { 90 sub sin 0 ge { (tv) } { (bv) } ie } ie } B
/FTXh FTz FTXa cos mul FTXw FTXa sin abs mul add FTp add D /FTXt { FTXa getYt FTXa getXt } D /FTYh FTz FTYa cos mul FTYw FTYa sin abs mul add FTp add D /FTYt { FTYa getYt FTYa getXt } D
/GPXh GPz GPXa cos mul GPXw GPXa sin abs mul add GPp add D /GPXt { GPXa getYt GPXa getXt } D /GPYh GPz GPYa cos mul GPYw GPYa sin abs mul add GPp add D /GPYt { GPYa getYt GPYa getXt } D
/ATX GPXh GPp add FTXh FTp add add DRh add Blw add D /ATY GPYh GPp add FTYh FTp add add DRh add Blw add D
/AXL YSLz YSLp add ATY add D /AXR FL pop KAYb KPYb or KQYb or { KLw KHt add sub } if D /AX AXR AXL sub D 
/AYT TTLz TTLp add TTlz TTlp add add XSLz XSLp add add ATX add D /AYB AYT AX add D /AY AX D
XYR 0 le { /XYR 1 D } if axesb not { XYR 1 ge { /AY AY XYR div D } { /AX AX XYR mul D } ie } if
/PYT AYB KAXb { KLb { KLh } { KHt } ie } { KLp } ie add D
/rspc FL exch pop PYT sub Pb { KPXb { KLb { KLh } { KHt } ie } { KLp } ie sub } if Qb { KQXb { KLb { KLh KLp sub } { KHt } ie } if sub } if D
/PY Pb { Ph 0 gt { 1.5 cm rspc Qb { 2 div } if Ph clim } { 2.0 cm } ie } { 0 } ie D /PYB PYT PY add D
/QYT PYB Pb { KPXb { KLb { KLh } { KHt } ie } { KLp } ie add } if D /QY Qb { rspc Pb { PY sub } if Qh 0 gt { 2 cm exch Qh clim } if } { 0 } ie D /QYB QYT QY add D
%
%%EndProcSet:   Page_Layout 1.0 0
%
%
%%BeginProcSet: Aplot_dict 1.0 0
%
tflg { (%%% Setting aplot dictionary %%%) msg } if
/aplotdict 120 dict D aplotdict begin
/Xscm { Xscale mul } B /Xscme { Xscm exch } B
/Yscm { Yscale mul } B /Yscme { Yscm exch } B
/Hscm { H { Xscm } { Yscm } ie } B
/rF { 1 exch dup 0 eq { pop 10 -9 exp } if div } B 
/Fm { Yscme Xscme m } B /Fl { Yscme Xscme l } B
/corner { S 4 -2 roll m 0 0 0 0 6 4 roll dup neg 5 1 roll 6 1 roll dup neg 4 1 roll exch 2 { rl S bg cmyk Blw 6 div slw K R rl S fg cmyk Blw slw [1 3] 0 setdash K R } repeat R } B 
/zoomtk { 4 copy 3 1 roll exch ATX ATY corner ATX neg ATY neg corner ATX ATY neg corner ATX neg ATY corner } D
/gradcol { dup dup dup 7 1 roll 5 1 roll 3 1 roll mul 7 1 roll mul 6 1 roll mul 5 1 roll mul 4 1 roll } B
/shp { S 7 dict begin /s_s X Hscm /s_e X Hscm /s_o X /s_p X /f_x { s_e s_o sub } D /s_m { f_x 2 div s_o add } D 0 BClw T { H { FTXa } { FTYa } ie s_m DRFTlh 4 -2 roll exch H { FTXt } { FTYt } ie FTf fg ttshw } if S s_o 0 T { DRht s_p mul DRhb add } { DRh } ie /f_y X f_x f_y F s_s (-) eq { 1 0 T -1 1 F } if { s_p gradcol } if cmyk cvx exec S fill R f_x rF f_y rF F fg cmyk Clw slw 2 setmiterlimit K R end R } B
/rbx { S rbxcol H { YH neg } { AX neg } ie 3 1 roll Hscm 3 1 roll Hscm 0 Clw2 ibox fill R } B /rln { S fg cmyk Hscm H { YH neg } { AX neg } ie 0 3 -1 roll dup 4 1 roll exch m l Clw slw K R } B /Rln { counttomark { rln } repeat pop } B
/grp { S 5 dict begin /s_s X Hscm /s_e X Hscm /s_o X /f_x { s_e s_o sub } D /s_m { f_x 2 div s_o add } D 0 BClw T { H { GPXa } { GPYa } ie s_m DRGPlh 4 -2 roll exch H { GPXt } { GPYt } ie GPf fg ttshw } if S cmyk { S s_o DRGPlnh s_o 0 s_e DRGPlnh s_e 0 2 { m l dotted Clw slw K } repeat R } if s_s (-) eq { s_e DRGPlnh T -1 1 F } { s_o DRGPlnh T } ie f_x exch Clw2 slw 2 setmiterlimit cvx exec R end R } B
/aln { S dup 4 1 roll exch { Alw mul Alw add slw } { pop Alw slw } ie { gradcol } { pop } ie cmyk Fm Fl K R } B
/xbox { S Yscme Yscme 4 -2 roll Xscme Xscm 4 1 roll exch bbox { S cmyk fill R } if cvx exec slw cmyk K R } B
/xcir { S Yscme Xscme T rotate Yscme Xscme 2 copy 5 2 roll F 0 0 1 0 360 arc closepath { S 6 2 roll cmyk fill R } if 2 { 1 exch div exch } repeat F cvx exec slw cmyk K R } B
/xtxt { S Yscme Xscme counttomark 2 roll not { fg } if ttshw pop R } B
/kkdevaka { S cmyk sfnt 8 dict begin /h X /v X /lbl X /angle X /y X /x X /hs lbl stringwidth pop D /vs lbl strh D x y T angle rotate h (rh) eq { hs } { h (ch) eq { hs 2 div } { 0 } ie } ie neg v (tv) eq { vs } { v (cv) eq { vs 2 div } { 0 } ie } ie neg m lbl show end 
%    ttshw
pop R } B
/xarw { S Yscme Xscme T dup neg counttomark 1 roll rotate 2 dict begin /la X /lb X cmyk 0 0 m lb 6 mul dup la gt { pop la 0.75 mul } if dup dup dup 3 div dup neg 3 1 roll l l closepath fill 0 m la 0 l lb slw K la lb add end 0 T 0 0 xtxt R } B
/chktk { 3 dict begin /pk X /ck 0 D /ek 1 D { ck 5 gt { exit } if /ek 10 ck exp D pk ek mul cvi ek div pk eq { exit } if /ck ck 1 add D } loop ck end } B /mymod { 2 copy chktk exch chktk max dup 0 eq { pop 2 { cvi exch } repeat mod } { 1 dict begin /ff 10 3 -1 roll exp D 2 { ff mul round cvi exch } repeat mod ff div end } ie } B /rndtk { dup abs 10 -6 exp le { pop 0 } if } B
/mkgrid { S 0 0 m rl fg cmyk { dashed KWn 2 mul slw } { ldotted KWn slw } ie K R } B /mjrtick { S 0 0 m { 0 KHx neg } { KHx 0 } ie rl KWx slw fg cmyk K R } B /mnrtick { S 0 0 m { 0 KHn neg } { KHn 0 } ie rl KWn slw fg cmyk K R } B
/hticklbl { S 10 string cvs 0 KHt neg 0 4 -1 roll (tv) (ch) KLf fg ttshw R } B /htickslbl { S 10 string cvs (tv) 3 -1 roll ZM { { (rh) KHn neg } { (lh) KHn } ie } { pop (ch) 0 } ie KHt neg 0 6 -3 roll KLf fg ttshw R } B
/htick { S 10 dict begin /tmn X /tmx X /te X /to X /yt X /lxo to to tmx mymod sub D /lxe tmx te tmx mymod sub te add D /lno to to tmn mymod sub D /lne tmn te tmn mymod sub te add D S /cnt lxo D to neg Xscm 0 T { cnt te ge { exit } if cnt to gt cnt te lt and { cnt Xscm S 0 T _t mjrtick KGb { _t 0 yt mkgrid } if cnt rndtk hticklbl R } if /cnt cnt tmx add D } loop R S /cnt lno D to neg Xscm 0 T { cnt te ge { exit } if cnt to gt cnt te lt and cnt tmx mymod 0 eq not and { cnt Xscm S 0 T _t mnrtick KGb { _f 0 yt mkgrid } if R } if /cnt cnt tmn add D } loop S to Xscm 0 T _t mjrtick _f to htickslbl R S te Xscm 0 T _t mjrtick _t te htickslbl R R end R } B
/vticklbl { S 10 string cvs KHt 0 0 4 -1 roll (cv) (lh) KLf fg ttshw R } B /vtickslbl { S 10 string cvs KHt ZM { KHn } { 0 } ie 0 5 -1 roll ZM { { (bv) } { (bv) } ie } { pop (cv) } ie 5 -1 roll exch (lh) KLf fg ttshw R } B
/vtick { S 10 dict begin /tmn X /tmx X /te X /to X /xt X /lxo to to tmx mymod sub D /lxe tmx te tmx mymod sub te add D /lno to to tmn mymod sub D /lne tmn te tmn mymod sub te add D xt 0 T S /cnt lxo D 0 to neg Yscm T { cnt te ge { exit } if cnt to gt cnt te lt and { cnt Yscm S 0 exch T _f mjrtick KGb { _t xt neg 0 mkgrid } if cnt rndtk vticklbl R } if /cnt cnt tmx add D } loop /cnt lno D { cnt te ge { exit } if cnt to gt cnt te lt and cnt tmx mymod 0 eq not and { cnt Yscm S 0 exch T _f mnrtick KGb { _f xt neg 0 mkgrid } if R } if /cnt cnt tmn add D } loop R S 0 to neg Yscm T S 0 to Yscm T _f mjrtick _f to vtickslbl R S 0 te Yscm T _f mjrtick _t te vtickslbl R R end R } B
/nucltick { XO XE KASm KASn htick } B
/mkshp { m { l } repeat closepath } B
/fbox { 0.0 1.0 1.0 1.0 1.0 0.0 3 0.0 0.0 mkshp } B /hbox { 0.0 0.5 1.0 0.5 1.0 0.0 3 0.0 0.0 mkshp } B
/fraw { 0.75 0.0 0.75 -0.1 1.00 0.5 0.75 1.1 0.75 1.0 0.00 1.0 6 0.0 0.0 mkshp } B /hraw { 1.00 0.0 0.75 1.1 0.75 1.0 0.00 1.0 4 0.0 0.0 mkshp } B
/flaw { 1 0 T -1 1 F fraw } B /hlaw { 1 0 T -1 1 F hraw } B
/frae { 0.25 0.5 0.00 1.0 1.00 1.0 1.00 0.0 4 0.0 0.0 mkshp } B /hrae { 0.00 1.0 1.00 1.0 1.00 0.0 3 0.25 0.0 mkshp } B
/flae { 1 0 T -1 1 F frae } B /hlae { 1 0 T -1 1 F hrae } B
/frsg { 0.75 0.0 0.75 -0.1 1.00 0.5 0.75 1.1 0.75 1.0 0.00 1.0 0.25 0.5 7 0.00 0.0 mkshp } B
/hrsg { 1.00 0.0 0.75 1.1 0.75 1.0 0.00 1.0 4 0.25 0.0 mkshp } B
/flsg { 1 0 T -1 1 F frsg } B /hlsg { 1 0 T -1 1 F hrsg } B
/frtn { 0.0 1.0 1.0 0.5 2 0.0 0.0 mkshp } B /hrtn { 0.0 1.0 1.0 0.0 2 0.0 0.0 mkshp } B
/fltn { 1 0 T -1 1 F frtn } B /hltn { 1 0 T -1 1 F hrtn } B
/futn { 0.5 1.0 1.0 0.0 2 0.0 0.0 mkshp } B /fdtn { 0.0 1.0 1.0 1.0 2 0.5 0.0 mkshp } B
/fdmd { 0.0 0.5 0.5 1.0 1.0 0.5 3 0.5 0.0 mkshp } B /fmdm { 1.0 0.0 0.0 1.0 1.0 1.0 3 0.0 0.0 mkshp } B
/fcir { 0.5 0.5 0.5 0 360 arc closepath } B /farc { 1 2 F 0.5 0 0.5 0 180 arc closepath } B /harc { 0.5 0 0.5 0 180 arc closepath } B
/gmid { 2 div dup 0 m GPpt l } B /gbas { S { dotted } if 0 0 m 0 l K R } B
/glns { dup _f gbas gmid K } B /glnd { dup _t gbas gmid K } B /gbrk { dup dup _f gbas gmid dup 0 m GPpt neg l 0 0 m 0 GPpt neg l K } B /gbrc { 4 dict begin /_l X /_lh _l 2 div D /_a GPpt 2 mul D /_b GPpt 4 mul D 0 GPpt neg m 0 _a sub _b _lh _b neg _lh GPpt curveto _l GPpt neg m _l _a add _b _lh _b neg _lh GPpt curveto K end } B
/gseg { exch dup 3 -1 roll gbas dup gmid dup GPpt m GPpt neg l 0 GPpt m 0 GPpt neg l K } B /gsgm { _f gseg } B /gsgd { _t gseg } B
/garw { 3 -1 roll dup 3 -1 roll gbas dup gmid 0 GPpt neg m 0 GPpt l K 0 T GPpt GPpt F { 0 0 m -2.5 1 l -2.5 -1 l closepath S fill R } { 0 0 m -2.5 1 l 0 0 m -2.5 -1 l } ie K } B /garh { 3 -1 roll dup 3 -1 roll gbas dup gmid 0 0 m 0 GPpt l K 0 T GPpt GPpt F { 0 0 m -2.5 1 l -2.5 0 l closepath S fill R } { 0 0 m -2.5 1 l } ie K } B
/gsaw { _f _f garw } B /gsad { _f _t garw } B /gfaw { _t _f garw } B /gfad { _t _t garw } B
/ghaw { _t _f garh } B /ghad { _t _t garh } B /ghsw { _f _f garh } B /ghsd { _f _t garh } B
%
/DoHeader { TTLb { S AXL TTLz neg 0 TTLl (bv) (lh) TTLf fg ttshw R } if TTlb { S AXL TTLz TTLp add TTlz add neg 0 TTll (bv) (lh) TTlf fg ttshw R } if } B
/shwcrd { S 2 dict begin /Cz Ch 1 pt PPC 2 div mul sub D /Cf { Cz /Courier } D FL Ch add neg 2 copy 0 (This plot has been obtained using GFF2APLOT. The most recent version is freely available at \042http:\057\057www1.imim.es\057software\057gfftools\057GFF2APLOT.html\042. Copyright\040\0401999-2003 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO) (bv) (rh) Cf fg ttshw exch S Cf sfnt (\0401999-2003 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO) stringwidth pop sub R exch 0 (\343) (bv) (ch) Cz /Symbol fg ttshw end R } B
/begindata { vflg { (### BEGINdata) msg } if S AXL AYB neg T S 0 0 AX AY 4 copy bbox ABc cmyk fill Blw obox fg cmyk Blw slw K R /Xscale AX XD div D /Yscale AY YD div D /YH AY D /YY YO D S KAXb { AY nucltick } if R S KAYb { AX YO YE KASm KASn vtick } if R S XSLb { AX 2 div AY ATX add XSLp add 0 XSLl (bv) (ch) XSLf fg ttshw } if YSLb { ATY YSLp add neg AY 2 div 90 YSLl (bv) (ch) YSLf fg ttshw } if R } B
/enddata { ZM { S 0 0 AX AY zoomtk R /ZM _f D } if R vflg { (### ENDdata) msg } if } B
/beginXseq { S 0 0 AX YH ATX add bbox clip newpath XO neg Xscm YH T colordict begin HT } B /beginYseq { S ATY neg 0 AX YH bbox clip newpath 0 YO neg Yscm T 90 rotate colordict begin VT } B /beginaln { S 0 0 AX YH bbox clip newpath XO neg Xscm YY neg Yscm T colordict begin } B /endseq { end R } B
/beginmatches { vflg { (### BEGINmatches) msg } if S AXL PYB neg T S 0 0 AX PY 4 copy bbox PBc cmyk fill Blw obox fg cmyk Blw slw K R /Yscale PY PD div D /YH PY D /YY PO D S KPXb { PY nucltick } if R S KPYb { AX PO PE KPSm KPSn vtick } if R S PBLb { DRFTlh PBlz add PBLp add neg PY 2 div 90 PBLl (bv) (ch) PBLf fg ttshw } if PBLb { DRFTlh neg PY 2 div 90 PBll (bv) (ch) PBlf fg ttshw } if R S } D
/endmatches { R R vflg { (### ENDmatches) msg } if } D
/beginextra { vflg { (### BEGINextra) msg } if S AXL QYB neg T S 0 0 AX QY 4 copy bbox QBc cmyk fill Blw obox fg cmyk Blw slw K R /Yscale QY D /YH QY D /YY QO D S KQXb { QY nucltick } if R S QBLb { DRFTlh QBlz add QBLp add neg PY 2 div 90 QBLl (bv) (ch) QBLf fg ttshw } if QBLb { DRFTlh neg PY 2 div 90 QBll (bv) (ch) QBlf fg ttshw } if R S } B
/endextra { R R vflg { (### ENDextra) msg } if } D
end % aplotdict
%
%%EndProcSet:   Aplot_dict 1.0 0
%
%%BeginProcSet: Openings 1.0 0
%
/DoInit { tflg { (%%% START NEW PLOT %%%) msg /vflg _t D } if aplotdict begin Dpage 0 0 bbox S bg cmyk fill R clip newpath FXO FYO T tflg { S 0 0 FL neg bbox fg cmyk K R } if flgcrd { shwcrd } if } B
/DoEnd { end tflg { (%%% PLOT DONE %%%) msg } if } B
%
%%EndProcSet:   Openings 1.0 0
%
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics % must not be used in EPS documents
% _t setpacking
_t setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
%%Page: 1 1
%%BeginPageSetup
%
% Saving current page settings
/pgsave save D
%
%%EndPageSetup
%
%
%%%%%%%% START NEW PLOT
%
DoInit
DoHeader
%
%%%%%%%% ALIGNMENT PLOT - BOX
%
begindata
%
%%%% DATA ---> X-sequence Annotations
%
beginXseq
/hrsg lightred _f _f (FORWARD) _t 1 1700 2500 (+) shp
/pt _f fg _f 1700 2500 (+) grp
/hrsg lightred _f _f (REVERSE) _t 1 500 1300 (-) shp
/pt _f fg _f 500 1300 (-) grp
endseq
%
%%%% DATA ---> Y-sequence Annotations
%
beginYseq
/hrsg lightred _f _f (FORWARD) _t 1 1700 2500 (+) shp
/pt _f fg _f 1700 2500 (+) grp
/hrsg lightred _f _f (REVERSE) _t 1 500 1300 (-) shp
/pt _f fg _f 500 1300 (-) grp
endseq
%
%%%% DATA ---> Alignment
%
beginaln
250 250 750 750 blue _f _t 0.000 aln
750 750 1250 1250 blue _f _t 0.667 aln
250 2750 750 2250 red _f _t 0.333 aln
750 2250 1250 1750 red _f _t 1.000 aln
400 1000 800 1400 grey _f _t 0.533 aln
2200 1600 2600 2000 grey _f _t 0.533 aln
1000 400 1200 600 grey _f _t 0.133 aln
1300 700 1500 900 grey _f _t 0.533 aln
400 2000 800 1600 grey _f _t 0.800 aln
2600 1000 2200 1400 grey _f _t 0.800 aln
2250 750 1750 1250 orange _f _t 1.000 aln
2750 250 2250 750 orange _f _t 0.333 aln
2250 2250 1750 1750 green _f _t 0.667 aln
2750 2750 2250 2250 green _f _t 0.000 aln
endseq
%
enddata
%
%
%%%%%%%% MATCHES PERCENT - BOX
%
beginmatches
%
%
%%%% DATA ---> Alignment
%
beginaln
250 0.25 750 0.25 blue _f _t 0.000 aln
750 0.75 1250 0.75 blue _f _t 0.667 aln
250 0.50 750 0.50 red _f _t 0.333 aln
750 1.00 1250 1.00 red _f _t 1.000 aln
400 0.65 800 0.65 grey _f _t 0.533 aln
2200 0.65 2600 0.65 grey _f _t 0.533 aln
1000 0.35 1200 0.35 grey _f _t 0.133 aln
1300 0.65 1500 0.65 grey _f _t 0.533 aln
400 0.85 800 0.85 grey _f _t 0.800 aln
2600 0.85 2200 0.85 grey _f _t 0.800 aln
2250 1.00 1750 1.00 orange _f _t 1.000 aln
2750 0.50 2250 0.50 orange _f _t 0.333 aln
2250 0.75 1750 0.75 green _f _t 0.667 aln
2750 0.25 2250 0.25 green _f _t 0.000 aln
endseq
%
endmatches
%
%
DoEnd
%
%%%%%%%% PLOT DONE
%
% grestoreall % must not be used in EPS documents
pgsave restore
showpage
%
% Page: 1 1
%%PageTrailer
%
%%Trailer
%
%%Pages: 1
%%Orientation: Portrait
%%BoundingBox: 0 0 595 842
%%EOF
