% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% $Id: SintenicGenePrediction.nw,v 1.5 2001-06-06 19:00:58 jabril Exp $
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%\usepackage{dcolumn}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %
 
% Colors for gff2ps
\input ColorDefs.tex
% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}

% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es}}

% defs
\def\drome{\textit{Drosophila melanogaster}}
\def\dro{\textit{Drosophila}}
\def\dme{\textit{D. melanogaster}}
\def\seq{\texttt{\textbf{X62937}}}
\def\nowf{[[SintenicGenePrediction.nw]]}
\def\rptm{\textsc{RepeatMasker}}
\def\bl{\textsc{Blast}}
\def\bn{\textsc{blastn}}
\def\bx{\textsc{blastx}}
\def\bp{\textsc{blastp}}
\def\tbn{\textsc{tblastn}}
\def\tbx{\textsc{tblastx}}
\def\ps{\textsc{PostScript}}
\def\gnid{\texttt{geneid}}
\def\gnsc{\texttt{genscan}}
\def\prog{\textsc{sgp}}

% Setting text for footers and headers

\def\tit{\textsc{Sintenic Gene Prediction Tool.- }}
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\rightmark}
\fancyfoot[LO,LE]{\small\textsl{Guig\`o, Parra, Abril}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
@ 
\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\textbf{\Huge Sintenic Gene Prediction Tool}\\[5ex]

\textbf{\Large Roderic Guig\`o}\\[1ex]
\textbf{\Large Gen\'{\i}s Parra}\\[1ex]
\textbf{\Large Josep F. Abril}\\[5ex] % \raisebox{0.85ex}{\footnotesize$\,\dag$}\\[0.5ex]

\textbf{\large --- \today ---}\\[10ex]

\begin{abstract}
\begin{center}
\parbox{0.75\linewidth}{
The project main goal is to implement the {\prog} tool in Perl, make its parameters able to get configured through a customization file, and draft a script to automatize fine tunning of the program. We have to include in the distributable package a modified version of {\gnid}. We will need to optimize the {\bl} databases in order to increase query search speed when long subject sequences are given.
} % parbox
\end{center}
\end{abstract}

\vfill

\begin{raggedleft}
\scalebox{0.9 1}{\Large\textsl{\textbf{Genome Informatics Research Lab}}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: \mtjabril}\\
\end{raggedleft}
\end{center}

\end{titlepage} %'

%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: SintenicGenePrediction.nw,v 1.5 2001-06-06 19:00:58 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{On using comparative genomics to improve gene prediction at genomic scale.}

Conservation in the genomic sequence of species at the appropiate
phylogenetic distance may be indicative of conservation of sequence
function.  We investigate here how sequence conservation may be
indicative of coding function, and develop program, SGP-2, which
integrates the results from {\gnid} and {\tbx} to produce gene
predictions when comparing human/mouse sintenic regions.  We set up a
number benchmark data sets, in which we benchmark {\prog} efficiency
and we test it against \textit{ab initio} programs, sequence similarity
based programs, and other hibrid programs.

% How the program works...
\subsctn{Overall algorithm}

Figure~\ref{fig:algo2} describes the approach in {\prog}.  Given two
genomic sequences, we follow the protocol outlined here: 

\begin{enumerate}
\item mask the sequences using {\rptm},
\item run {\tbx} of one sequence agains the other,
\item ``project'' the similarity regions onto each sequence,
\item  run {\gnid} on each sequence with the projected similarity regions.
\end{enumerate}

\begin{figure}
\begin{center}
\framebox{
\includegraphics[width=0.85\linewidth, trim= 10 10 20 10, clip]{./psfigures/algo2.ps}
}
\end{center}
\caption{\label{fig:algo2} Schemma of the homology-based gene-prediction used in this project.}
\end{figure}

\sctn{The parameters file}

\sctn{Parameter optimization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage
\appendix

\sctn{Sintenic Gene Prediction tool}

Our initial program outline (our root chunk) looks like:\\[1ex]

<<SGP TOOL>>=
<<PERL shebang>>
<<SGP Copyleft>>

#### MODULES ####

<<Use Modules - SGP>> 

#### CONSTANTS DEFINITION ####

<<Constant definition - SGP>>

#### GLOBAL VARIABLES ####

<<Global Vars - SGP>>

#### MAIN LOOP ####

    <<Main Loop - SGP>>

##### SUBS #####

<<Main Routines - SGP>>

#### EOF ####

<<POD man page - SGP>>
@ % 


A short description, followed by authors list and the GNU-GPL, appears at the begining of the code.

<<SGP Copyleft>>=
######################################################################
#                               SGP                                  #
######################################################################
#
#     Sinteny based Gene Prediction tool.
#
#     Copyright (C) 2001 - Josep Francesc ABRIL FERRANDO
#                                   Genis PARRA FARRE
#                                 Roderic GUIGO SERRA
<<Copyleft>>
@

\subsctn{Main code chunks}

<<Use Modules - SGP>>=
<<Use Modules - Benchmark>>
<<Use Modules - Dumper>>
@ 

<<Constant definition - SGP>>=
my $PROGRAM = "SGP";
my @tmp_ver = split / +/, 
    ': $Id: SintenicGenePrediction.nw,v 1.5 2001-06-06 19:00:58 jabril Exp $ :';
my $VERSION = "v$tmp_ver[3] [@tmp_ver[4,5,7]]";
<<Global Constants - Boolean>>
<<Global Constants - STDERR>>
@

<<Global Vars - SGP>>=
<<Global Vars - User and Date>>
<<Global Vars - Counter>>
<<SGP: Global Vars - STDERR>>
@

<<Main Loop - SGP>>=
&report('START_JOB');
# get options
&Which_Options();
# parameters for
&read_parameter_file();
#
&report('JOB_DONE',&timing($T));
exit(0);
@

<<SGP: runtime messages>>=
START_JOB => "$line$s    RUNNING: $PROGRAM\n".
                  "$s       USER: $USER\n".
                  "$s       DATE: $DATE\n$line$r",
JOB_DONE  => "$line$s  TOTAL TIME SPENT --> \%s\n$line",
HEADER    => "$line\%s$line",
TIMING    => "$r$s  \%s ...... DONE\n$s  Time Spent: \%s$r",
@

<<Common PERL subs - STDERR>>=
sub prt_header() {
    my $msg = $_[0];
    my $l = $term_width - (2 * length($s));
    $msg = &fill_mid($msg,$l,' ');
    &report('HEADER',$msg);
} # prt_header
@ %def &prt_header

<<Main Routines - SGP>>=
<<SGP: parsing command-line>>
<<SGP: parsing parameters file>>
<<SGP: run blast>>
<<SGP: extract HSPs>>
<<SGP: run geneid>>
<<SGP: graphical output>>
<<Common PERL subs - Check sys command>>
<<Common PERL subs - Min Max>>
<<Common PERL subs - Text fill>>
<<Common PERL subs - Counter>>
<<Common PERL subs - STDERR>>
@ 

\subsctn{Reporting to [[STDERR]]}

<<Global Constants - STDERR>>=
my $term_width = 60;
my $line = ("#" x $term_width)."\n";
my ($s,$r) = ("###","###\n");
my $Error = "\<\<\<  ERROR  \>\>\> "; # scaped symbols to avoid 
my $Warn  = "\<\<\< WARNING \>\>\> "; #     problems with noweb
my $spw   = "\<\<\<         \>\>\> ";
my $spl   = "\<\<\<\-\-\-\-\-\-\-\-\-\>\>\>\n";
@

<<SGP: errors>>=
@ 
<<SGP: messages>>=
@ 

<<SGP: Global Vars - STDERR>>=
#
# Error/Warning Message List
my %ErrorList = (
                 <<SGP: errors>>
                 <<SGP: commandline warnings>>
                 );
@

<<SGP: Global Vars - STDERR>>=
#
# Verbose Message List
my %MessageList = (
                   <<SGP: messages>>
                   <<SGP: runtime messages>>
                   );
@ 

\subsctn{Removing temporary files}

In such cases that we stop the program execution or it hangs up, we have to clean temporary path from any temporary files we have created.

<<trap temporary files>>=
$SIG{INT}  = \&trap_signals;
$SIG{QUIT} = \&trap_signals;
$SIG{TERM} = \&trap_signals;
$SIG{CHLD} = 'IGNORE';
sub trap_signals() {
    # opendir(TDIR, $TMP) or &go_to_die("Can't open directory $TMP: $!");
    # while (defined(my $file = readdir(TDIR)))
    &clean_tmp();
    &go_to_die("WARNING !!! $PROGRAM has been stopped by user.");
}
@ %$

The following signals are trapped by our signal handler routine (to be precise, when assigning to [[$SIG]] the call by reference to that routine): %$
\begin{itemize}\setlength{\itemsep}{-0.5ex}
\item [[SIGINT]] is normally triggered by Ctrl-C, requesting that a process interrupt what it's doing.%'
\item [[SIGQUIT]] is also generated by a terminal, usually Ctrl-$\backslash$, generating a core dump.
\item [[SIGTERM]] is sent by [[kill]] shell command when no signal name is explicitly given (think of it as a polite request for a process to die). 
\end{itemize}

\subsctn{Parsing command-line options}

<<declare uses>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling pass_through /;
@ 

\begin{description}\setlength{\itemsep}{-0.5ex}
\desc{[[use Getopt::Long;]]} This module implements an extended getopt function called [[GetOptions()]]. This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options having long names instead of single letters are introduced with a double dash "-\/-". A double dash on itself signals end of the options list and start of the input 'files'.

\desc{[[Getopt::Long::Configure qw( bundling pass_through );]]} [[GetOptions]] can be configured by calling subroutine [[Getopt::Long::Configure]]. This subroutine takes a list of quoted strings, each specifying a configuration option to be set. Options can be reset by prefixing with '[[no_]]'. 

 \begin{description}\setlength{\itemsep}{-0.5ex}
 \desc{[[bundling]]} Support for bundling of command line options, as was the case with the more traditional single-letter approach (introduced with a single dash "-"), is provided but not enabled by default. 

 \desc{[[pass_through]]} Unknown options are passed through in [[@ARGV]] instead of being flagged as errors. This makes it possible to write wrapper scripts that process only part of the user supplied options, and passes the remaining options to some other program.
 \end{description}
\end{description}

<<declare variables>>=
# GetOptions Variables
my ( $Seq1, $Seq2, $geneid_opt, $geneid_param, 
     $blast_opt, $score_cutoff, $shrink, $tbx,
     $hsp, $ofn, $ps_output, $savefiles_flg, $verbose_flg, $help_flg
     ) = ( undef, undef, undef, undef, undef, undef,
           undef, undef, undef, undef, undef, 0, 0, 0 );
@ %

Those variables will receive the values passed from command-line options in [[Which_Options()]] function. We set them as [[undef]] to check after [[Which_Options()]] if they have received any value (testing them with perl built-in [[defined()]] function).

<<SGP: parsing command-line>>=
# Parsing command-line options and processing its parameters.
<<getopts subs>>
sub Which_Options() {
    $SIG{__WARN__} = sub { &warn('UNKNOWN_CL_OPTION',$_[0]) };
    GetOptions( 
                "1=s"      => \$Seq1         , # seqfile_1
                "2=s"      => \$Seq2         , # seqfile_2
                "g=s"      => \$geneid_opt   , # geneid options      
                "P=s"      => \$geneid_param , # geneid parameter file 
                "o=s"      => \$blast_opt    , # tblastx options 
                "c=f"      => \$score_cutoff , # tblastx score cutoff
                "s=f"      => \$shrink       , # shrink hsp's by
                "t=s"      => \$tbx          , # read tblastx from file
                "f=s"      => \$hsp          , # read HSP files in directory
                "k=s"      => \$ofn          , # intermediate filename
                "p=s"      => \$ps_output    , # postscript output 
                "v"        => \$verbose_flg  , # verbose    
                "h|help|?" => \$help_flg     , # print help
                ) || (&warn('CMD_LINE_ERROR'), exit(1));
    $SIG{__WARN__} = 'DEFAULT';
    &prt_Help if $help_flg;
    &prt_Header("Processsing Command-Line Options") if $verbose_flg;
    <<set flags-vars>>
} # sub Which_Options
@ %def &Which_Options 
%$

<<SGP: commandline warnings>>=
UNKNOWN_CL_OPTION => "!!! Error trapped while processing command-line:\n",
CMD_LINE_ERROR => "!!! Please, check your command-line options!!!\n",
@
 
In [[GetOptions()]] function, sufixing an option with '=s' implies that it will require a mandatory string parameter, with '=f' the option must be provided with a real number. The following variables need a filename: [[$geneid_param]] [[$tbx]] [[$hsp]] [[$ofn]] [[$ps_output]].%$

\begin{comment}
\todo{get options}{
 \item [[$score_cutoff]] and [[$shrink]] still not used. 
 \item Define better how the paths/filenames are passed through those options. Remember that these variables will be defined by giving a path, but some need a prefix.
}
\end{comment}
 
<<getopts subs>>=
# Checking input sequence files
sub exists_file() {
    my @files = @_;
    my ($n, $r) = (' ', 0);
    foreach $n (@files) {
        $r++ if (-e "$n");
    };
    return $r;
}
sub check_fasta_format() {
    my $file = $_[0];
    my ($n, $c) = (undef, 0);
    open(TMP,"< $file");
    while (<TMP>) {
        next unless /^>/;
        />(\S+)\b/ && do {
            $n = $1;
            $c++;
            next unless $c>1;
        };
        &go_to_die("FATAL ERROR !!! Multiple locus names found.\n  File \'$file\' must contain only one sequence definition.\n");
    }
    &go_to_die("FATAL ERROR !!! There is no '>' line, locus name not found.\n  Please, verify your fasta file \'$file\'\n") unless defined($n);
    return $n;
}
@ %def &exists_file &check_fasta_format
%$

[[exists_file()]] : Given a list of filenames, this function returns how many among them does exist.

[[check_fasta_format()]] : For a given file, returns the \textit{locus} name if file is in [[fasta]] format, else program dies.

<<declare uses>>=
use File::Basename;
@

This standard module contains routines to split up a filename. [[basename]] is provided for programmer compatibility with the same name \textsc{Unix} shell command.

<<declare variables>>=
# sequence files
my ($Seq1_Name, $Seq2_Name, $Loc1, $Loc2, $SGPtmp1, $SGPtmp2, $SGPtmpG);
@ %def $Seq1_Name $Seq2_Name $Loc1 $Loc2 $SGPtmp1 $SGPtmp2 $SGPtmpG

<<set flags-vars>>=
# do seq files exists
my $file_number = &exists_file($Seq1, $Seq2);
&go_to_die("FATAL ERROR!!! Two sequences are needed (-1 and -2 options are mandatory).\n")
    unless $file_number == 2; 
# extract basenames
$Seq1_Name = basename($Seq1);
$Seq2_Name = basename($Seq2);
# check if files are provided in fasta format and get locus names
$Loc1 = &check_fasta_format($Seq1);
$Loc2 = &check_fasta_format($Seq2);
&go_to_die("FATAL ERROR!!! Locus1($Loc1) have the same name as Locus2($Loc2).\n  Sequences \'$Seq1_Name\' and \'$Seq2_Name\' must have different locus names.\n")
    if $Loc1 eq $Loc2;
# tmpfiles prefix
$SGPtmp1 = "$SGPTMP.$Seq1_Name";
$SGPtmp2 = "$SGPTMP.$Seq2_Name";
$SGPtmpG = "$SGPTMP.${Loc1}_${Loc2}"; 
@

We check here whether the user provided two sequences or not, either they are given in fasta format. We extract locus names and build some base filenames from which we can derive, when needed, several temporary output filenames.

<<declare variables>>=
# file flags
my ($blast_flg, $hsps_flg, $geneid_flg, $plots_flg) = (1, 1, 1, 1);
@ %def $blast_flg $hsps_flg $geneid_flg $plots_flg

We initialize those flag variables to '1' in order to get, by default, into all the main subroutines called from main loop. They will be modified when [[Which_Options()]] function resets some of the option variables. 

<<declare uses>>=
use File::Copy;
@

The [[File::Copy]] module provides [[copy]] and [[move]] functions ([[move]] works across file-sytem boundaries, the standard [[Perl]] built-in [[rename]] ---usually--- does not).

<<global subroutines>>=
# copying files
sub copy_files() {
  	&go_to_die("FATAL ERROR!!! Couln't find \'$_[0]\' file. $!\n")
         unless &exists_file($_[0]);
    copy(@_) or &copy_error(@_);
}
sub copy_error() { &go_to_die("FATAL ERROR !!! Could not copy file \'$_[0]\' to \'$_[1]\': $!\n") }
@ %def &copy_files &copy_error

<<define defaults>>=
my $verbose_str = " -v ";
@ %def $verbose_str
<<set flags-vars>>=
do {
    &copy_files("$hsp${Loc1}_${Loc2}.srQ", "$SGPtmpG.srQ");
    &copy_files("$hsp${Loc1}_${Loc2}.srS", "$SGPtmpG.srS");
    &copy_files("$hsp${Loc1}_${Loc2}.aln", "$SGPtmpG.aln");
    $hsps_flg = 0;
} if defined($hsp);
do {
    &copy_files("$tbx", "$SGPTMP.tbx");
    $blast_flg = 0;
} if defined($tbx);
# $geneid_flg = 0;
$savefiles_flg = 1 if defined($ofn);
$plots_flg = 0 unless defined($ps_output);
# setting other variables
$GeneidOptions = "$geneid_opt"   if defined($geneid_opt);
$GeneidParam   = "$geneid_param" if defined($geneid_param);
$BlastOptions  = "$blast_opt"    if defined($blast_opt);
$verbose_str = "" if $verbose_flg;
@

[[$verbose_str]] switch off the STDERR report generation on our GFF tools by default ('[[-v]]' option). If [[$verbose_flg]] %$
is given then that variable is set to empty string (GFF tools will produce the basic report output on STDERR).

\begin{comment}
\todo{set flags-vars}{
\item When redefining [[$GeneidOptions]] and [[$BlastOptions]] the new options passed through command-line override default ones, but these options are not checked (although that, program will die as [[geneid]] or [[blast]] receive wrong options). Is this a good choice, or maybe is better to join the user defined options to the default ones. Conflicts will arise with last approach whether the same option is defined from defaults and command-line (so, at least, it is simpler to override defaults by user provided values).
}
\end{comment}


\subsctn{Parsing parameters file}

<<SGP: parsing parameters file>>=
sub read_parameter_file() {
    &prt_header("Processing Parameters File");
    open(PFILE,"< $PARAM{PARAMETER_FILE}");
    $n = 0;
    while (<PFILE>) {
    $c = '.';
    <<Skip comments and empty records>>
    } continue {
        &counter(++$n,$c); 
	}; # while
    &counter_end($n,$c);
    close(PFILE);
    &report('TIMING',"Processing Parameters File",&timing($F));
} # read_parameter_file
@ %def &read_parameter_file

\subsctn{Running {\bl} on sequences}

<<SGP: run blast>>=
$start = new Benchmark;
$sys_rpt = system("$cmdline");
$end = new Benchmark;
&check_sys_result($sys_rpt);
$ttime = timestr(timediff($end,$start));
print STDERR "         Time Spent: $ttime \n";
@ % 

\subsctn{Processing HSPs from {\bl}}

<<SGP: extract HSPs>>=
@ % 

\subsctn{Running {\gnid} on SRs}

<<SGP: run geneid>>=
@ % 

\subsctn{Making plots}

<<SGP: graphical output>>=
@ % 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\subsctn{POD Pages}

The documentation for [[perl]] programs is written in a simple markup language called POD (Plain Old Documentation). Translators exist for [[pod2man]], [[pod2text]], [[pod2html]], [[pod2latex]], and [[pod2fm]]. 
The idea is to have the online documentation included with the source. That is possible with [[__DATA__]] tag, which defines a chunk of data within the same file.
%% TODO: define POD tags and which style was used for building up this man. 

<<POD man page - SGP>>=
__DATA__

=head1 NAME

    
$PROGRAM ($VERSION) - Improving Gene Prediction with Sinteny.

=head1 SYNOPSIS

    
    $PROGRAM [-hv] [-o 'options'] [-g 'options'] \
      [-P filename] [-p filename] [-k filename] \
      [-c value] [-s value] -1 seqfile_1 -2 seqfile_2

=head1 DESCRIPTION

=head1 OPTIONS

    

=over 4

=item B<-1> I<seqfile_1>

input file for first species.

=item B<-2> I<seqfile_2>

input file for second species.

=item B<-g>

geneid options

=item B<-o>

tblastx options

=item B<-c> I<value>

tblastx score cuttof

=item B<-s> I<value>

shrink hsp\'s by value

=item B<-t> I<filename>

read tblastx file

=item B<-f> I<prefix>

read hsp gff files with in directory prefix and extension .hsp-rs

=item B<-k> I<prefix>

keep intermediate files with prefix

=item B<-p> I<filename>

ps output in filename file 

=item B<-P> I<filename>

geneid parameter file

=item B<-v>

verbose mode

=item B<-h>

produces this message

=back

=head1 FILES

=head1 DIAGNOSTICS

=head1 REQUIRES

=head1 BUGS

    
Report any problem to: B<jabril@imim.es>

=head1 AUTHOR

    
Roderic Guigo   : B<rguigo@imim.es>

Josep F. Abril  : B<jabril@imim.es>

Genis Parra     : B<gparra@imim.es>

B<$PROGRAM> is under GNU-GPL (C) 2000
@ %$

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}

\sctn{Converting C filters to Perl modules}

We can improve speed by reducing the number of external programs that {\prog} has to fork, we can convert to Perl modules some of the filters that Enrique Blanco already developed in C. We take advantage of the new version of the [[Inline]] package by Brian Ingerson (v0.40). [[SGPfilters.pm]] basic outline is shown here:

<<SGP::filters>>=
package SGP::filters;
use strict;
#
<<SGP::filters Copyleft>>
#
require Exporter;
@SGP::filters::ISA = qw(Exporter);
@SGP::filters::EXPORT = qw(
                            <<Exported functions: blast to HSPs>>
                            <<Exported functions: HSPs to SRs>>
                            );
$SGP::filters::VERSION = '0.1';

use Inline ( C => DATA,
             NAME => 'SGP::filters',
             VERSION => '0.10' );

__DATA__
<<POD man page - SGP::filters>>
__C__
<<C functions: blast to HSPs>>
<<C functions: HSPs to SRs>>
@ 

We also require a [[Makefile.pl]] squetched here:

<<SGP::filters - Makefile.PL>>=
use Inline::MakeMaker;

WriteMakefile( NAME => 'SGP::filters';
               VERSION_FROM => 'SGPfilters.pm' );
@ 

Once we got it running, we should add a MANIFEST, a README, a test harness (test.pl) and some POD documentation. After that, '[[make dist]]' will do the rest, generating a distributable package as a gzipped tarball. Final user only has to unpack that file, type commands '[[make]]' and '[[make install]]', and the module will be copied into the appropiate Perl sitelib directory (where an installed module should go).

<<SGP::filters Copyleft>>=
######################################################################
#                         SGPfilters.pm                              #
######################################################################
#
#     Modules to filter HSPs and project them to SRs.
#
#     Copyright (C) 2001 - Josep Francesc ABRIL FERRANDO
#                                   Genis PARRA FARRE
#                                 Enrique BLANCO GARCIA
#                                 Roderic GUIGO SERRA
<<Copyleft>>
# 
<<Version Control Id Tag>>
@


\subsctn{Implementing module functions in C}

<<C functions: common code>>=
@
 
<<Exported functions: blast to HSPs>>=
@
<<C functions: blast to HSPs>>=
@
 
<<Exported functions: HSPs to SRs>>=
@
<<C functions: HSPs to SRs>>=
<<blast2gff.h>>
<<blast2gff.c>>
<<readargv.c>>
<<account.c>>
<<RequestMemory.c>>
<<ReadHSP.c>>
<<SortHSP.c>>
<<ProjectHSP.c>>
<<JoinSR.c>>
<<Output.c>>
@ 

\subsubsctn{Headers}

<<blast2gff.h>>=
/***************************************************************
*                                                              *
*   BLAST2GFF.                                                 *
*   (c) by Enrique Blanco &                                    *
*   Roderic Guigo, 2000                                        *
*                                                              *
*   Module: blast2gff.h                                        *
*                                                              *
*   Definition of all data structures used by blast2gff        *
***************************************************************/

/* Include libraries */
#include <stdio.h>
#include <sys/types.h>
#include <time.h>
#include <malloc.h>  
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <float.h>
#include <math.h>

/* Definitions used in blast2gff */
#define NUMHSPS 50000                  /* maximum number of HSPs          */
#define NUMSR 50000                    /* maximum number of SRs           */

#define LOCUSLENGTH 50                 /* maximum number of chars (locus) */

#define VERSION   "blast2gff"          /* The name of the game            */
#define HSP       "HSP"                /* The name of the sites           */
#define NONAME    "NONAME"
#define SR        "SR"                

#define FRAMES 3                       /* 3 possible reading frames       */
#define STRANDS 2                      /* 2 strands of DNA molecule       */ 

#define FORWARD 0                      /* DNA - Strands                   */
#define REVERSE 1

#define NOTFOUND -1

#define COFFSET 1                      /* C-arrays correction             */
#define LENGTHCODON 3                  /* 3 nucleotids                    */

#define MAXLINE 1000                   /* Max number of chars/inputline   */

#define MAXTYPE 20                     /* Max number of chars/exonTypes   */

#define MAXSTRING 100                   

#define FILENAMELENGTH 200             /* maximum length of filenames     */
#define INFI 9999999                   /* the biggest number of the world */
#define MAXSCORE 10000.0               /* Infinity score (evidence exons) */

#define MIN(a,b) (a<b)?a:b;
#define MAX(a,b) (a>b)?a:b;

#define MINUTE 60                      /* 1 minute = 60 seconds           */     

/****************************************************************************/

/* GeneId data types */
typedef struct s_hsp               /* Blast HSP           */
{
  long StartQ;
  long EndQ;
  char StrandQ;
  short FrameQ;
  float Score;
  float Bits;
  double Probability;
  double Expect;
  int Similarity;
  int Identity;
  long StartS;
  long EndS;
  long Lenght;
  char Subject[LOCUSLENGTH];
} hsp;

typedef struct s_packHSP             /* Pack of hsps                   */
{
  hsp** *hsps;
  long* nHsps;
  long nTotalHsps;
} packHSP;     

typedef struct s_sr_t* psr_t;
typedef struct s_sr_t 
{
  long Start;
  long End;
  char Strand;
  short Frame;
  float Score;
  char Locus[LOCUSLENGTH];
  psr_t next;
} sr_t;

typedef struct s_packSR
{
  sr_t* sr[STRANDS*FRAMES];            /* Lists of SR */
  int nr[STRANDS*FRAMES];              /* Counter of every list */
  sr_t* nr0[STRANDS*FRAMES];           /* Pointer to processed part of every list */

  sr_t* sortSR[NUMSR];
  long nSR;
} packSR;

typedef struct s_account               /* Accounting                      */
{
  time_t tStart;
} account;                      

/*** Headers of functions ***/
void printMess(char* s);
void printError(char *s);
void OutputTime();
void readargv (int argc,char* argv[],char* HSPFile);
void ReadHSP (packHSP* allHsp,char* HSPFile, char Query[LOCUSLENGTH]);
packHSP* RequestMemoryHSP();
packSR* RequestMemorySR();
account* InitAcc();
void Output(packHSP* allHSP, packSR* allSR, char Query[LOCUSLENGTH]);
void ProjectHSP(packHSP *allHsp, packSR *allSr);
void SortHSP(packHSP *allHsp);
void JoinSR(packSR* allSr);
void SortSR(packSR *allSr);

@

<<blast2gff.c>>=
/* Setup Flags of blast2gff */
int   VRB=0, GFFIN, PSR=1 ,GFFOUT=0;

/* Accounting time and results */
account *m;  

int main (int argc, char *argv[])
{
  /* Input Files */
  char   HSPFile[FILENAMELENGTH];
  
  /* HSP data structures */
  packHSP* allHsp;

  /* SR data structures */
  packSR* allSr;

  /* Query name */
  char Query[LOCUSLENGTH];

  char mess[MAXSTRING];

  /* initializing stats... */
  m = (account*)InitAcc(); 

  /* Read setup options */
  readargv(argc,argv,HSPFile);

  /* Alloc main memory structures */
  printMess("Request Memory to System");
  allHsp =      (packHSP*) RequestMemoryHSP();
  allSr  =      (packSR*) RequestMemorySR(); 

  /* Reading HSPs */
  printMess("Reading HSP file");
  ReadHSP(allHsp,HSPFile,Query);
  sprintf(mess,"%ld HSPs read",allHsp->nTotalHsps);
  printMess(mess);
  
  /* Sorting HSPs */
  printMess("QuickSorting HSPs");
  SortHSP(allHsp);
  
  /* Project HSP to SR */
  if (PSR)
    {
      printMess("Project HSPs to SRs");
      ProjectHSP(allHsp, allSr);

      printMess("Simplifiying SRs");
      JoinSR(allSr);

      printMess("MergeSorting SRs");
      SortSR(allSr);
    }
  
  /* Printing Results */
  printMess("Printing selected data");
  Output(allHsp, allSr, Query);

  /* The End */
  OutputTime(); 
  exit(0);
  return(0);   
}

@ 

<<readargv.c>>=
extern int VRB, GFFIN, GFFOUT, PSR;
                
extern char* optarg;
extern int optind;

char *USAGE="Incorrect usage:\nNAME\n\tblast2gff - A program to build similarity regions from blastx outputs\nSYNOPSIS\n\tblast2gff <HSP_file>\n\n";

void printHelp()
{
  printf("Short Manual for blast2gff:\n");
  printf("------------------------\n\n");
  printf("Setup Options:\n\n");
 
  printf("\t-g: Input HSP in GFF format\n");
  printf("\t-G: Print HSP in GFF format\n");
  printf("\t-o: Not SR construction\n");
  printf("\t-v: Verbose\n");
  printf("\t-h: Show this Short Manual\n");
}

void readargv (int argc,char* argv[],
	       char* HSPFile) 
{
  int c;
  int error=0;
  char mess[MAXSTRING];

  /* Reading setup options */
  while ((c = getopt(argc,argv,"Ggvoh")) != -1)
    switch(c)
      { 
      case 'g': GFFIN++; 
	break;
      case 'G': GFFOUT++; 
	break;
      case 'o': PSR--; 
	break;
      case 'v': VRB++; 
	break;
      case 'h': printHelp();
	exit(1);
	break;
      }

  if (error)
    printError(USAGE);

  /* Setup Errors: Wrong number of filenames */
  /* Get the name of the file *.hsp */
  if (optind < argc)
    {
      strcpy(HSPFile,argv[optind]);
      optind++;
      if (optind < argc)
	{ 
	  sprintf(mess,"Too many files. Only one filename needed\n%s",USAGE);
	  printError(mess);
	}
    }
  else
    {
      sprintf(mess,"Where is the HSP file?\n%s",USAGE);
      printError(mess);
    }
}

@ 

<<account.c>>=
/* Init accounting */
account* InitAcc()
{
  account* m; 
  
  m = (account *) malloc(sizeof(account));

  /* Reset counters */

  printMess("Reset accounting");
  /* What time is it? */ 
  clock();
  (void) time(&m->tStart);

  return(m);
}

@ 

<<RequestMemory.c>>=
packHSP* RequestMemoryHSP()
{
  packHSP *allHsp;
  int i; 

  if ((allHsp =
       (packHSP*) malloc(sizeof(packHSP)))  == NULL)
    printError("Not enough space to hold HSP data structure");

  /* HSP */
  if ((allHsp->hsps =
       (hsp ** *) calloc(STRANDS*FRAMES, sizeof(hsp**))) == NULL)
    printError("Not enough space to hold HSP 6-array");  


  for(i=0;i<STRANDS*FRAMES;i++)
    if ((allHsp->hsps[i] =
	 (hsp**) calloc(NUMHSPS, sizeof(hsp*)))  == NULL)
      printError("Not enough space to hold HSPs");

  /* Counters */
  if ((allHsp->nHsps =
       (long*) calloc(STRANDS*FRAMES, sizeof(int)))  == NULL)
    printError("Not enough space to hold HSP counters");  

  /* Hack of Alpha */
  for(i=0;i<STRANDS*FRAMES;i++)
    allHsp->nHsps[i] = 0;

  allHsp->nTotalHsps = 0;

  return(allHsp);
}

packSR* RequestMemorySR()
{
  packSR *allSr;
  int i;

  if ((allSr =
       (packSR*) malloc(sizeof(packSR)))  == NULL)
    printError("Not enough space to hold SR data structure");

  for(i=0;i<STRANDS*FRAMES;i++)
    {
      allSr->nr[i]  = 0;
      allSr->nr0[i] = NULL;
      allSr->sr[i]  = NULL;
    }
  
  allSr->nSR = 0;
  
  return(allSr);
}

@ 

<<ReadHSP.c>>=
extern int GFFIN;

hsp* allocateNewHSP()
{
  hsp* p;
  
  /* New HSP */
  if ((p = (hsp *) malloc(sizeof(hsp))) == NULL)
    printError("Not enough space to hold one new HSP");
  
  return(p);
}

long ReadHSP_RAW(packHSP* h,char *FileName)
{
  int i;
  FILE *file;
  char line[MAXLINE];
  char mess[MAXSTRING];
  long pos1, pos2;
  int score;
  char strand;
  short frame;
  float bits;
  double prob, exp;
  int id,sim;
  long pos3,pos4;
  int indexFrame;
  long L;
  char Subject[LOCUSLENGTH];

  if ((file=fopen(FileName, "r"))==NULL)
    printError("The HSP file file cannot be open for read");
  
  i = 0;
  while(fgets(line,MAXLINE,file)!=NULL)
    {
      if(line[0]=='#')
	{
	  /* Skip this line */
	}
      else
	{
	  if ((sscanf(line, "%*s %*s %ld %ld %c %hd %d %f %lf %lf %d %d %s %ld %ld %*c %*d %ld",
		      &pos1,
		      &pos2,
		      &strand,
		      &frame,
		      &score,
		      &bits,
		      &prob,
		      &exp,
		      &id,
		      &sim,
		      Subject,
		      &pos3,
		      &pos4,
		      &L) != 14) || (frame<1) || (frame>3))
	    {
	      sprintf(mess, "Error reading HPS: line %d\n",i);
	      printError(mess);
	    }
	  else
	    {
	      /* Allocating HSPs in packHSP */
	      if (strand == '+')
		indexFrame = (frame % 3);
	      else
		indexFrame = (frame % 3) + FRAMES;

	      /* New item HSP */
	      h->hsps[indexFrame][h->nHsps[indexFrame]] = allocateNewHSP();

	      /* Setting attributes */
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->StartQ = pos1;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->EndQ = pos2;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->StrandQ = strand;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->FrameQ = frame;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Score = score;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Bits = bits;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Probability = prob;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Expect = exp;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Similarity = sim;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Identity = id;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->StartS = pos3;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->EndS = pos4;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Lenght = L;
	      strcpy(h->hsps[indexFrame][h->nHsps[indexFrame]]->Subject,Subject);
	      h->nHsps[indexFrame]++;
	      h->nTotalHsps++;
	    }
	}
      i++;
    }
  fclose(file);
  
  return(h->nTotalHsps);
}

long ReadHSP_GFF (packHSP* h,char *FileName, char Query[LOCUSLENGTH])
{
  int i;
  FILE *file;
  char line[MAXLINE];
  char mess[MAXSTRING];
  long pos1, pos2;
  char strand;
  short frame;
  float score;
  int indexFrame;
  char Subject[LOCUSLENGTH];


  if ((file=fopen(FileName, "r"))==NULL)
    printError("The HSP file file cannot be open for read");
  
  i = 0;
  while(fgets(line,MAXLINE,file)!=NULL)
    {
      if(line[0]=='#')
	{
	  /* Skip this line */
	}
      else
	{
	  if ((sscanf(line, "%s %*s %*s %ld %ld %f %c %hd %s",
		      Query,
		      &pos1,
		      &pos2,
		      &score,
		      &strand,
		      &frame,
		      Subject) != 7) || (frame<1) || (frame>3))
	    {
	      sprintf(mess, "Error reading HPS: line %d\n",i);
	      printError(mess);
	    }
	  else
	    {
	      /* Allocating HSPs in packHSP */
	      if (strand == '+')
		indexFrame = (frame % 3);
	      else
		indexFrame = (frame % 3) + FRAMES;

	      /* New item HSP */
	      h->hsps[indexFrame][h->nHsps[indexFrame]] = allocateNewHSP();
	      
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->StartQ = pos1;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->EndQ = pos2;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->StrandQ = strand;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->FrameQ = frame;
	      h->hsps[indexFrame][h->nHsps[indexFrame]]->Score = score;
	      strcpy(h->hsps[indexFrame][h->nHsps[indexFrame]]->Subject,Subject);

	      h->nHsps[indexFrame]++;
	      h->nTotalHsps++;
	    }
	}
      i++;
    }
  fclose(file);
  
  return(h->nTotalHsps);
}

void ReadHSP (packHSP* allHsp,char* HSPFile, char Query[LOCUSLENGTH])
{
  if (GFFIN)
    ReadHSP_GFF(allHsp,HSPFile,Query); 
  else
    {
      ReadHSP_RAW(allHsp,HSPFile); 
      strcpy(Query,NONAME);
    }
}

@ 

<<SortHSP.c>>=
int Split(hsp** hsps,int i, int j)
{
  long k;
  int x,c1,c2,m;
  int pivot;
  int pivotStartQ;
  hsp* tmp;
  
  /* Choosing the random pivot */
  k = hsps[i]->StartQ;

  /* How many elements have less StartQ value than pivot */
  for(m = 0, x=i+1; x <=j; x++)
    if (hsps[x]->StartQ <= k)
	m++;
  
  /* This is the right place for the pivot */
  pivot = m+i;

  tmp = hsps[i];
  hsps[i] = hsps[pivot];
  hsps[pivot] = tmp;

  pivotStartQ = hsps[pivot]->StartQ; 
  c1 = i;
  c2 = pivot+1;
  while (c1 < m+i && c2 <= j) 
    if (hsps[c1]->StartQ <= pivotStartQ)
	c1++;
    else
      {
	tmp = hsps[c1];
	hsps[c1] = hsps[c2];
	hsps[c2] = tmp;

	c2++;
      }

  return(pivot);
}

void quickSort(hsp** hsps, int i, int j)
{
  int pivot;

  if (i == j+1)
    /* Nothing */;
  else
    {
      pivot = Split(hsps,i,j);
      
      quickSort(hsps,i,pivot-1);
      quickSort(hsps,pivot+1,j);
    }
}

void SortHSP(packHSP *allHsp)
{
  int i;

  /* quicksorting all the strands and frames */ 
  for(i=0; i<STRANDS*FRAMES; i++)
    quickSort(allHsp->hsps[i],0,allHsp->nHsps[i]-1);
}

@ 

<<ProjectHSP.c>>=
void printSR(sr_t* t, long i)
{
  sr_t* tmp; 

  printf("Resultados iteracion %ld\n",i);
  
  tmp = t;
  while(tmp != NULL)
    {
      printf("%s\t%s\t%s\t%ld\t%ld\t%f\t%c\t%hd\n",
	     NONAME,
	     VERSION,
	     SR,
	     tmp->Start,
	     tmp->End,
	     tmp->Score,
	     tmp->Strand,
	     tmp->Frame); 
      tmp = tmp->next;
    }
}

int FreeItems(sr_t* q)
{
  int numElems;
  
  if (q == NULL)
    numElems = 0;
  else
    {
      numElems = FreeItems(q->next);
      numElems++;
      free(q);
    }
  return(numElems);
}

/* Returns the number of free SR */
int CutAndPaste(sr_t** Left, sr_t** Right,
                sr_t** insLeft, sr_t** insRight,
                sr_t** sr)
{
  sr_t* tmp;
  int numElems;
  
/*    printf("nr0: %ld %ld %d\n",Left->Start,Left->End,Left->Score); */
/*    printf("sr: %ld %ld %d\n",sr->Start,sr->End,sr->Score); */
/*    printf("firstSR: %ld %ld %d\n",Right->Start,Right->End,Right->Score); */
/*    printf("fnSR: %ld %ld %d\n",insLeft->Start,insLeft->End,insLeft->Score); */
/*    printf("newSR: %ld %ld %d\n",insRight->Start,insRight->End,insRight->Score); */
  
  /* Cut and Paste at the beginning of the list */
  if (*Left == NULL)
    {
      /* tmp used for freeing the useless nodes*/
      tmp = *sr;
      *sr = *insLeft;
    }
  else
    {
      /* tmp used for freeing the useless nodes*/
      tmp = (*Left)->next;
      (*Left)->next = *insLeft;
    }

  
  (*insRight)->next = (*Right)->next;
  
  /* Free nodes between [Left->next | sr] and Right */
  (*Right)->next = NULL;

  numElems = FreeItems(tmp);
  
  return(numElems);
}

void Chain(sr_t** newSR, sr_t* auxSR, sr_t** firstNewSR)
{
  /* Chaining the new SR to the chain */
  if (*newSR != NULL)
    {
      (*newSR)->next = auxSR;
      (*newSR) = (*newSR)->next;
    }
  else
    {
      /*        printMess("INT: iniciando la nueva cadena"); */
      
      *newSR = auxSR;
      *firstNewSR = auxSR;
    }
}

sr_t* RequestMemoryNewSR()
{
  sr_t* s;
  
  if ((s = (sr_t *) malloc(sizeof(sr_t))) == NULL)
    printError("Not enough space to hold one new SR");
  
  return(s);
}

void project1HSP(hsp** hsps, long nHSP, packSR *allSr)
{
  int index;
  long i;
  sr_t* beforeFirstSR;
  sr_t* firstSR;
  sr_t* auxSR;
  sr_t* newSR;
  sr_t* firstNewSR;
  int numElems;
  
  /* For each HSP do... */
  for(i=0; i<nHSP; i++)
    {
      /*    printf("\nTratando HSP %ld: %ld %ld %d %hd\n", */
      /*  	     i,hsps[i]->StartQ,hsps[i]->EndQ,hsps[i]->Score,hsps[i]->FrameQ); */
      
      index = (hsps[i]->StrandQ == '+')?
      hsps[i]->FrameQ % 3 :  
	(hsps[i]->FrameQ % 3) + FRAMES;
      
      /* Searching into the list, the first SR after this HP */
      /* beforeFirstSR: the last before the first SR after this HP */
      /* Possible values for firstSR and beforeFirstSR */
      /* a. Reading from the start (1 element) */
      if (allSr->nr[index] > 0 && allSr->nr0[index]==NULL)
	{
	  firstSR = allSr->sr[index];
	  beforeFirstSR = NULL;
	}
      else
	{
	  /* b. Empty list */
	  if (allSr->nr[index] == 0 && allSr->nr0[index] == NULL)         
	    firstSR = NULL;         
	  /* c. Normal situation: inside the list */
	  else
	    firstSR = allSr->nr0[index];
	  
	  beforeFirstSR = firstSR;
	}
      
      /* scanning the list of SR */
      while(firstSR != NULL && firstSR->End < hsps[i]->StartQ)
	{
	  beforeFirstSR = firstSR;
	  firstSR = firstSR->next;
	}
      
      /* last SR before first selected SR */
      allSr->nr0[index] = beforeFirstSR;
      
      /* Empty list: Insert first SR (the same HP) */
      if(firstSR == NULL && beforeFirstSR == NULL)
	{
	  /*  printMess("Lista vacia: creando primer SR\n"); */
	  
	  /* Creating a new SR placed after end of this list */
	  auxSR = RequestMemoryNewSR();
	  
	  /* Setting HSP values */
	  auxSR->Start = hsps[i]->StartQ;
	  auxSR->End = hsps[i]->EndQ;
	  auxSR->Strand = hsps[i]->StrandQ;
	  auxSR->Frame = hsps[i]->FrameQ;
	  auxSR->Score = hsps[i]->Score;
	  strcpy(auxSR->Locus,hsps[i]->Subject);
	  auxSR->next = NULL;
	  
	  /* Insert at the beginning */
	  allSr->sr[index] = auxSR;
	  allSr->nr[index]  = 1;
	}
      else
	/* Insert SR at the end of the list */
	if(firstSR == NULL && beforeFirstSR != NULL)
	  {
	    /*  printMess("Recorrida lista completa: insertar al final\n"); */
	    
	    /* Creating a new SR placed after end of this list */
	    auxSR = RequestMemoryNewSR();
	    
	    /* Setting HSP values */
	    auxSR->Start = hsps[i]->StartQ;
	    auxSR->End = hsps[i]->EndQ;
	    auxSR->Strand = hsps[i]->StrandQ;
	    auxSR->Frame = hsps[i]->FrameQ;
	    auxSR->Score = hsps[i]->Score;
	    strcpy(auxSR->Locus,hsps[i]->Subject);
	    auxSR->next = NULL;
	    
	    /* Insert at the end */
	    beforeFirstSR->next = auxSR;
	    allSr->nr[index]++;
	  }
	else
	  {
	    /* We work with the sublist starting at firstSR */
	    /* newSR is the current created node */
	    /* firstNewSR is the beginning of the new SR chain */
	    newSR = NULL;
	    firstNewSR = NULL;
	    
	    /*  printMess("Intersecciones"); */
	    /*  	    printf("INT: SR1: %ld %ld\n",firstSR->Start,firstSR->End); */
	    
	    /* 1. Creating a new SR: START(firstSR) - START(HSP) */
	    if (firstSR->Start < hsps[i]->StartQ)
	      {
		newSR = RequestMemoryNewSR();
		firstNewSR = newSR;
		
		/* Setting HSP values */
		newSR->Start = firstSR->Start;
		newSR->End = hsps[i]->StartQ-1;
		newSR->Strand = firstSR->Strand;
		newSR->Frame = firstSR->Frame;
		newSR->Score = firstSR->Score;
		strcpy(newSR->Locus,hsps[i]->Subject);
		newSR->next = NULL; 
		
		allSr->nr[index]++;
		
		/*  printf("INT: Generado primer bloque\n"); */
		/*  		printf("%ld %ld\n",newSR->Start,newSR->End); */
	      }
	    
	    /* 2. Creating the rest of intersections until last*/
	    auxSR = RequestMemoryNewSR();
	    auxSR->Start = hsps[i]->StartQ;
	    
	    while((hsps[i]->EndQ > firstSR->End) && (firstSR->next != NULL))
	      {
		/*  printf("INT: Dentro del while\n"); */
		auxSR->End = firstSR->End;
		auxSR->Score = MAX(firstSR->Score,hsps[i]->Score);
		auxSR->Strand = firstSR->Strand;
		auxSR->Frame = firstSR->Frame;
		/*  auxSR->Locus = strcat(firstSR->Locus,hsps[i]->Subject); */
		strcpy(auxSR->Locus,hsps[i]->Subject);
		auxSR->next = NULL;
		
		allSr->nr[index]++;
		
		/*  printf("INT: Creado nuevo SR(while)\n"); */
		
		Chain(&newSR,auxSR,&firstNewSR);
		
		/* jumping to the next SR on the chain */
		firstSR = firstSR->next;
		
		auxSR = RequestMemoryNewSR();
		auxSR->Start = firstSR->Start;
	      }/* endwhile */
	    
	    /* 3. Creating the last intersections */
	    /* NO Sobresale por detras el SR */
	    if (hsps[i]->EndQ >= firstSR->End)
	      {
		auxSR->End = firstSR->End;
		auxSR->Score = MAX(firstSR->Score,hsps[i]->Score);
		auxSR->Strand = firstSR->Strand;
		auxSR->Frame = firstSR->Frame;
		/*  auxSR->Locus = strcat(firstSR->Locus,hsps[i]->Subject); */
		strcpy(auxSR->Locus,hsps[i]->Subject);
		auxSR->next = NULL;
		
		/*  printf("auxSR %ld %ld %d\n",auxSR->Start,auxSR->End,auxSR->Score); */

		allSr->nr[index]++;
		
		Chain(&newSR, auxSR,&firstNewSR); 

		/* Coinciden los finales */
		if (hsps[i]->EndQ == firstSR->End)
		  {}/*  printf("INT2: igual final. No se crean mas\n"); */
		else
		  {
		    /* Creating a new SR: END(firstSR) - END(HSP) */
 		    auxSR = RequestMemoryNewSR();
		    auxSR->Start = firstSR->End+1;
		    auxSR->End = hsps[i]->EndQ;
		    auxSR->Strand = firstSR->Strand;
		    auxSR->Frame = firstSR->Frame;
		    auxSR->Score = hsps[i]->Score;
		    strcpy(auxSR->Locus,hsps[i]->Subject);
		    auxSR->next = NULL;
		    
		    allSr->nr[index]++;
		    
		    Chain(&newSR,auxSR,&firstNewSR);
		  }
	      }
	    /* Sobresale por detras el SR */
	    else
	      {
		auxSR->End = hsps[i]->EndQ;
		auxSR->Strand = firstSR->Strand;
		auxSR->Frame = firstSR->Frame;
		auxSR->Score = MAX(firstSR->Score,hsps[i]->Score);
		/*  auxSR->Locus = strcat(firstSR->Locus,hsps[i]->Subject); */
		strcpy(hsps[i]->Subject,auxSR->Locus);
		auxSR->next = NULL;
		
		allSr->nr[index]++;
		
		Chain(&newSR,auxSR,&firstNewSR);
		
		auxSR = RequestMemoryNewSR();
		
		auxSR->Start = hsps[i]->EndQ +1;
		auxSR->End = firstSR->End;
		auxSR->Strand = firstSR->Strand;
		auxSR->Frame = firstSR->Frame;
		auxSR->Score = firstSR->Score;
		strcpy(auxSR->Locus,firstSR->Locus);
		auxSR->next = NULL;

		allSr->nr[index]++;

		Chain(&newSR,auxSR,&firstNewSR);
	      }

	    /* Recompute SR chain using saved before backup pointers */
	    /*  printMess("Cut and Paste!"); */
	    numElems = CutAndPaste(&allSr->nr0[index], 
				   &firstSR,
				   &firstNewSR, 
				   &newSR,
				   &allSr->sr[index]);
	    
	    /*  printf("%d erased elems\n",numElems); */

	    allSr->nr[index] = allSr->nr[index] - numElems;
	    
	  }/* end working with sublist*/
      
      /*  printSR(allSr->sr[index],i); */
    }/* endfor */
}

void ProjectHSP(packHSP *allHsp, packSR *allSr)
{
  int i;
  
  /* projecting all the strands and frames */ 
  for(i=0; i<STRANDS*FRAMES; i++)
    project1HSP(allHsp->hsps[i],allHsp->nHsps[i],allSr);
}

@ 

<<JoinSR.c>>=
void Merge(sr_t* A, sr_t* B)
{
  /* A will remain and B will be free */
  A->End = B-> End;
  A->next = B->next;

  free(B);
}

void Join1SR(packSR* allSr, int i)
{
  sr_t* A;
  sr_t* B; 
  int stop;

  A = allSr->sr[i];
  
  if (A != NULL)
    {
      stop = (A->next == NULL);
      while(!stop)
	{
	  B = A->next;
	  if (((A->End + 1) == B->Start) && (A->Score == B->Score))
	    {
	      /*  printf("Join %ld %ld -- %ld %ld\n", */
	      /*  		     A->Start,A->End, */
	      /*  		     B->Start,B->End); */
	      Merge(A,B);
	      allSr->nr[i]--;
	    }
	  else
	    {
	      /* Next loop */
	      A = A->next;
	    }
	  stop = (A->next == NULL);
	}
    }
}

void JoinSR(packSR* allSr)
{
  int i;

  /* join consecutive SR with the same score */
  for(i=0; i<STRANDS*FRAMES; i++)
    Join1SR(allSr,i);  
}

@ 

<<Output.c>>=
extern int VRB, GFFOUT, PSR;

extern account *m;    

/* Printing messages (information) */
void printMess(char* s)
{
  if (VRB)
     fprintf (stderr, "> %s\n",s);
}

/* Printing partial and final results (information) */
void printRes(char* s)
{
  if (VRB)
     fprintf (stderr, "\t%s\n",s);
}

/* Printing error messages */
void printError(char *s)
{
     fprintf(stderr,"Error: %s\n",s);
	  exit(1);
}

/* Get time of execution using account information */
void OutputTime()
{
  time_t tEnd;
  int t;
  float caux;
  char mess[MAXSTRING];

  (void) time(&tEnd);
  caux = (float)clock() / (float)CLOCKS_PER_SEC;

  t = (int) tEnd - m->tStart;

  if (t < caux)
    t++;

  printRes("_______________________________________________________________\n");
 
  sprintf(mess,"CPU time: \t%.3f secs",caux);
  printRes(mess);

  sprintf(mess,"Total time: \t%d secs(%.2f mins)\n\n",t,(float)t/MINUTE);
  printRes(mess);
}

void PrintHSP(packHSP* allHSP, char Query[LOCUSLENGTH])
{
  int i;
  long j;

  for(i=0; i < FRAMES*STRANDS; i++)
    for(j=0; j < allHSP->nHsps[i]; j++)
      printf("%s\t%s\t%s\t%ld\t%ld\t%f\t%c\t%hd\t%s\n",
	     Query,
	     VERSION,
	     HSP,
	     allHSP->hsps[i][j]->StartQ,
	     allHSP->hsps[i][j]->EndQ,
	     allHSP->hsps[i][j]->Score,
	     allHSP->hsps[i][j]->StrandQ,
	     allHSP->hsps[i][j]->FrameQ,
	     allHSP->hsps[i][j]->Subject);
}

void PrintSRStrands(packSR* allSR)
{
  int i;
  sr_t* tmp;

  printf("## blast2gff v 1.0. imim.es\n");

  for(i=0; i< FRAMES*STRANDS; i++)
    {
      printf("## Created %d SR(frame %d)\n",allSR->nr[i],i);

      tmp = allSR->sr[i];
      while(tmp != NULL)
	{
	  printf("%s\t%s\t%s\t%ld\t%ld\t%f\t%c\t%hd\n",
		 NONAME,
		 VERSION,
		 SR,
		 tmp->Start,
		 tmp->End,
		 tmp->Score,
		 tmp->Strand,
		 tmp->Frame); 
	  tmp = tmp->next;
	}
    }
}

void PrintSR(packSR* allSR, char Query[LOCUSLENGTH])
{
  int i;

  printf("## blast2gff v 1.0. imim.es\n");
  printf("## Created %ld SR\n",allSR->nSR);

  for(i=0; i < allSR->nSR; i++)
    {
      printf("%s\t%s\t%s\t%ld\t%ld\t%f\t%c\t%hd\n",
	     Query,
	     VERSION,
	     SR,
	     allSR->sortSR[i]->Start,
	     allSR->sortSR[i]->End,
	     allSR->sortSR[i]->Score,
	     allSR->sortSR[i]->Strand,
	     allSR->sortSR[i]->Frame); 
    }
}


void Output(packHSP* allHSP, packSR* allSR, char Query[LOCUSLENGTH])
{
  if (GFFOUT)
    PrintHSP(allHSP,Query);

  if (PSR)
      PrintSR(allSR,Query);
}

@ 

\subsctn{POD Pages}

<<POD man page - SGP::filters>>=
@

\newpage

\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
#
<<Version Control Id Tag>>
#
use strict;
#
@

<<Global Constants - Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@ %def $T $F

We also set here the date when the script is running and who is the user running it.

<<Global Vars - User and Date>>=
my $DATE = localtime;
my $USER = $ENV{USER};
@ %def $DATE $USER


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ %def &timing


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsctn{Checking signals returned by [[system]]}

We check for exit signals returned by system once it has run the command-line defined in [[$cmdline]] variable (we use the recipe shown in the O'Reilly book, ``Programming Perl'', 2$^n$ edition, page 230). %'

<<Common PERL subs - Check sys command>>=
#
sub check_sys_result() {
    my $runOK = $F;
    my $prog_exit = 0xffff & $_[0];
    printf STDERR "### Command returned %#04x : ", $prog_exit;
    if ($prog_exit == 0) {
        print STDERR "ran with normal exit ...\n";
        $runOK = $T;
    } elsif ($prog_exit == 0xff00) {
        print STDERR "command failed: $! ...\n";
    } elsif (($prog_exit & 0xff) == 00) {
        $prog_exit >>= 8;
        print STDERR "ran with non-zero exit status $prog_exit ...\n";
    } else {
        print STDERR "ran with ";
        if ($prog_exit &   0x80) {
            $prog_exit &= ~0x80;
            print STDERR "coredump from ";
        };
        print STDERR "signal $prog_exit ...\n";
    };
    return $runOK;
} # check_sys_result()
@ %def &check_sys_result


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@ %def &max &min

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@ %def &fill_right &fill_left &fill_mid

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@ %def &counter &counter_end

<<Global Vars - Counter>>=
my ($n,$c); # counter and char (for &counter function)
@ %def $n $c


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%MessageList]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($MessageList{ shift @_ },@_) }
@ %def &report

The same happens to '[[warn]]' function which also requires a hash variable '[[%ErrorList]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($ErrorList{ shift @_ }, @_) }
@ %def &warn


\subsctn{AWK scripts}

<<GAWK shebang>>=
#!/usr/bin/gawk -f
# GNU Awk 3.0.4
<<Version Control Id Tag>>
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{License Terms}

The programs are distributed under GNU General Public License as described below.  Those are the license terms that must appear at programs begining.

<<Copyleft>>=
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
@

\subsctn{CVS Tags}

This document is under Concurrent Version System (CVS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: SintenicGenePrediction.nw,v 1.5 2001-06-06 19:00:58 jabril Exp $
@ 

The code tangled from this document will keep same tag until we check in the new versions.

\newpage

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracting Script code chunks from the [[noweb]] file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original [[noweb]] file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"SGP TOOL" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' > $BIN/sgp.pl ;
notangle -L -R"SGP::filters" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' > $LIB/sgpfilters/SGPfilters.pm ;
notangle -L -R"SGP::filters - Makefile.PL" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' > $LIB/sgpfilters/Makefile.PL ;
# program without line numbering comments
notangle -R"SGP TOOL" $WORK/$nwfile.nw \
    > $BIN/sgp.pl ;
notangle -R"SGP::filters" $WORK/$nwfile.nw \
    > $LIB/sgpfilters/SGPfilters.pm ;
notangle -R"SGP::filters - Makefile.pl" $WORK/$nwfile.nw \
    > $LIB/sgpfilters/Makefile.PL ;
# making them runnable
chmod a+x $BIN/sgp.pl ;
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
notangle -R"root" $WORK/$nwfile.nw \
    > $DATA/root_config ;
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
notangle -Rweaving  $WORK/$nwfile.nw > $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw > $WORK/ltx ;
chmod a+x $WORK/nw2tex $WORK/ltx;
@ 

<<weaving>>=
<<BASH shebang>>
# weaving and LaTeXing
<<BASH Environment Variables>>
noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
popd ;
<<BASH script end>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
# Global Variables
export WORK="$HOME/development/sggp" ;
export BIN="$WORK/bin" ;
export LIB="$WORK/lib" ;
export DOCS="$WORK/docs" ;
export DATA="$WORK/data" ;
export nwfile="SintenicGenePrediction" ;
@ 

<<CSH Environment Variables>>=
# Global Variables
setenv WORK "$HOME/development/sggp" ;
setenv BIN  "$WORK/bin" ;
setenv LIB  "$WORK/lib" ;
setenv DOCS "$WORK/docs" ;
setenv DATA "$WORK/data" ;
setenv nwfile "SintenicGenePrediction" ;
@ 

<<tangling>>=
# TO DO: add a test to check which shell is running
# BASH shell
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw \
         > $WORK/.bash_VARS ; 
# CSH shell
notangle -R'CSH Environment Variables'  $WORK/$nwfile.nw \
         > $WORK/.csh_VARS ; 
# sourcing
source $WORK/.bash_VARS ;
source $WORK/.csh_VARS ;
@

\end{document}
