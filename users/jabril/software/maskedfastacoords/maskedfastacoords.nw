% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: maskedfastacoords.nw,v 1.3 2001-09-25 17:24:54 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}
%
<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
\item {#1}\dotfill[\textit{Section}~\ref{#2}, \textit{page}~\pageref{#2}]
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\progname{maskedfastacoords.pl}
\def\mtjabril{
 \htmladdnormallink{\texttt{jabril@imim.es}}
                   {MAILTO:jabril@imim.es?subject=[maskedfastacoords]}
 } % def mtjabril
\def\authorslist{
 Josep F. Abril {\mdseries\small\dotfill \mtjabril } \\
 % Other authors here...\\
 } % def authorslist
\def\license{GNU General Public License (GNU-GPL)}
\def\description{
 Retrieving positions for masked regions of masked sequences in fasta format.
Program can also output those coords in GFF format, where you can define several fields from command-line. } % def description 
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\textbf{Genome Informatics Research Lab}}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\def\tit{\textsc{\progname}}
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\tit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textsl{Authors List Here}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\begin{bfseries}
\begin{large}
\newlength{\lttbl}\setlength{\lttbl}{0.25\linewidth}
\newlength{\rttbl}\setlength{\rttbl}{0.70\linewidth}
%\fbox{
%\vskip 2ex
\begin{tabular}{>{\scshape}r@{\quad}l}
\rule{\lttbl}{0pt} & \rule{\rttbl}{0pt} \\[2ex]
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
Program Name: & {\Huge\progname}                       \\[3ex]
\multicolumn{2}{c}{\rule[0.5ex]{0.95\linewidth}{2pt}}\\[2ex]
      Author: & {\Large
                 \begin{minipage}[t]{0.95\rttbl}
                 \authorslist
                 \end{minipage}}                       \\[2ex]
     License: & {\license}                             \\[2ex]
 Last Update: & {\today}                               \\[2ex]
 Description: & {\large\mdseries
                 \begin{minipage}[t]{0.95\rttbl}
                 \description
                 \end{minipage}}                       \\[2ex]
\\
\multicolumn{2}{c}{\shortstack{\rule[0ex]{0.95\linewidth}{2pt}\\[0ex]
                               \rule[1ex]{0.95\linewidth}{2pt}}}\\[2ex]
\end{tabular}
%} % fbox
\end{large}
\end{bfseries}
\end{center}

\vfill

\begin{raggedleft}
\showaffiliation
\end{raggedleft}

\end{titlepage} %'

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: maskedfastacoords.nw,v 1.3 2001-09-25 17:24:54 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{Program description}

\description


\subsctn{Input}

<<HIDE: new LaTeX definitions>>=
\def\RptM{\htmladdnormallinkfoot{\textsc{RepeatMasker}}{http://www.genome.washington.edu/UWGC/analysistools/repeatmask.htm}}
@

The following example illustrates both, ``classical'' (using 'N') and soft (using lowercase letters), masking of fasta sequences as they can be obtained from a program such {\RptM}. Sequence is splitted into 50 chararacter-length lines.

\begin{center}
\begin{minipage}[c]{0.75\linewidth}
<<masked fasta input file>>=
>Masked_fasta_sequence
TATCCATGCCCTCACTAATGTCTCAGTTTTTAGAAATTTTACAGTGCTTA
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
TAAACTTTCTTCTGATGTTGTCTAACCtgtatgttctttgaggacaagga
gagtacacagtaggaactcaatgaatacttgctgatgaNNNNNNNNNNNN
CTCTTAACACTcctcgactcagaatgttcccgtgttctcctctagTGTGA
CCTCTTTTGTGTCTTGAAaggaannnnnatcgctCATCAATCACCAAATA
TCAGTCCCTGTTGGGTGTAGGTCTG
@ 
\end{minipage}
\end{center}

The sequence '[[Masked_fasta_sequence]]' is 325 nucleotides long. Masking is distributed in the following coords:

\begin{center}
\begin{tabular}{rrl}
  51 & 100 & N-masking \\
 128 & 188 & soft-masking \\
 189 & 200 & N-masking \\
 212 & 245 & soft-masking \\
 269 & 284 & soft-masking \\
 274 & 278 & n-masking (soft) \\
\end{tabular}
\end{center}


\subsctn{Output}

The program can produce three different outputs returning the coords of the sequence masked segments: only ``classical'' masking ('N' or 'n'), only soft-masking ('[a-z]'), both. From the previous example we must obtain the following results:

\begin{center}
\renewcommand{\arraystretch}{0.75}
\begin{tabular}{c@{\qquad}c@{\qquad}c}
 \begin{tabular}[t]{rrl}
\multicolumn{3}{l}{ \hspace{-0.5cm}\textbf{Basic-masking} \hrulefill } \\
  51 & 100 & N-masking \\
 189 & 200 & N-masking \\
 274 & 278 & n-masking \\[2ex]
 \end{tabular}
&
 \begin{tabular}[t]{rrl}
\multicolumn{3}{l}{ \hspace{-0.5cm}\textbf{Soft-masking} \hrulefill } \\
 128 & 188 & soft-masking \\
 212 & 245 & soft-masking \\
 269 & 284 & soft-masking \\[2ex]
 \end{tabular}
&
 \begin{tabular}[t]{rrl}
\multicolumn{3}{l}{ \hspace{-0.5cm}\textbf{Merged-masking} \hrulefill } \\
  51 & 100 & N-masking \\
 128 & 188 & soft-masking \\
 189 & 200 & N-masking \\
 212 & 245 & soft-masking \\
 269 & 273 & soft-masking \\
 274 & 278 & n-masking (soft) \\
 279 & 284 & soft-masking \\
 \end{tabular}
\\
\end{tabular}
\end{center}


% \subsctn{Comments}

\subsctn{To Do}

\begin{itemize}
 \input todo.tex
\end{itemize}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Implementation}

\subsctn{Program outline}
 
\label{todo:AAA}
<<HIDE: new defs TODO>>=
\def\todoAAA{This is a first draft of the {\progname}.} % todoAAA
@
<<HIDE: TODO>>=
\todoitem{\todoAAA}{todo:AAA}
@
\todo{ \item \todoAAA } % todo

<<maskedfastacoords>>=
<<PERL shebang>>
#
# MODULES
#
<<Use Modules>>
#
# VARIABLES
#
<<Global Vars>>
#
# MAIN LOOP
#
<<Main Loop>>
#
# FUNCTIONS
#
<<Functions>>
@ 

<<Program Info>>=
my $PROGRAM = 'getfastamasked.pl';
my $VERSION = '0.1_alpha';
@ 
<<Prog USAGE>>=
#$PROGRAM [options] < fasta_file > coords_file
@
<<Prog DESC>>=
#Retrieving masked regions coords from fasta files.
@

<<Program Description>>=
# 
#  <<Prog USAGE>>
#
#  <<Prog DESC>>
#
@ 

<<Use Modules>>=
<<Use Modules - Benchmark>>
<<Use Modules - Getopt>>
<<Use Modules - Bio::Seq>>
@

<<Global Vars>>=
<<Boolean>>
<<Stderr subs vars>>
my ($id,$seq) = ('','');
@

<<Main Loop>>=
&parse_cmdline(); # PROG-START

&main();

&report('PROG-FINISH',&timing($T));

exit(0);
@

<<messages: program running>>=
'PROG-START'  => "$line$s\n$s Running $PROGRAM\n$s".
                 "$s HOST: $host".
                 "$s USER: $USER".
                 "$s DATE: $DATE\n$s\n$line$s" ,
'PROG-FINISH' => "$s\n$line$s\n$s $PROGRAM FINISHED\n$s".
                 "$s TOTAL TIME: \%s\n$line" ,
@ 

<<Functions>>=
<<Parsing command line options>>
<<Main program function>>
<<Common PERL subs - Benchmark>>
<<Common PERL subs - STDERR>>
@

\subsctn{{\biop} modules}

<<HIDE: new LaTeX definitions>>=
\def\biop{\textsc{BioPerl}}
\def\biopORG{\htmladdnormallinkfoot{\biop}{http://bioperl.org/}}
\def\biopCPAN{\htmladdnormallinkfoot{{\biop} is also available from CPAN}{http://search.cpan.org/search?dist=bioperl}}
\def\bioseq{\htmladdnormallinkfoot{\texttt{Bio::Seq}}{http://bioperl.org/Core/POD/Bio/Seq.html}}
\def\bioseqIO{\htmladdnormallinkfoot{\texttt{Bio::SeqIO}}{http://bioperl.org/Core/POD/Bio/SeqIO.html}}
@ 

{\bioseq} is the {\biopORG} main sequence object while {\bioseqIO} is the {\biop} support for sequence input/output into files. {\biopCPAN}.

<<Use Modules - Bio::Seq>>=
use Bio::Seq;
use Bio::SeqIO;
@

<<perl requires - BioPerl>>=
"Bio::Seq"
"Bio::SeqIO" - BioPerl modules to handle sequence objects. (*)
               You can download directly from CPAN or 
               from BioPerl web site at "http://bioperl.org/".
@

\sctn{Program functions}

\subsctn{Processing command-line options}

<<Use Modules - Getopt>>=
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
@ 

<<perl requires - Getopt>>=
"Getopt::Long" - processing command-line options.
@

See '[[man Getopt::Long]]' for further info about this package.

<<Parsing command line options>>=
sub parse_cmdline() {

    $SIG{__WARN__} = sub { &warn('UNKNOWN_CL_OPTION',$T,$_[0]) };
    GetOptions(
               <<command-line options - masking>>
               <<command-line options - fasta>>
               <<command-line options - GFF>>
               <<command-line options with exit>>
               ) || (&warn('CMD_LINE_ERROR',$T), exit(1));
    $SIG{__WARN__} = 'DEFAULT';

    &report("PROG-START");
} # parse_cmdline
@

<<warnings: command-line>>=
'UNKNOWN_CL_OPTION' =>
  $Warn."Error trapped while processing command-line:\n".(" "x16)."\%s\n",
'CMD_LINE_ERROR' =>
  $spl.$spw." Please, check your command-line options!!!\n".$Error."\n".
  $spw." ".("."x12)." Type \"maskedfastacoords.pl -h\" for help.\n".$spl,
@ 

\subsubsctn{Defining help and auxiliary code chunks}

The following command-line checkings look for those options exiting the program: '[[help]]' and '[[version]]'. Both need to output to screen without any other message/warning being displayed at the same time.

<<command-line options with exit>>=
"version"   => \&prt_version, 
"h|help|?"  => \&prt_help,
@ 
<<command-line help - help>>=
-h, --help            Shows this help.
--version             Shows current version and exits.
@

<<Parsing command line options>>=
sub prt_version() {
    &report('SHOW_VERSION',$PROGRAM,$VERSION);
    exit(1);
} # prt_version
@ 

<<messages - parsing command-line>>=
'SHOW_VERSION' => $sp."### \%s -- \%s\n".$sp,
@

Printing command-line help to [[STDERR]]:

<<Parsing command line options>>=
sub prt_help() {
    print STDERR <<"+++EndOfHelp+++";
PROGRAM:
                        $PROGRAM - $VERSION

    <<Prog DESC>>

USAGE:    <<Prog USAGE>>


DESCRIPTION:

    Retrieving positions for masked regions of masked sequences 
    in fasta format. Program can also output those coords in GFF
    format, where you can define several fields from command-line.


REQUIRES:

    <<perl requires help>>


COMMAND-LINE OPTIONS:

    <<command-line help>>


BUGS:    Report any problem to 'jabril\@imim.es'.

AUTHOR:  $PROGRAM is under GNU-GPL (C) 2000 - Josep F. Abril

+++EndOfHelp+++
    exit(1);
} # prt_help
@

<<perl requires help>>=
$PROGRAM needs the following Perl modules 
installed in your system, we used those available 
from the standard Perl distribution. Those that 
are not in the standard distribution are marked 
with an '(*)', in such cases make sure that you 
already have downloaded them from CPAN 
(http://www.perl.com/CPAN) and installed.

  <<perl requires - BioPerl>>
  <<perl requires - Getopt>>
  <<perl requires - Benchmark>>
@ %$

<<command-line help>>=
A double dash on itself "--" signals end of the options
and start of file names (if present). After double dash,
you can use a single dash "-" as STDIN placeholder. 
Available options and a short description are listed here:

+ General options:

  <<command-line help - help>>

  <<command-line help - masking>>

  <<command-line help - fasta>>

+ GFF output:

  <<command-line help - GFF>>
@

\subsubsctn{Defining command-line options}

<<command-line options - masking>>=
"s|soft-masked"  => ,
"m|merge-masked" => ,
@ 
<<command-line help - masking>>=
-s, --soft-masked      Default is looking for "N" masked sequence
                       segments. This option distinguish between 
                       upper/lower-case and assumes lower-case to 
                       define masked regions too (so called soft-masking).
-m, --merge-masked     Default is differentiating classical-masking
                       (with "N"s) from soft-masking. This option merges
                       both as if they were the same masking type
                       (it also enables soft-masking search so previous 
                       option is not required when passing this one).
@
 
<<command-line options - fasta>>=
"l|large-fasta"  => ,
@ 
<<command-line help - fasta>>=
-l, --large-fasta      For large genomic sequence you can enable
                       Bio::SeqIO to work with temporary files
                       avoiding memory overload (though it makes
                       the script to run slowly).
@

<<command-line options - GFF>>=
"g|gff"        => ,
"seq-name=s"   => ,
"source=s"     => ,
"f|feature=s"  => ,
"strand=s"     => ,
"group=s"      => ,
@ 
<<command-line help - GFF>>=
-g, --gff              Output in GFF format (default coords).

--seq-name <string>    Sets sequence GFF field (default "noname").
--source <string>      Sets source GFF field (default "masked").
-f, --feature <string> Sets feature GFF field (default "masked").
--strand <string>      Sets strand GFF field (default ".").
--group  <string>      Sets group GFF field (default none).
@

\subsctn{Main program function}

<<Main program function>>=
sub main() {
    my $seqin = Bio::SeqIO->new(-format => 'FASTA', -fh => \*STDIN);
    while (my $sequence = $seqin->next_seq()) {
        my ($sid,$len,$seq,@nuc,@coords,$masked_flg,$match,$msk_num);
        @coords = ();
        <<Setting sequence variables from fasta record>>
        <<Finding masked regions coords>>
        <<Writing masked regions coords in GFF>>
    }; # while 
} # main
@ 

<<Setting sequence variables from fasta record>>=
print STDERR "### READING FASTA............\n";
$sid  = $sequence->display_id();
$len  = $sequence->length();
$seq  = $sequence->seq();
@ 

\label{todo:CCC}
<<HIDE: new defs TODO>>=
\def\todoCCC{We can define mask checking as three different subroutines that will be called by reference, so that a variable name (called for instance \texttt{\$test}) will be set depending on command-line options.} % todoCCC
@
<<HIDE: TODO>>=
\todoitem{\todoCCC}{todo:CCC}
@
\todo{ \item \todoCCC } % todo

<<Finding masked regions coords>>=
print STDERR "###         PARSING SEQUENCE: $sid ($len bp)\n";
@nuc = split //og, $seq;
($masked_flg,$match) = ($F,$F) ;
for (my $n = 0; $n <= $#nuc; $n++) {
    $match = ( $nuc[$n] =~ /[NnXx]/o ) ? $T : $F;
    ( !$masked_flg && $match ) && do {
        $masked_flg = $T ;
        # $n contains the last non-masked nucleotide
        push @coords, ($n + 1);
        next;
    };
    $masked_flg && do {
        $match && (next);
        $masked_flg = $F ;
        # $n contains the last masked nucleotide now
        push @coords, $n;
    };
}; # for nuc in $seq
# if last nucleotide is masked, previous loop not includes its coord. 
$masked_flg &&( push @coords, $len);
@ 

<<Writing masked regions coords in GFF>>=
$msk_num = scalar(@coords) / 2;
print STDERR "###         WRITING GFF COORDS: $msk_num masked regions found.\n";
for (my $n = 0; $n <= $#coords; $n+=2) {
    my $GFFstring = ("\%s\t" x 5).(".\t" x 3).".\n";
    printf STDOUT $GFFstring, $sid, "masked", "masked", @coords[$n..($n + 1)];
}; # for coords in @coords
@ 

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{empty appendix section}

\subsctn{empty appendix subsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/bin/perl -w
# This is perl, version 5.005_03 built for i386-linux
#
<<Program Description>>
#
<<GNU License>>
#
<<Version Control Id Tag>>
#
use strict;
#
# BEGIN {
    <<Program Info>>
    my $DATE = localtime;
    my $USER = defined($ENV{USER}) ? $ENV{USER} : 'Child Process';
    my $host = `hostname`;
    chomp($host);
# } # BEGIN
@

<<Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@

\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    push @Timer, (new Benchmark);
    # partial time 
    $_[0] || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 

<<perl requires - Benchmark>>=
"Benchmark" - checking and comparing running times of code.
@

\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Global Vars - Counter>>=
my ($n,$c); # counter and char (for &counter function)
@ %def $n $c


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%Messages]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($Messages{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also uses the hash variable '[[%Messages]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($Messages{ shift @_ }, @_) }
@

Those are accessory variables for the messages strings:

<<Stderr subs vars>>=
my $line = ('#' x 80)."\n";
my $s = '### ';
my $Error = "\<\<\<  ERROR  \>\>\> ";
my $Warn  = "\<\<\< WARNING \>\>\> ";
my $spl   = "\<\<\<\-\-\-\-\-\-\-\-\-\>\>\>\n";
my $spw   = "\<\<\<         \>\>\> ";
@ 

And here the main messages hash:

<<Stderr subs vars>>=
my %Messages = (
    # ERROR MESSAGES
    <<warnings: command-line>>
    # WORKING MESSAGES
    <<messages: program running>>
   ); # %Messages 
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: maskedfastacoords.nw,v 1.3 2001-09-25 17:24:54 jabril Exp $
@ 

\subsctn{GNU General Public License}

<<GNU License>>=
# #----------------------------------------------------------------#
# #                          maskedfastacoords                         #
# #----------------------------------------------------------------#
# 
#    Remember to put a short description of your script here...
# 
#     Copyright (C) 2001 - Josep Francesc ABRIL FERRANDO  
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# 
# #----------------------------------------------------------------#
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling>>=
# showing line numbering comments in program
notangle -L -R"maskedfastacoords" $WORK/$nwfile.nw | \
    perl -ne '$.>1 && print' | cpif $BIN/maskedfastacoords.pl ;
chmod a+x $BIN/maskedfastacoords.pl ;
@ 

<<tangling>>=
# reformating program with perltidy
notangle -R"maskedfastacoords" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/maskedfastacoords.pl ;
# html pretty-printing program with perltidy
notangle -R"maskedfastacoords" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/maskedfastacoords.html ;
#
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling>>=
notangle -R"root" $WORK/$nwfile.nw | \
         cpif $DATA/root_config ;
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling>>=
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
chmod a+x $WORK/nw2tex $WORK/ltx;
@ 

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH shebang>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$

\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<BASH Environment Variables>>=
#
# Setting Global Variables
WORK="/home/ug/jabril/development/softjabril/maskedfastacoords" ;
BIN="$WORK/bin" ;
PARAM="$BIN/param" ;
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
nwfile="maskedfastacoords" ;
export WORK BIN PARAM DOCS DATA nwfile ;
#
@ 

<<tangling>>=
# 
# BASH Environment Variables
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
source $WORK/.bash_VARS ;
#
@

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
