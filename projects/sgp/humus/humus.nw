% -*- mode: Noweb; noweb-code-mode: perl-mode; tab-width: 4 -*-
\documentclass[11pt]{article}
%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
%
% # $Id: humus.nw,v 1.4 2002-02-15 17:29:05 jabril Exp $ 
%
\usepackage{noweb}
\usepackage[a4paper,offset={0pt,0pt},hmargin={2cm,2cm},vmargin={1cm,1cm}]{geometry}
\usepackage{graphics}
\usepackage[dvips]{graphicx}
%% pstricks
\usepackage[dvips]{pstcol}
\usepackage{pstricks}
%\usepackage{pst-node}
%\usepackage{pst-char}
%\usepackage{pst-grad}
%% bibliography
\usepackage{natbib}
%% latex2html
\usepackage{url}
\usepackage{html}     
\usepackage{htmllist} 
%% tables    
\usepackage{dcolumn}
%\usepackage{colortbl}
%\usepackage{multirow}
%\usepackage{hhline}
%\usepackage{tabularx}
%% seminar
%\usepackage{semcolor,semlayer,semrot,semhelv,sem-page,slidesec}
%% draft watermark
%\usepackage[all,dvips]{draftcopy}
%\draftcopySetGrey{0.9}
%\draftcopyName{CONFIDENTIAL}{100}
%% layout
\usepackage{fancyhdr} % Do not use \usepackage{fancybox} -> TOCs disappear
%\usepackage{lscape}
%\usepackage{rotating}
%\usepackage{multicol}
\usepackage{verbatim}
%\usepackage{version}
%% fonts
\usepackage{times}\fontfamily{ptm}\selectfont
\usepackage{t1enc}

% noweb options
\noweboptions{smallcode}
\def\nwendcode{\endtrivlist \endgroup} % relax page breaking scheme
\let\nwdocspar=\par                    %

\input defs.tex % from <LaTeX new definitions> chunk

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{document}
%
<<HIDE: LaTeX new definitions>>=
%%%%% Colors for gff2ps
\input ColorDefs.tex

%%%%% New Commands are defined here
\newcommand{\sctn}[1]{\section{#1}}
\newcommand{\subsctn}[1]{\subsection{#1}}
\newcommand{\subsubsctn}[1]{\subsubsection{#1}}
\newcommand{\desc}[1]{\item[#1] \ \\}
\newcommand{\todo}[1]{
  \vskip 3ex
  \hspace{-0.75cm}
   \psframebox[framearc=0.2,linecolor=darkred,linewidth=1pt,
              fillstyle=solid,fillcolor=verylightyellow,framesep=2ex]{
     \begin{minipage}[t]{16cm}
     \vskip -4.75ex
     \hspace{-1.25cm}
       \psframebox[framearc=1,linecolor=darkred,linewidth=1.25pt,
               fillstyle=solid,fillcolor=verylightorange,framesep=5pt]{
               \textcolor{darkred}{\textbf{\hspace{2ex}TO DO\hspace{2ex}}}
         } % psframebox
      \begin{itemize}\setlength{\itemsep}{-0.5ex} #1 \end{itemize}
     \end{minipage}
     } % psframebox
  \vskip 1.5ex
} % newcommand todo
\newcommand{\todoitem}[2]{
  \item[$\triangleright$] [\textit{Section}~\ref{#2}, 
                           \textit{page}~\pageref{#2}]\\ {#1}
} % newcommand todoitem
<<HIDE: new LaTeX commands>>

%%%%% PSTRICKs definitions
\pslongbox{ExFrame}{\psframebox}
\newcommand{\cln}[1]{\fcolorbox{black}{#1}{\textcolor{#1}{\rule[-.3ex]{1cm}{1ex}}}}
\newpsobject{showgrid}{psgrid}{subgriddiv=0,griddots=1,gridlabels=6pt}
% \pscharpath[fillstyle=solid, fillcolor=verydarkcyan, linecolor=black, linewidth=1pt]{\sffamily\scshape\bfseries\veryHuge #1 }
<<HIDE: new LaTeX pstricks>>

%%%%% global urls
% \newcommand{\getpsf}[1]{\html{(\htmladdnormallink{Get PostScript file}{./Psfiles/#1})}}   
<<HIDE: new LaTeX urls>>

%%%%% defs
\def\noweb{\textsc{noweb}}
\def\ps{\textsc{PostScript}}
<<HIDE: new LaTeX definitions>>

%%%%% TODO defs
<<HIDE: new defs TODO>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\genomelab{\textbf{Genome Informatics Research Lab}}
\def\shorttit{\textbf{Human + Mouse}}
\def\tit{\textsc{\shortstack{Human Genome Annotation\\using Mouse Homology}}}
%
\def\mtauthor{
 \htmladdnormallink{\texttt{author@imim.es}}
                   {MAILTO:author@imim.es?subject=[humus]}
 } % def mtauthor
%
\def\authorslist{
 The Author/s {\mdseries\small\dotfill \mtauthor } \\
 % Other authors here...\\
 } % def authorslist
\def\authorshort{
 Abril, JF; Parra, G; Guig\'o, R
 } % def authorshort
%
\def\license{GNU General Public License (GNU-GPL)}
%
\def\progdesc{
We are going to scale up all the processes we have tested on {\lhsap} chromosomes 22 and 21, to the whole genome approach, in which we take advantage of the homology between {\hsap} and {\lmmus} genomes to increase gene prediction accuracy and producing a better genome annotation of the coding regions.
 } % def progdesc
%
\def\showaffiliation{
\scalebox{0.9 1}{\Large\textsl{\genomelab}}\\
Grup de Recerca en Infom\`atica Biom\`edica\\
Institut Municipal d'Investigaci\'o M\`edica\\
Universitat Pompeu Fabra\\[2ex]
 } % def showaffiliation
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% Setting text for footers and headers
\fancyhead{} % clear all fields
\fancyfoot{} % clear all fields
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO,RE]{\shorttit\quad\rightmark}
\fancyfoot[LO,LE]{\small\textbf{\genomelab}}
\fancyfoot[CO,CE]{\small\textsl{\authorshort}}
\fancyfoot[RO,RE]{\small\textbf{\today}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%
@

<<HIDE: new LaTeX commands>>=
\newcommand{\mylst}[2]{
 \begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{#1}
   \begin{itemize}
     #2
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}
} % newcommand->mylst
\newcommand{\whtlst}[1]{\mylst{What to do here:}{#1}} % newcommand->chklst
\newcommand{\chklst}[1]{\mylst{Check points:}{#1}} % newcommand->chklst
@ 
<<HIDE: new LaTeX pstricks>>=
@ 
<<HIDE: new LaTeX urls>>=
\def\mtjabril{\htmladdnormallink{\textbf{jabril@imim.es}}{MAILTO:jabril@imim.es?subject=[HuMus]}}
\def\mtgparra{\htmladdnormallink{\textbf{gparra@imim.es}}{MAILTO:gparra@imim.es?subject=[HuMus]}}
\def\mtrguigo{\htmladdnormallink{\textbf{rguigo@imim.es}}{MAILTO:rguigo@imim.es?subject=[HuMus]}}
\def\mthomology{\htmladdnormallink{\textbf{homology@viaken.com}}{MAILTO:homology@viaken.com?subject=[HuMus]}}
@ 
<<HIDE: new LaTeX definitions>>=
\def\perl{\textsc{Perl}}
\def\biop{\textsc{BioPerl}}
\def\ps{\textsc{PostScript}}
\def\rptm{\textsc{RepeatMasker}}
\def\bl{\textsc{Blast}}
\def\bn{\textsc{blastn}}
\def\bx{\textsc{blastx}}
\def\bp{\textsc{blastp}}
\def\tbn{\textsc{tblastn}}
\def\tbx{\textsc{tblastx}}
\def\pb{\texttt{parseblast}}
\def\gnid{\texttt{geneid}}
\def\gnsc{\texttt{genscan}}
\def\twsc{\texttt{twinscan}}
\def\slam{\textsc{slam}}
\def\sgp{\textsc{sgp}}
\def\gps{\texttt{gff2ps}}
\def\aps{\texttt{gff2aplot}}
\def\refseq{\textsc{RefSeq}}
\def\ens{\textit{\texttt{emsembl}}}
\def\hsap{\textit{H. sapiens}}
\def\lhsap{\textit{Homo sapiens}}
\def\mmus{\textit{M. musculus}}
\def\lmmus{\textit{Mus musculus}}
@ 
<<HIDE: new defs TODO>>=
@ 

\thispagestyle{empty}

\begin{titlepage}

\ \vfill
\begin{center}
\textbf{\Huge \tit}\\[5ex]

% \textbf{\Large Authors List Here}\\[1ex]
\textbf{\Large Josep F. Abril}\\[1ex]
\textbf{\Large Gen\'{\i}s Parra}\\[1ex]
\textbf{\Large Roderic Guig\'o}\\[5ex] % \raisebox{0.85ex}{\footnotesize$\,\dag$}\\[0.5ex]

\textbf{\large --- \today ---}\\[10ex]

\begin{abstract}
\begin{center}
\parbox{0.75\linewidth}{
\progdesc
} % parbox
\end{center}
\end{abstract}

\vfill

\begin{raggedleft}
\showaffiliation
\raisebox{0.85ex}{\footnotesize$\dag\,$}{\large e-mail: {\mtjabril}, {\mtgparra} and {\mtrguigo}}\\
\end{raggedleft}
\end{center}

\end{titlepage} %'

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}

\ \ \\
% EMPTY PAGE

%
%%%%%%%%%%%%%%%%%%%% FRONTMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{fancy}
% Marks redefinition must go here because pagestyle 
% resets the values to the default ones.
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection.\ #1}}
\renewcommand{\subsectionmark}[1]{\markboth{}{\thesubsection.\ \textsl{#1}}}

\tableofcontents
\listoftables
\listoffigures

\vfill
\begin{center}
{\small$<$ \verb$Id: humus.nw,v 1.4 2002-02-15 17:29:05 jabril Exp $$>$ }
\end{center}

%%%%%%%%%%%%%%%%%%%% MAINMATTER

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{arabic}
\setcounter{page}{1}

\sctn{Introduction}

\subsctn{Project protocol}

\textbf{Issues:}
\begin{itemize}
 \item Whole genome, chromosome and process (all sequences or single sequence) runs.
 \item Results validation.
 \item Unassembled sequences IDs (those ``random''). Loop through each sequence in chromosomes.
 \item Move all verified software to a global path, like [[/usr/local/molbio/share]], \\ instead of [[/projects/sgp/bin]].
 \item Make every protocol step runnable on any machine (so wrapper must handle PBS queues too).
 \item Generate global report by chromosome.
 \item ...
\end{itemize}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Sequence Analysis}

\whtlst{
\item Get annotations for each sequence from Golden Path annotation.
\item Get fragment lengths, fragment number.
\item Get coords of N-masked regions from assembly gaps.
\item Get G+C content.
}

\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

<<Global: >>=
#
#
# HUMUS="$BASE/H.sapiens" -> .project_VARS
#
CheckDirs $HUMUS/.ftp $HUMUS/.ftp/PankajAgarwal
#
CHRLIST="22" ;
#
for n in $CHRLIST;
  do {
       chrdir="$HUMUS/chr$n" ;
       CheckDirs $chrdir ;
       CheckDirs $chrdir/fasta $chrdir/annotation $chrdir/masking \
                 $chrdir/tblastx $chrdir/geneid $chrdir/sgp ;
     };
  done ;
#
CHRNUM="22" ; # length -> 47748585
CHR="chr$CHRNUM" ;
XID="20020122";
#
@

<<Global: >>=
#
# Retrieving Golden path sequence names
#
HSAP="/seq/genomes/H.sapiens/golden_path_20010806" ; # UCSC
HSAPID="20010806";
# 
$BIN/getfastadesc.pl $MySQLPAR/chrs.tbl $HSAP/chromosomes > $HUMUS/seqid_list ;
#
perl -e '
  use strict;
  my %chr = ();
  my ($idir,$ifile) = @ARGV;
  $idir =~ s%/$%%o;
  open(FI,"< $ifile");
  while (<FI>) {
      my @l;
      next if /^[#>]/o;
      next if /^\s*$/o;
      s/^\s*//o;
      @l = split /\s+/o, $_, 2;
      $chr{$l[0]} .= $l[1];
  };
  close(FI);

  my @dirs = qw( annotation fasta masking tblastx geneid sgp );
  foreach my $l (keys %chr) {
      my $odir = "$idir/chr$l";
      &check_dirs($odir,$l) || next;
      foreach my $pd (@dirs) {
          &check_dirs("$odir/$pd",$l);
      };
      open(FO,"> $odir/seqid_list");
      print FO $chr{$l};
      close(FO);
  };

  exit(0);

  sub check_dirs() {
      my ($odir,$chr) = @_;
      ( -e $odir && -d _ ) || do {
          print STDERR "# Making chr $chr directory: $odir\n";
          (mkdir $odir) || do {
              print STDERR "# Error making directory \"$odir\" ".
                           "for chr $chr : SKIPPING !!!\n";
              return 0;
          };
          return 1;
      };
      print STDERR "# Directory \"$odir\" for chr $chr ALREADY EXIST...\n".
      return 1;
  } # check_dirs
' $HUMUS $HUMUS/seqid_list ;
#
@ 


\subsubsctn{Scripts: retrieving sequence names and nucleotide composition}

<<tangling: perl scripts>>=
notangle -R"getfastadesc.pl" $WORK/$nwfile.nw | cpif $BIN/getfastadesc.pl ;
is_exec $BIN/getfastadesc.pl ;
@ 

<<getfastadesc.pl>>=
<<PERL shebang>>
# USAGE: $0 chr_list.file fasta_files.dir > chr_seqs.list
# [chr_seqs.list] -> chr_id seq_id date_file description
use strict;
my ($chrlistfile,$ipath) = @ARGV;
$ipath =~ s%/$%%o;
my (@files,%seqs,@order);
%seqs = ();
@order = ();
 #
open(CHR,"< $chrlistfile");
while (<CHR>) {
    my $chr;
    next if /^#/o;
    next if /^\s*$/o;
    next if /^>>\s/o;
    chomp;
    s/^\s*//o;
    ($chr,undef) = split /\s+/og, $_, 2;
    push @order, $chr;
    @{ $seqs{$chr} } = ();
};
close(CHR);

opendir(FA, $ipath);
@files = grep { /\.fa$/ } readdir(FA);
closedir(FA);
# 
# we are going to assume that input filenames
# have the following "chr"$chr"(.*).fa" (so we can assign
# "automagically" which sequence correspond to each chromosome)
#
foreach my $fl (@files) {
    my ($thechr,$modtime);
    ($thechr) = uc($fl) =~ /^CHR([\d]+|[XY]|NA|UL)/o;
    $fl = "$ipath/$fl";
    open(FAF,"< $fl") || do {
        print STDERR "### Cannot open file \"$fl\" for chr \"$thechr\"...\n";
        next;
    };
    print STDERR "### Working on chr \"$thechr\" file: \"$fl\"\n";
    $modtime = &get_fh_mod_date(\*FAF);
    my ($ct,$cc) = (0,".");
    while (<FAF>) {
        my ($id,$desc);
        next unless s/^>//o;
        chomp;
        ($id,$desc) = split /\s+/og, $_, 2;
        defined($desc) || ($desc = ".");
        push @{ $seqs{$thechr} }, [ $id, $modtime, $desc ];
        print STDERR "X";
    } continue {
        $ct++;
        ($ct%10 == 0) && (print STDERR "$cc");
        ($ct%1000 == 0) && (print STDERR " [$ct]\n");
    }; # while <FAF>
    ($ct%1000 != 0) && (print STDERR " [$ct]\n");
    close(FAF);
}; # foreach $fl

foreach my $cs (@order) {
    defined($seqs{$cs}) || do {
        print STDOUT "# No sequences found for chromosome $cs !!!";
        next;
    };
    scalar(@{ $seqs{$cs} }) > 1 && do {
        @{ $seqs{$cs} } = map { $_->[1] }
                          sort { $a->[0] cmp $b->[0] } # ascending alpha sort
                          map { [ $_->[0], $_ ] } @{ $seqs{$cs} };
    };
    foreach my $sq (@{ $seqs{$cs} }) {
        print STDOUT "$cs @{$sq}\n";
    };  # foreach $sq
}; # foreach $cs
#  print STDOUT 

#  print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
#             (sprintf("%12s %12s %8s %8s %10s  %s\n",
#                      "begin","end","#seqs","#errors","rand","file"));
exit(0);

sub get_fh_mod_date() {
    my $fh = shift;
    my ($year,$month,$day,$hour,$min,$sec);
    ($year,$month,$day,$hour,$min,$sec) = 
            (localtime((stat $fh)[9]))[5,4,3,2,1,0];
    # stat ->  [8] is access date,
    #          [9] is modif date and
    #         [10] is inode change date
    return sprintf("%04d%02d%02d%02d%02d%02d",
                   $year + 1900,$month + 1,$day,$hour,$min,$sec);
} # get_fh_mod_date
@ 

\subsubsctn{Scripts: Processing Golden Path annotation}

<<tangling: perl scripts>>=
notangle -R"gp2gff.pl" $WORK/$nwfile.nw | cpif $BIN/gp2gff.pl ;
is_exec $BIN/gp2gff.pl ;
@ 
<<gp2gff.pl>>=
<<PERL shebang>>
# Transforms the goldenpath format to gff file
#   retrieving gene(mrna)/utr/cds coordinates.
#
# USAGE: gp2gff.pl "chrname" "source" goldenpath_file > stdout
#
<<PERL strict pragma + info>>
my $PROG = 'gp2gff.pl';
#
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;

my ($overlap,$exon_ori_fix,$exon_end_fix) = (0,0,0);
$SIG{__WARN__} = sub {
                       print STDERR "### UNKNOWN COMMAND-LINE OPTION: $_[0]\n";
                     };
GetOptions(
           'no-overlap'        => \$overlap,
           'exonori-nuclfix=i' => \$exon_ori_fix,
           'exonend-nuclfix=i' => \$exon_end_fix,
           ) || do {
               print STDERR "### ERROR when PARSING ARGUMENTS\n";
               exit(1);
           };
$SIG{__WARN__} = 'DEFAULT';

my ($seqname,$source,$ifile) = @ARGV;
my $c = 0;
my @exary;
my %laste = ();

open(GPFILE,"< $ifile");
while (<GPFILE>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    $c++ if &process_gene($_);
};
close(GPFILE);
print STDERR "### $c genes for $seqname were found in \"$ifile\".\n";
exit(0);

sub process_gene() {
    my $rec = shift;
    my $maxrec = 10; # refseq record structure
    my ($gene,$seq,$strand,$mrna_ori,$mrna_end,
        $cds_ori,$cds_end,$exons_num,$exons_ori,$exons_end) = (0..($maxrec - 1));
    my (@l,@o,@e,$frame,$cdso,$cdse);
    @l = split /\s+/og, $rec;
    ((scalar(@l) >= $maxrec) && ($l[$seq] eq $seqname)) || return 0;
    @o = split /,/og, $l[$exons_ori];
    @e = split /,/og, $l[$exons_end];
    # fixing displacement at exon coordinates (also at mrna and cds levels)
    $exon_ori_fix == 0 || do {
         $l[$mrna_ori] += $exon_ori_fix;
         $l[$cds_ori]  += $exon_ori_fix;
         @o = map { $_ += $exon_ori_fix } @o;
    };
    $exon_end_fix == 0 || do {
         $l[$mrna_end] += $exon_end_fix;
         $l[$cds_end]  += $exon_end_fix;
         @e = map { $_ += $exon_end_fix } @e;
    };
    #
    ($cdso,$cdse) = @l[$cds_ori,$cds_end];
    # checking if gene overlaps previous one...
    #   (we assume they are sorted by acceptor)
    $overlap && do {
        defined($laste{$l[$strand]}) && do {
            ($laste{$l[$strand]} > $cdso) && return 0;
		};
        $laste{$l[$strand]} = $cdse;
    }; # $overlap
    #
    &prt_gene(@l[$mrna_ori,$mrna_end,$strand,$gene,$exons_num]);
    @exary = ();
    $frame = 0;
    for (my $j = 0; $j < $l[$exons_num]; $j++) {
        my ($ori,$end,$p);
        $p = ($l[$strand] eq '-') ? ($l[$exons_num] - ($j + 1)) : $j;
        ($ori,$end) = ($o[$p],$e[$p]);
        ($end < $cdso || $ori > $cdse) && do {
            &prt_utr($ori,$end,@l[$strand,$gene]);
            next;
        };
        ($ori < $cdso  && $end <= $cdse) && do {
            &prt_utr($ori,($cdso - 1),@l[$strand,$gene]);
            $frame = &prt_exon($cdso,$end,$frame,@l[$strand,$gene],$cdso,$cdse);
            &swap_items(0) if ($l[$strand] eq '-');
            next;
        };
        ($ori >= $cdso && $end > $cdse) && do {
            $frame = &prt_exon($ori,$cdse,$frame,@l[$strand,$gene],$cdso,$cdse);
            &prt_utr(($cdse + 1),$end,@l[$strand,$gene]);
            &swap_items(0) if ($l[$strand] eq '-');
            next;
        };
        ($ori < $cdso  && $end > $cdse) && do {
            &prt_utr($ori,($cdso - 1),@l[$strand,$gene]);
            $frame = &prt_exon($cdso,$cdse,$frame,@l[$strand,$gene],$cdso,$cdse);
            &prt_utr(($cdse + 1),$end,@l[$strand,$gene]);
            &swap_items(1) if ($l[$strand] eq '-');
            next;
        };
        $frame = &prt_exon($ori,$end,$frame,@l[$strand,$gene],$cdso,$cdse);
    };
    ($l[$strand] eq '-') && (@exary = reverse @exary);
    print STDOUT join('',@exary); # each line already has its own linefeed
    return 1;
} # process_gene
# GFF: seqname source feat start end score strand frame group
sub prt_gene() {
    my @data = @_;
    print STDOUT "# Gene: $data[3]   Strand: $data[2]   Exons: $data[4]\n";
    print STDOUT join("\t",$seqname,$source,"mrna",@data[0,1],
                      ".",$data[2],".",$data[3])."\n";
} # prt_gene
sub prt_utr() {
    my @data = @_;
    push @exary, join("\t",$seqname,$source,"utr",@data[0,1],
                      ".",$data[2],".",$data[3])."\n";
} # prt_utr
sub prt_exon() {
    my ($eo,$ee,$frm,$str,$grp,$co,$ce) = @_;
    my $feat;
#     my ($myfrm,$feat);
    # remainder = ((exon_end - exon_ori + 1) + frame) mod 3;
    # nextframe = (3 - ((exon_end - exon_ori + 1) + frame) mod 3) mod3;
#   $myfrm = ($str eq '-') # exon frame is set to remainder for - strand
#            ? ( (($ee - $eo + 1) + $frm) % 3 )
#            : $frm;
    $feat = &get_feat($eo,$ee,$str,$co,$ce);
#   $feat =~ /Single/io && ($myfrm = 0); # single frame hack (specially for -)
    push @exary, join("\t",$seqname,$source,$feat,$eo,$ee,
                      ".",$str,$frm,$grp)."\n";
#                       ".",$str,$myfrm,$grp)."\n";
    return ( (3 - (($ee - $eo + 1) + $frm) % 3 ) % 3 ); # return nextframe
} # prt_exon
# gene structure GFF-feature names
sub get_feat() {
    my ($eo,$ee,$str,$co,$ce) = @_;
    my ($fts,$fto,$fti,$fte);
    ($fts,$fto,$fti,$fte) = ("Single","First","Internal","Terminal");
    $str eq "-" && do {
        ($fto,$fte) = ($fte,$fto);
    };
    ($eo == $co && $ee == $ce) && return $fts;
    ($eo == $co) && return $fto;
    ($ee == $ce) && return $fte;
    return $fti;
} # get_feat
sub swap_items() {
     shift || do {
         ($exary[$#exary],$exary[$#exary-1]) =
             ($exary[$#exary-1],$exary[$#exary]);
         return;
     };
     ($exary[$#exary],$exary[$#exary-1],$exary[$#exary-2]) =
         ($exary[$#exary-2],$exary[$#exary-1],$exary[$#exary]);
     return;
} # swap_items
@ 


\subsctn{Sequence analysis: \textit{H.sapiens}}

<<HIDE: >>=
#
# NOT filtering overlapping genes (gp2gff '--no-overlap' option)...
#
### 679 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/ensGene.txt".
### 816 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/genscan.txt".
### 343 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/refGene.txt".
#
# Filtering overlapping genes (gp2gff '--no-overlap' option)...
#
### 575 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/ensGene.txt".
### 816 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/genscan.txt".
### 318 genes for chr22 were found in 
    "/seq/genomes/H.sapiens/golden_path_20010806/database/refGene.txt".
@ 

\subsubsctn{Retrieving annotations from Golden Path}

<<Sequence: H.sapiens>>=
#
# 
#
IDIR="$HSAP/database" ;
ODIR="$HUMUS/$CHR/annotation/$HSAPID" ;
#
CheckDirs $ODIR $ODIR/refseq $ODIR/genscan $ODIR/ensembl $ODIR/gaps $ODIR/repeats ;
#
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $CHR refseq $IDIR/refGene.txt \
                 > $ODIR/refseq/$CHR.fullgff \
                2> $ODIR/refseq.report       ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
     $ODIR/refseq/$CHR.fullgff > $ODIR/refseq/$CHR.gff ;
#
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
               $CHR ensembl $IDIR/ensGene.txt \
                 > $ODIR/ensembl/$CHR.fullgff \
                2> $ODIR/ensembl.report       ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
     $ODIR/ensembl/$CHR.fullgff > $ODIR/ensembl/$CHR.gff ;
#
@ 

\chklst{
\item Annotations for {\refseq} and {\ens} genes.
}


\subsubsctn{Preparing annotation files for evaluation}

<<Sequence: >>=
#
# TO BE redefined................ include frame0-mapping too
function pre_eval {
  gawk 'BEGIN{
          src = ARGV[1]; len = ARGV[2]; ARGV[1] = ARGV[2] = ""; 
          print "chr22\t"src"\tsequence\t1\t"len"\t.\t.\t."
       }' $n $lenaug > $TDIR/${HSAPIDaug}_seqlength.gff ;
  sort +3n -5 $TDIR/${HSAPIDaug}_$n.gff > $TDIR/${HSAPIDaug}.tmp ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  gawk '$7 == "+" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_fwd.gff ;
  cat $TDIR/${HSAPIDaug}_seqlength.gff > $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  gawk '$7 == "-" {print $0}' $TDIR/${HSAPIDaug}.tmp \
                           >> $TDIR/${HSAPIDaug}_${n}_rev.gff ;
  /bin/rm -v $TDIR/${HSAPIDaug}.tmp ;
} ;
#
@ 

\chklst{
\item Evaluation files for {\refseq} and {\ens} genes: SR projection of features when mapping all frames to 0, and forward/reverse selection of non-overlapping genes.
}


\subsubsctn{Retrieving gene prediction results from Golden Path ({\gnsc})}

<<Sequence: H.sapiens>>=
#
# 
#
IDIR="$HSAP/database" ;
ODIR="$HUMUS/$CHR/annotation/$HSAPID/genscan" ;
#
$BIN/gp2gff.pl --no-overlap --exonori-nuclfix 1 -- \
       $CHR genscan $IDIR/genscan.txt \
                 > $ODIR/$CHR.fullgff \
                2> $ODIR.report       ;
gawk '$3~/^(Single|First|Internal|Terminal)$/ {print $0}' \
     $ODIR/$CHR.fullgff > $ODIR/$CHR.gff ;
#
@ 

\chklst{
\item Annotations for {\gnsc} genes.
}


\subsubsctn{Evaluating {\gnsc} results from Golden Path versus annotation}

<<Sequence: H.sapiens>>=
#
# Evaluation of genscan results
#
SDIR="$HSAP/database" ;
IDIR="$HUMUS/$CHR/annotation/$HSAPID/genscan" ;
ODIR="$HUMUS/$CHR/annotation/$HSAPID/genscan" ;
#
# run_evaluation #chrom program param prog_results_dir \
#                annotation_dir   testset   lenght_file
run_evaluation   $CHR "genscan" $XID $IDIR $SDIR "refseq" $LFILE;
#
@

\chklst{
\item Evaluation records (extended and brief) for each seq and for each chromosome.
\item ...
}


\subsctn{Sequence analysis: \textit{M.musculus}}

<<Sequence: M.musculus>>=
#
# 
#
MMUS="/seq/genomes/M.musculus/sanger_phusion_20011109" ;
ODIR="" ;
#
#

@ 

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Masking sequences} %%%%%%%%%%%%%%%%%%%%%%

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
    \item Human genome assembly from UCSC Golden Path August release (20010806).
    \item Pankaj run {\rptm} with the following parameters:\\[-3ex]
\begin{small}
\begin{verbatim}
###
I used the masked sequence from UCSC and masked it again. I used -s
"slow" option. We actually used RepeatBlaster and not Repeatmasker. RB
is faster version of RM that uses Blast instead of crossmatch.
\end{verbatim}
\end{small}
   \end{itemize}
  \end{minipage}
% } % fbox
\end{center}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Processing {\tbx} results} %%%%%%%%%%%%%%%%%%%%%%

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
 \item Process {\tbx} results from Pankaj:
  \begin{itemize}
   \item Human genome assembly from UCSC Golden Path August release (20010806).
   \item Mouse genome assembly from Sanger Center Phusion assembly (20011109).\\[-3ex]
\begin{verbatim}
# Database:  /bioinfo/gapdb/blastdb/MusPhusion
# Title:  MusPhusion
# # of letters in database:  2,374,690,634  (Z = 3000000000)
# # of sequences in database:  431,480
# Format:  XDF-1
# Created:  5:32:13 PM EST Dec 10, 2001
# Posted:  5:32:14 PM EST Dec 10, 2001
\end{verbatim}
   \item {\tbx} was run with the following parameters:\\[-3ex]
%	   \begin{center}
%	   \begin{minipage}[c]{0.75\linewidth}
\begin{verbatim}
W=5  Z=3000000000
matrix=blosum62mod  filter=xnu+seg
nogaps  hspmax=500  topcomboN=100
B=9000  V=9000  E=0.01  E2=0.01  S2=80
warnings  cpus=4  ctxfactor=36.0
\end{verbatim}
% tail -54 ori/chr22_* | sort | uniq -c | sort +0nr | more
%	   \end{minipage}
%	   \end{center}
  \end{itemize}
\item Get HSPs $\Rightarrow$ SRs $\Rightarrow$ HSP-SRs
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}


\subsctn{Initialization} %%%%%%%%%%%%%%%%%%%%%%

\subsubsctn{Scripts: Verifying SBP {\tbx} output for chromosome fragments}

<<tangling: perl scripts>>=
notangle -R"sbp-checkblastout.pl" $WORK/$nwfile.nw | \
     cpif $BIN/sbp_checkblastout.pl ;
is_exec $BIN/sbp_checkblastout.pl ;
@ 
<<sbp-checkblastout.pl>>=
<<PERL shebang>>
# Parsing tblastx files from SBP to check blast output
#   contents for each fragment of the broken chromosomic sequence
#
# USAGE: sbp_checkblastout.pl "chrname" input_dir > stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'sbp_checkblastout.pl';
#
my $chr = shift @ARGV;
my $path = shift @ARGV;
my @files = ();
my ($c,$e,$z);
opendir(TBX, $path);
@files = map { [ $_ ,
                 /^.*_(\d+)_(\d+)(?:\..*)?$/o,
                 (/^.*_(\D+)_.*$/o || "-"),
               ] } 
         grep { /^[^\.]/ } readdir(TBX);
closedir(TBX);
@files = map { $_->[1] }
         sort { $a->[0] <=> $b->[0] }
         map { [ $_[0], $_ ] } @files;
print STDOUT "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
             (sprintf("%12s %12s %8s %8s %10s  %s\n",
                      "begin","end","#seqs","#errors","rand","file"));
$z = 0;
foreach my $fl (@files) {
    ($c,$e) = (0,0);
    my $fname = "$path/$fl->[0]";
    print STDERR "# Working on $fname\n";
    open(TBXFL,"< $fname");
    while (<TBXFL>) {
        /^>/o   && ($c++,next);
        /EXIT/o && ($e++);
    }; # while
    $c == 0 && ($z++);
    close(TBXFL);
    printf STDOUT "  %12s %12s %8s %8s %10s  %s\n",
           ($fl->[1] + 1),($fl->[1] + $fl->[2]),$c,$e,$fl->[3],$fl->[0];
}; # foreach
print STDOUT "# $chr ran into ".(scalar @files).
             " fragments, $z of which having NO HSPs.\n";
#
exit(0);
@ 

\subsubsctn{Scripts: Parsing SBP {\tbx} output to GFF}

<<tangling: perl scripts>>=
notangle -R"sbp-blast2gff.pl" $WORK/$nwfile.nw | \
     cpif $BIN/sbp_blast2gff.pl ;
is_exec $BIN/sbp_blast2gff.pl ;
@ 
<<sbp-blast2gff.pl>>=
<<PERL shebang>>
# Parsing tblastx files from SBP to get HSPs in GFF format
#
# USAGE: sbp_blast2gff.pl "chrname" length_file input_dir \
#                          > gff_output  2> stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'sbp_blast2gff.pl';
#
my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
my @frame = ( 3, 1, 2 ); # frm 0 -> blastfrm 3
                         # frm 1 -> blastfrm 1
                         # frm 2 -> blastfrm 2
my %SEQlen;
my ($chr, $seqln, $input) = @ARGV;
my @files = ();
my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
          "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                     "all" => 8,            "sum" => [ (0) x 9 ] );
my ($cf,$cr);
open(FRGLEN, "< $seqln");
while (<FRGLEN>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    my @l = split /\s+/og, $_;
    $SEQlen{$l[0]} = $l[1];
}; # while
close(FRGLEN);
open(FRGLST, "< $input.report");
while (<FRGLST>) {
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    s/^\s*//o;
    my @l = split /\s+/og, $_;
    ($l[2] > 0) && do {
        push @files, [ $l[$#l], ($l[0] - 1) ];
    };
    # skipping fragments without HSPs
}; # while
close(FRGLST);
#
print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
             (sprintf("%8s %8s %8s  %s\n","#hsp","#hsp(+)","#hsp(-)","file"));
system("/bin/rm","$input.parseblast.err");
foreach my $fl (@files) {
    $cf = $cr = 0;
    my ($fname,$offset) = ("$input/$fl->[0]", $fl->[1]);
    open(TBXFL, "parseblast --fullgff --full-scores --comments".
                " --verbose --bit-score $fname 2>> $input.parseblast.err |");
    my @l;
    while (<TBXFL>) {
        next if /^\s*$/o;
        /^#/o && do {
            print STDOUT $_;
            next;
        };
        chomp;
        @l = split /\s+/og, $_, 9;
        $l[$seq] = $chr;
        $l[$src] = "tblastx";
        $l[$ftr] = "hsp";
        $l[$ori] += $offset;
        $l[$end] += $offset;
        if ($l[$str] eq "-") {
            $l[$frm] = $frame[(($SEQlen{$chr} - $l[$end] + 1) % 3)];
            $cr++;
        } else {
            $l[$frm] = $frame[($l[$ori] % 3)];
            $cf++;
        };
        print STDOUT join("\t", @l)."\n";
        $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
    }; # while
    close(TBXFL);
    printf STDERR "  %8s %8s %8s  %s\n",($cf+$cr),$cf,$cr,$fl->[0];
}; # foreach
$g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
$g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
$g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
             $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
   printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
}; # foreach
#
exit(0);
@

\subsctn{Unpacking {\tbx} results obtained by Pankaj}

<<Homology: >>=
#
# Unpacking TBLASTX results obtained by Pankaj
#
IDIR="$HUMUS/.ftp/PankajAgarwal/20020111.tbxPhusion" ;
ODIR="$HUMUS/$CHR/tblastx/$XID" ;
#
CheckDirs $ODIR $ODIR/ori ;
#
mv -v $IDIR/${CHR}* $ODIR/ori ;
#
$BIN/sbp_checkblastout.pl $CHR $ODIR/ori > $ODIR/ori.report ;
#
@ 

\chklst{
\item get number of sequences from DB matching each chromosome fragment.
\item do the regions without HSPs correspond to N regions at original sequences (being gaps or masked) ? (maybe using [[evaluation]])
}

\subsctn{Retrieving {\tbx} results by chromosome}

\begin{figure}[!t]
\begin{center}
 \input psfigures/blast_frames.tex
\end{center}
\end{figure}

We had to deal with the frame issue of the HSPs fragments; once the HSP coords were mapped to the chromosome, frames also must be recomputed taking into account if HSP was in forward or in reverse strand (see figure~\ref{fig:blastframes}).

<<Homology: >>=
#
# Retrieving TBLASTX results by chromosome
#
IDIR="$HUMUS/$CHR/tblastx/$XID/ori" ;
ODIR="$HUMUS/$CHR/tblastx/$XID/hsp" ;
SDIR="$HUMUS/$CHR/annotation" ;
#
CheckDirs $ODIR ;
#
$BIN/sbp_blast2gff.pl $CHR $SDIR/$HSAPID/length $IDIR \
         > $ODIR/$CHR.fullgff 2> $ODIR.report ;
#
perl -ne '/^#/o && next; /^\s+$/o && next; 
          $_ =~ s/;\s+Strand//o; 
          $_ =~ s/;\s+Frame//o; 
          $_ =~ s/;\s+E_value.*$//o;
          print STDOUT $_;' $ODIR/$CHR.fullgff | \
          sort +3n -6 +6 -7 - > $ODIR/$CHR.gff ;
#
@ 

\chklst{
\item find number of HSPs per fragment and total per chromosome.
}

\subsubsctn{Projecting HSPs into SRs}

<<Homology: >>=
#
# Projecting HSPs into SRs
#
IDIR="$HUMUS/$CHR/tblastx/$XID/hsp" ;
ODIR="$HUMUS/$CHR/tblastx/$XID/sr" ;
#
CheckDirs $ODIR ;
#
BLAST2GFF="/projects/bin/blast2gff";
$BLAST2GFF -g $IDIR/$CHR.gff > $ODIR/$CHR.gff ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $CHR $ODIR/$CHR.gff > $ODIR.report ;
#
@

\chklst{
\item Get SRs number for each sequence.
\item ...
}

\subsubsctn{Evaluating SRs versus annotation}

<<Homology: >>=
#
# Evaluation of SRs
#
IDIR="$HUMUS/$CHR/tblastx/$XID/sr" ;
ODIR="$HUMUS/$CHR/tblastx/$XID" ;
#
@

\chklst{
\item Evaluation records (extended and brief) for each seq and for each chromosome.
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Gene Prediction} %%%%%%%%%%%%%%%%%%%%%%

\subsctn{Initialization}

\subsubsctn{Scripts: Running evaluation for gene-prediction}

<<tangling: perl scripts>>=
notangle -R"runeval.pl" $WORK/$nwfile.nw | cpif $BIN/runeval.pl ;
is_exec $BIN/runeval.pl ;
@ 
<<runeval.pl>>=
<<PERL shebang>>
# Running evaluation by chromosome.
#
# USAGE: runeval.pl chromosome 
#
<<PERL strict pragma + info>>
my $PROG = 'runeval.pl';
#

#
## MAIN
open(FSHRT,"> ");
open(FLONG,"> ");

&print_file_header(\*FSHRT,);
&print_file_header(\*FLONG,);
exit(0);

#
## SUBS
sub print_file_header() {
    my ($fh,$prog,$chr,$run,$outname,$gver) = ;
    print $fh <<"EOTXT";
### 
### EVALUATION of $prog RESULTS on CHR $chr ($run)
###
### $outname
###
### $USER - $DATE 
###
### $gver
###
EOTXT
} # print_file_header
@ 


\subsubsctn{Scripts: Re-scoring SRs}

<<tangling: perl scripts>>=
notangle -R"getHSPSR.pl" $WORK/$nwfile.nw | cpif $BIN/getHSPSR.pl ;
is_exec $BIN/getHSPSR.pl ;
@ 
<<getHSPSR.pl>>=
<<PERL shebang>>
# Re-scoring SRs to produce HSP-SRs for SGP homology.
#
# USAGE: getHSPSR.pl "chrname" < SR_file.gff > HSP-SR_file.gff > stdout.report
#
<<PERL strict pragma + info>>
my $PROG = 'getHSPSR.pl';
#
my $chr = shift;
my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
          "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                     "all" => 8,            "sum" => [ (0) x 9 ] );
my $HSPminLEN = 1; # $ori + $HSPminLEN - 1 ==> minimum length is 1 nucleotide
my $S_CUTOFF = 26;
my $SCF = 0; # substract to tblastx scores S_CUTOFF - SCF
my $DSC = $S_CUTOFF - $SCF;
my $SHSP  = 0;    # SHSP=6 # shrink hsp by $SHSP
my $WTBX  = 0.19; # weigth of tblastx score
my $WTBXF = 0.30; # weigth of tblastx score
my $WTBXI = 0.20; # weigth of tblastx score
my $WTBXT = 0.30; # weigth of tblastx score
while (<STDIN>) {
    my @l;
    next if /^#/o;
    next if /^\s*$/o;
    chomp;
    @l = split /\s+/og, $_;
    next unless $l[$sco] > $S_CUTOFF;
    $l[$sco] = ($l[$sco] - $DSC) * $WTBX;
    $l[$ori] += $SHSP;
    $l[$end] -= $SHSP;
    next if $l[$end] < ($l[$ori] + $HSPminLEN - 1);
    print STDOUT join("\t",@l)."\n";
    $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
}; # while
$g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
$g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
$g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
             $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
   printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
}; # foreach
#
exit(0);
@


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Gene Prediction: {\gnid}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Run {\gnid} without homology, then evaluate results.
\item Remember to run [[/projects/sgp/src/geneid_v1.1]] 
\item ...
}

<<GENEID: >>=
#
# Initialization
# 
ODIR="$HUMUS/$CHR/geneid/$XID" ;
#
CheckDirs $ODIR ;
for c in hsp-sr out gff gtf2 cds prot logs tmp ;
    do { CheckDirs $ODIR/$c ; } ; done ;
#
@

\subsubsctn{Running {\gnid} (without homology)}


<<GENEID: >>=
#
# Running geneid without homology
#
GNID="/projects/sgp/src/geneid_v1.1" ;
     # binaries, scripts and params in SGP2
GENEID="$GNID/bin/geneid" ; # geneid v1.1
PARAM="$GNID/param/human3iso.param" ;
EW=0 ; # add to exon weigth
#
# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$CHR.fa.masked" ; 
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$CHR.fa" ;
IDIR="$HUMUS/$CHR/geneid/$XID/" ;
# ODIR="$HUMUS/$CHR/geneid/$XID/out" ;
#
# {
  { $GENEID -v -DE $EW -P $PARAM $ISEQ | grep -v evidence \
        > $IDIR/out/$CHR ;
  } 2> $IDIR/logs/$CHR ;
#   } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\gnid} (without homology)}

<<GENEID: >>=
#
# Processing geneid format from geneid output (without homology)
#
IDIR="$HUMUS/$CHR/geneid/$XID" ;
#
geneid_raw2GFF $IDIR $IDIR/out/$CHR ;
#
ls -1 $IDIR/gff/ | egrep "^$CHR" | \
  while read n;
    do {
         cat $IDIR/gff/$n;
       };
    done | sort +3n +4n -5 - > $IDIR/gff/$CHR ;
#
get_geneid_genes $IDIR/gff/$CHR > $IDIR/out.gene_list ;
#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\gnid} predictions (without homology)}

<<GENEID: >>=
#
# Evaluation of geneid predictions (without homology)
#
IDIR="$HUMUS/$CHR/geneid/$XID" ;
#
# run_evaluation #chrom program param       prog_results_dir \
#                annotation_dir           testset  lenght
run_evaluation   $CHR   geneid  $XID \
   $ANALYSIS/geneid $DATASETS/annotation/set/pseudo VH_pseudo 47662662;
#
@

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsctn{Gene Prediction: {\sgp}} %%%%%%%%%%%%%%%%%%%%%%

\whtlst{
\item Re-score similarity regions: SRs to HSP-SRs.
\item Initialize any auxiliarly file (like those [[*.termini]]).
\item Run {\sgp} with homology, then evaluate results.
\item Run {\sgp} with homology plus evidences, then evaluate results.
}

<<SGP: >>=
#
# Initialization
# 
ODIR="$HUMUS/$CHR/sgp/$XID" ;
#
CheckDirs $ODIR ;
for c in hsp-sr out gff gtf2 cds prot logs tmp ;
    do { ChckDirs $ODIR/$c ; } ; done ;
#
@

\subsubsctn{Re-scoring SRs}

<<SGP: >>=
#
# Re-scoring SRs to produce HSP-SRs
#
IDIR="$HUMUS/$CHR/tblastx/$XID/sr" ;
ODIR="$HUMUS/$CHR/sgp/$XID/hsp-sr" ;
#
$BIN/getHSPSR.pl $CHR < $IDIR/$CHR.gff > $ODIR/$CHR.gff 2> $ODIR.report ;
#
@
%$

\chklst{
\item ...
}

\subsubsctn{Preparing auxiliarly files}

<<SGP: >>=
#
# Preparing auxiliarly files: CHR.termini
#
ODIR="$HUMUS/$CHR/sgp/$XID/tmp" ;
SDIR="$HUMUS/$CHR/annotation/$HSAPID" ;
#
perl -e '
  use strict;
  my $chr = shift @ARGV;
  my %SEQlen;
  my $seqln = shift @ARGV;
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  print STDOUT join("\t", $chr, qw/ force cap  -2  0 . + 0 / )."\n";
  print STDOUT join("\t", $chr, qw/ force poly /,
                        ($SEQlen{$chr} - 1) x 2, qw/ . + 0/ )."\n";
' $CHR $SDIR/length > $ODIR/$CHR.termini ;
#
@
%$

\chklst{
\item ...
}

\subsubsctn{Running {\sgp} ({\gnid} with homology)}

<<SGP: >>=
#
# Running geneid with homology
#
SGP2="/projects/sgp/src/geneid_v1.1-sgp" ;
     # binaries, scripts and params in SGP2
GENEID="$SGP2/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SGP2/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$CHR.fa.masked" ; 
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$CHR.fa" ;
IDIR="$HUMUS/$CHR/sgp/$XID/" ;
# ODIR="$HUMUS/$CHR/sgp/$XID/out" ;
HOMOLOGY="$HUMUS/$CHR/sgp/$XID/hsp-sr/$CHR.gff" ;
#
# {
  { $GENEID -v -DE $EW -P $PARAM -S $HOMOLOGY \
        -R $IDIR/tmp/$CHR.termini $ISEQ | grep -v evidence \
        > $IDIR/out/$CHR ;
  } 2> $IDIR/logs/$CHR ;
#   } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@ 

\chklst{
\item ...
}

\subsubsctn{Processing output for {\sgp} (with homology)}

<<SGP: >>=
#
# Processing geneid format from sgp output (with homology)
#
IDIR="$HUMUS/$CHR/sgp/$XID" ;
#
geneid_raw2GFF $IDIR $IDIR/out/$CHR ;
#
ls -1 $IDIR/gff/ | egrep "^$CHR" | \
  while read n;
    do {
         cat $IDIR/gff/$n;
       };
    done | sort +3n +4n -5 - > $IDIR/gff/$CHR ;
#
get_geneid_genes $IDIR/gff/$CHR > $IDIR/out.gene_list ;
#
@
%$

\chklst{
\item Number of genes, average length, average exon number, exon/intron length ratio...
\item ...
}

\subsubsctn{Evaluation of {\sgp} predictions (with homology)}

<<SGP: >>=
#
# Evaluation of SGP predictions (with homology)
#
IDIR="$HUMUS/$CHR/sgp/$XID" ;
#
#
@

\chklst{
\item ...
}

\subsubsctn{Running {\sgp} with homology and evidences}

<<SGP: >>=
#
#  Running geneid with homology + evidences
#
SGP2="/projects/sgp/src/geneid_v1.1-sgp" ;
     # binaries, scripts and params in SGP2
GENEID="$SGP2/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SGP2/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
ISEQ="$HSAP/chromFaMasked/$CHRNUM/$CHR.fa.masked" ;
IDIR="$HUMUS/$CHR/sgp/$XID/" ;
# ODIR="$HUMUS/$CHR/sgp/$XID/out" ;
HOMOLOGY="$HUMUS/$CHR/sgp/$XID/hsp-sr/$CHR.gff" ;
EVIDENCES="/$CHR.gff" ;
#
{ $GENEID -v -D -E $EW -P $PARAM -S $HOMOLOGY \
        -R $EVIDENCES $ISEQ > $IDIR/out/$CHR ;
  } 2> $IDIR/logs/$CHR ;
#  } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@

\chklst{
\item ...
}


\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Masking gene-predictions along masked sequences}

<<Global: >>=
#
#
# HUMUS="$BASE/H.sapiens" -> .project_VARS
#
CHRLIST="22" ;
#
for n in $CHRLIST;
  do {
       chrdir="$HUMUS/chr$n" ;
       CheckDirs $chrdir ;
       CheckDirs $chrdir/tblastx+ $chrdir/sgp+ ;
     };
  done ;
#
CHRNUM="22" ; # length -> 47748585
CHR="chr$CHRNUM" ;
XID="20020212";
#
@

<<>>=
# bash
# CLEAR, RESET, CONCEALED,
# BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE,
# BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, 
# ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE 
#
function show_masked {
    perl -npe '
        use Term::ANSIColor;
        s/^(>.*?)(\s+.*)$/color("bold red").$1.color("reset").$2/oe;
        # masked
        s/(N+)/color("green").$1.color("reset")/oge;
        s/(n+)/color("yellow").$1.color("reset")/oge;
        # starts
        s/(ATG)/color("black on_green").$1.color("reset")/oge; # forward
        s/(CAT)/color("white on_green").$1.color("reset")/oge; # reverse
        # stops
        s/(TAA|TAG|TGA)/color("black on_red").$1.color("reset")/oge; # forward
        s/(TTA|CTA|TCA)/color("white on_red").$1.color("reset")/oge; # reverse
    ' "$@" | more
}
#
@ 

\subsctn{Masking cds on Pankaj masked sequence fragments}

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
    \item Mask CDSs predicted by {\sgp} on the sequence fragmetns already masked by Pankaj.
   \end{itemize}
  \end{minipage}
% } % fbox
\end{center}

<<>>=
perl -e '
  use strict;
  my ($base,$ipath,$opath,$gnlst,@files,
      %offset,%cds,%genes,$n,$totgns,$totcds,$tgenes,$tcds);
  my $chr = shift @ARGV;
  $base = "/projects/H.sapiens";
  $ipath = "$base/.ftp/PankajAgarwal/20020123.seq-masked";
  $opath = "$base/.ftp/PankajAgarwal/20020208.seq-masked+genes-masked";
  my $gff = "$base/$chr/sgp/20020122/gff/$chr";
  # $gnlst = "$base/$chr/sgp/20020122/out.gene_list";
  # getting input filenames
  opendir(NA,$ipath);
  @files = grep { /^$chr/ } readdir(NA);
  closedir(NA);
  print STDERR "## Found ".scalar(@files)." input files for $chr...\n";
  # get sequence starting coord offset
  foreach my $fl (@files) {
      $fl =~ /_(\d+)_\d+$/o && ($offset{$1} = $fl);
  };
 #
  # reading gene coords
  # open(GF,"< $gnlst");
  # $n = 0;
  # while (<GF>) {
  #     my @l;
  #     next if /^#/o;
  #     next if /^\s*$/o;
  #     chomp;
  #     @l = split /\s+/og, $_, 5;
  #     $genes{$n++} = [ @l[1,2],"$l[0]$l[3]" ];
  # };
  # close(GF);
  # $tgenes = $n;
  # print STDERR "## Found $tgenes genes to mask on $chr...\n";
 #
  # reading from GFF
  open(GFF,"< $gff");
  $n = 0;
  %genes = ();
  while (<GFF>) {
      my @l;
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      @l = split /\s+/og, $_;
      $cds{$n++} = [ @l[3,4],"$l[8]$l[6]" ];
      $genes{"$l[8]$l[6]"}++;
  };  
  close(GFF);
  $tgenes = scalar (keys %genes);
  $tcds   = $n;
  print STDERR "## Found $tgenes genes ($tcds cds) to mask on $chr...\n";
  # processing fastas
  $totgns = $totcds = 0;
  foreach my $fl (sort keys %offset) {
      my ($sqn,$fstg,$fcds);
      open(FI,"< $ipath/$offset{$fl}");
      open(FO,"> $opath/$offset{$fl}.cds");
      $sqn = $fl;
      $n = $fstg = $fcds = 0;
      %genes = ();
      while ($cds{$n}[1] <= $fl) { $n++; }; # if gene ends before sequence ori
      while (<FI>) {
          my (@l,$ln);
          next if /^\s*$/o;
          /^>/o && do {
              print FO $_;
              next;
          };
          chomp;
          s/\s*$//o; s/^\s*//o;
          @l = split //, uc($_);
          $ln = "";
          for (my $i = 0; $i <= $#l; $i++) {
              $sqn++;
              $ln .= ($sqn >= $cds{$n}[0] && $sqn <= $cds{$n}[1]) 
                     ? "n" : $l[$i] ;
              ($sqn == $cds{$n}[0]) && ($fcds++);
              ($sqn == $cds{$n}[1]) && ($n++, $genes{$cds{$n}[2]}++);
          }; 
          print FO "$ln\n";
      };
      close(FO);
      close(FI);
      $fstg = scalar (keys %genes);
      print STDERR "### $fstg genes ($fcds cds) were masked on \"$offset{$fl}\"...\n";
      # $totgns += $fstg;
      $totgns += $fstg;
      $totcds += $fcds;
  };
  print STDERR "### $totgns of $tgenes genes ($totcds of $tcds cds) were masked on $chr...\n";
  # counter sums are not well done... but masking is ok
' chr22 2> ./masking_cds.log ; # 2> ./masking_genes.log ;
@ 


\subsctn{Processing Pankaj {\tbx} results}

\begin{center}
% \fbox{
  \begin{minipage}{0.95\linewidth}
   \textbf{What to do here:}
   \begin{itemize}
 \item Process {\tbx} results from Pankaj:
  \begin{itemize}
   \item Masked sequences plus {\sgp} predicted cds also masked (20020208).
   \item Mouse genome assembly from Sanger Center Phusion assembly (20011109 ???).\\[-3ex]
\begin{verbatim}
# Database:  /bioinfo/gapdb/blastdb/MusPhusion
# Title:  MusPhusion
# # of letters in database:  2,374,690,634  (Z = 3000000000)
# # of sequences in database:  431,480
# Format:  XDF-1
# Created:  5:32:13 PM EST Dec 10, 2001
# Posted:  5:32:14 PM EST Dec 10, 2001
\end{verbatim}
   \item {\tbx} was run with the following parameters:\\[-3ex]
%	   \begin{center}
%	   \begin{minipage}[c]{0.75\linewidth}
\begin{verbatim}
W=5  Z=3000000000
matrix=blosum62mod  filter=xnu+seg
nogaps  hspmax=500  topcomboN=100
B=9000  V=9000  E=0.01  E2=0.01  S2=80
warnings  cpus=4  ctxfactor=36.0
\end{verbatim}
% tail -54 ori/chr22_* | sort | uniq -c | sort +0nr | more
%	   \end{minipage}
%	   \end{center}
  \end{itemize}
\item Get HSPs $\Rightarrow$ SRs $\Rightarrow$ HSP-SRs
   \end{itemize}
  \end{minipage}
% } % fbox
 \end{center}

<<Homology: >>=
#
# Unpacking TBLASTX results obtained by Pankaj
#
IDIR="$HUMUS/.ftp/PankajAgarwal/20020212.genes-masked+tbxPhusion" ;
ODIR="$HUMUS/$CHR/tblastx+/$XID" ;
#
CheckDirs $ODIR $ODIR/ori ;
#
mv -v $IDIR/${CHR}* $ODIR/ori ;
#
$BIN/sbp_checkblastout.pl $CHR $ODIR/ori > $ODIR/ori.report ;
#
@ 

\subsctn{Retrieving {\tbx} results by chromosome}

<<Homology: >>=
#
# Retrieving TBLASTX results by chromosome
#
IDIR="$HUMUS/$CHR/tblastx+/$XID/ori" ;
ODIR="$HUMUS/$CHR/tblastx+/$XID/hsp" ;
SDIR="$HUMUS/$CHR/annotation" ;
#
CheckDirs $ODIR ;
#
$BIN/sbp_blast2gff.pl $CHR $SDIR/$HSAPID/length $IDIR \
         > $ODIR/$CHR.fullgff 2> $ODIR.report ;
#
perl -ne '/^#/o && next; /^\s+$/o && next; 
          $_ =~ s/;\s+Strand//o; 
          $_ =~ s/;\s+Frame//o; 
          $_ =~ s/;\s+E_value.*$//o;
          print STDOUT $_;' $ODIR/$CHR.fullgff | \
          sort +3n -6 +6 -7 - > $ODIR/$CHR.gff ;
#
@ 

\subsubsctn{Merging HSPs from first {\tbx} run and the new ones}

<<Homology: >>=
#
# Merging TBLASTX results 
PXID="20020122" ; # XID of the tblastx run we want to merge (default PXID==XID)
IDIR="$HUMUS/$CHR/tblastx/$PXID/hsp" ;
ODIR="$HUMUS/$CHR/tblastx+/$XID/hsp" ;
#
cat $IDIR/$CHR.gff $ODIR/$CHR.gff |  \
          sort +3n -6 +6 -7 - > $ODIR/$CHR.merged.gff ;
#
@ 

\subsubsctn{Projecting HSPs into SRs}

<<Homology: >>=
#
# Projecting HSPs into SRs
#
IDIR="$HUMUS/$CHR/tblastx+/$XID/hsp" ;
ODIR="$HUMUS/$CHR/tblastx+/$XID/sr" ;
#
CheckDirs $ODIR ;
#
BLAST2GFF="/projects/bin/blast2gff";
$BLAST2GFF -g $IDIR/$CHR.gff > $ODIR/$CHR.gff ;
$BLAST2GFF -g $IDIR/$CHR.merged.gff > $ODIR/$CHR.merged.gff ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $CHR $ODIR/$CHR.gff > $ODIR.report ;
#
gawk '
  BEGIN{ chr=ARGV[1]; ARGV[1]=""; }
  $1 !~ /^#/ { a[$7.$8]++; b[$7]++ }
  END{ 
    printf "# TOTAL %s SRs on %s: %s forward, %s reverse.\n", 
           b["+"]+b["-"], chr, b["+"], b["-"];
    for (i in a) {
      printf "#  \t%s : %s\n", i, a[i];
    };
  }
' $CHR $ODIR/$CHR.merged.gff > $ODIR.merged.report ;
#
@

\subsctn{Gene Prediction: {\sgp}} %%%%%%%%%%%%%%%%%%%%%%

<<SGP: >>=
#
# Initialization
# 
ODIR="$HUMUS/$CHR/sgp+/$XID" ;
#
CheckDirs $ODIR ;
for c in hsp-sr out gff gtf2 cds prot logs tmp ;
    do { CheckDirs $ODIR/$c ; } ; done ;
#
@

\subsubsctn{Re-scoring SRs}

<<SGP: >>=
#
# Re-scoring SRs to produce HSP-SRs
#
IDIR="$HUMUS/$CHR/tblastx+/$XID/sr" ;
ODIR="$HUMUS/$CHR/sgp+/$XID/hsp-sr" ;
#
$BIN/getHSPSR.pl $CHR < $IDIR/$CHR.merged.gff \
                      > $ODIR/$CHR.gff 2> $ODIR.report ;
#
@

\subsubsctn{Preparing auxiliarly files}

<<SGP: >>=
#
# Preparing auxiliarly files: CHR.termini
#
ODIR="$HUMUS/$CHR/sgp+/$XID/tmp" ;
SDIR="$HUMUS/$CHR/annotation/$HSAPID" ;
#
perl -e '
  use strict;
  my $chr = shift @ARGV;
  my %SEQlen;
  my $seqln = shift @ARGV;
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  print STDOUT join("\t", $chr, qw/ force cap  -2  0 . + 0 / )."\n";
  print STDOUT join("\t", $chr, qw/ force poly /,
                        ($SEQlen{$chr} - 1) x 2, qw/ . + 0/ )."\n";
' $CHR $SDIR/length > $ODIR/$CHR.termini ;
#
@

\subsubsctn{Running {\sgp} ({\gnid} with homology)}

<<SGP: >>=
#
# Running geneid with homology
#
SGP2="/projects/sgp/src/geneid_v1.1-sgp" ;
     # binaries, scripts and params in SGP2
GENEID="$SGP2/bin/geneid" ; # geneid v1.1-sgp
PARAM="$SGP2/param/human3iso.param.sgp" ;
EW=0 ; # add to exon weigth
#
# ISEQ="$HSAP/chromFaMasked/$CHRNUM/$CHR.fa.masked" ; 
#--> we do not run geneid on masked sequences at this moment
#--> we are using original un-masked fasta sequences from GP
ISEQ="$HSAP/chromosomes/$CHR.fa" ;
IDIR="$HUMUS/$CHR/sgp+/$XID/" ;
# ODIR="$HUMUS/$CHR/sgp/$XID/out" ;
HOMOLOGY="$HUMUS/$CHR/sgp+/$XID/hsp-sr/$CHR.gff" ;
#
# {
  { $GENEID -v -DE $EW -P $PARAM -S $HOMOLOGY \
        -R $IDIR/tmp/$CHR.termini $ISEQ | grep -v evidence \
        > $IDIR/out/$CHR ;
  } 2> $IDIR/logs/$CHR ;
#   } 2>&1 | tee $HUMUS/logs/geneid_sgp.$locus ;
#
@ 

\subsubsctn{Processing output for {\sgp} (with homology)}

<<SGP: >>=
#
# Processing geneid format from sgp output (with homology)
#
IDIR="$HUMUS/$CHR/sgp+/$XID" ;
#
geneid_raw2GFF $IDIR $IDIR/out/$CHR ;
#
ls -1 $IDIR/gff/ | egrep "^$CHR" | \
  while read n;
    do {
         cat $IDIR/gff/$n;
       };
    done | sort +3n +4n -5 - > $IDIR/gff/$CHR ;
#
get_geneid_genes $IDIR/gff/$CHR > $IDIR/out.gene_list ;
#
@

\subsubsctn{Evaluation of {\sgp} predictions (with homology)}

<<SGP: >>=
#
# Evaluation of SGP predictions (with homology)
#
IDIR="$HUMUS/$CHR/sgp+/$XID" ;
#
#
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%% BACKMATTER

% \newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \bibliographystyle{apalike}
% \bibliography{/home1/rguigo/docs/biblio/References}

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\sctn{Auxiliarly Code}

\subsctn{Interacting with MySQL} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsctn{Building database}

<<MySQL: Creating Database Report>>=
shell>  mysql -u root -p   (u:user, p:passwd)
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 772 to server version: 3.23.36

Type 'help;' or '\h' for help. Type '\c' to clear the buffer

mysql> CREATE DATABASE db_Hsapiens;
Query OK, 1 row affected (0.06 sec)

mysql> show databases;
+-----------------+
| Database        |
+-----------------+
| admin_db        |
| db_Hsapiens     |
| db_SPtest       |
| ensembl_generic |
| horde           |
| mysql           |
| ontology_db     |
| popper          |
| smartie         |
| test            |
| texbiblio_db    |
| web_db          |
+-----------------+
12 rows in set (0.01 sec)

mysql> GRANT ALL on db_Hsapiens.* TO genome@localhost IDENTIFIED BY "xxxx" ;
Query OK, 0 rows affected (0.10 sec)
@ 


<<MySQL: Setting up Tables>>=
/* Setting working database */
USE db_Hsapiens ;

/* Sequence related tables */
CREATE TABLE tb_chromosome
(
  id      CHAR(2)      NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  version VARCHAR(30),
  descr   TEXT
);
CREATE TABLE tb_sequence
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  chr     INT UNSIGNED NOT NULL,
  version CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  descr   TEXT
);

/* Process related tables */
CREATE TABLE tb_job
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT
);
CREATE TABLE tb_step
(
  id      VARCHAR(25)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  job     INT UNSIGNED NOT NULL,
  version VARCHAR(40), /* which program and its version is being run */
  descr   TEXT
);

/* Execution related tables */
CREATE TABLE tb_status
(
  id      VARCHAR(10)  NOT NULL,
  code    INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  descr   TEXT  
);
CREATE TABLE tb_exec
(
  status       INT UNSIGNED NOT NULL,
  chr_seq      INT UNSIGNED NOT NULL,
  job_step     INT UNSIGNED NOT NULL,
  exec_pid     INT UNSIGNED NOT NULL,
  exec_date    CHAR(14)     NOT NULL, /* YYYYMMDDhhmmss */
  host         VARCHAR(15)  NOT NULL,
  user         VARCHAR(15)  NOT NULL,
  stdout       TEXT,
  stderr       TEXT
);

/* EOF */
@
<<tangling: mySQL scripts>>=
#
# MySQL tables description for db_Hsapiens
notangle -R'MySQL: Setting up Tables' $WORK/$nwfile.nw | \
    cpif $MySQLPAR/db_Hsapiens.sql;
#
@ 
 

\subsubsctn{Initialitation files}

<<MySQL: initialization file for Perl scripts>>=
#
# db_Hsapiens_in.pm
#
#   setting user access to db_Hsapiens mySQL database
#
<<Version Control Id Tag>>
#
package db_Hsapiens_in;
use strict;
use vars qw( @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION
             $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw( $mySQL_db $mySQL_host $mySQL_user $mySQL_pswd );
# @@EXPORT_OK = qw( );
# %EXPORT_TAGS = ();

$mySQL_db   = 'db_Hsapiens';
$mySQL_host = 'monstre1.imim.es';
$mySQL_user = 'genome';
$mySQL_pswd = ''; # use vi to introduce the pswd for this user!!!

1;
@
<<BASH Variables: Perl>>=
#
PERL5OPT="-I$BBIN/libperl" ;
export PERL5OPT;
#
@ 


This file was tangled the first time, since then it is under version control and edited by hand...

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files
# 
# notangle -R'MySQL: initialization file for Perl scripts' \
#     $WORK/$nwfile.nw | cpif $MySQLPAR/db_Hsapiens_in.pm ;
# chmod 660 $MySQLPAR/db_Hsapiens_in.pm ;
#
@ 

The following files will serve to load rows on different tables with [[admin_db_Hsapiens.pm]].

<<MySQL: adm file - chrs>>=
#
# chrs.tbl
#
#   chromosome table
#
<<Version Control Id Tag>>
#
# Setting global version (must start with '>> ')
>> Golden Path 20010806
#
# Record Format:
#   <chr_id> <version> <description>
# where:
#       <version> == . --> global version
#   <description> == . --> undef
 1 . .
 2 . .
 3 . .
 4 . .
 5 . .
 6 . .
 7 . .
 8 . .
 9 . .
10 . .
11 . .
12 . .
13 . .
14 . .
15 . .
16 . .
17 . .
18 . .
19 . .
20 . .
21 . .
22 . .
 X . .
 Y . .
#
NA . .
UL . .
#
@
<<MySQL: adm file - seqs>>=
#
# seqs.tbl
#
#   sequences for each chromosome
#
<<Version Control Id Tag>>
#
# Record Format:
#   <chr_id> <sequence_id> <file_modifying_date> <description>
# where:
#   <file_modifying_date> is in YYYYMMDDhhmmss format
#   <description> == . --> undef
# 
@
<<MySQL: adm file - jobs>>=
#
# jobs.tbl
#
#   main process id table
#
<<Version Control Id Tag>>
#
@
<<MySQL: adm file - steps>>=
#
# steps.tbl
#
#   process step (executable scripts) id table
#
<<Version Control Id Tag>>
#
@
<<MySQL: adm file - status>>=
#
# status.tbl
#
#   program execution status table
#
<<Version Control Id Tag>>
#
# Record format:
#   <process_ID>
#   <description-line_0>
#    ...
#   <description-line_n>
#   // # this is the new record separator
#
TODO
Process was not started yet... 
//
RUNNING
Current step is being executed at this moment...
//
DONE
This step has finished without errors...
//
CHECK
Process reported warnings...
Verify its execution log but following steps are going to be run...
//
KILLED
Program execution was interrupted by user... 
Following steps are being skipped...
//
DIED
An error ocurred when running this step...
Please, check error report that has been produced...
//
SKIPPED
This step has been skipped due to a unfinished previous step... 
Please, check previous steps of the current job...
//
N/A
Job status is Not Available at this moment...
Just wait to the next update round to see if connection problem persist...
//
@

<<tangling: mySQL param>>=
# 
# mySQL perl auxiliarly files 
for n in chrs jobs steps status;
  do { 
       notangle -R"MySQL: adm file - $n" \
           $WORK/$nwfile.nw | cpif $MySQLPAR/$n.tbl ;
     }; 
  done;
# seqs.tbl is produced by initialization script on sequence analysis section
{ notangle -R'MySQL: adm file - seqs' $WORK/$nwfile.nw ; 
  cat $HUMUS/seqid_list ; } | cpif $MySQLPAR/seqs.tbl ;
#
@ 


\subsubsctn{Perl interface to mySQL database}

<<tangling: mySQL perl scripts>>=
# 
# mySQL perl scripts: interacting with mySQL DB
notangle -R'MySQL: perl DB interface' \
    $WORK/$nwfile.nw | cpif $LIBPERL/db_Hsapiens.pm ;
is_exec $LIBPERL/db_Hsapiens.pm ;
#
@ 

<<MySQL: perl DB interface>>=
<<PERL shebang>>
# db_Hsapiens.pm
#
package db_Hsapiens;
use strict;
<<Use Modules - Dumper>>
#
use vars qw(
           @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION 
           $mySQL_db $mySQL_host $mySQL_user $bpath $dbh $sth
           $_verbose %status %chrs 
           );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw(
    $mySQL_db $mySQL_host $mySQL_user $_verbose
    &open_DB &close_DB $bpath $dbh $sth
    &get_tbl_hash
    &get_DB_codes %status %chrs
  );
@@EXPORT_OK = qw(
    &connection_details &load_to_tbl_ifdef
    &list_tables &show_tbl_desc
  );
%EXPORT_TAGS = (
    AdminFunc => [ qw( &connection_details &load_to_tbl_ifdef
                       &list_tables &show_tbl_desc
                       ) ],
    );

# use lib "/projects/sgp/bin/mySQL/param";
$bpath = "/projects/sgp/bin/mySQL/param";
use db_Hsapiens_in;
my $dsn = "DBI:mysql:database=$mySQL_db;host=$mySQL_host";

use DBI;
#
use global;
#

$_verbose = 1;

sub connection_details() {
    print STDERR $Messages{'DBIHEADER'}->("DBI: Available DBD Drivers");
    print STDERR $Messages{'DBIMSG'}->(
        "",(map { "\t$_" } DBI->available_drivers),"");
    print STDERR $Messages{'DBIHEADER'}->("mySQL DataBase Connection Info:");
    print STDERR $Messages{'DBIMSG'}->("","\tDBname: $mySQL_db",
        "\t  Host: $mySQL_host","\t  User: $mySQL_user","");
} # connection_details

sub open_DB() {
    my $trace_level = shift || 0;
    print STDERR $Messages{'DBIHEADER'}->(
        "Openning mySQL connection to \'$mySQL_db\' DB...");
    DBI->trace($trace_level);
    $dbh = DBI->connect($dsn, $mySQL_user, $mySQL_pswd,
                        { RaiseError => 1, AutoCommit => 1 } );
    # put here error processing...
    print STDERR $Messages{'DBIMSG'}->(
        "","mySQL connection to \'$mySQL_db\' DB succesfully established.","");
} # open_DB

sub close_DB() {
    defined($dbh) && $dbh->disconnect();
    # put here error processing...
    print STDERR $Messages{'DBIHEADER'}->(
        "mySQL connection to \'$mySQL_db\' DB has been closed.");
} # close_DB

sub list_tables() {
    my @tbls;
    print STDERR $Messages{'DBIHEADER'}->(
        "Retrieving tables definition for '$mySQL_db' DB...");
    @tbls = $dbh->func('_ListTables');
    # put here error processing...
    return @tbls;
} # do_DB

sub show_tbl_desc() {
    my ($table, $fhref) = @_;
    my @strdesc = ();
    $sth = $dbh->prepare(qq{
           DESC $table /* Shows mySQL table description */
         });
    # put here error processing...
    $sth->execute;
    # put here error processing...
    push @strdesc, '|-> DESC '.$table;
    while (my @fld = $sth->fetchrow_array()) {
        # put here error processing...
        push @strdesc, sprintf("\t%-10s : %s",$fld[0],@fld[1..$#fld]);
    };
    $sth->finish;
    # put here error processing...
    print $fhref $Messages{'DBIMSG'}->("",@strdesc);
} # show_tbl_desc

sub load_to_tbl_ifdef() { # mv $field to end of args and set as an array to allow multiple fields select... ;^D
    my ($table, $field, $aryfld, $aryrow) = @_;
    my ($ssth,$isth);
    print STDERR $Messages{'DBIHEADER'}->(
        "UPDATING FIELDS for TABLE \"$table\"");
    my $fldstr = "(".join(', ',@{$aryfld}).")"; 
    my $valstr = "VALUES(".join(',',('?') x scalar(@{$aryfld})).")"; 
    my $sstr = qq{
        SELECT COUNT($aryfld->[$field])
               FROM $table
               WHERE $aryfld->[$field]=?
		};
    my $istr = qq{
        INSERT $table
               $fldstr
               $valstr /* adding new records */
        };
    print STDERR $Messages{'DBICMD'}->("$sstr$istr");
    $ssth = $dbh->prepare($sstr);
    $isth = $dbh->prepare($istr);
    foreach my $row (@{$aryrow}) {
        my $count;
        $ssth->execute($row->[$field]);
        $count = $ssth->fetchrow_array();
        ($count == 0) && do {
            print STDERR $Messages{'DBIMSG'}->(
                "\"$row->[$field]\" not found in \"$table\": INSERTING...");
            $isth->execute(@{$row});
            next;
		};
        print STDERR $Messages{'DBIMSG'}->(
            "\"$row->[$field]\" already defined in \"$table\": SKIPPING...");
    }; # foreach $row 
    print STDERR $Messages{'DBIMSG'}->(
        "",(scalar (@{$aryrow}))." records were checked...","");
    $ssth->finish();
    $isth->finish();
} # load_to_tbl_ifdef

sub get_tbl_hash() {
    # here we assume that the first element of $aryfld is a hash key
    my ($href, $table, $aryfld) = @_;
    print STDERR $Messages{'DBIHEADER'}->(
        "RETRIEVING HASH from TABLE \"$table\"");
    my ($ssth,@ary);
    my $aryfld_len = $#{ $aryfld };
    my $sstr = qq{
        SELECT @{[ join(', ',@{$aryfld}) ]}
               FROM $table
        }; 
    print STDERR $Messages{'DBICMD'}->("$sstr");
    $ssth = $dbh->prepare($sstr);
    $ssth->execute();
    while (@ary = $ssth->fetchrow_array()) {
        $$href{$ary[0]} = [ @ary[1..$aryfld_len] ];
    }; # while @ary
    print STDERR $Messages{'DBIMSG'}->(
        "",(scalar (keys %{$href}))." records were retrieved...","");
    $ssth->finish();
} # get_tbl_hash

sub get_DB_codes() {
    my @sel_fields = ();
    #
    # Loading Status tables
    %status = ();
    @sel_fields =  qw( id code descr );
    &get_tbl_hash(\%status, 'tb_status', \@sel_fields);
#    print STDOUT (Data::Dumper->Dump([ \%status ],
#                                  [ qw( *status ) ]));
    #
    # Loading Chromosome tables
    %chrs = ();
    @sel_fields =  qw( id code version descr );
    &get_tbl_hash(\%chrs, 'tb_chromosome', \@sel_fields);
#    print STDOUT (Data::Dumper->Dump([ \%chrs ],
#                                  [ qw( *chrs ) ]));
} # get_DB_codes

1;
@ 


\subsubsctn{Loading administrative tables}

<<tangling: mySQL perl scripts>>=
# 
# mySQL perl scripts: loading mySQL admin tables
notangle -R'MySQL: Initialize administrative tables' \
    $WORK/$nwfile.nw | cpif $MySQLPAR/admin_db_Hsapiens.pl ;
is_exec $MySQLPAR/admin_db_Hsapiens.pl ;
#
@ 

<<MySQL: Initialize administrative tables>>=
<<PERL shebang>>
# admin_db_Hsapiens.pl
#
use strict;
# use lib "/usr/local/molbio/share/libperl";
use db_Hsapiens qw( :DEFAULT :AdminFunc );
# $bpath/$admfiles[$i].tbl where $bpath eq "/usr/local/molbio/share/mySQL"
# my @admfiles = qw/ chrs seqs jobs steps status /;
#
use global;
$PROG = 'admin_db_Hsapiens.pl';

%CmdLineOpts = (
        "version" => sub {
            print STDERR "#### Hi, you are running $PROG version 0.9alpha ...\n";
            exit(1);
        }
    );

#
## MAIN
&parse_cmdline();
&program_started($PROG);

&connection_details();

&open_DB();

&listing_tables();

&load_status_tbl("$bpath/status.tbl");
&load_chromosome_tbl("$bpath/chrs.tbl");

&get_DB_codes();

&close_DB();

&program_finished($PROG);
exit(0);

#
## SUBS
sub listing_tables() {
    my @k = &list_tables();
    for (my $n=0; $n<=$#k; $n++) {
        &show_tbl_desc($k[$n], *STDERR);
    };
} # listing_tables
sub load_status_tbl() {
    my $ifile = shift;
    my @rows = ();
    open(IFILE,"< $ifile");
    local $/ = "\/\/\n";
    while (<IFILE>) {
        chomp;
        my @r = ();
        my @f = split /\n/og, $_;
        foreach my $l (@f) {
            next if $l =~ /^#/o;
            next if $l =~ /^\s*$/o;
            $l =~ s/^\s+//o;
            $l =~ s/\s+$//o;
            defined($r[0]) || ($r[0] = $l, next);
            $r[1] .= "$l\n";
        };
        push @rows, [ @r ];
    };
    close(IFILE);
	my @flds = qw( id descr );
    my ($tbl, $fld) = qw( tb_status 0 );
    &load_to_tbl_ifdef($tbl, $fld, \@flds, \@rows);
} # load_status_tbl
sub load_chromosome_tbl() {
    my $ifile = shift;
    my @rows = ();
    my $gpver = '';
    open(IFILE,"< $ifile");
    while (<IFILE>) {
        my @f;
        next if /^#/o;
        next if /^\s*$/o;
        chomp;
        s/^\s+//o;
        s/\s+$//o;
        /^>>\s+\b(.*)$/o && ($gpver = $1,next);
        @f = split /\s+/og, $_, 3;
        ($f[1] eq '.' && $gpver ne '') && ($f[1] = $gpver);
        push @rows, [ @f ];
    };
    close(IFILE);
	my @flds = qw( id version descr );
    my ($tbl, $fld) = qw( tb_chromosome 0 );
    &load_to_tbl_ifdef($tbl, $fld, \@flds, \@rows);
} # load_chromosome_tbl
@ 


\subsctn{Step processing script: [[stepper.pl]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl scripts>>=
# 
# mySQL perl scripts: loading mySQL admin tables
notangle -R'Step Execution Script' \
    $WORK/$nwfile.nw | cpif $BIN/stepper.pl ;
is_exec $BIN/stepper.pl ;
#
@ 

<<Step Execution Script>>=
<<PERL shebang>>
# stepper.pl
#
# USAGE: stepper param_file step_0 ... step_n
#
use strict;
#
use db_Hsapiens;
#
use global;
$PROG = 'stepper.pl';

# $bpath/$admfiles[$i].tbl where $bpath eq "/usr/local/molbio/share/sgp/mySQL"
# my @admfiles = qw/ chrs seqs jobs steps status /;

&init_signals();
&init_timer(\@exectime);

#
## VARS
%CmdLineOpts = (
    "version" => sub { 
        print STDERR "#### Hi, you are running $PROG version 0.9alpha ...\n";
            exit(1);
        }     
    );
<<stepper.pl: global vars>>

#
## MAIN
&parse_cmdline();
my $parfile = shift @ARGV;
my @stepfls = @ARGV;
&program_started($PROG);

&get_param($parfile);
&get_steps(@stepfls);

&open_DB();
&get_DB_codes();
&loop_through_steps();

while (!$skip_next) {};

&close_DB();

&program_finished($PROG);
exit(0);

#
## SUBS
<<stepper.pl: subs>>
@

<<stepper.pl: subs>>=
sub get_param() {
} # get_param
@ 
<<stepper.pl: subs>>=
sub get_steps() {
} # get_steps
@ 

<<stepper.pl: subs>>=
sub loop_through_steps() {
} # loop_through_steps
@ 
<<stepper.pl: global vars>>=
@ 

\subsctn{Shared code: [[global.pm]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl modules>>=
# 
# mySQL perl scripts: interacting with mySQL DB
notangle -R'shared functions and settings' \
    $WORK/$nwfile.nw | cpif $LIBPERL/global.pm ;
is_exec $LIBPERL/global.pm ;
#
@ 

<<shared functions and settings>>=
<<PERL shebang>>
# global.pm
#
package global;
use strict;
use vars qw(
           @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION 
           $PLVER $PROG $USAGE $DATE $USER $HOST
           $T $F $skip_next @exectime
           $ERRFH %Messages $_verbose $_color_report
           %CmdLineDefs %CmdLineOpts
           );

use Exporter;
$VERSION = 1.00;
@@ISA = qw(Exporter);
@@EXPORT = qw(
           $PLVER $PROG $USAGE $DATE $USER $HOST
           $T $F $skip_next %Messages $_verbose $_color_report $ERRFH
           &init_timer &timing @exectime
           &init_signals &trap_signals &trap_signals_prog
           &program_started &program_finished
           &parse_cmdline %CmdLineDefs %CmdLineOpts
           &check_syscall_exit &check_file &check_dir
           &min &max
           );
@@EXPORT_OK = qw(
           &comment_line &header &left_header &right_header
           &fill_right &fill_left &fill_mid
           );
%EXPORT_TAGS = (
           # ParseCMDLN => [ qw( &parse_cmdline %CmdLineDefs %CmdLineOpts ) ],
           StringFill => [ qw( &fill_right &fill_left &fill_mid ) ],
           );
    # AdminFunc => [ qw( &connection_details &load_to_tbl_ifdef ) ],
    # );
# use lib "/projects/sgp/bin/";

#
# Setting Default Variables
$ERRFH = \*STDERR;
($T,$F) = (1,0);
$PLVER = sprintf("v%vd",$^V);
$PROG  = 'UNDEF';
$USAGE = 'WARNING: Program variable "$USAGE" was not defined yet...';
$DATE  = localtime;
if (defined($ENV{USER})) {
    $USER = $ENV{USER};
} else {
    chomp($USER = `whoami`);
};
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
<<global.pm: messages>>

<<global.pm: timing>>
<<global.pm: trapping signals>>
<<global.pm: reporting messages>>
<<global.pm: parsing command-line args>>
<<global.pm: validate file/dir>>
<<global.pm: check exit status for sys calls>>
<<global.pm: general functions>>

1;
@
@ 

\subsubsctn{Timing processes}

<<global.pm: timing>>= 
#
# Timing definitions
use Benchmark;
@exectime = ();
sub init_timer() {
    my $refary = shift;
    @{ $refary } = (new Benchmark);
    return;
} # init_timer
sub timing() {
    my ($refary,$tmp) = @_;
    my $flg = defined($tmp) || $F;
    push @{ $refary } , (new Benchmark);
    my $mx = $#{ $refary };
    # partial time 
    $flg || do {
        return timestr(timediff($refary->[$mx],$refary->[($mx - 1)]));
    };
    # total time
    return timestr(timediff($refary->[$mx],$refary->[0]));
} # timing
@ 

\subsubsctn{Trapping system signals}

<<global.pm: trapping signals>>=
#
# Trapping signals
sub init_signals() {
    $SIG{HUP}  = \&trap_signals_prog;
    $SIG{ABRT} = \&trap_signals;
    $SIG{INT}  = \&trap_signals;
    $SIG{QUIT} = \&trap_signals;
    $SIG{TERM} = \&trap_signals;
    $SIG{KILL} = \&trap_signals;
    $SIG{CHLD} = 'IGNORE'; # child processes are automatically reaped
    $skip_next = $F;
} # init_signals
sub trap_signals() {
    print $ERRFH $Messages{'USER_HALT'}->($PROG);
    $skip_next = $T;
} # trap_signals
sub trap_signals_prog() {
    print $ERRFH $Messages{'PROCESS_HALT'}->($PROG);
    $skip_next = $T;
} # trap_signals_prog
@

<<global: warnings - input/output>>=
USER_HALT    => sub {
         my $name = shift;
         return
           &header(
             $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "$name has been stopped by user !!!",
             "---------- Exiting NOW !!! ----------",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
PROCESS_HALT => sub {
         my $name = shift;
         return
           &header(
             $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),$mlin{'empty_warn_line'}->(),
             "------- $name is down !!! -------",
             "---------- Exiting NOW !!! ----------",
             $mlin{'empty_warn_line'}->(),$mlin{'warn_line'}->(),
             );
     },
@

\subsubsctn{Processing messages}

<<global.pm: messages>>=
#
# Program status strings.
$_verbose = $F;
$_color_report = $F;
#
use Term::ANSIColor;
my $_pre_flg = $F;
my $term_width = 80;
my %mlin = (
    error_base     => sub {
                        my $str = "\<\<\<\< ERROR \>\>\>\>";
                        $_color_report && 
                            ($str = color("bold red").$str.color("reset"));
                        return $str." ";
                      },
    error_pre      => sub {
                        my $str = "\<\<\<";
                        $_color_report && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    error_post     => sub {
                        my $str = "\>\>\>";
                        $_color_report && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    error_len      => sub { return ($term_width - ( 16 + 3 + 3 )) },
      # error_base + error_pre + error_post
    warn_base      => sub {
                        my $str = "\<\<\< WARNING \>\>\>";
                        $_color_report && 
                            ($str = color("bold yellow").$str.color("reset"));
                        return $str." ";
                      },
    warn_pre       => sub {
                        my $str = "\<\<\<";
                        $_color_report && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    warn_post      => sub {
                        my $str = "\>\>\>";
                        $_color_report && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      },
    warn_len       => sub { return ($term_width - ( 16 + 3 + 3 )) },
      # error_base + error_pre + error_post
    comment_base   => sub { return "" },
    comment_pre    => sub {
                        my $str = "###";
                        $_color_report && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      },
    comment_post   => sub {
                        my $str = "###";
                        $_color_report && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      },
    comment_len    => sub { return ($term_width - ( 0 + 3 + 3 )) },
      # comment_base + comment_pre + comment_post
    dbi_base       => sub {
                        my $str = "### ";
                        $_color_report && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_pre        => sub {
                        my $str = "MySQL *";
                        $_color_report && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_post       => sub {
                        my $str = "*";
                        $_color_report && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      },
    dbi_len        => sub { return ($term_width - ( 4 + 7 + 1 )) },
      # dbi_base + dbi_pre + dbi_post
    spacer         => sub { return "###" },
    );
#
$mlin{'error_line'} = sub {
                        my $str = ('-' x $mlin{'error_len'}->());
                        $_color_report && 
                            ($str = color("yellow").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_error_line'} = sub { return (' ' x $mlin{'error_len'}->()) };
#
$mlin{'warn_line'} = sub { return $mlin{'error_line'}->() };
$mlin{'empty_warn_line'} = sub { return $mlin{'empty_error_line'}->() };
#
$mlin{'comment_line'} = sub {
                        my $str = ("#" x $mlin{'comment_len'}->());
                        $_color_report && 
                            ($str = color("green").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_comment_line'} = sub { return (' ' x $mlin{'comment_len'}->()) };
#
$mlin{'dbi_line'} = sub {
                        my $str = ("*" x $mlin{'dbi_len'}->());
                        $_color_report && 
                            ($str = color("cyan").$str.color("reset"));
                        return $str;
                      };
$mlin{'empty_dbi_line'} = sub { return (' ' x $mlin{'dbi_len'}->()) };
#
%Messages = (
    # ERROR MESSAGES
    <<global: warnings - input/output>>
    <<global: warnings - parsing command-line options>>
    # WORKING MESSAGES
    <<global: messages - program start-stop>>
    <<global: messages - interacting with DB>>
    <<global: messages - parsing command-line options>>
   ); # %Messages
@

<<global.pm: reporting messages>>=
#
# Reporting program status and messages
sub comment_line() {
    my ($tlen,$base,$pre,@lns) = @_;
    my ($comment,$ln);
    foreach $ln (@lns) {
        $ln =~ s/^$/ /o; 
        $comment .= "$base$pre $ln\n";
        };
    return $comment;
} # header
sub header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_mid($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # header
sub left_header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_left($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # left_header
sub right_header() {
    my ($tlen,$base,$pre,$post,@lns) = @_;
    my $comment = $_pre_flg ? $mlin{'spacer'}->()."\n" : '';
    $_pre_flg || ($_pre_flg = $T); 
    foreach my $ln (@lns) { 
        $comment .= "$base$pre".
                    (&fill_right($ln,$tlen," "))."$post\n";
        };
    return $comment;
} # right_header
sub program_started() {
    my $prog = shift;
    print $ERRFH $Messages{'HEADER'}->("RUNNING $prog",'',
        "Host: $HOST","User: $USER","Perl: $PLVER",'',"Date: $DATE");
} # program_started
sub program_finished() {
    my $prog = shift;
    print $ERRFH $Messages{'HEADER'}->("$prog HAS FINISHED",'',
                                       &timing(\@exectime,$T));
} # program_finished
@

<<global: messages - program start-stop>>=
HEADER       => sub {
         my @mssg = @_;
         return
           &header(
	         $mlin{'comment_len'}->(),$mlin{'comment_base'}->(),
             $mlin{'comment_pre'}->(),$mlin{'comment_post'}->(),
             $mlin{'comment_line'}->(),
             "", @mssg, "",
             $mlin{'comment_line'}->(),
             );
     },
@

\subsubsctn{Interacting with DB standard messages}

<<global: messages - interacting with DB>>=
DBIHEADER    => sub {
         my @mssg = @_;
         return
           &right_header(
	         $mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
             $mlin{'dbi_pre'}->(),$mlin{'dbi_post'}->(),
             $mlin{'dbi_line'}->(),
             &prespc(@mssg),
             $mlin{'dbi_line'}->(),
             );
     },
DBIMSG       => sub {
         my @mssg = @_;
         return &comment_line($mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
                              $mlin{'dbi_pre'}->(),@mssg);
     },
DBICMD       => sub {
         my @mssg = (split /[\n]/o, $_[0]);
         @mssg = map { s/^\s{6}//o; $_ } @mssg;
         return &comment_line($mlin{'dbi_len'}->(),$mlin{'dbi_base'}->(),
                              $mlin{'dbi_pre'}->(),@mssg);
     },
@


\subsubsctn{Parsing command-line}

<<global.pm: parsing command-line args>>=
#
# Parsing command-line options
use Getopt::Long;
Getopt::Long::Configure qw/ bundling /;
%CmdLineDefs = ();
%CmdLineOpts = ();

sub parse_cmdline() {
    # we ensure here that options hash always exist 
    # (and that it has a default option: 'help')
    $CmdLineOpts{'v|verbose'} = sub {
            $_verbose = $T;
        };
    $CmdLineOpts{'V|color-verbose'} = sub {
            ($_verbose, $_color_report) = ($T, $T);
        };
    $CmdLineOpts{'h|help|?'} = sub {
            print $ERRFH $Messages{'SHOW_HELP'}->($USAGE);
            exit(1);
        };
    # looking for STDIN "-" to avoid problems with GetOptions
    my $cmdln_stdin = undef;
    for (my $a = 0; $a <= $#ARGV; $a++) { 
        next unless $ARGV[$a] =~ /^-$/o;
        $cmdln_stdin = $a - $#ARGV;
        splice(@ARGV,$a,1);
    };    
    # parsing command-line
    $SIG{__WARN__} = sub {
            print $ERRFH $Messages{'CMDLINE_OPT_ERR'}->($_[0]);
        };
    GetOptions(%CmdLineOpts) || do {
            print $ERRFH $Messages{'CMDLINE_ERROR'}->($PROG,"@ARGV");
            exit(1);
        };
    $SIG{__WARN__} = 'DEFAULT';
    # if "-" return to its position on cmd-line
    my $t = scalar(@ARGV);
    defined($cmdln_stdin) && do {
        abs($cmdln_stdin) > $t && ($cmdln_stdin = -$t);
	    $cmdln_stdin > 0  && ($cmdln_stdin = 0 );
        $t += $cmdln_stdin;
        splice(@ARGV,$t,0,'-');
    };
} # parse_cmdline
@ 

<<global: messages - parsing command-line options>>=
SHOW_HELP    => sub {
         my @mssg = split /[\n]/og, shift;
         return 
           &right_header(
	         $mlin{'comment_len'}->(),$mlin{'comment_base'}->(),
             $mlin{'comment_pre'}->(),$mlin{'comment_post'}->(),
             $mlin{'comment_line'}->(),
             &prespc(@mssg),
             $mlin{'comment_line'}->(),
             );
     },
@ 

<<global: warnings - parsing command-line options>>=
CMDLINE_OPT_ERR => sub {
         my $mssg = shift;
         $mssg =~ s/^\s*//o;
         $mssg =~ s/\s*$//o;
         return
           &right_header(
	         $mlin{'warn_len'}->(),$mlin{'warn_base'}->(),
             $mlin{'warn_pre'}->(),$mlin{'warn_post'}->(),
             $mlin{'warn_line'}->(),
             &prespc("Error trapped while processing command-line:",
                     (" "x8)."--> $mssg <--"),
             $mlin{'warn_line'}->(),
             );
     },
CMDLINE_ERROR   => sub {
         my ($name,$mssg) = @_;
         return
           &right_header(
	         $mlin{'error_len'}->(),$mlin{'error_base'}->(),
             $mlin{'error_pre'}->(),$mlin{'error_post'}->(),
             $mlin{'error_line'}->(),
             &prespc("Please, check your command-line options!!!",
                     (" "x8)."Type \"$name --help\" for help..."),
             $mlin{'error_line'}->(),
             );
     },
@


\subsubsctn{Validating filenames and directories}

<<HIDE: global.pm: validate file/dir>>=
#
# Filename and directories validation
sub check_file() {
    my $stdin_flg = $F;
    &report("CHECKING_FILENAMES");
  FILECHK: foreach my $test_file (@ARGV) {
        $test_file ne '-' && do {
            -e $test_file || do {
                &warn('FILE_NO_OPEN',$T,$test_file);
                next FILECHK;
            };
            &report('READING_FILE',$test_file);
            push @data_files, $test_file;
            next FILECHK;
        };
        $stdin_flg = $T;
        push @data_files, '-';
	}; # foreach
    scalar(@data_files) == 0 && do {
        push @data_files, '-';
        $stdin_flg = $T;
    };
    $stdin_flg && &report('READING_STDIN');
} # check_file
@ 

<<warnings - input/output>>=
FILE_NO_OPEN =>
  $spl.$Warn."Cannot Open Current file \"\%s\" . Not used !!!\n".$spl,
@
<<messages - input/output>>=
CHECKING_FILENAMES =>
  $sp."### Validating INPUT FILENAMES\n".$sp,
READING_FILE =>
  "###---> \"\%s\" exists, including as Input File.\n",
READING_STDIN =>
  "###---> Including GFF records from standard input.\n",  
@

<<global.pm: validate file/dir>>=
#
sub check_dir() {
    my ($flg,@odir) = @_;
    (scalar(@odir) == 0) && (return 0);
    my @okdir = ();
    foreach my $thisdir (@odir) {
        ( -e $thisdir && -d _ ) || do {
#            print $ERRFH "# Making chr $chr directory: $odir\n";
            (mkdir $thisdir) || do {
#                print $ERRFH "# Error making directory \"$odir\" ".
#                             "for chr $chr : SKIPPING !!!\n";
                push @okdir, $F;
                next;
            };
            push @okdir, $T;
            next;
        };
#        print $ERRFH "# Directory \"$odir\" for chr $chr ALREADY EXIST...\n".
        push @okdir, $T; 
    }; # foreach $d
    return @okdir;
} # check_dir
@


\subsubsctn{Checking exit status for system calls}

We check for exit signals returned by system once it has run the command-line defined in [[$cmdline]] variable (we use the recipe shown in the O'Reilly book, ``Programming Perl'', 2$^n$ edition, page 230). %' 

<<global.pm: check exit status for sys calls>>=
# 
# Checking exit status for sys calls
sub check_syscall_exit() {
    my $prog_exit = 0xffff & shift;
    my ($exitflg,$exitstr) = ($F,'');
    $exitstr = sprintf("Command returned %#04x : ", $prog_exit);
    if ($prog_exit == 0) {
        $exitflg = $T;
        $exitstr .= "ran with normal exit ...";
    }
    elsif ($prog_exit == 0xff00) {
        $exitstr .= "command failed: $! ...";
    }
    elsif (($prog_exit & 0xff) == 00) {
        $prog_exit >>= 8;
        $exitstr .= "ran with non-zero exit status $prog_exit ...";
    }
    else {
        $exitstr .= "ran with ";
        if ($prog_exit &   0x80) {
            $prog_exit &= ~0x80;
            $exitstr .= "coredump from ";
            };
        $exitstr .= "signal $prog_exit ...";
    };
    return ($exitflg,$exitstr);
} # check_syscall_exit
@

<<HIDE: >>=
perl -e '
  use global;
  @kmd = (
           "echo $USER",
           "echo $USER; exit;",
           "echo $USER; exit 0;",
           "echo $USER; exit 1;",
           "ls echo",
           "ls echo; exit",
           "ls echo; exit 0",
           "perl -e \"exit(0);\"",
           "perl -e \"exit(1);\"",
           "perl -e \"exit(2);\"",
         ); 
  foreach $cmd (@kmd) {
      $kk = system($cmd);
      ($f,$s) = &check_syscall_exit($kk);
      print STDOUT ("#" x 60)."\n".
                   "# Command line:\n".$cmd."\n".
                   "# Program returned signal $kk\n".
                   "# Did it run ? ".($f ? "Yes" : "No")."\n".
                   "# Diagnostics:\n$s\n\n";
  }; # foreach 
' 
@ 

\subsubsctn{General functions}

<<global.pm: general functions>>=
# 
# General functions
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
#
sub fill_right() { return $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { return ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    return ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l + $k)));
} # fill_mid
sub prespc() { return ( map { " $_" } @_ ); } 
@


\subsctn{Implementing scripts with [[Tk]]} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<tangling: perl Tk scripts>>=
# 
# Tk perl scripts
notangle -R'stv: Status Table Viewer' $WORK/$nwfile.nw | cpif $BIN/stv ;
is_exec $BIN/stv ;
#
@ 

<<stv: Status Table Viewer>>=
<<PERL shebang>>
# stv - visualizing a dinamic status table in perl Tk (pTk)
#
use strict;
use Tk;
# database interface module
# use lib "/projects/sgp/bin/mySQL";
use db_Hsapiens;
#
use global;
$PROG = 'stv';

my @chrom = qw/ 1 2 3 4 X Y /; # to load from DB
my @jobs  = qw/ Masking Homology GenePred SGP /; # to load from DB
my (%col,%row); 

#
## MAIN
&parse_cmdline();
&program_started($PROG);
# Open mySQL DataBase conection
&open_DB();
# Initialize Tk table
&Init_Window();
# Infinite loop to dispatch incoming events
MainLoop();
# Disconecting from mySQL DB
&close_DB();
#
&program_finished($PROG);
exit(0);

#
## SUBS
sub Init_Window() {
    # Create main window
    my $main_window = MainWindow->new();
    $main_window->title("Status Table Viewer");

    # Instatiating widgets
    $col{HEADER} = $main_window->Frame(
                    borderwidth => 2,
                    foreground  => 'yellow',
                    )->pack(
                        side   => 'left',
                        fill   => 'y', 
                        expand => 'y',
                        );
    $row{HEADER}{HEADER} = $col{HEADER}->Label(
                               text        => "CHR->\nPROG-v",
                             # anchor      => 'n',
                               width       => 10,
                               height      => 2,
                               foreground  => 'black',
                               background  => 'lightgrey',
                               borderwidth => 2,
                               )->pack();
    foreach my $j (@jobs) {
        $row{HEADER}{$j} = $col{HEADER}->Label(
                               text        => "$j",
                             # anchor      => 'n',
                               width       => 10,
                               height      => 2,
                               foreground  => 'black',
                               background  => 'lightblue',
                               borderwidth => 2,
                               )->pack();
    }; # foreach @jobs

    foreach my $j (@chrom) {
        my $frame = $main_window->Frame(
                    borderwidth => 2,
                    foreground  => 'yellow',
                    )->pack(
                        side   => 'left',
                        fill   => 'y', 
                        expand => 'y',
                        );
        %{ $row{$j} } = (); 
        $col{$j} = $frame;
        $row{$j}{HEADER} = $col{$j}->Label(
                               text        => "Chr $j",
                             # anchor      => 'n',
                               width       => 6,
                               height      => 2,
                               foreground  => 'black',
                               background  => 'lightgrey',
                               borderwidth => 2,
                               )->pack();
        foreach my $i (@jobs) {
            $row{$j}{$i} = $col{$j}->Label(
                               text        => "-",
                             # anchor      => 'n',
                               width       => 6,
                               height      => 2,
                               foreground  => 'black',
                               background  => 'orange',
                               borderwidth => 2,
                               )->pack();
        }; # foreach @jobs
    }; # foreach @chrom
} # Init_Window
@ 


\subsctn{Tests} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Testing scripts: >>=
#
perl -e '
  use strict;
  my ($seq,$src,$ftr,$ori,$end,$sco,$str,$frm) = (0..7);
  my @frame = ( 3, 1, 2 ); # frm 0 -> blastfrm 3
                           # frm 1 -> blastfrm 1
                           # frm 2 -> blastfrm 2
  my %SEQlen;
  my ($chr, $seqln, $input, $odir) = @ARGV;

  &child("$odir/$chr");
  &main();
  close(STDOUT);

sub child() {
  my $base = shift;
  open(FGFF,"> $base.fullgff");
  open(CGFF,"| sort +3n -6 +6 -7 - > $base.gff");
  # reopen STDOUT in parent and return
  return if my $pid = open(STDOUT, "| -");
  die("### Cannot fork: $!") unless defined($pid);
  # process STDIN in child
  while (<STDIN>) {
      my $j = $_;
      print FGFF $j;
      next if $j =~ /^#/o;
      next if $j =~ /^\s*$/o;
      $j =~ s/;\s+Strand//o;
      $j =~ s/;\s+Frame//o;
      $j =~ s/;\s+E_value.*$//o;
      print CGFF $j;
  }; # STDIN
  # do not let child return to main!!!
  exit;
} # sub child

sub main() {
  my @files = ();
  my %g = ( "+1" => 0,  "+2" => 1,  "+3" => 2,  "+" => 3,
            "-1" => 4,  "-2" => 5,  "-3" => 6,  "-" => 7,
                       "all" => 8,            "sum" => [ (0) x 9 ] );
  my ($cf,$cr);
  open(FRGLEN, "< $seqln");
  while (<FRGLEN>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      my @l = split /\s+/og, $_;
      $SEQlen{$l[0]} = $l[1];
  }; # while
  close(FRGLEN);
  open(FRGLST, "< $input.report");
  while (<FRGLST>) {
      next if /^#/o;
      next if /^\s*$/o;
      chomp;
      s/^\s*//o;
      my @l = split /\s+/og, $_;
      ($l[2] > 0) && do {
          push @files, [ $l[$#l], ($l[0] - 1) ];
      };
      # skipping fragments without HSPs
  }; # while
  close(FRGLST);
  #
  print STDERR "#\n# $chr has ".(scalar @files)." fragments (files)\n#\n# ".
               (sprintf("%8s %8s %8s  %s\n","#hsp","#hsp(+)","#hsp(-)","file"));
  system("/bin/rm","$input.parseblast.err");
  foreach my $fl (@files) {
      $cf = $cr = 0;
      my ($fname,$offset) = ("$input/$fl->[0]", $fl->[1]);
      open(TBXFL, "parseblast --fullgff --full-scores --comments".
                  " --verbose --bit-score $fname 2>> $input.parseblast.err |");
      my @l;
      while (<TBXFL>) {
          next if /^\s*$/o;
          /^#/o && do {
              print STDOUT $_;
              next;
          };
          chomp;
          @l = split /\s+/og, $_, 9;
          $l[$seq] = $chr;
          $l[$src] = "tblastx";
          $l[$ftr] = "hsp";
          $l[$ori] += $offset;
          $l[$end] += $offset;
          if ($l[$str] eq "-") {
              $l[$frm] = $frame[(($SEQlen{$chr} - $l[$end] + 1) % 3)];
              $cr++;
          } else {
              $l[$frm] = $frame[($l[$ori] % 3)];
              $cf++;
          };
          print STDOUT join("\t", @l)."\n";
          $g{sum}[$g{"$l[$str]$l[$frm]"}]++;
      }; # while
      close(TBXFL);
      printf STDERR "  %8s %8s %8s  %s\n",($cf+$cr),$cf,$cr,$fl->[0];
  }; # foreach
  $g{sum}[$g{"+"}] = $g{sum}[$g{"+1"}] + $g{sum}[$g{"+2"}] + $g{sum}[$g{"+3"}];
  $g{sum}[$g{"-"}] = $g{sum}[$g{"-1"}] + $g{sum}[$g{"-2"}] + $g{sum}[$g{"-3"}];
  $g{sum}[$g{"all"}] = $g{sum}[$g{"+"}] + $g{sum}[$g{"-"}];
  print STDERR "# TOTAL ".$g{sum}[$g{"all"}]." HSPs on $chr: ".
               $g{sum}[$g{"+"}]." forward, ".$g{sum}[$g{"-"}]." reverse.\n";
  foreach my $t (qw/ +1 +2 +3 -1 -2 -3 /) {
     printf STDERR "#\t%s : %s\n",$t,$g{sum}[$g{$t}];
  }; # foreach
} # sub main
' $CHR $SDIR/$HSAPID/length $IDIR $ODIR 2> $ODIR.report ;
#
@
 
<<Testing scripts: >>=
#
# cat > run_local_childs <<'###EOF###';
cat > run_remote_childs <<'###EOF###';
#!/usr/local/bin/perl -w
  use strict;
  use IPC::Shareable; # XAVI must install this !!!!!
  my @seqs = qw( seq1  seq2  seq3  seq4  seq5  seq6  seq7  seq8  seq9  seq10
                 seq11 seq12 seq13 seq14 seq15 seq16 seq17 seq18 seq19 seq20 );
  my @jobs = qw( job1 job2 job3 job4 job5 );
  my $BASE = "/home/ug/jabril/development/projects/sgp/humus/tests/childs";
  my %jobscode = (
      job1 => <<'$$$EOF$$$',
#
perl -e '
  ($jn,$dr) = @ARGV;
  print STDOUT "Running $jn on $ENV{CWD}: $ENV{USER} at $ENV{HOSTNAME}\n";
  print STDERR "## Output was sent to $jn.out";
  sleep(5);
  print STDERR "## Sleep period has finished";
  exit(0);
  ' "job1($MPID)" $HOME > $SEQ.job1.out 2> $SEQ.job1.err;
#
$$$EOF$$$
      job2 => <<'$$$EOF$$$',
#
STRING=`hostname`;
#
echo "HEY it is me: $USER @ $STRING" > $SEQ.job2.out 2> $SEQ.job2.err;
#
$$$EOF$$$
      job3 => <<'$$$EOF$$$',
#
STRING=`hostname`;
wc /seq/genomes/H.sapiens/golden_path_20010806/chromosomes/chr1.fa | \
  perl -e '$h = shift;
           $wc = <>;
           print "# $ENV{USER} at $h \n# File length is: $wc\n";
          ' $STRING - \
          > $SEQ.job3.out \
         2> $SEQ.job3.err ;
#
$$$EOF$$$
      job4 => "",
      job5 => "",
  );
#  $jobscode{job1} =~ s/(\n)/$1#--> /og ;
#  print STDOUT "#--> ".$jobscode{job1}."\n" ;

  my @pids = ();
  my ($pid,$sem);
  my @hosts = qw( monstre1 monstre2 monstre3 monstre4 ik12 ik13 i8 i10 i26 );
  my $maxjobs = scalar(@hosts);
  my @semaphore ;
  my $gid = $$;

  my $handle = tie @semaphore, 'IPC::Shareable', undef, { destroy => 1 };
  @semaphore = ( 0 ) x $maxjobs;

open(FHERR, "> $BASE/run.rpt");
  # BEGIN brown_dispatcher
  print FHERR "### MAIN $gid ### BEGIN MAIN LOOP\n".
              "### MAIN $gid ### SEMAPHORE: @semaphore\n";
  my $pending_seqs = scalar(@seqs);
  while ($pending_seqs > 0) {
      for ($sem = 0; $sem < $maxjobs; $sem++) {
         $semaphore[$sem] || do {
             next if (! &find_victim($hosts[$sem]));
             next if $pending_seqs == 0; # next unless scalar(@seqs) > 0;
             &breed_crows( shift @seqs, $sem);
             push @pids, $pid;
             --$pending_seqs;
         }; # if job semaphore == 0 then fork child
         &do_wait();
      }; # for semaphores...
  }; # while
  while (&all_done(\@semaphore)) { &do_wait(); };
  print FHERR "### MAIN $gid ### All Jobs ID: \n @pids \n".
              "### MAIN $gid ### END MAIN LOOP\n";
  # END brown_dispatcher

close(FHERR);
  exit(0);

  sub do_wait() {
      sleep 1; # select(undef,undef,undef,1);
      print FHERR "### MAIN $gid ### SEMAPHORE: @semaphore\n";
  } # do_wait
  sub all_done() {
      my $aryref = shift;
      my $sum = 0;
      $handle->shlock();
      for (my $s = 0; $s < $maxjobs; $s++) {
          $sum += $semaphore[$s];
      }; # for semaphores...
      $handle->shunlock();
      return ($sum>0) ? 1 : 0;
  } # all_done
  sub find_victim() {
      my $host = shift;
      system("rsh $host echo $host 2>/dev/null 1>&2; exit") == 0  && do {
          print FHERR "### MAIN $gid ### Connection to $host available...\n";
          return 1;
      };
      print FHERR "### MAIN $gid ### Connection to $host NOT available...\n";       
      return 0;
  } # find_victim
  sub breed_crows() {
      my ($pre,$clhpid);
      my ($seq,$pos) = @_;
      return if $pid = fork(); # return to parent, follows child code
      $clhpid = "$$.$gid";
      $handle->shlock();
      $semaphore[$pos] = $clhpid;
      $handle->shunlock();
      print FHERR "## $clhpid ## Running child \"$clhpid\" on sequence \"$seq\".\n";
      $pre = sprintf("SEQ=$BASE/data/%s ;\nMPID=%s ;\n",$seq,$clhpid);
      foreach my $job (qw( job1 job2 job3 )) {
          print FHERR "## $clhpid ## Running job \"$job\" on sequence \"$seq\".\n";
          open(TMP,"> $BASE/tmp/$clhpid");
          print TMP $pre.$jobscode{$job};
          close(TMP);
          system <<"#@#EOF#@#"
/bin/chmod a+x $BASE/tmp/$clhpid ;
rsh $hosts[$pos].imim.es $BASE/tmp/$clhpid ;
/bin/rm $BASE/tmp/$clhpid ;
#@#EOF#@#
      }; # foreach job
      $handle->shlock();
      $semaphore[$pos] = 0;
      $handle->shunlock();
      print FHERR "## $clhpid ## Child \"$clhpid\" is going to finish.\n";
      exit(0); # child process exits when done
  } # breed_crows
###EOF###
#
@ 

<<HIDE: >>=
cat > getremoteinfo.pl <<'###EOF###';
#!/usr/local/bin/perl -w
print STDOUT sprintf("--> %s --> v%vd\n",$ENV{HOSTNAME},$^V);
###EOF###
chmod a+x getremoteinfo.pl ;
#
for n in monstre1 monstre2 monstre3 monstre4 ik12 ik13 i8 i10 i26;
  do {
     rsh $n /home/ug/jabril/development/projects/sgp/humus/tests/childs/getremoteinfo.pl;
     };
  done 
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Common code blocks}

\subsctn{PERL scripts}

<<PERL shebang>>=
#!/usr/local/bin/perl -w
# This is perl, version 5.6.1 built for i386-linux
#
<<Version Control Id Tag>>
#
@ 

<<PERL strict pragma + info>>=
use strict;
#
my $PVER = sprintf("v%vd",$^V);
my $DATE = localtime;
my ($USER,$HOST);
if (defined($ENV{USER})) {
    $USER = $ENV{USER};
} else {
    chomp($USER = `whoami`);
};
if (defined($ENV{HOSTNAME})) {
    $HOST = $ENV{HOSTNAME};
} else {
    chomp($HOST = `hostname`);
};
my $host = $HOST; ###
#
@

<<Global Constants - Boolean>>=
my ($T,$F) = (1,0); # for 'T'rue and 'F'alse
@ %def $T $F


\subsubsctn{Timing our scripts}

The '[[Benchmark]]' module encapsulates a number of routines to help to figure out how long it takes to execute a piece of code and the whole script.

<<Use Modules - Benchmark>>=
use Benchmark;
  <<Timer ON>>
@ 

See '[[man Benchmark]]' for further info about this package. 
We set an array to keep record of timing for each section.

<<Timer ON>>=
my @Timer = (new Benchmark);
@ 

<<Common PERL subs - Benchmark>>=
sub timing() {
    my $flg = shift || 0;
    push @Timer, (new Benchmark);
    # partial time 
    $flg || 
        (return timestr(timediff($Timer[$#Timer],$Timer[($#Timer - 1)])));
    # total time
    return timestr(timediff($Timer[$#Timer],$Timer[0]));
} # timing
@ 


\subsubsctn{Printing complex Data Structures}

With '[[Data::Dumper]]' we are able to pretty print complex data structures for debugging them.


<<Use Modules - Dumper>>=
use Data::Dumper;
local $Data::Dumper::Purity = 0;
local $Data::Dumper::Deepcopy = 1;
@ 


\subsubsctn{Common functions}

<<Skip comments and empty records>>=
next if /^\#/o;
next if /^\s*$/o;
chomp;
@

<<Common PERL subs - Min Max>>=
#
sub max() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l > $z };
    return $z;
} # max
sub min() {
    my $z = shift @_;
    foreach my $l (@_) { $z = $l if $l < $z };
    return $z;
} # min
@

<<Common PERL subs - Text fill>>=
#
sub fill_right() { $_[0].($_[2] x ($_[1] - length($_[0]))) }
sub fill_left()  { ($_[2] x ($_[1] - length($_[0]))).$_[0] }
sub fill_mid()   { 
    my $l = length($_[0]);
    my $k = int(($_[1] - $l)/2);
    ($_[2] x $k).$_[0].($_[2] x ($_[1] - ($l+$k)));
} # fill_mid
@

These functions are used to report to STDERR a single char for each record processed (useful for reporting parsed records).

<<Common PERL subs - Counter>>=
#
sub counter { # $_[0]~current_pos++ $_[1]~char
    print STDERR "$_[1]";
    (($_[0] % 50) == 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter
#
sub counter_end { # $_[0]~current_pos   $_[1]~char
    (($_[0] % 50) != 0) && (print STDERR "[".&fill_left($_[0],6,"0")."]\n");
} # counter_end
@

<<Global Vars - Counter>>=
my ($n,$c); # counter and char (for &counter function)
@ %def $n $c


\subsubsctn{Common functions for reporting program processes}
\label{sec:messagerpt}

Function '[[report]]' requires that a hash variable '[[%MessageList]]' has been set, such hash contains the strings for each report message we will need. The first parameter for '[[report]]' is a key for that hash, in order to retrieve the message string, the other parameters passed are processed by the [[sprintf]] function on that string.

<<Common PERL subs - STDERR>>=
sub report() { print STDERR sprintf($MessageList{ shift @_ },@_) }
@

The same happens to '[[warn]]' function which also requires a hash variable '[[%ErrorList]]' containing the error messages.

<<Common PERL subs - STDERR>>=
sub warn() { print STDERR sprintf($ErrorList{ shift @_ }, @_) }
@

\subsctn{AWK scripts}

<<GAWK shebang>>=
#!/usr/bin/gawk -f
# GNU Awk 3.0.4
<<Version Control Id Tag>>
@

\subsctn{BASH scripts}

<<BASH shebang>>=
#!/usr/bin/bash
# GNU bash, version 2.03.6(1)-release (i386-redhat-linux-gnu)
<<Version Control Id Tag>>
#
SECONDS=0 # Reset Timing
# Which script are we running...
L="####################"
{ echo "$L$L$L$L";
  echo "### RUNNING [$0]";
  echo "### Current date:`date`";
  echo "###"; } 1>&2;
@

<<BASH script end>>=
{ echo "###"; echo "### Execution time for [$0] : $SECONDS secs";
  echo "$L$L$L$L";
  echo ""; } 1>&2;
#
exit 0
@

\subsctn{Version control tags}

This document is under Revision Control System (RCS). The version you are currently reading is the following:

<<Version Control Id Tag>>=
# $Id: humus.nw,v 1.4 2002-02-15 17:29:05 jabril Exp $
@ 

\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sctn{Extracting code blocks from this document}

From this file we can obtain both the code and the
documentation. The following instructions are needed:

\subsctn{Extracts Script code chunks from the {\noweb} file} % \\[-0.5ex]

Remember when tangling that '-L' option allows you to include program line-numbering relative to original {\noweb} file. Then the first line of the executable files is a comment, not a shebang, and must be removed to make scripts runnable.

<<tangling programs>>=
<<tangling: perl modules>>
<<tangling: mySQL perl scripts>>
<<tangling: perl scripts>>
<<tangling: perl Tk scripts>>
@ 

<<examples of tangling commands>>=
# showing line numbering comments in program
notangle -L -R"humus" $WORK/$nwfile.nw | \
   perl -ne '$.>1 && print' | cpif $BIN/humus ;
is_exec $BIN/humus ;
# reformating program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy - | cpif $BIN/humus ;
# html pretty-printing program with perltidy
notangle -R"humus" $WORK/$nwfile.nw | \
    perltidy -html - | cpif $DOCS/html/humus.html ;
#
@ 

\subsctn{Extracting different Config Files} % \\[-0.5ex]

<<tangling param files>>=
<<tangling: mySQL scripts>>
<<tangling: mySQL param>>
@ %$

\subsctn{Extracting documentation and \LaTeX{}'ing it} % \\[-0.5ex] %'

<<tangling complementary LaTeX files>>=
notangle -R"HIDE: LaTeX new definitions" $WORK/$nwfile.nw | \
    cpif $DOCS/defs.tex ;
notangle -R"HIDE: TODO" $WORK/$nwfile.nw | cpif $DOCS/todo.tex ; 
@ 

<<weaving>>=
<<BASH shebang>>
# weaving and LaTeXing
<<BASH Environment Variables>>
<<tangling complementary LaTeX files>>
noweave -v -t4 -delay -x -filter 'elide "HIDE: *"' \
        $WORK/$nwfile.nw | cpif $DOCS/$nwfile.tex ;
# noweave -t4 -delay -index $WORK/$nwfile.nw > $DOCS/$nwfile.tex 
pushd $DOCS/ ;
#
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
popd;
<<BASH script end>>
@ 

<<LaTeXing>>=
<<BASH shebang>>
# only LaTeXing
<<BASH Environment Variables>>
pushd $DOCS/ ;
#
echo "### RUNNING LaTeX on $nwfile.tex" 1>&2 ;
latex $nwfile.tex ; 
latex $nwfile.tex ; 
latex $nwfile.tex ;
dvips $nwfile.dvi -o $nwfile.ps -t a4 ;
#
# pdflatex $nwfile.tex ;
echo "### CONVERTING PS to PDF: $nwfile" 1>&2 ;
ps2pdf $nwfile.ps $nwfile.pdf ;
#
popd ;
<<BASH script end>>
@ %$


\subsctn{Defining working shell variables for the current project} % \\[-0.5ex]

<<tangling shell variables>>=
# 
# BASH Environment Variables
echo "# Running notangle on $nwfile.nw: .bash_VARS";
notangle -R'BASH Environment Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.bash_VARS ; 
echo "# Running notangle on $nwfile.nw: .project_VARS";
notangle -R'BASH Project Variables' $WORK/$nwfile.nw | \
         cpif $WORK/.project_VARS ;
# source $WORK/.bash_VARS ;
#
@

<<BASH Environment Variables>>=
#
# Setting Global Variables
# WORK is set by "setcwd"
WBIN="$WORK/bin" ;
WPARAM="$BIN/param" ;
WSRC="$WORK/src" ; # where to put the distributable files
DOCS="$WORK/docs" ;
DATA="$WORK/data" ;
TEST="$WORK/tests" ;
nwfile="humus" ;
export WBIN WPARAM WSRC DOCS DATA TEST nwfile ;
#
source $WORK/.project_VARS ;
@ 

<<BASH Project Variables>>=
#
umask 002 ;
#
BASE="/projects" ;
HUMUS="$BASE/H.sapiens" ;
BBIN="/usr/local/molbio/share/sgp" ;
BIN="$BBIN/bin" ;
MySQLPAR="$BBIN/mySQL" ;
LIBPERL="$BBIN/libperl" ;
LIBSTEP="$BBIN/libstep" ;
SRC="$BBIN/src" ;
export BASE HUMUS BBIN BIN MySQLPAR LIBPERL LIBSTEP SRC ;
#
<<BASH Variables: Perl>>
#
<<BASH Basic Shell Functions>>
<<BASH Functions: Filtering GENEID RAW Output>>
<<BASH Functions: Get Gene Number from GENEID Output>>
<<BASH Functions: Gene-Prediction Evaluation>>
#
@ 

<<BASH Basic Shell Functions>>=
#
# BASIC Shell Functions
#
function CheckDirs () {
  #
  # USAGE: ChckDirs <path_list>
  #
  for name in "$@" ;
    do {
         [ -d "$name" ] && 
           echo "### Directory Already Exist: $name" ||
             mkdir --verbose $name ;
      } ;
    done ;
}
#
function is_exec () {
  # USAGE: is_exec <filename_0>...<filename_N>
  for file in $@; do { [ -x $file ] || chmod a+x $file ; }; done
}
@

<<BASH Functions: Filtering GENEID RAW Output>>=
#
# Script from gparra to retrieve GFF annotation from geneid big output
geneid_raw2GFF ()
{
  # USAGE:  geneid_raw2GFF output_dir geneid_file
  # filtering geneid output (obtained with "-D" option -> default output+cDNA)
  PD=$1 ;
  /bin/rm -vf $PD/gff/* $PD/prot/* $PD/cds/* ;
  gawk 'BEGIN{ OFS="\t"; odir=ARGV[1]; ARGV[1]="" }
    { if ($2=="Sequence") seqname=$3;
      if ($2=="Gene") gene=$3;
      if (NF>8 && substr($1,1,1)!="#" && $1!="Annotation")
        print seqname,"geneid_v1.1",$1,$2,$3,$4,$5,$6,seqname"_"gene \
              > odir "/gff/" seqname"_"gene;
      if (substr($1,1,1)==">") {
        if (substr($1,length($1)-1,2)=="NN") {
          print ">"seqname"_"gene > odir "/cds/" seqname"_"gene;
          bol=1;
        } else if (substr($1,length($1)-1,2)=="AA") {
          print ">"seqname"_"gene > odir "/prot/" seqname"_"gene;
          bol=2;
        };
      } else {
        if (bol==1 && NF==1 && substr($1,1,1)!=">" ) 
          print $0 > odir "/cds/" seqname"_"gene;
      };
      if (bol==2 && NF==1 && substr($1,1,1)!=">" )
        print $0 > odir "/prot/" seqname"_"gene;
    }' $PD $2 ;
}
#
@

<<BASH Functions: Get Gene Number from GENEID Output>>=
#
# Counting gene number found in geneid output
get_geneid_genes ()
{
  #
  # USAGE: get_geneid_genes geneid_out.gff > gene_list.rpt
  #
  gawk '{
      genes[$9]++;
      if (genes[$9]>1) {
        min[$9] = $4<min[$9] ? $4 : min[$9] ;
        max[$9] = $5>max[$9] ? $5 : max[$9] ;
      } else {
        min[$9] = $4 ;
        max[$9] = $5 ;
        strand[$9] = $7;
      };
      len[$9]+=$5-$4+1
    }
    END {
      for (n in genes) {
        print n, min[n], max[n], strand[n], len[n],genes[n];
      };
    }
  ' $1 | sort +1n +2n -3 - ;
}
#
@

<<BASH Functions: Gene-Prediction Evaluation>>=
#
# PREPARING EVALUATION STUFF
export GENEIDVERSION="geneid v1.1" ;
#
run_evaluation ()
{
  #
  # USAGE:
  #     run_evaluation #chrom program param       prog_results_dir \
  #                    annotation_dir           testset  lenght
  # Ex: run_evaluation 22     geneid  Hsap.masked $ANALYSIS/geneid \
  #                    $DATASETS/annotation/all all ;
  #
  CHR="$1" ;
  prog="$2" ;
  PROG=`echo $prog | tr a-z A-Z` ;
  RUN="$3" ;
  BASE="$4" ;
  RESULTS="$BASE/gff/chr$CHR" ;
  SUBSET="$6" ;
  TESTSET="$5/chr$CHR" ;
  LENSEQ="$7";
  FINALTESTSET="/tmp/tmp$$" ;
  LONG_OUTPUT="$BASE/eval_$prog.$RUN.chr${CHR}_$SUBSET" ;
  SHORT_OUTPUT="$BASE/eval_${prog}_brief.$RUN.chr${CHR}_$SUBSET" ;
  GVER="------------------------- <${GENEIDVERSION}> -------------------------";
  # EVALUATION tool command-line options:
  #  -v: Verbose. Print all messages
  #  -a: Average. Print average stats (more than 1 sequence)
  #  -t: Total. Print total stats (more than 1 sequence)
  #  -s: Short. Print a short output
  # TEMPORAL FILE ADDING A RECORD WITH THE LENGHT OF THE SEQUENCE
  gawk "BEGIN{OFS=\"\t\";\
        print \"chr\"$CHR,1,\"Sequences\",1,$LENSEQ,\".\",\".\",\".\",1}\
        {print}" $TESTSET > /tmp/tmp$$;
  # /tmp/tmp$$ temporal file containing lenght+annotation gff records
  { echo "###" ; echo "### EVALUATION of $PROG RESULTS on CHR $CHR ($RUN)" ; echo "###" ;
    echo "### $LONG_OUTPUT" ; echo "###" ;
    echo "### "`whoami`" - "`date` ; echo "###" ;
    echo "### $GVER" ; echo "###" ; } > $LONG_OUTPUT ;
  $SGPBIN/evaluation -ta $RESULTS $FINALTESTSET >> $LONG_OUTPUT ;
  { echo "###" ; echo "### EVALUATION of $PROG RESULTS on CHR $CHR ($RUN)" ; echo "###" ;
    echo "### $SHORT_OUTPUT" ; echo "###" ;
    echo "### "`whoami`" - "`date` ; echo "###" ;
    echo "### $GVER" ; echo "###" ; } > $SHORT_OUTPUT ;
  $SGPBIN/evaluation -tsa $RESULTS $FINALTESTSET >> $SHORT_OUTPUT ;
}
#
@ 


\subsctn{Extracting code blocks for all the scripts}

Remember to set WORK variable at the very beggining, moving into the corresponding "[[/WORK/PATH/.../]]" directory and executing [[setcwd]] (a shell function that sets [[$WORK]] and sources [[.bash_VARS]]).

<<tangling>>=
#
# tangling all .*_VARS
notangle -R'tangling shell variables' $WORK/$nwfile.nw | bash ;
source $WORK/.bash_VARS ;
#
notangle -Rweaving  $WORK/$nwfile.nw | cpif $WORK/nw2tex ;
notangle -RLaTeXing $WORK/$nwfile.nw | cpif $WORK/ltx ;
is_exec $WORK/nw2tex $WORK/ltx;
#
# tangling all steps
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling steps'       $WORK/$nwfile.nw ; } | bash ;
# tangling all scripts
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling programs'    $WORK/$nwfile.nw ; } | bash ;
# tangling all param files
{ cat $WORK/.bash_VARS ;
  notangle -R'tangling param files' $WORK/$nwfile.nw ; } | bash ;
@ 

%
\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
