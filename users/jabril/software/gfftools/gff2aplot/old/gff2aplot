#!/bin/sh
######################################################################
#                            GFF2APLOT                               #
######################################################################
#
#    Converting alignments to PostScript dotplots with PiP box,
#    parsing GFF records to annotate sequence features on axes.
#
#     Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
#                                  Thomas WIEHE                   
#                                 Roderic GUIGO SERRA       
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################
#
# Creation Date: 10.01.1999
#
# Last Update:  
#
# $Id: gff2aplot,v 1.2 2000-01-24 13:18:24 jabril Exp $	
#
# Autor : Josep Francesc ABRIL FERRANDO
# e-mail: jabril@imim.es
#
#

##############################################################
#################### PROGRAM DEFINITIONS #####################
# 
T_start=`date +%s`;
TT_start=`date +%T`;
CMDLine=$0" "$*;
PID=$$;
CFDIR=`pwd`;
TEMP="/tmp";
  if [ $GFF2APLOT_TMP ];
    then
      if [ -d "$GFF2APLOT_TMP" ];      ###### Environment variable for temporary files directory.
        then
          TEMP="$GFF2APLOT_TMP";
        fi;
    fi;
PSHEAD=$TEMP/HEADPS.$PID;
PSMAIN=$TEMP/MAINPS.$PID;
GWKPRG=$TEMP/GAWKCODE.$PID;
GWKOPT=$TEMP/GAWKOPTS.$PID;

#
# To delete temporary files if program breaks...
trap "rm -f $GWKPRG $GWKOPT $PSHEAD $PSMAIN 2>/dev/null; exit 1"  0 1 2 3 9 15 ;

# 
# Defining Default Values...
#
Defaults () {
 # 
 # Constants: 
  PROGRAM="aplot";
  VERSION="v1.9";
  CREATIONDATE="1999/01/10"; # PSCREATION="1998/11/05"
  REVISION=`echo '$Revision: 1.2 $' | gawk '{print $2}'`
  DATERELEASE=`echo '$Date: 2000-01-24 13:18:24 $' | gawk '{print $2,$3}'`
  PSPROGRAM="PostScript Output from GFF2APLOT";
  AUTHOR="Josep Francesc ABRIL FERRANDO";
  EMAIL="jabril@imim.es";
  USAGE=$PROGRAM" [-h] [ ...(See available options with -h)... ] -- gff_files";
        # [-H <option>] 
        # [-S <Seq1Ori>][-E <Seq1End>][-s <Seq2Ori>][-e <Seq2End>] 
        # [-Z [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ] ]
        # [-z [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ] ]
        # [-A <SeqXName:SeqYName>] [-N <SeqXName>] [-n <SeqYName>]
        # [-T <MainTitle>][-t <SubTitle>][-X <X-AxesLabel>][-Y <Y-AxesLabel>] 
        # [-L <PercentBoxLabel>][-l <ExtraBoxLabel>] 
        # [-B <BGcolor>][-b <FGcolor>][-D <APLOTBGcolor>] 
        # [-C <PercentBoxBGcolor>][-c <ExtraBoxBGcolor>][-F <FunctionColor>]
        # [GgPpQqRrfMmWwv]
  COLORS="       Basic Colors: black white
       Variable Colors: grey magenta violet blue skyblue cyan seagreen green limegreen yellow orange red brown
       You can get five color shades from Variable Colors with \"verydark\", \"dark\", \"light\" and \"verylight\" prefixes.
         An example: verydarkseagreen darkseagreen seagreen lightseagreen verylightseagreen";
  PAGES="       From A0 to A10, from B0 to B10, 10x14, executive, folio, ledger, legal, letter, quarto, statement and tabloid.";
 # 
 # Default User-Defined Options: 
  bgcolor="white";
  fgcolor="black";

  v01="##dflt##";n01="SEQUENCE1_ORIGIN";
  v02="##dflt##";n02="SEQUENCE1_END";
  v03="##dflt##";n03="SEQUENCE2_ORIGIN";
  v04="##dflt##";n04="SEQUENCE2_END";
  v05="##dflt##";n05="ZOOM_Zoom";
      v25="##dflt##";n25="Zoom_Marks";
      v28="##dflt##";n28="Zoom_SEQUENCE1_ORIGIN";
      v29="##dflt##";n29="Zoom_SEQUENCE1_END";
      v30="##dflt##";n30="Zoom_SEQUENCE2_ORIGIN";
      v31="##dflt##";n31="Zoom_SEQUENCE2_END";
  v06="##dflt##";n06="ZOOM_Area";
  v07="##dflt##";n07="Display_GRID";
  v08="##dflt##";n08="Display_PERCENT-BOX";
  v09="##dflt##";n09="Display_EXTRA-BOX";
  v10="##dflt##";n10="TITLE";
      v39="##dflt##";n39="Display_TITLE";
  v11="##dflt##";n11="SUBTITLE";
      v40="##dflt##";n40="Display_SUBTITLE";
  v12="##dflt##";n12="X-Axis_LABEL";
  v13="##dflt##";n13="Y-Axis_LABEL";
  v14="##dflt##";n14="Percent-Box_LABEL";
  v15="##dflt##";n15="Extra-Box_LABEL";
  v16="##dflt##";n16="XY_AXES_Same-SIZE";
  v17="##dflt##";n17="Display_FUNCTION";
      v35="##dflt##";n35="Function_COLOR";
  v18="##dflt##";n18="APlotLine_ScaleWidth";
      v26="##dflt##";n26="APlotLine_GroupScore";
  v19="##dflt##";n19="APlotLine_ScaleGrey";
      v27="##dflt##";n27="APlotLine_GroupScore";
  v20="##dflt##";n20="BACKGROUND_COLOR";
  v21="##dflt##";n21="FOREGROUND_COLOR";
  v22="##dflt##";n22="APlotBox_BGCOLOR";
  v23="##dflt##";n23="PercentBox_BGCOLOR";
  v24="##dflt##";n24="ExtraBox_BGCOLOR";
  v33="##dflt##";n33="Display_GFF";
  v34="##dflt##";n34="Display_GFF-ReverseOrder";
  v36="##dflt##";n36="Align_NAME";
  v37="##dflt##";n37="X-Sequence_NAME";
  v38="##dflt##";n38="Y-Sequence_NAME";
  v41="##dflt##";n41="PAGE_SIZE";
  # v42="##dflt##";n42="Page_Orientation";
  # v43="##dflt##";n43="CONFIG_FILE";
  v42="F"; n42="Show_Ribbons";

  if [ $GFF2APLOT_CFDIR ];
    then
      if [ -d "$GFF2APLOT_CFDIR" ];      ###### Environment variable for custom file directory.
        then
          CFDIR="$GFF2APLOT_CFDIR";
        fi; # else CFDIR=="./"
    fi;
  v95=0; n95="Exist_CustomFile";
  if [ $GFF2APLOT_CUSTOMFILE ];         ###### Environment variable for default custom file name.
    then
      v96="$CFDIR/$GFF2APLOT_CUSTOMFILE";
    else
      v96="$CFDIR/.gff2aplotrc";
    fi;
    n96="CustomFile_Name";

  v97=1; n97="Show_Credits";
  v98=0; n98="Print_Report";
  v99=1; n99="Quiet_Mode";

  APLOToptions=""; P="";
  getzoom=0;
  xtron=1;
} # End of Defaults

#
# Defining Custom File...
#
WriteCustomFile () {
cat <<'@@@Custom@@@' >$v96
## ########################################################################## ##
##                                                                            ##
##                  USER CUSTOMIZATION FILE FOR GFF2APLOT                     ##
##                                                                            ##
## ########################################################################## ##
##
## This is the file in which you can define
##   the OPTIONS and FEATURES required by gff2aplot program.
## 
## If you want to modify this file, please, do not
##   forget to make a backup copy of your old file 
##   (like .gff2aplot.rc.old or .gff2aplot.rc.bck).
##
## Creation Date: 27.01.99
## Last Revision: 20.04.99
##
## Creator: Josep Francesc ABRIL FERRANDO
##
##  e-mail:        jabril@imim.es
##
## ########################################################################## ##
## #################### OPTIONS for gff2aplot PROGRAM ##################### ##
## ########################################################################## ##
##
FL ########################################################################## ##
## #################################### FLAGs ############################### ##
##
## You could set FLAG variables to:
##       0/OFF/NO/N/FALSE/F - Switch OFF
##       1/ON/YES/Y/TRUE/T  - Switch ON
##
## Variable ############# Switch ############
##
Display_TITLE             : Y
Display_SUBTITLE          : Y
Display_X-Axis_LABEL      : Y
Display_Y-Axis_LABEL      : Y
Display_Percent-Box_LABEL : Y
Display_Extra-Box_LABEL   : Y
Display_PERCENT-BOX       : N
Display_EXTRA-BOX         : N
Display_GENE_LABEL        : Y
Display_GENE_RULE         : Y
Display_HalfHeightBOX     : Y
Display_FullHeightBOX     : Y
Display_BOX_LABEL         : Y
Display_UserDef_BOX_LABEL : Y
Display_ARROW             : Y
Display_JOINS             : Y
Display_RIBBON            : Y
Display_SELECTION-BOX     : Y
Display_GFF               : N
Display_GFF-ReverseOrder  : N
Display_FUNCTION          : N
APlotLine_GroupScore      : N
APlotLine_ScaleWidth      : N
APlotLine_ScaleGrey       : N
XY_AXES_Same-SIZE         : N
Display_TickMark-LABEL    : Y
Display_APlot_X-Ticks     : Y
Display_Percent_X-Ticks   : Y
Display_ExtraBox_X-Ticks  : Y
Display_APlot_Y-Ticks     : Y
Display_Percent_Y-Ticks   : Y
Display_ExtraBox_Y-Ticks  : Y
Display_OnlyLower_X-Ticks : N
Display_GRID              : N
ZOOM_Zoom                 : N
ZOOM_Area                 : N
Zoom_Marks                : N
##
DF ########################################################################## ##
## ############################# DEFAULT VALUES ############################# ##
##
## Some Default Values...
##
## Variable ######## Definition ######## 
##
PAGE_SIZE               :  a4
FEATURE_LABELS_LENGTH   :  0     # Number of chars displayed in labels (0 means show full label string).
GROUP_LABELS_LENGTH     :  0     # Number of chars displayed in labels (0 means show full label string).
FEATURE_X-LABELS_ANGLE  :  0     # In degrees.
GROUP_X-LABELS_ANGLE    :  0     # In degrees.
FEATURE_Y-LABELS_ANGLE  :  0     # In degrees.
GROUP_Y-LABELS_ANGLE    :  0     # In degrees.
FEATURE_LABELS_FONTSIZE :  1     # Font size scale Factor.
GROUP_LABELS_FONTSIZE   :  1     # Font size scale Factor.
BACKGROUND_COLOR        : white
FOREGROUND_COLOR        : black
APlotBox_BGCOLOR        :  BG
PercentBox_BGCOLOR      :  BG
ExtraBox_BGCOLOR        :  BG
Strand-Arrows_COLOR     :  FG
Join-Lines_COLOR        :  FG
SelectionBox_BGCOLOR    : grey
Function_COLOR          : red
Zoom_Area_Mark_COLOR    : lightred
PERCENT_ORIGIN          :  50
PERCENT_END             : 100
ScaleMajorTICKMARK      :   2    # major tickmarks per axis.
ScaleMinorTICKMARK      :   5    # minor tickmarks per each major.
PercentMajorTICKMARK    :   5    # major tickmarks per axis.
PercentMinorTICKMARK    :   5    # minor tickmarks per each major.
ExtraMajorTICKMARK      :   2    # major tickmarks per axis.
ExtraMinorTICKMARK      :   5    # minor tickmarks per each major.
##
OP ########################################################################## ##
## #################################### OPTIONs ############################# ##
##
## Changing default values overrides any other definition you made for features.
##
##   ##DEFAULT##  means that program uses for these options
##                those values you have defined in feature table.
##         FG    the option is defined with FOREGROUND_COLOR.
##         BG    the option is defined with BACKGROUND_COLOR.
##
## Variable ######## Definition ######## 
##
Align_NAME            : ##DEFAULT##
X-Sequence_NAME       : ##DEFAULT##
Y-Sequence_NAME       : ##DEFAULT##
TITLE                 : ##DEFAULT##
SUBTITLE              : ##DEFAULT##
X-Axis_LABEL          : ##DEFAULT##
Y-Axis_LABEL          : ##DEFAULT##
Percent-Box_LABEL     : ##DEFAULT##
Percent-Box_SUBLABEL  : ##DEFAULT##
Extra-Box_LABEL       : ##DEFAULT##
Extra-Box_SUBLABEL    : ##DEFAULT##
HalfSizeBox_BGCOLOR   : ##DEFAULT##
FullSizeBox_BGCOLOR   : ##DEFAULT##
Ribbon_BGCOLOR        : ##DEFAULT##
SEQUENCE1_ORIGIN      : ##DEFAULT##
SEQUENCE1_END         : ##DEFAULT##
SEQUENCE2_ORIGIN      : ##DEFAULT##
SEQUENCE2_END         : ##DEFAULT##
Zoom_SEQUENCE1_ORIGIN : ##DEFAULT##
Zoom_SEQUENCE1_END    : ##DEFAULT##
Zoom_SEQUENCE2_ORIGIN : ##DEFAULT##
Zoom_SEQUENCE2_END    : ##DEFAULT##
TICKMARK              : ##DEFAULT##
SMALLTICKMARK         : ##DEFAULT##
##
FT ########################################################################## ##
## #################################### GFF FEATUREs DEFINITION ############# ##
## 
## ########### Description of each element of the Features Array. ########### ##
##
## (str) means a string of chars (in a string numbers are treated as chars).
## (bin) means you only could define variable as
##       0/OFF/NO/N/FALSE/F = Switch OFF the element.
##       1/ON/YES/Y/TRUE/T  = Switch ON  the element.
## (FHN) means you can choose between "(F)ull" or "(H)alf" size Boxes,
##       also you can define "(N)one", then the feature is without a box.
## (NLRB) means you can choose among "(N)o lines", "draw (L)ines at <feature>
##       boundaries", "(R)ibbons" or "(B)oth -Lines and Ribbons".
## (HND) means "(H)alfSize", "(N)ormalSize" or "(D)oubleSize" LineWidth.
##
## (clr) means that you can choose among the following color names:
##
##    black | verydarkgrey | darkgrey | grey | lightgrey | verylightgrey | white
##       verydarkgreen | darkgreen | green | lightgreen | verylightgreen
##   verydarkskyblue | darkskyblue | skyblue | lightskyblue | verylightskyblue
##          verydarkblue | darkblue | blue | lightblue | verylightblue
##         verydarkcyan | darkcyan | cyan | lightcyan | verylightcyan
##     verydarkviolet | darkviolet | violet | lightviolet | verylightviolet
##            verydarkred | darkred | red | lightred | verylightred
##     verydarkorange | darkorange | orange | lightorange | verylightorange
##     verydarkyellow | darkyellow | yellow | lightyellow | verylightyellow
##        verydarkbrown | darkbrown | brown | lightbrown | verylightbrown 
##
##       If you do not want to define a color, you can enter
##        BG (background color) or FG (foreground color), 
##        but you must choose one of the above definitions.
## 
## ## 
## Feature (str): A feature name. Only <features> defined below
##    will be recognized in your .gff file.
## ## 
## XTR (bin): Force those <features> for which XTR is switched ON
##   to be displayed in the third panel, if the Plot Option 
##   "Display_EXTRA-BOX" is switched ON.
## ## 
## Box (FHN): Define the box size (FHN) for <feature>.
## ##
## Line (NLRB): Draw lines across all panels for the <feature>.
## ##
## Join (bin): Switch ON to connect elements of one group with splice symbols.
## ##
## Arrw (bin): Swicth ON to display an arrow that shows the <feature>'s strand.
## ##
## Lbl (bin): Swicth ON to display the <feature>'s label
##   (if it's defined in the .gff file).
## ##
## Color (clr): Fill <Box> with this color.
## ##
## CLine (clr): Fill Line <Ribbons> with this color.
## ##
## Wdth (HND): You can choose among three predefined LineWidths.
## ##
## Layr : Layer where is drawed each feature.
##   You must pass an integer for feature ordering (1..n),
##   put 0 to print the feature always on top. 
## ##
##  
## ########################## Features Definition ################################ ##
## Feature  #XTR #Box #Line#Join#Arrw#Lbl #Wdth#Layr#Color ###########CLine #########
##
intron        N    H    N    N    N    N    H    4    lightgrey        BG           
exon          N    F    R    Y    Y    Y    H    0    red              lightgrey    
#altexon       N    F    R    Y    Y    Y    H    1    orange           lightgrey     ## alternative splice-exon.
cdexon        N    F    L    Y    Y    Y    H    1    darkred          BG           
ncdexon       N    F    L    Y    Y    Y    H    1    lightred         BG           
utr           N    F    L    Y    N    Y    H    3    lightred         BG           
3'-utr        N    F    L    Y    N    Y    H    3    lightred         BG           
5'-utr        N    F    L    Y    N    Y    H    3    lightred         BG           
est           Y    H    N    Y    N    N    H    4    darkgreen        BG           
3'-est        Y    H    N    Y    N    N    H    4    orange           BG           
5'-est        Y    H    N    Y    N    N    H    4    orange           BG           
gap           N    N    L    N    N    N    D    6    black            BG           
cpg           N    N    R    N    N    Y    H    6    yellow           lightyellow  
sine          N    N    R    N    N    N    H    6    BG               verylightgreen
line          N    N    R    N    N    N    H    6    BG               verylightgreen
alu           N    N    R    N    N    N    H    6    BG               lightgreen   
repeat        N    N    R    N    N    N    H    6    BG               verylightgreen
## ######1#########2#########3#########4#########5#########6#########7#########8#####
##  
SP ########################## Special gff Features ############################### ##
##
# GENELIMITS : genebounds
PLOTLIMITS : seqbounds                                             
APLOT      : align
HIGHLIGHT  : boxit
RECTANGLE  : rectangle
CIRCLE     : circle
TEXT       : text
FUNCTION   : function
EXTRABOX   : est
## ######1#########2#########3#########4#########5#########6#########7#########8#####
@@@Custom@@@
}

#  
# Default ColorDefinition:
#
colorDef () { # still not defined seagreen and limegreen (now same as green)
cat <<'@@@COLORS@@@'
%
% COLORS.gff2ps,v 1.3 1999/12/14 09:20:05 jabril Exp jabril
%
% black+grey+white
black               0.00 0.00 0.00 1.00
verydarkgrey        0.00 0.00 0.00 0.80
darkgrey            0.00 0.00 0.00 0.60
grey                0.00 0.00 0.00 0.40
lightgrey           0.00 0.00 0.00 0.20
verylightgrey       0.00 0.00 0.00 0.10
white               0.00 0.00 0.00 0.00
% magenta
verydarkmagenta     0.00 1.00 0.00 0.30
darkmagenta         0.00 0.80 0.00 0.05
magenta             0.00 0.60 0.00 0.00
lightmagenta        0.00 0.40 0.00 0.00
verylightmagenta    0.00 0.20 0.00 0.00
% violet
verydarkviolet      0.45 0.85 0.00 0.00
darkviolet          0.30 0.65 0.00 0.00
violet              0.22 0.55 0.00 0.00
lightviolet         0.15 0.40 0.00 0.00
verylightviolet     0.10 0.20 0.00 0.00
% blue
verydarkblue        1.00 1.00 0.00 0.20
darkblue            0.90 0.90 0.00 0.00
blue                0.75 0.75 0.00 0.00
lightblue           0.50 0.50 0.00 0.00
verylightblue       0.30 0.30 0.00 0.00
% skyblue
verydarkskyblue     0.90 0.50 0.00 0.15
darkskyblue         0.75 0.45 0.00 0.00
skyblue             0.60 0.38 0.00 0.00
lightskyblue        0.45 0.25 0.00 0.00
verylightskyblue    0.30 0.15 0.00 0.00
% cyan
verydarkcyan        1.00 0.00 0.00 0.10
darkcyan            0.80 0.00 0.00 0.00
cyan                0.60 0.00 0.00 0.00
lightcyan           0.40 0.00 0.00 0.00
verylightcyan       0.20 0.00 0.00 0.00
% seagreen
verydarkseagreen    0.75 0.00 0.45 0.00
darkseagreen        0.62 0.00 0.38 0.00
seagreen            0.50 0.00 0.30 0.00
lightseagreen       0.38 0.00 0.22 0.00
verylightseagreen   0.25 0.00 0.15 0.00
% green
verydarkgreen       1.00 0.00 1.00 0.25
darkgreen           0.80 0.00 0.80 0.00
green               0.60 0.00 0.60 0.00
lightgreen          0.40 0.00 0.40 0.00
verylightgreen      0.20 0.00 0.20 0.00
% limegreen
verydarklimegreen   0.50 0.00 1.00 0.10
darklimegreen       0.40 0.00 0.95 0.00
limegreen           0.30 0.00 0.80 0.00
lightlimegreen      0.20 0.00 0.65 0.00
verylightlimegreen  0.10 0.00 0.50 0.00
% yellow
verydarkyellow      0.00 0.00 1.00 0.25
darkyellow          0.00 0.00 1.00 0.10
yellow              0.00 0.00 1.00 0.00
lightyellow         0.00 0.00 0.50 0.00
verylightyellow     0.00 0.00 0.25 0.00
% orange
verydarkorange      0.00 0.50 0.80 0.10
darkorange          0.00 0.40 0.80 0.00
orange              0.00 0.30 0.80 0.00
lightorange         0.00 0.20 0.75 0.00
verylightorange     0.00 0.15 0.70 0.00
% red
verydarkred         0.00 1.00 1.00 0.15
darkred             0.00 0.80 0.80 0.00
red                 0.00 0.60 0.60 0.00
lightred            0.00 0.40 0.40 0.00
verylightred        0.00 0.20 0.20 0.00
% brown
verydarkbrown       0.35 0.85 1.00 0.40
darkbrown           0.30 0.70 1.00 0.35
brown               0.25 0.75 1.00 0.25
lightbrown          0.20 0.60 0.70 0.15
verylightbrown      0.15 0.45 0.55 0.00
@@@COLORS@@@
} # End of colorDef

##############################################################
################### SHELL MAIN FUNCTIONS #####################
#
# Defining Help...
#
Help () {
#  echo ""
#  echo "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
#  echo "         1         2         3         4         5         6         7         8"
  echo "";
  echo "NAME           $PROGRAM";
  echo "VERSION        $VERSION";
  echo "";
  echo "Creation DATE: $CREATIONDATE";
  echo "Last REVISION: $DATERELEASE";
  echo "";
  echo "SYNOPSIS";
  echo "";
  echo "      $USAGE";
  echo "";
  echo "DESCRIPTION";
  echo "";
  echo "       This program draws color-filled DotPlots";
  echo "       from files with gff-formatted data fields.";
  echo ""; echo "";
  echo "OPTIONS";
  echo "";
  echo "     -h  Show this help.";
  echo "     -H <option> Show only help for the especified option.";
  echo "     -S <pos>   Sets X-axes first nucleotide (for SEQUENCE1_ORIGIN).";
  echo "     -E <pos>   Sets X-axes last  nucleotide (for SEQUENCE1_END)." 
  echo "     -s <pos>   Sets Y-axes first nucleotide (for SEQUENCE2_ORIGIN).";
  echo "     -e <pos>   Sets Y-axes last  nucleotide (for SEQUENCE2_END).";
  echo "        -S -E -s -e are optionals, if you do not specify any of them, <pos> are taken from gff files."; 
  echo "     -Z [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ] ";
  echo "        -Z makes a zoom of the area you have selected with -S,-E,-s,-e (all 4 are optional).";
  echo "        [-S <pos>]   Sets X-axes first nucleotide (for -Z SEQUENCE1_ORIGIN).";
  echo "        [-E <pos>]   Sets X-axes last  nucleotide (for -Z SEQUENCE1_END).";
  echo "        [-s <pos>]   Sets Y-axes first nucleotide (for -Z SEQUENCE2_ORIGIN).";
  echo "        [-e <pos>]   Sets Y-axes last  nucleotide (for -Z SEQUENCE2_END).";
  echo "     -z [ [-S <pos>] [-E <pos>] [-s <pos>] [-e <pos>] ] ";
  echo "        -z remarks a zoom area on your plot, but does not make a zoom.";
  echo "        [-S <pos>]   Sets X-axes first nucleotide (for -z SEQUENCE1_ORIGIN).";
  echo "        [-E <pos>]   Sets X-axes last  nucleotide (for -z SEQUENCE1_END).";
  echo "        [-s <pos>]   Sets Y-axes first nucleotide (for -z SEQUENCE2_ORIGIN).";
  echo "        [-e <pos>]   Sets Y-axes last  nucleotide (for -z SEQUENCE2_END).";
  echo "     -G   Switches on Grid (if it is disabled on your custom file).";
  echo "     -g   Switches off Grid (if it is enabled on your custom file).";
  echo "     -P   Switches on Percent Box (if it is disabled on your custom file).";
  echo "     -p   Switches off Percent Box (if it is enabled on your custom file).";
  echo "     -Q   Switches on Extra Box (if it is disabled on your custom file).";
  echo "     -q   Switches off Extra Box (if it is enabled on your custom file).";
  echo "     -A <SeqXName:SeqYName>   Defining which alignment is going to be plotted if you have more than one alignment in your gff files.";
  echo "     -N <SeqXName>   Defining which sequence is going to be plotted at X-axes.";
  echo "     -n <SeqYName>   Defining which sequence is going to be plotted at Y-axes.";
  echo "     -T <Title>   Definning Plot Title.";
  echo "     -t <Subtitle>   Definning Plot SubTitle.";
  echo "     -X <X-Label>   Definning X-Axis Label.";
  echo "     -Y <Y-Label>   Definning Y-Axis Label.";
  echo "     -L <PBox-Label>   Definning Percent-Box Label.";
  echo "     -l <XBox-Label>   Definning Extra-Box Label.";
  echo "     -R   X and Y axes having same plot lenght (if XY_AXES_Same-SIZE disabled on your custom file).";
  echo "     -r   X and Y axes having same scale factor (if XY_AXES_Same-SIZE enabled on your custom file).";
  echo "     -F <color>   Displays FUNCTION at Extra-Box with <color> line.";
  echo "     -f   Displays FUNCTION at Extra-Box.";
  echo "     -M   Displays GFF features assigned to Extra-Box (down to up).";
  echo "     -m   Displays GFF features assigned to Extra-Box on reverse order (up to down).";
  echo "     -W   Scaling score on width for Aplot Line.";
  echo "     -w   Scaling score on grey-scale color for Aplot Line.";
  echo "     -B <color>   BackGround Color.";
  echo "     -b <color>   ForeGround Color.";
  echo "     -D <color>   APlot Main-Box BackGround Color.";
  echo "     -C <color>   Percent Box BackGround Color.";
  echo "     -c <color>   Extra Box BackGround Color.";
  echo "     -K <ribbon_type> Force Ribbons for all features on axes: (N)one, (L)ines, (R)ibbons, (B)oth.";
  echo "     -O <Config_filename> Define configuration file name (default is \".gff2aplotrc\").";
  echo "     -I <page_size> Set page size for plot (default is a4).";
  # echo "     -i Rotate page to landscape (default is portrait).";
  echo "     -V Verbose mode, a full report is sent to standard error (default is only send Warnings).";
  echo "     -v Silent mode: Disable all warnings, no messages sent to standard error.";
  echo "     -a Switch off CopyRight line on plot.";
  echo "";
  echo "ENVIRONMENT VARIABLES";
  echo "";
  echo "   There are three environmental variables that can be set by users to their preferences:";
  echo "   + You can specify the path where GFF2APLOT can find the default files with the shell variable \"GFF2APLOT_CFDIR\". Default value is path where you are running GFF2APLOT.";
  echo "   + You can also define the default custom filename you will like with the variable \"GFF2APLOT_CUSTOMFILE\", program default filename for custom file is \".gff2aplotrc\".";
  echo "   + GFF2APLOT needs to write few temporary files in a directory with permissions for current user to read and write. Default temporary directory path is set to \"/tmp/\" but you can assign a different temporary directory path using the variable \"GFF2APLOT_TMP\".";
  echo "   + Setting those vars in Bourne-shell and C-shell:";
  echo "     o Using a Bourne-Shell (e.g. bash):";
  echo "           export GFF2APLOT_CFDIR=\"path\"";
  echo "           export GFF2APLOT_CUSTOMFILE=\"file_name\"";
  echo "           export GFF2APLOT_TMP=\"path\"";
  echo "     o Using a C-Shell:";
  echo "           setenv GFF2APLOT_CFDIR \"path\"";
  echo "           setenv GFF2APLOT_CUSTOMFILE \"file_name\"";
  echo "           setenv GFF2APLOT_TMP \"path\"";
  echo "";
  echo "COMMENTS";
  echo "";
  echo "  * Colors defined are:";
  echo "";
  echo "$COLORS";
  echo "";
  echo "  * Page Sizes defined are:";
  echo "";
  echo "$PAGES";
  echo "";
  echo "BUGS";
  echo "";
  echo "  Please, report bugs to:";
  echo "       $AUTHOR";
  echo "       e-mail: $EMAIL";
  echo "";
  return 0;
} # End of Help

ShowHelpLine () {
 Help | gawk 'BEGIN{
  IGNORECASE=1; flg=0; srch=ARGV[1]; ARGV[1]=""
  gsub("-","",srch); srch="\ -"srch"\ " }
  { if ($0~srch) { print $0; flg=1 } }
  END{ if (!flg) printf "\n\tERROR: Option %s is not defined,\n\t\tmake sure which option you need help.\n",srch }' $1;
 echo "";
 return 0;
} # End of ShowHelpLine

##############################################################
################# POSTSCRIPT MAIN FUNCTIONS ##################
#
# Printing PostScript Prolog (Constants,Variables and Functions)...
{
cat <<'@@@EndProlog@@@'
%
%         Converting GFF files for an alignment to PostScript.
%
%          Copyright (C) 1999 - Josep Francesc ABRIL FERRANDO  
%                                       Thomas WIEHE                   
%                                      Roderic GUIGO SERRA       
%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
% ------------------------------------------------------------------------
%
%
%%BeginProlog
%
%%BeginProcSet: ShortNames 1.0 0
/tflg false def % test flag
/bdf { bind def } bind def
/xdf { exch def } bdf
/cm { 28.35 mul } bdf
/ivcm { 28.35 div } bdf
/in { 72    mul } bdf
%%EndProcSet:   ShortNames 1.0 0
%
%%BeginProcSet: Constants 1.0 0
% Printing Offset
/VUpOS 0.25 cm def  % offset defines non printable
/VDnOS 0.25 cm def  % paper area for pages (printer outlimits).
/HLtOS 0.25 cm def
/HRtOS 0.25 cm def
% /pgA4 { 595 842 } def
@@@EndProlog@@@
#
colorDef | gawk 'BEGIN{ i=0 }
 { if ($1!="%") { count[i++]=$1; C[$1]=$2; M[$1]=$3; Y[$1]=$4; K[$1]=$5 } }
 END {
  printf "%% Fixed Color Variables (CMYK)\n";
  # printf "/colordict %s dict def colordict begin %% %s colors + 28 definitions\n", (i+28), i;
  for (j=0;j<i;j++) { n=count[j]; printf "/%-20s { %-4s %-4s %-4s %-4s } def\n", n,C[n],M[n],Y[n],K[n] }
  # printf "end %% colordict\n"
 }' - 
#
cat <<'@@@EndGolorp@@@'
/htag   0 def
/Xmarg  5.0 cm def       % Starting Point (upper left corner)
/Ymarg  842 2 cm sub def
/Y Ymarg def
/PlotWidth  14 cm def    % Blocks Size
/Spacer   1.00 cm def    % BBox relative to dotplot
/BBoxX  PlotWidth def    % SBox relative to percent box
/BBoxY   14.00 cm def    % XBox relative to extra box
/SBoxX  PlotWidth def
/SBoxY    2.25 cm def
/XBoxX  PlotWidth def
/XBoxY    3.00 cm def
/WBox     0.50 cm def    % TagBox Size
/HWBox WBox 2 div    def
/Warw  WBox 0.75 mul def
/HWarw Warw 2 div    def
@@@EndGolorp@@@
} >$PSHEAD
#### End of MAINPSHEADER function #### 

#
# Printing Main PostScript Routines... 
cat <<'@@@MAINProcs@@@' >$PSMAIN
%%EndProcSet:   Setting_Vars 1.0 0
%
/TitleFont    { 24 /Times-Bold  } def
/SubTtFont    { 16 /Times-Roman } def
/ElmFont      { 12 FTLbsc mul /Times-Roman } def
/TagFont      { 14 GPLbsc mul /Times-Roman } def
/TagLabelFont { 16 /Times-Bold  } def
/TickFont     { 10 /Helvetica } def
%
/xBDspl  1.8 putExon add putExLbl add putGnLbl add def % 1.25
/xGLDspl 1.0 putExon add putExLbl add def              % 0.85
/xGDspl  0.75 putExon add putExLbl add def
/FBDspl 0.60 def % For example, for mRNA.
%
/vertical   { /htag 0 def } bdf
/horizontal { /htag 1 def } bdf
%
/FSF 4 def % Point size for Credits for A4
/CSF { pagedict begin pga4 pop end Dpage pop exch div mul } bdf
% End of user-defined variables...
%
%%BeginProcSet: Page_Layout 1.0 0
% checking if margins are within the defined offset
flglscape {
 UpM HLtOS lt { /UpM HLtOS def } if % Checking margins for flglscape mode
 DnM HRtOS lt { /DnM HRtOS def } if
 LtM VDnOS lt { /LtM VDnOS def } if
 RtM VUpOS lt { /RtM VUpOS def } if
 } {
  UpM VUpOS lt { /UpM VUpOS def } if % Checking margins for portrait mode
  DnM VDnOS lt { /DnM VDnOS def } if
  LtM HLtOS lt { /LtM HLtOS def } if
  RtM HRtOS lt { /RtM HRtOS def } if
  } ifelse
% defining pagelimits and X - Y scales (Xlim Ylim)
/pglim { Dpage pop LtM RtM add sub Dpage exch pop UpM DnM add sub } def
% Defining starting point on page.
/XORI LtM def
/YORI UpM def
%%EndProcSet:   Page_Layout 1.0 0
%
%%BeginProcSet: functions 1.0 0
/F { scale } bdf
/T { translate } bdf
/S { gsave } bdf
/R { grestore } bdf
/m { moveto } bdf
/rm { rmoveto } bdf
/l { lineto } bdf
/rl { rlineto } bdf
/K { stroke } bdf
/scmyk { setcmykcolor } bdf
/slw { setlinewidth } bdf
/bbox { 4 copy 3 1 roll exch 6 2 roll 8 -2 roll m l l l closepath } bdf
/dotted { [ 1 ] 0 setdash } def
%%EndProcSet:   functions 1.0 0
%
%%BeginProcSet: text_functions 1.0 0
/sfont { findfont exch scalefont setfont } bdf
/tshow { S scmyk sfont m rotate show R } bdf
/ctshow { 10 -1 roll dup 11 1 roll 7 -2 roll 2 copy 9 2 roll S sfont stringwidth pop R 2 div htag 1 eq { 9 -1 roll exch sub 8 1 roll } { 8 -1 roll exch sub 7 1 roll } ifelse tshow } bdf
/ltshow { 10 -1 roll dup 11 1 roll 7 -2 roll 2 copy 9 2 roll S sfont stringwidth pop R htag 1 eq { 9 -1 roll exch sub 8 1 roll } { 8 -1 roll exch sub 7 1 roll } ifelse tshow } bdf
%
% X Y angle string valign halign fnt color ttxt
 % valign : tv (top)  cv (middle) bv (bottom)
 % halign : lh (left) ch (center) rh (right)
/chrh { S newpath 0 0 m false charpath flattenpath pathbbox exch pop 3 -1 roll pop R } bdf
/strh { 2 dict begin /lly 0.0 def /ury 0.0 def { ( ) dup 0 4 -1 roll put chrh dup ury gt { /ury xdf } { pop } ifelse dup lly lt { /lly xdf } { pop } ifelse } forall ury end } bdf
/ttxt { S scmyk sfont 8 dict begin /h xdf /v xdf /lbl xdf /angle xdf /y xdf /x xdf /hs lbl stringwidth pop neg def /vs lbl strh neg def x y T angle rotate h (rh) eq { hs } { h (ch) eq { hs 2 div } { 0 } ifelse } ifelse v (tv) eq { vs } { v (cv) eq { vs 2 div } { 0 } ifelse } ifelse m lbl show end R } bdf
%
/Title { S 0 Xmarg Y TitleFont FGcolor tshow R /Y Y 0.75 cm sub def } bdf 
/SubTitle { S 0 Xmarg Y SubTtFont FGcolor tshow R /Y Y 2.5 cm sub def } bdf 
%%EndProcSet:   text_functions 1.0 0
%
%%BeginProcSet: aplotdict 1.0 0
/aplot 120 dict def aplot begin
/min { 2 copy gt { exch } if pop } bdf 
/max { 2 copy lt { exch } if pop } bdf
/Xscm { Xscale mul } bdf /Xscme { Xscm exch } bdf
/Yscm { Yscale mul } bdf /Yscme { Yscm exch } bdf
/fmt { Yscme Xscme m } bdf /flt { Yscme Xscme l } bdf
/line { scmyk slw m l K } bdf
/uline { scmyk slw m S htag 1 eq { 0 -0.1 cm } { 0.1 cm 0 } ifelse rl K R l S htag 1 eq { 0 -0.1 cm } { 0.1 cm 0 } ifelse rl K R K } bdf
/ZoomTicks { /zmdict 3 dict def zmdict begin /r { TxWB BDspl mul Xscm } def /s { TyWB BDspl mul Yscm } def /corner { S 10 -2 roll m 2 { rl S BGcolor scmyk .4 slw K R rl S FGcolor scmyk 2 slw [1 3] 0 setdash K R } repeat R } def 4 copy 3 1 roll exch 0 s 0 s neg r neg 0 r 0 corner 0 s neg 0 s r 0 r neg 0 corner 0 s neg 0 s r neg 0 r 0 corner 0 s 0 s neg r 0 r neg 0 corner end } def
/Line { S 9 5 roll 2 { Yscm 4 1 roll Xscm 4 1 roll } repeat 9 4 roll line R } bdf
/Xline { S 3 1 roll Xscme Xscme 3 -1 roll Yscm xwdt sub dup 3 1 roll xwdt 9 -4 roll line R } bdf
/Bline { S htag 1 eq { Xscme Xscme y0 Yscme y1 Yscm bbox } { Yscme Yscme X0 Xscm 3 1 roll X1 Xscme bbox } ifelse S scmyk fill R scmyk slw K R } bdf
/Bsquare { S Yscme Yscme 4 2 roll Xscme Xscme 4 1 roll exch bbox S scmyk fill R scmyk slw K R } bdf
/Msquare { S Yscme Yscme 4 2 roll Xscme Xscme 4 1 roll exch bbox scmyk slw K R } bdf
/Mcircle { S Yscme Xscme 3 -1 roll Xscm 0 360 arc closepath scmyk slw K R } bdf
/Join { S 2 copy 2 copy pop sub 2 div add exch htag 1 eq { y1 TyWB add dup dup TyWB 0.75 mul add 4 1 roll 5 1 roll } { X0 TxWB sub dup dup TxWB 0.75 mul sub 5 1 roll 6 1 roll exch } ifelse 3 { Yscme Xscme 6 2 roll } repeat m l l 0.25 slw scmyk K R } bdf
/Arrow { /acol [ 9 -4 roll ] def /acolor { acol aload pop } def S 1 eq { exch /sn { 1 mul } def } { /sn { 1 neg mul } def } ifelse htag 1 eq { Xscm dup y1 Yscm HWBox add m HWarw sn HWarw rl 0 Warw neg rl HWarw neg sn HWarw rl closepath S acolor scmyk fill R y1 Yscm HWBox add m Xscm y1 Yscm HWBox add l acolor scmyk 1 slw K } { Yscm dup X0 Xscm HWBox sub exch m HWarw neg HWarw sn rl Warw 0 rl HWarw neg HWarw neg sn rl closepath S acolor scmyk fill R X0 Xscm HWBox sub exch m Yscm X0 Xscm HWBox sub exch l acolor scmyk 1 slw K } ifelse R } bdf
/FBox { htag 1 eq { Xscme Xscme y1 Yscme y1 TyWB FBDspl mul add Yscm bbox } { Yscme Yscme X0 Xscm 3 1 roll X0 TxWB FBDspl mul sub Xscme bbox } ifelse S scmyk fill R FGcolor scmyk 1 slw K } bdf
/FTalgn { htag 1 eq { FTXangle 0 eq { (bv) (ch) } { (cv) (lh) } ifelse } { FTYangle 0 eq { (cv) (rh) } { (bv) (rh) } ifelse } ifelse } bdf
/GPalgn { htag 1 eq { GPXangle 0 eq { (bv) (ch) } { (cv) (lh) } ifelse } { GPYangle 0 eq { (cv) (rh) } { (bv) (rh) } ifelse } ifelse } bdf
/Box { 2 copy 2 copy pop sub 2 div add 7 1 roll S htag 1 eq { Xscme Xscme y1 Yscme y1 TyWB add Yscm bbox } { Yscme Yscme X0 Xscm 3 1 roll X0 TxWB sub Xscme bbox } ifelse S scmyk fill R FGcolor scmyk 1 slw K htag 1 eq { Xscm y1 TyWB 1.75 mul add Yscm FTXangle } { Yscm X0 TxWB 1.75 mul sub Xscme FTYangle } ifelse 6 -1 roll FTalgn 8 -2 roll FGcolor ttxt R } bdf
%
/GDmore { MxFtLBL S ElmFont sfont (M) stringwidth pop R mul htag 1 eq { FTXangle sin } { FTYangle cos } ifelse abs mul ivcm add } bdf
/BDmore { MxGpLBL S TagFont sfont (M) stringwidth pop R mul htag 1 eq { GPXangle sin } { GPYangle cos } ifelse abs mul ivcm add } bdf
%
/GnBanner{ S 1 eq { 2 copy htag 1 eq { Xscme Xscme y1 TyWB GDspl mul add dup Yscme Yscm 3 1 roll } { Yscme Yscme X0 TxWB GDspl mul sub dup Xscme Xscme 4 1 roll exch } ifelse 0.5 FGcolor uline } if 2 copy pop sub 2 div add htag 1 eq { Xscm y1 TyWB GLDspl mul add Yscm GPXangle } { Yscm X0 TxWB GLDspl mul sub Xscme GPYangle } ifelse 6 -1 roll GPalgn 8 -2 roll FGcolor ttxt R } bdf
/SbBanner { S htag 1 eq { 0 X0 X1 X0 sub 2 div add Xscm y1 TyWB GDspl mul add Yscm } { 90 X0 TxWB GDspl mul sub Xscm y0 y1 y0 sub 2 div add Yscm } ifelse 5 -2 roll FGcolor ctshow R } bdf
/Banner { S htag 1 eq { 0 X0 X1 X0 sub 2 div add Xscm y1 TyWB BDspl mul add Yscm } { 90 X0 TxWB BDspl mul sub Xscm y0 y1 y0 sub 2 div add Yscm } ifelse 5 -2 roll FGcolor ctshow R } bdf
%
% mxt mnt xp yp ori end htick
/tckdict 15 dict def tckdict begin /mkmxt { dup 0 lt { neg } if dup 10 lt { 10 mul log round 10 exch exp cvi } { log round 10 exch exp cvi } ifelse } def /nwmod { dup 1 le { 100 mul cvi exch 100 mul cvi exch mod 100 div } { exch dup 1 le { 100 mul cvi exch 100 mul cvi mod 100 div } { cvi exch cvi mod } ifelse } ifelse } def /isltone { dup 1 lt { 100 mul cvi 100 div } if } def end
/htick { S tckdict begin horizontal /yp exch Yscm def /xp exch Xscm def /xend xdf /xori xdf /nmnt exch cvi def /nmxt exch cvi def /mxt exch dup 0 lt { pop xend xori sub mkmxt } if def /mnt exch dup 0 lt { pop mxt nmnt div } if def /lori xori dup mnt nwmod sub mnt add def /lend xend dup mnt nwmod sub mnt sub def xp yp T lori mnt lend { isltone dup dup xori gt exch xend lt and { dup Xscm 0 m dup dup Xscme mxt nwmod 0 eq { 7.5 } { 4 } ifelse neg l 1 slw FGcolor scmyk K GridON 1 eq { S 0 y0 Yscm neg T dup Xscm dup y0 Yscm m y1 Yscm l 0.1 slw verylightgrey scmyk K R } if dup mxt nwmod 0 eq { dup xend mnt sub exch ge { dup dup 1 ge { cvi } if 10 string cvs 0 3 -1 roll Xscm -18 TickFont FGcolor ctshow } if } { pop } ifelse } if } for xori Xscm dup 0 m 7.5 neg l 2 slw FGcolor scmyk K xori 10 string cvs 0 xori Xscm ZoomON 1 eq { 4 sub } if -18 TickFont FGcolor ZoomON 0 eq { ctshow } { ltshow } ifelse xend Xscm dup 0 m 7.5 neg l 2 slw FGcolor scmyk K xend 10 string cvs 0 xend Xscm ZoomON 1 eq { 4 add } if -18 TickFont FGcolor ZoomON 0 eq { ctshow } { tshow } ifelse end R } def
/vtick { S tckdict begin vertical /yp exch Yscm def /xp exch Xscm def /xend xdf /xori xdf /nmnt exch cvi def /nmxt exch cvi def /mxt exch dup 0 lt { pop xend xori sub mkmxt } if def /mnt exch dup 0 lt { pop mxt nmnt div } if def /lori xori dup mnt nwmod sub mnt add def /lend xend dup mnt nwmod sub mnt sub def xp yp T lori mnt lend { isltone dup dup xori gt exch xend lt and { dup Yscm 0 exch m dup dup Yscme mxt nwmod 0 eq { 7.5 } { 4 } ifelse exch l 1 slw FGcolor scmyk K GridON 1 eq { S X0 Xscm 0 T dup Yscm dup X0 neg Xscme m X1 neg Xscme l 0.1 slw verylightgrey scmyk K R } if dup 0 eq { S dup dup X0 Xscme Yscm m X1 neg Xscme Yscm l 0.1 slw FGcolor scmyk K R } if dup mxt nwmod 0 eq { dup xend mnt sub exch ge { dup dup 1 ge { cvi } if 10 string cvs 0 10 4 -1 roll Yscm 2.5 sub TickFont FGcolor tshow } if } { pop } ifelse } if } for 7.5 xori Yscm dup 0 exch m l 2 slw FGcolor scmyk K xori 10 string cvs 0 10 xori Yscm ZoomON 0 eq { 2.5 sub } { 2.5 add } ifelse TickFont FGcolor tshow 7.5 xend Yscm dup 0 exch m l 2 slw FGcolor scmyk K xend 10 string cvs 0 10 xend Yscm ZoomON 0 eq { 2.5 sub } { 2.5 add } ifelse TickFont FGcolor tshow end R } def
/nucltick { tickmn tickmx maxtck mintck X0 X1 0 y0 htick } def
/pctmarks { S y0 10 y1 { Yscm dup X0 Xscm X1 Xscm 3 1 roll 4 1 roll 0.5 FGcolor line } for R } bdf
%
/beginfunct { R S 3 dict begin /maxx exch ceiling def /minx exch floor def /Yscale XBoxY maxx minx sub div def minx 0 lt { 0 minx neg Yscm T } if S XBYtickflg 1 eq { -1 -1 xtrmxt xtrmnt minx maxx X1 0 vtick } if R } def /endfunct { end R } def
end % aplot dict
%%EndProcSet:   aplotdict 1.0 0
%
%%BeginProcSet: main_function_calls 1.0 0
%
/s_credits { S 1 dict begin /fs_cd FSF def pagedict begin pga4 pop end 1 cm sub DnM T 0 0 0 (This plot has been obtained using GFF2APLOT. The most recent version of GFF2APLOT is freely available at \042http:\/\/www1.imim.es/\176jabril/\042. Copyright      1999 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO) (cv) (rh) fs_cd /Times-Roman FGcolor ttxt S fs_cd /Times-Roman sfont (   1999 by Josep F. ABRIL, Thomas WIEHE & Roderic GUIGO) stringwidth pop neg R 0 0 (\343) (cv) (ch) fs_cd /Symbol FGcolor ttxt end R } bdf
%
/estlbl { S 3 dict begin /lbl xdf /ypos xdf /xpos xdf horizontal 0 Xlwdt 4 div neg T lbl 0 xpos Xscm ypos Yscm 5 /Helvetica black ctshow vertical end R } bdf
%
/GsclonX { /Y exch Y Spacer sub exch sub def Xmarg Y T axesp 0 eq { /Xscale { BBoxX X1 X0 sub Y1 Y0 sub max div } def } { /Xscale { BBoxX X1 X0 sub div } def } ifelse } bdf
%
% DOTPLOT BOX
/begindata { aplot begin S /y1 Y1 def /y0 Y0 def BBoxY GsclonX axesp 0 eq { /Yscale Xscale def } { /Yscale { BBoxY y1 y0 sub div } def } ifelse /TxWB { WBox Xscale div } def /TyWB { WBox Yscale div } def /GDspl { xGDspl GDmore } def /GLDspl { xGLDspl GDmore } def /BDspl { xBDspl GDmore BDmore } def X0 Xscm neg y0 Yscm neg T S X0 Xscm y0 Yscm X1 Xscm y1 Yscm bbox BBoxcol scmyk fill R S X0 Xscm y0 Yscm X1 Xscm y1 Yscm ZoomON 1 eq { 4 copy ZoomTicks } if bbox 2 slw FGcolor scmyk K R S BBXtickflg 1 eq { nucltick /Spacer 1 cm def } { /Spacer 0.5 cm def } ifelse BBYtickflg 1 eq { tickmn tickmx maxtck mintck y0 y1 X1 0 vtick } if R newpath } def /enddata { R /GDspl xGDspl def /GLDspl xGLDspl def /BDspl xBDspl def end } def
%
% PERCENT BOX
/beginmatches { aplot begin /ZoomON 0 def S /y1 xdf /y0 xdf SBoxY GsclonX /Yscale SBoxY y1 y0 sub div def X0 Xscm neg y0 Yscm neg T S X0 Xscm y0 Yscm X1 Xscm y1 Yscm bbox S S SBoxcol scmyk fill R S SBoxLab TagLabelFont Banner SBoxSLab TagFont SbBanner SBXtickflg 1 eq { nucltick /Spacer 1 cm def } { /Spacer 0.5 cm def } ifelse R S SBYtickflg 1 eq { -1 -1 pctmxt pctmnt y0 y1 X1 0 vtick } if R S X0 Xscm y0 Yscm X1 Xscm y1 Yscm bbox 2 slw FGcolor scmyk K R R clip newpath } def /endmatches { R R end } def
%
% EXTRA BOX
/beginextra { aplot begin S /nlines xdf /y0 0 def XBoxY GsclonX /Yscale XBoxY nlines 1 add div def /Xlwdt Yscale 0.75 mul def /xwdt Yscale 2 div def /y1 XBoxY Yscale div def X0 Xscm neg 0 T S X0 Xscm y0 Yscm X1 Xscm y1 Yscm bbox S XBoxcol scmyk fill R S XBoxLab TagLabelFont Banner XBoxSLab TagFont SbBanner XBXtickflg 1 eq { nucltick } if R newpath } def /endextra { /Yscale XBoxY nlines 1 add div def X0 Xscm y0 Yscm X1 Xscm y1 Yscm bbox 2 slw FGcolor scmyk K R  R end } def
%
%%EndProcSet:   main_function_calls 1.0 0
%
%%EndProlog
%
%%BeginSetup
%
% initgraphics
% true setpacking
true setstrokeadjust
0.125 setlinewidth
0 setlinejoin
0 setlinecap
%
%%EndSetup
%
@@@MAINProcs@@@
#
#### End of MAINPSPROCS function

##############################################################
##################### SHELL FUNCTIONS ########################
#
# Testing parameters passed by User.
#
CheckColor () {
  gawk 'BEGIN{
    color=ARGV[1]
    if (tolower(color)!~/^((b|f)g(color)?|black|white|(very)?(light|dark)?(grey|(sea|lime)?green|(sky)?blue|cyan|violet|magenta|red|orange|yellow|brown))$/) {
      if (ARGV[4]) {
        printf "\n<<<<ERROR>>>> \" %s \" is not a defined color.\n", color | "cat 1>&2";
        printf "              Default \" ARGV[2] \" is asigned to this option.\n" | "cat 1>&2";
        printf "              You can choose one of this colors:\n" | "cat 1>&2";
        print ARGV[3] | "cat 1>&2";
        print "" | "cat 1>&2";
      }
      color=ARGV[2]
    } # if color
    print color
    ARGV[1]=ARGV[2]=ARGV[3]=ARGV[4]=""
    }' $1 $2 "$COLORS" $v99;
  return 0;
} # End of CheckColor

#
# Testing parameters passed by User: Integer Numbers.
CheckInt () {
  if [ `expr $1 : '[0-9]*'` -eq `expr $1 : '.*'` ];
    then
      echo "1"; return 0;
    elif [ $v99 -eq 1 ];
     then
      { echo "<<<<ERROR>>>> \" $1 \" is not an integer value.";
        echo "              You must especify an integer value to -$W_OPTION";
        echo "              Program will take value from defaults..."; echo ""; } 1>&2 ;
      echo "0"; return 1;
    else
      return 1;
    fi
} # End of CheckInt

#
# Checking ribbon parameters
CheckRBN () {
  k=$1;
  tk=`echo $k | sed 's/^[NnLlRrBb]$//'`;
  if [ -z "$tk" ];
    then echo $1;
    else echo "F";
  fi;
} # End of CheckRBN

#
# Testing if files exist.
ExistFile () {
  if [ ! -f "$1" -a ! -f "$CFDIR/$1" -a ! -f "./$1" ];
    then
      echo "0";
      if [ $v99 -eq 1 ];
        then 
          echo "Warning: File \"$1\" is empty or does not exist... Not Loaded!" 1>&2;
        fi;
      return 1;
    else
      echo "1"; # exist_file
      if [ $v99 -eq 1 ];
        then 
          echo "Report: File \"$1\" exist, included as GFF-file." 1>&2;
        fi;
      return 0;
    fi;
} # End of ExistFile

#
# Checking if custom file exist
#  else it is created.
ExistCustomfile () {
  if [ ! -f "$1" -a ! -f "$CFDIR/$1" -a ! -f "./$1" ];
    then
      echo 0;
      if [ $v99 -eq 1 ];
        then 
          { echo "Warning: Creating New Custom File...";
            WriteCustomFile;
            echo "         Your custom file is at: " $v96; } 1>&2
          # { echo "Warning: Default Custom File does not exist... Not Loaded!"; echo "" } 1>&2
        fi;
      return 0;
    else
      echo 1; # exist_default_customfile
      if [ $v99 -eq 1 ];
        then 
          { echo "Report: Default Custom File exist.";
            echo "        Using Custom Filename: ";
            echo "            $1"; echo ""; } 1>&2
        fi;
      return 1;
    fi;
} # End of ExistCustomfile

###################################################################
############### MAIN GFF2APLOT  SHELL SCRIPT ######################
###################################################################
############### CONVERTING GFF TO POSTSCRIPT ######################
###################################################################

Defaults;

#
# When no options, no parameters and 
#  no inputstream are given, print USAGE.
#
npar=$#;
if [ $npar -eq 0 ];
  then
    echo; echo $USAGE; echo; exit 1;
  fi;

#
# Asking for Help, output it to screen. 
#
case $1 in
  -h) (Help | more); exit 2;;
  -H) echo; echo $PROGRAM" : Option Definition Help."; echo;
      if [ $npar -gt 1 ]; 
        then shift; fi;
      for temp in $@;
        do ShowHelpLine $temp; done;
      exit 2;;
  esac;

#
# Processing all options and parameters passed to program.
#
while getopts :S:E:s:e:ZzGgPpQqT:t:X:Y:L:l:RrF:fA:N:n:MmWwB:b:D:C:c:K:O:I:iaVvHh W_OPTION;
  do
    case $W_OPTION in
      H|h) (Help | more); exit 2;;
       S) if [ `CheckInt $OPTARG` -eq 1 ];
           then
            if [ $getzoom -eq 0 ];
             then v01=$OPTARG;    # SEQUENCE1_ORIGIN
             else v28=$OPTARG;    # Zoom_SEQUENCE1_ORIGIN
             fi;
           fi;;
       E) if [ `CheckInt $OPTARG` -eq 1 ];
           then
            if [ $getzoom -eq 0 ];
             then v02=$OPTARG;    # SEQUENCE1_END
             else v29=$OPTARG;    # Zoom_SEQUENCE1_END
             fi;
           fi;;
       s) if [ `CheckInt $OPTARG` -eq 1 ];
           then
            if [ $getzoom -eq 0 ];
             then v03=$OPTARG;    # SEQUENCE2_ORIGIN
             else v30=$OPTARG;    # Zoom_SEQUENCE2_ORIGIN
             fi;
           fi;;
       e) if [ `CheckInt $OPTARG` -eq 1 ];
           then
            if [ $getzoom -eq 0 ];
             then v04=$OPTARG;    # SEQUENCE2_END
             else v31=$OPTARG;    # Zoom_SEQUENCE2_END
             fi;
           fi;;
       Z) v05=1;v25=1;getzoom=1;; # ZOOM_Zoom; Zoom_Marks
       z) v06=1;getzoom=1;;       # ZOOM_Area
       G) v07=1;;         # Display_GRID
       g) v07=0;;         # Display_GRID
       P) v08=1;;         # Display_PERCENT-BOX
       p) v08=0;;         # Display_PERCENT-BOX
       Q) v09=1;xtron=1;; # Display_EXTRA-BOX
       q) v09=0;xtron=0;; # Display_EXTRA-BOX
       T) v10=$OPTARG;v39=1;; # TITLE
       t) v11=$OPTARG;v40=1;; # SUBTITLE
       X) v12=$OPTARG;;   # X-Axis_LABEL
       Y) v13=$OPTARG;;   # Y-Axis_LABEL
       L) v14=$OPTARG;;   # Percent-Box_LABEL
       l) v15=$OPTARG;;   # Extra-Box_LABEL
       R) v16=1;;         # XY_AXES_Same-SIZE
       r) v16=0;;         # XY_AXES_Same-SIZE
       F) v35=`CheckColor $OPTARG $fgcolor`;
          v17=1;v09=1;;   # Function_COLOR;Display_FUNCTION; Display_EXTRA-BOX
       f) v17=1;v09=1;;   # Display_FUNCTION; Display_EXTRA-BOX
       M) v33=1;v09=1;;   # Display_GFF; Display_EXTRA-BOX
       m) v33=1;v34=1;v09=1;; # Display_GFF-ReverseOrder; Display_EXTRA-BOX
       W) v18=1;v26=1;;   # APlotLine_ScaleWidth; APlotLine_GroupScore
       w) v19=1;v27=1;;   # APlotLine_ScaleGrey; APlotLine_GroupScore
       B) v20=`CheckColor $OPTARG $bgcolor`;;  # BACKGROUND_COLOR
       b) v21=`CheckColor $OPTARG $fgcolor`;;  # FOREGROUND_COLOR
       D) v22=`CheckColor $OPTARG $bgcolor`;;  # APlotBox_BqGCOLOR
       C) v23=`CheckColor $OPTARG $bgcolor`;;  # PercentBox_BGCOLOR
       c) v24=`CheckColor $OPTARG $bgcolor`;;  # ExtraBox_BGCOLOR
       A) v36=$OPTARG;;   # Align_NAME
       N) v37=$OPTARG;;   # X-Sequence_NAME
       n) v38=$OPTARG;;   # Y-Sequence_NAME
       K) v42=`CheckRBN $OPTARG`;;   # Show_Ribbons (NLRB)
       I) v41=$OPTARG;;   # PAGE_SIZE
       O) v96=$OPTARG;;   # CustomFile_Name
     # i) v42="Landscape";; # Page_Orientation
       a) v97=0;;         # Show_Credits
       V) v98=1; v99=1;;  # Print_Report
       v) v99=0;;         # Quiet_Mode
       :)  ShowHelpLine $1; exit 2;;
      \?)  ShowHelpLine $1; exit 2;;
    esac # case $W_OPTION
  done   # while getopts
# Done GetOpts

#
# Shifting all options tested before,
# without removing files passed to shell...
incr=1;
while [ $OPTIND -gt $incr ];
  do shift; incr=`expr $incr + 1`; done;

#
# Report Command Line
if [ $v99 -eq 1 ];
  then 
    { echo "********************************************";
      echo "*  Running $PROGRAM $VERSION";
      echo "********************************************"; echo "";
      echo "Report: You have typed the following command line:"; echo "";
      echo $CMDLine; echo "";
      if [ -n "$GFF2APLOT_CFDIR" -o -n "$GFF2APLOT_CUSTOMFILE" -o -n "$GFF2APLOT_TMP" ];
        then
          echo "Report: You have defined the following $PROGRAM Shell-Vars:"; echo "";
          if [ $GFF2APLOT_CFDIR ];      then echo "        \$GFF2APLOT_CFDIR      = \"$GFF2APLOT_CFDIR\""; fi;
          if [ $GFF2APLOT_CUSTOMFILE ]; then echo "        \$GFF2APLOT_CUSTOMFILE = \"$GFF2APLOT_CUSTOMFILE\""; fi;
          if [ $GFF2APLOT_TMP ];        then echo "        \$GFF2APLOT_TMP        = \"$GFF2APLOT_TMP\""; fi;
          echo "";
        fi; } 1>&2;
  fi;

#
# Checking files
if [ $v99 -eq 1 ];
  then 
    { echo "********************************************";
      echo "*  Checking input filenames given by user";
      echo "********************************************"; echo ""; } 1>&2;
  fi;

v95=`ExistCustomfile "$v96"`; # Exist_CustomFile

GFF_INPUT_FILES=""; ck=0; hmf=0; rd_std=1;
if [ $npar -ge $OPTIND ];
   then
     for files in $@;
       do
         if [ $files = "-" ];
           then
             if [ $ck -eq 1 ]; 
               then
                 GFF_INPUT_FILES=$GFF_INPUT_FILES" ";
               fi;
             GFF_INPUT_FILES=$GFF_INPUT_FILES$files;  
             shift; ck=1;
             hmf=`expr $hmf + 1`;
             rd_std=1;
             if [ $v99 -eq 1 ];
               then 
                 echo "REPORT: Standard-input is going to be included with input files..." 1>&2;
               fi;
           else
             if [ `ExistFile $files` ];  # Checks any kind of input files (*, ./*, path/*). 
               then 
                 if [ $ck -eq 1 ]; 
                   then
                     GFF_INPUT_FILES=$GFF_INPUT_FILES" ";
                   fi;
                 GFF_INPUT_FILES=$GFF_INPUT_FILES$files;
                 shift; ck=1;
                 hmf=`expr $hmf + 1`;
               fi;
         fi;
       done;
   fi;
if [ $hmf -eq 0 ];
   then
     GFF_INPUT_FILES="-";
     if [ $v99 -eq 1 ];
       then
         echo "REPORT: Redirecting from standard-input..." 1>&2;
       fi;
   fi;

#
# Defining PLOToptions STRING for GNU awk programs.
if [ $v99 -eq 1 ];
  then
    { echo "";
      echo "***************************************************";
      echo "*  Processing Command-Line Options for $PROGAM...";
      echo "***************************************************"; echo ""; } 1>&2;
  fi;

#
# Defining APLOToptions STRING for GNU awk programs.
#
cat <<@@@EndOfOptions@@@ > $GWKOPT
$n01:=$v01::$n02:=$v02::$n03:=$v03::$n04:=$v04::$n05:=$v05
$n06:=$v06::$n07:=$v07::$n08:=$v08::$n09:=$v09::$n10:=$v10
$n11:=$v11::$n12:=$v12::$n13:=$v13::$n14:=$v14::$n15:=$v15
$n16:=$v16::$n17:=$v17::$n18:=$v18::$n19:=$v19::$n20:=$v20
$n21:=$v21::$n22:=$v22::$n23:=$v23::$n24:=$v24::$n25:=$v25
$n26:=$v26::$n27:=$v27::$n28:=$v28::$n29:=$v29::$n30:=$v30
$n31:=$v31::$n32:=$v32::$n33:=$v33::$n34:=$v34::$n35:=$v35
$n36:=$v36::$n37:=$v37::$n38:=$v38::$n39:=$v39::$n40:=$v40
$n41:=$v41::$n42:=$v42::$n95:=$v95::$n97:=$v97::$n98:=$v98::$n99:=$v99
InputFNs:=$GFF_INPUT_FILES::PS_Header_FN:=$PSHEAD::PS_Main_FN:=$PSMAIN
PROGRAM:=$PROGRAM::VERSION:=$VERSION::AUTHOR:=$AUTHOR::EMAIL:=$EMAIL::PSPROGRAM:=$PSPROGRAM
@@@EndOfOptions@@@

#
# Main GFF2APLOT GNU AWK PROGRAM
#
cat << '@@@EndPROGRAM@@@' >> $GWKPRG # Shell file
BEGIN{
  #
  IGNORECASE=1;
  OFS="\t";
  #
  # Loading Default Variables...
  GFF_FORMAT_DEFS();
  # ARY_VARIABLES();
  PageSizesDEF();
  #
  # Find actual date...
  "date +%Y/%m/%d" | getline date;
  "date +%T" | getline time;
  #
  # Finding logged user...
  "whoami" | getline usr;
  #
  # gff2ps strand-frame codification
  strands["+"]=0;
  strands["-"]=1;
  strands["."]=".";
  # wstr[1]="+";wstr[2]=".";wstr[3]="-";
  Frames["."]=Frames["0"]=Frames["1"]=Frames["2"]=1;
  #
  # Color REGEXP
  V_COLORS="^(fg(color)?|black|white|(very)?(light|dark)?(grey|green|(sky)?blue|cyan|violet|red|orange|yellow|brown))$";
  #
  ############## Program Constants ############ 
  Var["Print_Report"]=PRPT;
  Var["Quiet_Mode"]=PQTM;
  BigLINE="********************************************";
  fseq1=0; fseq2=0; falign=0;
  DefLimits=0; hlcnt=0; NGROUPS=0
  MinF=10000; MaxF=0 # MXend=1; MYend=1
  #
  # Default Variables
  MAKE_VAR_ARY();
  #
  # Obtaining variables from Custom File
  READ_CUSTOM();
  #
  # Modifying variables from CommandLine
  # print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>COMMANDLINE" | "cat 1>&2"
  READ_CL();
  PrintRPT(sprintf("\n%s\n*  Processing GFF Input...\n%s\n\n",BigLINE,BigLINE));
}
########## INITIALITATION Finished ##########
#
############ READING .GFF FILES  ############
{ 
  is_EOF=0;
  #
  # skips those comment lines (starting with "#") or empty lines
  # also checking if input line is gff_formated.
  while (!ChkInput()) { 
    if (Var["quiet_mode"]) printf ">>> %10s :: Not Read :: %s\n", NR, $0 | "cat 1>&2";
    # PrintWRN(sprintf(">>> %10s :: Not Read :: ", NR) $0 "\n");
    if (getline<=0) { is_EOF=1; break };
  } # while
  if (!is_EOF) {
    #
    # Printing Input Lines
	PrintRPT(sprintf("OK: %10s :: GFF v.%s  :: %s\n", NR, GFF_V, $0));
    #
    # Reading gff-line elements.
	ReadElements();
  } # if (!is_EOF)
}
############ .GFF FILES ARE READ ############
#
########### MAIN PROGRAM PROCESSES ##########
END{
 # 
 ######### Defining some variables #######
 SET_PAGE_VARS();
 #
 ######### Printing PostScript: Header, Prologue, OpenPage 
 PSheader();
 PSprologue();
 startPSpage();
 #
 ######### Printing APLOT BLOCK #######
 APLOT_BLOCK();
 #
 ######### Printing PERCENT-BOX BLOCK #######
 PERCENT_BLOCK();
 #
 ######### Printing EXTRA-BOX BLOCK #######
 EXTRA_BLOCK();
 #
 ######### Printing PostScript EOF #######
 endPSpage(); PSTrailer();
 #
 # Final Report
 if (Var["Print_Report"]) prtReport();
 }
############ MAIN PROCESSES DONE ############
#
#################### MAIN ###################
############ FUNCTIONS DEFINITION ###########
#
function GFF_FORMAT_DEFS() {
  #
  # gff BASIC data-structure
  seqname = 1 ; REseqname = "[^\\# ]+" ;
  source  = 2 ; REsource  = "[^\\# ]+"  ;
  feature = 3 ; REfeature = "[^\\# ]+"  ;
  start   = 4 ; REstart   = "([+-]?[0-9]+)" ;
  end     = 5 ; REend     = "([+-]?[0-9]+)" ;
  score   = 6 ; REscore   = "([+-]?[0-9]*[.]?[0-9]*(e[+-]?[0-9]+)?)" ;
  strand  = 7 ; REstrand  = "[+-.]"  ;
  frame   = 8 ; REframe   = "[.012]" ;
  group   = 9 ;
  #
  # GFF2APLOT extra data-structure
  gpname=1; gpstart=2; gpend=3; is_grouped=4; gplabel=5;
  vector=10; v_window=11; v_step=12; v_scmin=13; v_scmax=14; v_DATA=15; v_NUM=16; v_CLASS=0;
  #
  ### GFF FORMAT - Tag-Value definition ###
  REST="^";
  REND="$";
  REtag= "[A-Za-z][A-Za-z0-9_]*" ;
  REval= "\\\"[^\\#]+\\\"" ;
  #
  ### GFF FORMAT - Version 1 - Record Definition ###
  REfs1     = "[\\t ]+" ;
  REtagval  = REtag REfs1 REval ; # "([\\t ]*;)?"
  PlainGP   = "[^\\\"\\# ]+" ;
  REtail1   = ".*" ;     # ".*" ;
  REgroupV1 = "(" PlainGP "|" REval "|" REtagval REtail1 ")" ;
  CKgroupV1 = "(" PlainGP "|" REval ")" ;
  REGV1     = "(" REfs1 "(" REgroupV1 ")?)?" ;
  #    Version1 : ..$1.......FS.....$2......FS.....$3.......FS.....$4.....FS.....$5...FS.....$6.....FS.....$7......FS.....$8.....FS.....$9.....
  gff_format_V1 = REST REseqname REfs1 REsource REfs1 REfeature REfs1 REstart REfs1 REend REfs1 REscore REfs1 REstrand REfs1 REframe REGV1 REND ;
  #
  ### GFF FORMAT - Version 2 - Record Definition ###
  # In version 2 gff-format field separator is \t.
  REfs2     = "[\\t]+" ;
  REgroupV2 = REtagval ; # REtag REfs1 REval ;
  REtail2   = ".*" ;
  REGV2     = "(" REfs2 "(" REgroupV2 REtail2 ")?)?" ; # "([^\\#]+)*";
  #    Version2 : ..$1.......FS.....$2......FS.....$3.......FS.....$4.....FS.....$5...FS.....$6.....FS.....$7......FS.....$8.....FS.....$9.....
  gff_format_V2 = REST REseqname REfs2 REsource REfs2 REfeature REfs2 REstart REfs2 REend REfs2 REscore REfs2 REstrand REfs2 REframe REGV2 REND ;
  #
  ### GFF FORMAT - APLOT - Record Definition ###
  afs = ":";
  REGtgt="[Tt][Aa][Rr][Gg][Ee][Tt]";
  REGAplot = "(" REfs2 "(" REGtgt REfs1 REval REfs1 REstart REfs1 REend REfs1 "(;?" REfs1 REtag ")?" REscore REfs2 REtail2 ")?)?" ;
  gff_aplot= REST REseqname afs REseqname REfs1 REsource REfs1 REfeature REfs1 REstart afs REstart REfs1 REend afs REend REfs1 REscore REfs1 REstrand "(:" REstrand ")?" REfs1 REframe "(:" REframe ")?" REGV1 REND ;
  gff_aplot_V2= REST REseqname REfs2 REsource REfs2 REfeature REfs2 REstart REfs2 REend REfs2 REscore REfs2 REstrand REfs2 REframe REGAplot REND ;
  # gff_aplot= REST REseqname afs REseqname REfs1 REsource REfs1 REfeature REfs1 REstart afs REstart REfs1 REend afs REend REfs1 REscore afs REscore REfs1 REstrand afs REstrand REfs1 REframe afs REframe REGV1 REND ;
} # End of GFF_FORMAT_DEFS
#
function  MAKE_VAR_ARY() {
  # make default values (if something happens with config file...Who knows...)
  # tag explanation on config file
### FL ## FLAGs ##
  Var["Display_TITLE"]="Y";
  Var["Display_SUBTITLE"]="Y";
  Var["Display_X-Axis_LABEL"]="Y";
  Var["Display_Y-Axis_LABEL"]="Y";
  Var["Display_Percent-Box_LABEL"]="Y";
  Var["Display_Extra-Box_LABEL"]="Y";
  Var["Display_PERCENT-BOX"]="N";
  Var["Display_EXTRA-BOX"]="N";
  Var["Display_GENE_LABEL"]="Y";
  Var["Display_GENE_RULE"]="Y";
  Var["Display_HalfHeightBOX"]="Y";
  Var["Display_FullHeightBOX"]="Y";
  Var["Display_BOX_LABEL"]="Y";
  Var["Display_UserDef_BOX_LABEL"]="Y";
  Var["Display_ARROW"]="Y";
  Var["Display_JOINS"]="Y";
  Var["Display_RIBBON"]="Y";
  Var["Display_SELECTION-BOX"]="Y";
  Var["Display_GFF"]="N";
  Var["Display_GFF-ReverseOrder"]="N";
  Var["Display_FUNCTION"]="N";
  Var["APlotLine_GroupScore"]="N";
  Var["APlotLine_ScaleWidth"]="N";
  Var["APlotLine_ScaleGrey"]="N";
  Var["XY_AXES_Same-SIZE"]="N";
  Var["Display_TickMark-LABEL"]="Y";
  Var["Display_APlot_X-Ticks"]="Y";
  Var["Display_Percent_X-Ticks"]="Y";
  Var["Display_ExtraBox_X-Ticks"]="Y";
  Var["Display_APlot_Y-Ticks"]="Y";
  Var["Display_Percent_Y-Ticks"]="Y";
  Var["Display_ExtraBox_Y-Ticks"]="Y";
  Var["Display_OnlyLower_X-Ticks"]="N";
  Var["Display_GRID"]="N";
  Var["ZOOM_Zoom"]="N";
  Var["ZOOM_Area"]="N";
  Var["Zoom_Marks"]="N";
### DF ## DEFAULT VALUES ##
  Var["PAGE_SIZE"]="a4";
  Var["FEATURE_LABELS_LENGTH"]=0;
  Var["GROUP_LABELS_LENGTH"]=0;
  Var["FEATURE_X-LABELS_ANGLE"]=0;
  Var["GROUP_X-LABELS_ANGLE"]=0;
  Var["FEATURE_Y-LABELS_ANGLE"]=0;
  Var["GROUP_Y-LABELS_ANGLE"]=0;
  Var["FEATURE_LABELS_FONTSIZE"]=1;
  Var["GROUP_LABELS_FONTSIZE"]=1;
  Var["BACKGROUND_COLOR"]="white";
  Var["FOREGROUND_COLOR"]="black";
  Var["APlotBox_BGCOLOR"]="BG";
  Var["PercentBox_BGCOLOR"]="BG";
  Var["ExtraBox_BGCOLOR"]="BG";
  Var["Strand-Arrows_COLOR"]="FG";
  Var["Join-Lines_COLOR"]="FG";
  Var["SelectionBox_BGCOLOR"]="grey";
  Var["Function_COLOR"]="red";
  Var["Zoom_Area_Mark_COLOR"]="lightred";
  Var["PERCENT_ORIGIN"]="50";
  Var["PERCENT_END"]="100";
  Var["ScaleMajorTICKMARK"]="2";
  Var["ScaleMinorTICKMARK"]="5";
  Var["PercentMajorTICKMARK"]="5";
  Var["PercentMinorTICKMARK"]="5";
  Var["ExtraMajorTICKMARK"]="2";
  Var["ExtraMinorTICKMARK"]="5";
### OP ## OPTIONs ##
  Var["Align_NAME"]="##DEFAULT##";
  Var["X-Sequence_NAME"]="##DEFAULT##";
  Var["Y-Sequence_NAME"]="##DEFAULT##";
  Var["TITLE"]="##DEFAULT##";
  Var["SUBTITLE"]="##DEFAULT##";
  Var["X-Axis_LABEL"]="##DEFAULT##";
  Var["Y-Axis_LABEL"]="##DEFAULT##";
  Var["Percent-Box_LABEL"]="##DEFAULT##";
  Var["Percent-Box_SUBLABEL"]="##DEFAULT##";
  Var["Extra-Box_LABEL"]="##DEFAULT##";
  Var["Extra-Box_SUBLABEL"]="##DEFAULT##";
  Var["HalfSizeBox_BGCOLOR"]="##DEFAULT##";
  Var["FullSizeBox_BGCOLOR"]="##DEFAULT##";
  Var["Ribbon_BGCOLOR"]="##DEFAULT##";
  Var["SEQUENCE1_ORIGIN"]="##DEFAULT##";
  Var["SEQUENCE1_END"]="##DEFAULT##";
  Var["SEQUENCE2_ORIGIN"]="##DEFAULT##";
  Var["SEQUENCE2_END"]="##DEFAULT##";
  Var["Zoom_SEQUENCE1_ORIGIN"]="##DEFAULT##";
  Var["Zoom_SEQUENCE1_END"]="##DEFAULT##";
  Var["Zoom_SEQUENCE2_ORIGIN"]="##DEFAULT##";
  Var["Zoom_SEQUENCE2_END"]="##DEFAULT##";
  Var["TICKMARK"]="##DEFAULT##";
  Var["SMALLTICKMARK"]="##DEFAULT##";
### FT ## GFF FEATUREs DEFINITION ##
  # FTcounter++;
  # FTindex[""]="";
  # FTputEXTRA[""]=OnOff("");
  # FTBoxType[""]="";
  # FTLineType[""]="";
  # FTputJoin[""]=OnOff("");
  # FTputArrow[""]=OnOff("");
  # FTputLabel[""]=OnOff("");
  # FTLineWidth[""]="";
  # FTLayer[""]="";
  # FTColor[""]=Var["BACKGROUND_COLOR"];
  # FTRbnColor[""]=Var["BACKGROUND_COLOR"];
### SP ## Special gff Features ##
  # FTGeneBounds="genebounds";
  FTLimits="seqbounds";
  FTAPlot="align";
  FTHighLight="boxit";
  FTRectangle="rectangle";
  FTCircle="circle";
  FTText="text";
  FTExtraFunction="function";
  FTExtraDisplay="est";
}
#
function READ_CUSTOM() {
  FTFunction="##DEFAULT##";
  FTText="##DEFAULT##"; FTCircle="##DEFAULT##"; FTRectangle="##DEFAULT##";
  FTHighLight="##DEFAULT##"; FTAPlot="##DEFAULT##"; FTLimits="##DEFAULT##";
  defaultBGC="white"; defaultFGC="black";
  doproc=0; FTcounter=0;
  # print "*************CUSTOMFILE: ", CUSTOMFILE | "cat 1>&2";
  while (getline < CUSTOMFILE > 0) {
  # print "*************CUSTOMFILE: ", $0 | "cat 1>&2";
    if ($0!~/^[ ]*$|^\#+/) {
      if ($0~/^FL \#/) doproc=1; 
      else if ($0~/^DF \#/) doproc=2;
      else if ($0~/^OP \#/) doproc=3;
      else if ($0~/^FT \#/) doproc=4;
      else if ($0~/^SP \#/) doproc=5;
      else if (doproc==5) LoadEspecial();
      else if (doproc==4) AddtoFeatures();
      else if (doproc==3) {
        split($0,tt," : ");
        Var[$1]=tt[2];
        }
      else if (doproc==2) {
        if ($1~/^BACKGROUND_COLOR$/ && $3~/^BG$|(\#\#DEFAULT\#\#)/) $3=defaultBGC;
        else if ($1~/^FOREGROUND_COLOR$/ && $3~/^FG$|(\#\#DEFAULT\#\#)/) $3=defaultFGC;
        else if ($1~/COLOR$/ && $3~/^BG$/) $3=Var["BACKGROUND_COLOR"];
        else if ($1~/COLOR$/ && $3~/^FG$/) $3=Var["FOREGROUND_COLOR"];
        Var[$1]=$3;
        }
      else if (doproc==1) Var[$1]=OnOff($3);
      PrintRPT(sprintf( "***: %s : DOPROC : %s\n", $1, doproc));
      } # if not empty nor comment
    } # while 
  close(CUSTOMFILE); 
  PrintRPT(sprintf("\n%s\n* LOADING VARS from CUSTOM FILE:\n*     \"%s\"\n%s\n\n",BigLINE,CUSTOMFILE,BigLINE));
  if (Var["Print_Report"]) { # PrintRPT
	for (v in Var)
	  printf "VAR: %-28s :: Value: %s\n", v, Var[v] | "sort 1>&2";
	close("sort 1>&2") }
} # End of function READ_CUSTOM
#
function READ_CL() {
  while ((getline < ARGV[1])>0) {
	npar=split($0,parm,"::");
	for (r=1;r<=npar;r++) {
	  split(parm[r],elem,":=");
      if (elem[2]!="##dflt##") {
	    if (elem[1]~/COLOR$/) {
		  ecolor=elem[2];
          if (ChkColor(ecolor)) {
            if (ecolor~/^FG$/) { elem[2]=Var["FOREGROUND_COLOR"] }
            } # if ChkColor
          else { elem[2]=Var["BACKGROUND_COLOR"] }
	      } # if elem[1]
	    Var[elem[1]]=elem[2];
	    } # if elem[2]
      } # for
    } # while
  ARGV[1]="";   
  PrintRPT(sprintf("\n%s\n* LOADING VARS from COMMANDLINE...\n%s\n\n",BigLINE,BigLINE));
  if (Var["Print_Report"]) { # PrintRPT
	for (v in Var)
	  printf "VAR: %-28s :: Value: %s\n", v, Var[v] | "sort 1>&2";
	close("sort 1>&2") }
} # End of function READ_CL
#
function ChkInput() { # some changes will be made on input line if some defaults were present.
  f=split($0,ln,/[\t ]*[\#]/); GFF_aplot=0;
  if (ln[1]!="") {
	$0=""; $0=ln[1]; for (s=1;s<=f;s++) { delete ln[s] };
	if (!($frame in Frames)) { 
	  PrintWRN(sprintf("***************\n*** WARNING ***  Unknown frame \"%s\" (replaced by \".\") in :\n***************  %s\n",$frame,$0));
	  $frame=".";
	} # if frame not exist
	if (!($strand in strands)) {
	  PrintWRN(sprintf("***************\n*** WARNING ***  Unknown strand \"%s\" (replaced by \".\") in :\n***************  %s\n",$strand,$0));
	  $strand=".";
	} # if strand not exist
	if ($0~gff_aplot) { 
	    # printf "\n***APLOT*** %s ***RE*** \/%s\/\n", $0~gff_aplot, gff_aplot | "cat 1>&2";
	    GFF_V=0; GFF_aplot=1; # "APLOT Standard";
	    return 1;
    } # if gff-line APLOT OK
    else {
  	 if ($start>$end) {
	   kk=$start; $start=$end; $end=kk;
	   PrintWRN(sprintf("***************\n*** WARNING ******  Non-standard gff-formatted input line: %s\n***************  REMEMBER that START(%s) must be lower or equal than END(%s): Swapping their values.\n", $0,$start,$end));
	 } # if start>end
	 if ($0~gff_aplot_V2) { 
	     # printf "\n***TARGET*** %s ***RE*** \/%s\/\n", $0~gff_aplot_V2, gff_aplot_V2 | "cat 1>&2";
	     GFF_V=2; GFF_aplot=1; # "GFF Standard";
	     return 1;
     } # if gff-line GFF-APLOT OK
     else {
	  if ($0~gff_format_V2) { 
	    # printf "\n***GFFv2*** %s ***RE*** \/%s\/\n", $0~gff_format_V2, gff_format_V2 | "cat 1>&2";
	    GFF_V=2;
	    return 1;
	  } # if gff-line Version 2 OK
	  else { 
	    if ($0~gff_format_V1) {
		  # printf "***GFFv1*** %s ***RE*** \/%s\/\n", $0~gff_format_V1, gff_format_V1 | "cat 1>&2";
		  GFF_V=1;
		  return 1;
	    } # if gff-line Version 1 OK    
	    else { # PrintWRN
		  if (NF<8) PrintWRN(sprintf("***************\n*** WARNING ***  Non-standard gff-formatted input line: %s\n***************  There are %s fields left: Standard gff lines need a minimum of 8 fields.\n", 8-NF,$0));
		  else {		
		    PrintWRN(sprintf("***************\n*** WARNING ******  GARBAGE\!: Non-standard gff-formatted input line:\n***************  %s\n", $0));
		  } # else if NF>8
		  return 0 } # else gff-line WRONG
	    } # else gff-line NON-Standard
      } # else check standard GFF format.
    } # else aplot GFF-standard.
  } # else empty line
  else {
	if (Var["quiet_mode"]) { # PrintWRN
	  if ($0~/^[\t ]*[\#].*/) printf ">>>Comment Line: %s\n", $0 | "cat 1>&2";
	  else printf ">>>Empty line... %s\n", $0 | "cat 1>&2";
	} # if !quiet_mode
	return 0;
  } # if not comment
} # End function ChkInput
#
function scan_quotes(Vscn) {
  while ($Vscn!~/^.*[^\"]\"$/ && Vscn<NF) { Gtv=Gtv" "$Vscn; $Vscn=""; Vscn++ }
  if ($Vscn~/^.*[^\"]\"$/) Gtv=Gtv" "$Vscn;
  else Gtv=Gtv" "$Vscn"\"";
  $Vscn="";
} # End function scan_quotes
#
function LOAD_Quoted(GFN,    mm) {
  gp_tag=".";
  if ($GFN~"^"REgroupV2"$") { 
	split($GFN,mm,/\"/);
	gp_tag=mm[1];
	Gtv=mm[2];
	gp_TYPE="Tag-Value (Single)";
  } # if tag-value single single
  else {
	if ($GFN~"^"REtag"$" && $(GFN+1)~"^"REval"$") {
	  gp_tag=$GFN;
	  Gtv=$(GFN+1);
	  gp_TYPE="Tag-Value (Single)";
	} # if tag-value single double
	else {
	  if ($GFN~"^"REtag"$" && $(GFN+1)~/^\".*[^\"]$/) {
		gp_tag=$GFN;
		Gtv=$(GFN+1);
		Vscn=GFN+2;
		scan_quotes(Vscn);
		gp_TYPE="Tag-Value (Multiple)";
	  } # if tag-value multiple
	  else {
		if ($GFN~"^"CKgroupV1"$") {
		  Gtv=$GFN;
		  gp_TYPE="Value (Single)";
		} # if value single
		else {
		  if ($GFN~/^\".*[^\"]$/) {
			Gtv=$GFN;
			Vscn=GFN+1;
			scan_quotes(Vscn);
			gp_TYPE="Value (Multiple)";
		  } # if value multiple
		} # else value multiple
	  } # else value single
	} # else tag-value multiple
  } # else tag-value single double
  if (GFF_V==2 && GFF_aplot==1 && gp_tag~"^"REGtgt"$") {
    $seqname=$seqname":"Gtv;
    almkv2=group; cnv2aplot=0;
    while (almkv2<=NF) {
      if ($(++almkv2)~REstart) { 
        cnv2aplot=1;
        al2_st=$almkv2;
        al2_nd=$(++almkv2);
        while ($(++almkv2)!~REscore && almkv2<NF) { };
        al2_sc=$almkv2;
        almkv2==NF;
      }
    } # while
    if (cnv2aplot) {
      $start=$start":"al2_st;
      $end  =  $end":"al2_nd;
      Gtv=Gtv":"al2_sc;
      PrintRPT(sprintf("*** TARGET Record USED: %s\n", $seqname" "$source" "$feature" "$start" "$end" "$score" "$strand" "$frame" "Gtv));
    }
    else {
      PrintWRN(sprintf("*** TARGET Record NOT USED: %s\n",$0));
    } # if not cnv2aplot
  } # if tag value align file.
} # End function LOAD_Quoted
#
function LOAD_Groups(    pnt,lbgp_tmp) {
  # Obtaining group string values.
  gptv=1;
  if (NF>8 && $group!=".") {
	LOAD_Quoted(group);
	gsub("\"","",Gtv);            # removing quotes from group name.
	flg_grp=1;
  } # else NF>8 and group!="." o group!=""
  else {                               # else group = string_value
	# if (NF==8 || $group==".") {             # if no group is given.
	Gtv="."
	gp_TYPE="Ungrouped";
	flg_grp=0;
  } # if NF=8 and group="." o group=""
} # End function LOAD_Groups
#
function ReadElements() {
  # loading seqnames...
  if (!($seqname in SEQNAME)) { 
    SEQNAME[$seqname]=$seqname; MSend[$seqname]=1; gpsqcnt[$seqname]=0;
    if ($feature~FTAPlot) alcnt=1; else cnt=1;
    }
  else {
    if ($feature~FTAPlot) alcnt=LAST[$seqname]+1; else cnt=LAST[$seqname]+1 }
  # Loading groups...
  LOAD_Groups();
  GP_ary[Gtv]++;              # field 9 (group) record-counter
  #
 if ($feature~FTAPlot) {
   prterr=0;
   if (!falign) { 
     falign=1; ALIGNname=$seqname;
     split($seqname,sqn,":");
     ALIGNseq1=sqn[1]; ALIGNseq2=sqn[2];
     MXend[$seqname]=MYend[$seqname]=1;
     }
   nx=split($start,xpos,":"); ny=split($end,ypos,":"); done=0;
   if (nx==1) { xpos[2]=xpos[1]; prterr=1 }
   else if (ny==1) { ypos[2]=ypos[1]; prterr=1 }
   if (prterr && !done) {
     done=1;
     PrintWRN("<<< ERROR >>> Your aligment gff-file only defined one sequence positions...\n\tPlease check your aligment gff-file.\n\tPlot is made with one sequence positions against two axes...\n");
     }
   ds=split($strand,st_ary,":");
   if (ds==1) st_ary[2]=st_ary[1];
   df=split($frame,fr_ary,":");
   if (ds==1) fr_ary[2]=fr_ary[1];
   ns=split(Gtv,gsco,":");
   if (ns==1) gsco[2]=1;
   LAST[$seqname]=alcnt;
   al_ref=$seqname SUBSEP "-" SUBSEP alcnt;
   FEATURE[al_ref]=$feature;
   ALIGNxori[al_ref]=xpos[1];
   ALIGNxend[al_ref]=ypos[1];
     MXend[$seqname]=max(MXend[$seqname],ypos[1]);
   ALIGNyori[al_ref]=xpos[2];
   ALIGNyend[al_ref]=ypos[2]; 
     MYend[$seqname]=max(MYend[$seqname],ypos[2]);
   ALIGNscore[al_ref]=$score;
   ALIGNxstrand[al_ref]=st_ary[1];
   ALIGNystrand[al_ref]=st_ary[2];
   ALIGNxframe[al_ref]=fr_ary[1];
   ALIGNyframe[al_ref]=fr_ary[2];
   ALIGNgroup[al_ref]=gsco[1];
   ALIGNscgroup[al_ref]=gsco[2];
   } # if aplot
 else if ($feature~FTLimits) {
   nx=split($start,xpos,":"); ny=split($end,ypos,":"); done=0;
   if (nx==1) { xpos[2]=xpos[1]; prterr=1 }
   else if (ny==1) { ypos[2]=ypos[1]; prterr=1 }
   if (prterr && !done) {
     done=1;
     PrintWRN("<<< ERROR >>> Your aligment gff-file only defined one sequence positions...\n\tPlease check your aligment gff-file.\n\tPlot is made with one sequence positions against two axes...\n");
     }
   OSQ1=xpos[1]; ESQ1=ypos[1]; OSQ2=xpos[2]; ESQ2=ypos[2]; DefLimits=1;
   } # if FTlimits
 else if ($feature~FTExtraFunction) { 
   funcname=$seqname SUBSEP "-" SUBSEP $group;
   FunctionXaxis[funcname,"-",$start]=$score; FunctionFlg[funcname,"-",$start]=1;
   MinF=min(MinF,$score); MaxF=max(MaxF,$score);
   if (!($group in FnctSEQ)) {
     FnctSEQ[$group]=$seqname;
     if ($10~"Color") {
       if (ChkColor($11)) FunctionColor[funcname]=$11;
       else FunctionColor[funcname]=Var["Function_COLOR"];
       }
     }
   } # if FTExtraFunctions
 else {
   if (!fseq1) { fseq1=1; SEQ1name=$seqname }
   if (!fseq2 && fseq1) { fseq2=1; SEQ2name=$seqname }
   LAST[$seqname]=cnt;
   ft_ref=$seqname SUBSEP "-" SUBSEP cnt;
   SOURCE[ft_ref]=$source;
   FEATURE[ft_ref]=$feature;
   SQ_ORI[ft_ref]=$start;
   SQ_END[ft_ref]=$end;
     MSend[$seqname]=max(MSend[$seqname],$end);
   SCORE[ft_ref]=$score;
   STRAND[ft_ref]=strands[$strand];
   FRAME[ft_ref]=$frame;
   gn=split(Gtv,bgroup,":");
   GROUP[ft_ref]=bgroup[1];
   if (gn==2) {
     LABEL[ft_ref]=bgroup[2];
     ApLED[ft_ref]=FTputLabel[$feature];
     ngrp=bgroup[2];
     MxGpLBL=max(MxGpLBL,length(bgroup[1]));
     MxFtLBL=max(MxFtLBL,length(bgroup[2]));
   }
   else {
     if (bgroup[1]==".") {
       bgroup[1]="";
       bgroup[2]="";
       }
     else bgroup[2]=bgroup[1];
     LABEL[ft_ref]=bgroup[2];
     ApLED[ft_ref]=FTputLabel[$feature];
     ngrp=bgroup[1];
     } # else gn==1
#
   tgmp=$seqname SUBSEP bgroup[1];
   if (!(tgmp in glist)) {
     gpsqcnt[$seqname]++;
     gp_rf=$seqname SUBSEP gpsqcnt[$seqname];
     glist[tgmp]=gp_rf;
     GP_NAME[gp_rf]=bgroup[1];
     GP_ORI[gp_rf]=SQ_ORI[ft_ref];
     GP_END[gp_rf]=SQ_END[ft_ref];
     }
   else {
     gp_rf=glist[tgmp];
     GP_ORI[gp_rf]=min(GP_ORI[gp_rf],SQ_ORI[ft_ref]);
     GP_END[gp_rf]=max(GP_END[gp_rf],SQ_END[ft_ref]);
     }
#
   if ($feature~FTExtraDisplay) {
     if (!(ngrp in BigGROUP)) BigGROUP[ngrp]=NGROUPS++;
     NGROUP[ft_ref]=BigGROUP[ngrp];
     } # if FTExtraDISPLAY
  } # else annotation field...
}
#
function SET_PAGE_VARS() {
 PrintRPT(sprintf("\n%s\n* Setting Some Variables...\n%s\n\n",BigLINE,BigLINE));
 # page size
 bbpgsz=tolower(Var["PAGE_SIZE"]); 
 if (!chkps(bbpgsz)) { bbx=PsizeX["a4"]; bby=PsizeY["a4"] }
 else { bbx=PsizeX[bbpgsz]; bby=PsizeY[bbpgsz] }
 PrintRPT(sprintf("::: PAGE_SIZE ::: %s (%sx%s)\n",bbpgsz,bbx,bby));
 # Defining axes
 if (Var["Align_NAME"] in SEQNAME) { 
   ALIGNname=Var["Align_NAME"];
   split(Var["Align_NAME"],sqn,":");
   ALIGNseq1=sqn[1]; ALIGNseq2=sqn[2];
   }
 if (Var["X-Sequence_NAME"] in SEQNAME) { SEQ1LABEL=Var["X-Sequence_NAME"] }
 else {
   if (falign) { SEQ1LABEL=ALIGNseq1 }
   else { SEQ1LABEL=SEQ1name }
   }
 if (Var["Y-Sequence_NAME"] in SEQNAME) { SEQ2LABEL=Var["Y-Sequence_NAME"] }
 else {
   if (falign) { SEQ2LABEL=ALIGNseq2 }
   else { SEQ2LABEL=SEQ2name }
   }
 PrintRPT(sprintf(":::\n::: ALIGN NAME ::: %s\n::: SEQ1 NAME ::: %s\n::: SEQ2 NAME ::: %s\n",ALIGNname,SEQ1LABEL,SEQ2LABEL));
 # Defining axes limits...
 if (!DefLimits) {         # Default Limits ( nor "seqlimits" given neither user-defined).
   OSQ1=1; ESQ1=(int(max(MXend[ALIGNname],MSend[SEQ1LABEL])/100)+1)*100;
   OSQ2=1; ESQ2=(int(max(MYend[ALIGNname],MSend[SEQ2LABEL])/100)+1)*100;
   }                       # Else Limits are defined with "seqlimits" gff record
 if (Var["ZOOM_Zoom"]) {  # Zoom active, then checklimits.
   if (Var["Zoom_SEQUENCE1_ORIGIN"]!~"##DEFAULT##") OSQ1=Var["Zoom_SEQUENCE1_ORIGIN"];
   if (Var["Zoom_SEQUENCE1_END"]!~"##DEFAULT##")    ESQ1=Var["Zoom_SEQUENCE1_END"];
   if (Var["Zoom_SEQUENCE2_ORIGIN"]!~"##DEFAULT##") OSQ2=Var["Zoom_SEQUENCE2_ORIGIN"];
   if (Var["Zoom_SEQUENCE2_END"]!~"##DEFAULT##")    ESQ2=Var["Zoom_SEQUENCE2_END"];
   }
 else {                   # User-defined Limits.
   if (Var["SEQUENCE1_ORIGIN"]!~"##DEFAULT##") OSQ1=Var["SEQUENCE1_ORIGIN"];
   if (Var["SEQUENCE1_END"]!~"##DEFAULT##")    ESQ1=Var["SEQUENCE1_END"];
   if (Var["SEQUENCE2_ORIGIN"]!~"##DEFAULT##") OSQ2=Var["SEQUENCE2_ORIGIN"];
   if (Var["SEQUENCE2_END"]!~"##DEFAULT##")    ESQ2=Var["SEQUENCE2_END"];
   }
 PrintRPT(sprintf(":::\n::: X-axes LIMITS ::: %s to %s\n::: Y-axes LIMITS ::: %s to %s\n",OSQ1,ESQ1,OSQ2,ESQ2));
 # labels
 if (!Var["Display_TITLE"]) T=" ";
 else {
   if (Var["TITLE"]~"##DEFAULT##") { 
     if (SEQ1LABEL!="" && SEQ2LABEL!="") T=SEQ1LABEL" x "SEQ2LABEL;
     else T=" ";
     }
   else T=Var["TITLE"];
   }
 ST=" "; SBLbl=" "; XBLbl=" "; SBSLbl=" "; XBSLbl=" ";
 if (Var["Display_SUBTITLE"] && Var["SUBTITLE"]!~"##DEFAULT##") ST=Var["SUBTITLE"];
 if (Var["Display_Percent-Box_LABEL"] && Var["Percent-Box_LABEL"]!~"##DEFAULT##") SBLbl=Var["Percent-Box_LABEL"];
 if (Var["Display_Extra-Box_LABEL"] && Var["Extra-Box_LABEL"]!~"##DEFAULT##") XBLbl=Var["Extra-Box_LABEL"];
 if (Var["Display_Percent-Box_LABEL"] && Var["Percent-Box_SUBLABEL"]!~"##DEFAULT##") SBSLbl=Var["Percent-Box_SUBLABEL"];
 if (Var["Display_Extra-Box_LABEL"] && Var["Extra-Box_SUBLABEL"]!~"##DEFAULT##") XBSLbl=Var["Extra-Box_SUBLABEL"];
 PrintRPT(sprintf(":::\n::: PLOT TITLE ::: \"%s\"\n::: SUBTITLE ::: \"%s\"\n::: PIP BOX LABEL ::: \"%s\"\n::: PIP BOX SubLABEL ::: \"%s\"\n::: EXTRA BOX LABEL ::: \"%s\"\n::: EXTRA BOX SubLABEL ::: \"%s\"\n",T,ST,SBLbl,SBSLbl,XBLbl,XBSLbl));
 # Tickmarks
 if (Var["Display_OnlyLower_X-Ticks"]) {
   if (Var["Display_Extra-Box_LABEL"]) {
     Var["Display_APlot_X-Ticks"]=0;
     Var["Display_Percent_X-Ticks"]=0;
     Var["Display_ExtraBox_X-Ticks"]=1;
     }
   else if (Var["Display_Percent-Box_LABEL"]) {
     Var["Display_APlot_X-Ticks"]=0;
     Var["Display_Percent_X-Ticks"]=1;
     Var["Display_ExtraBox_X-Ticks"]=0;
     } 
   else {
     Var["Display_APlot_X-Ticks"]=1;
     Var["Display_Percent_X-Ticks"]=0;
     Var["Display_ExtraBox_X-Ticks"]=0;
     } 
   }
 if (Var["TICKMARK"]!~"##DEFAULT##") tmtck=Var["TICKMARK"];
 else tmtck=-1;
 if (Var["SMALLTICKMARK"]!~"##DEFAULT##" && mtck>0) tntck=Var["SMALLTICKMARK"];
 else tntck=-1;
 if (Var["ScaleMajorTICKMARK"]!~"##DEFAULT##" && Var["ScaleMajorTICKMARK"]>0)
   smtck=Var["ScaleMajorTICKMARK"];
 else smtck=2;
 if (Var["ScaleMinorTICKMARK"]!~"##DEFAULT##" && Var["ScaleMinorTICKMARK"]>0)
   sntck=Var["ScaleMinorTICKMARK"];
 else sntck=5;
 if (Var["PercentMajorTICKMARK"]!~"##DEFAULT##" && Var["PercentMajorTICKMARK"]>0)
   pmtck=Var["PercentMajorTICKMARK"];
 else pmtck=2;
 if (Var["PercentMinorTICKMARK"]!~"##DEFAULT##" && Var["PercentMinorTICKMARK"]>0)
   pntck=Var["PercentMinorTICKMARK"];
 else pntck=5;
 if (Var["ExtraMajorTICKMARK"]!~"##DEFAULT##" && Var["ExtraMajorTICKMARK"]>0)
   xmtck=Var["ExtraMajorTICKMARK"];
 else xmtck=2;
 if (Var["ExtraMinorTICKMARK"]!~"##DEFAULT##" && Var["ExtraMinorTICKMARK"]>0)
   xntck=Var["ExtraMinorTICKMARK"];
 else xntck=5;
 # Other
 if (Var["Display_FullHeightBOX"] || Var["Display_HalfHeightBOX"] || Var["Display_ARROW"]) tmpflag=1;
 else tmpflag=0;
 if (Var["FEATURE_LABELS_LENGTH"]>0) MxFtLBL=Var["FEATURE_LABELS_LENGTH"];
 if (Var["GROUP_LABELS_LENGTH"]>0)   MxGpLBL=Var["GROUP_LABELS_LENGTH"];
}
#
function APLOT_BLOCK() {
 printf "%%\n%% New BLOCK ---> LABELS\n%%\n"
 printf "%% (label) Title\n(%s) Title\n", checklbl(T);
 printf "%% (label) SubTitle\n(%s) SubTitle\n", checklbl(ST);
 printf "%%\n%% New BLOCK ---> APLOT\n%%\n";
 printf "%% xori xend yori yend\n";
 printf "/X0 %s def\n/X1 %s def\n/Y0 %s def\n/Y1 %s def\n", OSQ1, ESQ1, OSQ2, ESQ2;
 printf "%%\nbegindata\n";
 printf "%%\nhorizontal\n%%\n";
 printf "%% lwidth lcolor bcol ori end Bline\n";
 printf "%% x0 y0 x1 y1 lwidth lcolor Line\n";
 if (Var["Display_RIBBON"]) PLOTRibbons(SEQ1LABEL,1);
 print "% tag definitions: Box,Join,Arrow,Banner";
 PLOTFEATURES(SEQ1LABEL,1);
 if (Var["X-Axis_LABEL"]~"##DEFAULT##") s1lbl=SEQ1LABEL;
   else s1lbl=Var["X-Axis_LABEL"];
 if (Var["Display_X-Axis_LABEL"]) { 
   printf "%% (label) TagLabelFont Banner\n(%s) TagLabelFont Banner \n", checklbl(s1lbl) }
 printf "%%\nvertical\n%%\n";
 printf "%% lwidth lcolor bcol ori end Bline\n";
 printf "%% x0 y0 x1 y1 lwidth lcolor Line\n";
 if (Var["Display_RIBBON"]) {
   PLOTRibbons(SEQ2LABEL,0);
   PLOTLINES();
   }
 print "%%\n% tag definitions: Box,Join,Arrow,Banner";
 PLOTFEATURES(SEQ2LABEL,0);
 if (Var["Y-Axis_LABEL"]~"##DEFAULT##") s2lbl=SEQ2LABEL;
   else s2lbl=Var["Y-Axis_LABEL"];
 if (Var["Display_Y-Axis_LABEL"]) { 
   printf "%% (label) TagLabelFont Banner\n(%s) TagLabelFont Banner \n", checklbl(s2lbl) }
 printf "%%\n%% Extra Features: Nice Band Lines Finishing for Seq1lines, Bsquare\n";
 printf "%%\n%% lwidth lcolor bcolor Hori Hend Vori Vend Bsquare\n";
 if (Var["Display_SELECTION-BOX"]) {
   for (i=1;i<=LAST[ALIGNname];i++) {
     if (FEATURE[ALIGNname,"-",i]~FTHighLight) {
       split(SQ_ORI[ALIGNname,"-",i],Oori,":");
       split(SQ_END[ALIGNname,"-",i],Eend,":");
       if (ChkXlim(Oori[1],Eend[1]) && ChkYlim(Oori[2],Eend[2])) {
         Oori[1]=max(Oori[1],OSQ1);Eend[1]=min(Eend[1],ESQ1);
         Oori[2]=max(Oori[2],OSQ2);Eend[2]=min(Eend[2],ESQ2);
         printf "%s %s %s %s %s %s %s Bsquare\n", GetLW("N"), Var["FOREGROUND_COLOR"], Var["SelectionBox_BGCOLOR"], Oori[1], Eend[1], Oori[2], Eend[2];
         }
       }
     }
   }
 printf "%%\n%%\n%% DATA ---> Alignment...\n%%\n";
 for (i=1;i<=LAST[ALIGNname];i++) {
   alname=ALIGNname SUBSEP "-" SUBSEP i;
   if (Var["APlotLine_GroupScore"]) {
     if (Var["APlotLine_ScaleWidth"]) wdth=ALIGNscgroup[alname]*10; else wdth=2;
     if (Var["APlotLine_ScaleGrey"]) color="0 0 0 "ALIGNscgroup[alname];
       else color=Var["FOREGROUND_COLOR"];
     }
   else {
     if (Var["APlotLine_ScaleWidth"]) wdth=ALIGNscore[alname]*10; else wdth=2;
     if (Var["APlotLine_ScaleGrey"]) color="0 0 0 "ALIGNscore[alname];
       else color=Var["FOREGROUND_COLOR"];
     }
   if (FEATURE[alname]~FTAPlot) {
   #
   # swap axes OK.
     if (index(ALIGNname,SEQ1LABEL)==1) {
       txo=ALIGNxori[alname];
       txe=ALIGNxend[alname];
       tyo=ALIGNyori[alname];
       tye=ALIGNyend[alname];
       }
     else {
       tyo=ALIGNxori[alname];
       tye=ALIGNxend[alname];
       txo=ALIGNyori[alname];
       txe=ALIGNyend[alname];
       }
     if (ChkXlim(txo,txe) && ChkYlim(tyo,tye)) {
       txo=max(txo,OSQ1);
       txe=min(txe,ESQ1);
       tyo=max(tyo,OSQ2);
       tye=min(tye,ESQ2);
       printf "%s %s %s %s %s %s Line\n", txo, tyo, txe, tye, wdth, color;
       }
     }
   }
 printf "%%\n%%\n%% Plot - Remarks...\n%%\n";
 PLOTREMARKS(SEQ1LABEL,1);
 PLOTREMARKS(SEQ2LABEL,0);
 if (!Var["ZOOM_Zoom"] && Var["ZOOM_Area"]) {
   if (ChkXlim(Var["Zoom_SEQUENCE1_ORIGIN"],Var["Zoom_SEQUENCE1_END"]) && ChkYlim(Var["Zoom_SEQUENCE2_ORIGIN"],Var["Zoom_SEQUENCE2_END"])) {
     Var["Zoom_SEQUENCE1_ORIGIN"]=max(Var["Zoom_SEQUENCE1_ORIGIN"],OSQ1);
     Var["Zoom_SEQUENCE1_END"]=min(Var["Zoom_SEQUENCE1_END"],ESQ1);
     Var["Zoom_SEQUENCE2_ORIGIN"]=max(Var["Zoom_SEQUENCE2_ORIGIN"],OSQ2);
     Var["Zoom_SEQUENCE2_END"]=min(Var["Zoom_SEQUENCE2_END"],ESQ2);
     printf "%s %s %s %s %s %s Msquare\n", 2, Var["Zoom_Area_Mark_COLOR"], Var["Zoom_SEQUENCE1_ORIGIN"], Var["Zoom_SEQUENCE1_END"], Var["Zoom_SEQUENCE2_ORIGIN"], Var["Zoom_SEQUENCE2_END"];
     }
   }    
 printf "%%\nenddata\n%%\n";
}
#
function PERCENT_BLOCK() {
 if (Var["Display_PERCENT-BOX"]) {
   printf "%%\n%% New BLOCK ---> MATCHES\n%%\n"
   printf "%% xpct ypct\n %s %s beginmatches\n", Var["PERCENT_ORIGIN"], Var["PERCENT_END"]
   printf "%%\nhorizontal\n"
   printf "%% lwidth lcolor bcol ori end Bline\n"
   printf "%% x0 y0 x1 y1 lwidth lcolor Line\n"
   if (Var["Display_RIBBON"]) { 
     PLOTRibbons(SEQ1LABEL,1)
     PLOTLINES()
     }
   printf "%%\nvertical\n%%\npctmarks\n"
   printf "%%\n%%\n%% DATA ---> Alignment...\n%%\n"
   for (i=1;i<=LAST[ALIGNname];i++) {
     pcname=ALIGNname SUBSEP "-" SUBSEP i
     if (Var["APlotLine_GroupScore"]) {
#       if (Var["APlotLine_ScaleWidth"]) wdth=ALIGNscgroup[pcname]*10; else wdth=2
       if (Var["APlotLine_ScaleGrey"]) color="0 0 0 "ALIGNscgroup[pcname]
         else color=Var["FOREGROUND_COLOR"]
       }
     else {
#     if (Var["APlotLine_ScaleWidth"]) wdth=ALIGNscore[pcname]*10; else wdth=2
       if (Var["APlotLine_ScaleGrey"]) color="0 0 0 "ALIGNscore[pcname]
         else color=Var["FOREGROUND_COLOR"]
       }
     wdth=2
     nscore=ALIGNscore[pcname]*100
     if (FEATURE[pcname]~FTAPlot) {
     #
     # Percent box zoom: vertical clip added, and swap axes.
       if (index(ALIGNname,SEQ1LABEL)==1) {
         txo=ALIGNxori[pcname]
         txe=ALIGNxend[pcname]
         tyo=ALIGNyori[pcname]
         tye=ALIGNyend[pcname]
         }
       else {
         tyo=ALIGNxori[pcname]
         tye=ALIGNxend[pcname]
         txo=ALIGNyori[pcname]
         txe=ALIGNyend[pcname]
         }
       if (ChkXlim(txo,txe) && ChkYlim(tyo,tye)) {
         txo=max(txo,OSQ1)
         txe=min(txe,ESQ1)
         printf "%s %s %s %s %s %s Line\n", txo, nscore, txe, nscore, wdth, color
         }
       }
     }
   printf "%%\nendmatches\n%%\n"
   }
}
#
function EXTRA_BLOCK() {
 if (Var["Display_EXTRA-BOX"]) {
   printf "%%\n%% New BLOCK ---> EXTRA-BOX\n%%\n"
   printf "%% numlines\n %s beginextra\n", NGROUPS 
   printf "%%\nhorizontal\n"
   printf "%% lwidth lcolor bcol ori end Bline\n"
   printf "%% x0 y0 x1 y1 lwidth lcolor Line\n"
   if (Var["Display_RIBBON"]) {
     PLOTRibbons(SEQ1LABEL,1)
     PLOTLINES()
     }
   printf "%%\nvertical\n"
   if (Var["Display_GFF"]) {
     for (i=1;i<=LAST[SEQ1LABEL];i++) {
       slbl=SEQ1LABEL SUBSEP "-" SUBSEP i
       if (FEATURE[slbl]~FTExtraDisplay) {
         if (!ChkColor(FTColor[FEATURE[slbl]])) xcolor=Var["FOREGROUND_COLOR"]
           else xcolor=FTColor[FEATURE[slbl]]
         if (Var["Display_GFF-ReverseOrder"]) gffpos=NGROUPS-NGROUP[slbl]
           else gffpos=NGROUP[slbl]+1
         if (ChkXlim(SQ_ORI[slbl],SQ_END[slbl])) {
           SQ_ORI[slbl]=max(SQ_ORI[slbl],OSQ1)
           SQ_END[slbl]=min(SQ_END[slbl],ESQ1)
           printf "%s %s %s %s %s %s Line\n", SQ_ORI[slbl], gffpos, SQ_END[slbl], gffpos, "Xlwdt", xcolor
           }
         }
       }
     }
   if (Var["Display_FUNCTION"]) {
     printf "%%\n%s %s\nbeginfunct\n",MinF,MaxF
     for (fnc in FnctSEQ) {
       if (FnctSEQ[fnc]==SEQ1LABEL) {
         fori=0; thefnc=SEQ1LABEL SUBSEP "-" SUBSEP fnc
         for (i=OSQ1;i<=ESQ1;i++) {
           if (fori) { 
             if (FunctionFlg[thefnc,"-",i])
               printf "%s %s flt\n", i, FunctionXaxis[thefnc,"-",i]
             }
           else if (!fori) { 
             if (FunctionFlg[thefnc,"-",i]) {
               printf "S\n%s %s fmt\n", i, FunctionXaxis[thefnc,"-",i]; fori=1 }
             }
           }
         if (fori) {
           printf "2 slw %s scmyk K R\n",FunctionColor[thefnc] }
         }
       }
       printf "%%\nendfunct\n%%\n"
     }
   printf "%%\nendextra\n%%\n"
   }
}
#
########################################
######## Secondary Functions ###########
#
function PrintRPT(STRNG) { if (Var["Print_Report"]) printf STRNG | "cat 1>&2" }
function PrintWRN(STRNG) { if (Var["Quiet_Mode"]) printf STRNG | "cat 1>&2" }
#
function OnOff(v) { if (tolower(v)~/^1$|^on$|^y(es)?$|^t(rue)?$/) return 1; else return 0 }
function TxtBool(n) { if (n) return "true"; else return "false" }
function min(a,b) { if (a<=b) return a; else return b }
function max(a,b) { if (a>=b) return a; else return b }
#
function ChkXlim(o,e) { if (o>=ESQ1 || e<=OSQ1) return 0; else return 1 }
function ChkYlim(o,e) { if (o>=ESQ2 || e<=OSQ2) return 0; else return 1 }
function ChkColor(ncolor) {
 if (tolower(ncolor)~V_COLORS) return 1;
 else return 0; # also when ncolor == ^BG$|(##DEFAULT##)
 }
#
function checklbl(chain) {
  if (chain=="") return ""; 
  else { gsub(/[\(]/,"\\050",chain); gsub(/[\)]/,"\\051",chain); return chain }
} # End of function checklbl
#
function chkpo(v) { if (v=="Portrait") return "false"; else return "true" }
function chkps(v) {
  if (v~/^(a|b)([0-9]|10)$|^10x14$|^(executive|folio|(le)(tter|gal)|quarto|statement|tabloid|userdefined)$/)
	return 1;
  else return 0;
} # End of function chkps
#
function ChkFT(feat) {
 if (feat~FTExtraDisplay || feat~FTText || feat~FTCircle || feat~FTRectangle || feat~FTExtraFunction || feat~FTLimits || feat~FTHighLight || feat~FTAPlot)
   return 1;
 else return 0;
 }
function ChkStr(char) {
 if (char~/^0$|^\+$/)      return "(fwd)";
 else if (char~/^1$|^\-$/) return "(rvs)";
 else if (char~/^\.$/)     return "(nst)";
 else return "(err)";
 }
function tick(nm) {
 end1=ESQ1-OSQ1; if (end1==0) end1=10000;
 end2=ESQ2-OSQ2; if (end2==0) end2=10000;
 wy=max(end1,end2);
 y=wy/nm;
 ylog=(log(y)/log(10));
 yfloor=int(ylog);
 y1=y/(10^yfloor);
 y2=int(y1);
 t=y2*(10^yfloor);
 return t;
 }
function LoadEspecial() {
 if ($1~/^(EXTRABOX)$/) FTExtraDisplay=$3;
 else if ($1~/^(FUNCTION)$/) FTExtraFunction=$3;
 else if ($1~/^(TEXT)$/) FTText=$3;
 else if ($1~/^(CIRCLE)$/) FTCircle=$3;
 else if ($1~/^(RECTANGLE)$/) FTRectangle=$3;
 else if ($1~/^(HIGHLIGHT)$/) FTHighLight=$3;
 else if ($1~/^(APLOT)$/) FTAPlot=$3;
 else if ($1~/^(PLOTLIMITS)$/) FTLimits=$3;
 # else if ($1~/^(GENELIMITS)$/) FTGeneBounds=$3;
}
function AddtoFeatures() {
 FTindex[$1]=$1;
 FTcounter++;
 FTputEXTRA[$1]=OnOff($2);
 FTBoxType[$1]=$3;
 FTLineType[$1]=$4;
 FTputJoin[$1]=OnOff($5);
 FTputArrow[$1]=OnOff($6);
 FTputLabel[$1]=OnOff($7);
 FTLineWidth[$1]=$8;
 FTLayer[$1]=$9;
 maxlayer=max(maxlayer,$9);
 if (ChkColor($10)) {
   if (tolower($10)~/^fg(color)?$/) FTColor[$1]=Var["FOREGROUND_COLOR"];
   else FTColor[$1]=$10;
   }
 else FTColor[$1]=Var["BACKGROUND_COLOR"];
 if (ChkColor($11)) {
   if (tolower($11)~/^fg(color)?$/) FTRbnColor[$1]=Var["FOREGROUND_COLOR"];
   else FTRbnColor[$1]=$11;
   }
 else FTRbnColor[$1]=Var["BACKGROUND_COLOR"];
}
function GetLW(type) {
 if (type~/H|h/) return 0.25;
 else if (type~/N|n/) return 0.5;
 else if (type~/D|d/) return 1;
 }
function PLOTRibbons(SEQ,ish) {
 for (l=maxlayer;l>=0;l--) {          ### Plotting features by layers...  
   for (i=1;i<=LAST[SEQ];i++) {
     name=SEQ SUBSEP "-" SUBSEP i;
     feat=FEATURE[name];
    if (feat in FTindex) {
     if (FTLayer[feat]==l) {
       bori=SQ_ORI[name]; bend=SQ_END[name];
       featln=tolower(FTLineType[feat]);
       tpftSR=tolower(Var["Show_Ribbons"]);
       if (tpftSR!="f") featln=tpftSR;
       lnw=GetLW(FTLineWidth[feat]);
       if (Var["Ribbon_BGCOLOR"]~"##DEFAULT##") rbbncol=FTRbnColor[feat];
       else rbbncol=Var["Ribbon_BGCOLOR"];
       if (featln=="r") rbbnlnc=rbbncol;
       else rbbnlnc=Var["FOREGROUND_COLOR"];
       PrintRPT(sprintf("************PLOTRIBBONS***%s:%s-%s(%s):%s\n",feat,bori,bend,featln,rbbnlnc));
       if (featln~/b|r/) {
         goprt=0;
         if (ish) {
           if (ChkXlim(bori,bend)) {
             bori=max(bori,OSQ1); bend=min(bend,ESQ1); goprt=1 }
             if (featln~/b/) {
               HLary[hlcnt]=bori; HLWary[hlcnt]=lnw; HLWcol[hlcnt]=rbbnlnc; hlcnt++;
               HLary[hlcnt]=bend; HLWary[hlcnt]=lnw; HLWcol[hlcnt]=rbbnlnc; hlcnt++;
               }
           }
         else { 
           if (ChkYlim(bori,bend)) {
             bori=max(bori,OSQ2); bend=min(bend,ESQ2); goprt=1 }
           }
         if (goprt) {
           printf "%s %s %s %s %s Bline\n", lnw, rbbnlnc, rbbncol, bori, bend }
         } 
       else if (featln~/l/) {
         if (ish) {
           rbbnlnc=Var["FOREGROUND_COLOR"];
           PRTLine(bori, bori, lnw, rbbnlnc);
           PRTLine(bend, bend, lnw, rbbnlnc);
           HLary[hlcnt]=bori; HLWary[hlcnt]=lnw; HLWcol[hlcnt]=rbbnlnc; hlcnt++;
           HLary[hlcnt]=bend; HLWary[hlcnt]=lnw; HLWcol[hlcnt]=rbbnlnc; hlcnt++;
           }
         else { 
           PRTLineV(bori, bori, lnw, Var["FOREGROUND_COLOR"]);
           PRTLineV(bend, bend, lnw, Var["FOREGROUND_COLOR"]);
           }
         } 
       }  # if FTLayer
      }  # if feat in FTindex
     }  # for i 
   }  # for l
 }  # function
function PLOTFEATURES(SEQ,isq) {
 printf "%% (label) ElmFont bcol ori end Box\n"
 printf "%% color ori end dir Arrow %% dir: 0=left 1=rigth\n"
 printf "%% jcol ori end Join\n"
 for (l=maxlayer;l>=0;l--) {          ### Plotting features by layers...  
   for (i=1;i<=LAST[SEQ];i++) {
     name=SEQ SUBSEP "-" SUBSEP i
     feat=FEATURE[name]
    if (feat in FTindex) {
     if (FTLayer[feat]==l) {
       bori=SQ_ORI[name]; bend=SQ_END[name];
       grpcnt[SEQ,"-",GROUP[name]]++
       if (Var["FullSizeBox_BGCOLOR"]~"##DEFAULT##") fboxcol=FTColor[FEATURE[name]]
         else fboxcol=Var["FullSizeBox_BGCOLOR"]
       if (Var["HalfSizeBox_BGCOLOR"]~"##DEFAULT##") hboxcol=FTColor[FEATURE[name]]
         else hboxcol=Var["HalfSizeBox_BGCOLOR"]
       if (FEATURE[name]!~FTExtraDisplay) {
         if (FTputLabel[FEATURE[name]]) {
           if (ApLED[name]) {
             if (Var["Display_UserDef_BOX_LABEL"]) tlabel=LABEL[name]
             else if (Var["Display_BOX_LABEL"]) tlabel=grpcnt[SEQ,"-",GROUP[name]]
             }
           }
         else tlabel=""
         if (Var["FEATURE_LABELS_LENGTH"]>0) tlabel=substr(tlabel,1,Var["FEATURE_LABELS_LENGTH"]);
         goprt=0
         if (isq) { 
           if (ChkXlim(bori,bend)) {
             bori=max(bori,OSQ1); bend=min(bend,ESQ1); goprt=1 } }
         else {
           if (ChkYlim(bori,bend)) {
             bori=max(bori,OSQ2); bend=min(bend,ESQ2); goprt=1 } }
         if (goprt) {
           if (FTBoxType[FEATURE[name]]~/F|f/) {
             if (Var["Display_FullHeightBOX"]) {
               printf"(%s) ElmFont %s %s %s Box\n", checklbl(tlabel), fboxcol, bori, bend }
             if (Var["Display_ARROW"] && FTputArrow[FEATURE[name]] && STRAND[name]!="." ) {
               printf"%s %s %s %s Arrow\n", Var["Strand-Arrows_COLOR"], bori, bend, STRAND[name] }
             }
           else if (FTBoxType[FEATURE[name]]~/H|h/ && Var["Display_HalfHeightBOX"]) {
             printf"%s %s %s FBox\n", hboxcol, bori, bend }
           }
         }  # if FTExtraDisplay
       }  # if FTLayer
     }  # if feat in FTindex
   }  # for i
 }  # for l
  #
  if (Var["Display_JOINS"] && Var["Display_FullHeightBOX"]) {
    G_ORI[GROUP[SEQ,"-",1]]=SQ_ORI[SEQ,"-",1]
    for (i=1;i<LAST[SEQ];i++) {
     name=SEQ SUBSEP "-" SUBSEP i
     nxtn=SEQ SUBSEP "-" SUBSEP (i+1)
     gname=GROUP[name]
     feat=FEATURE[name]
     if (FTputJoin[feat] && feat!~FTExtraDisplay) {
       if (G_ORI[gname]>SQ_ORI[name]) G_ORI[gname]=SQ_ORI[name]
       if (G_END[gname]<SQ_END[name]) G_END[gname]=SQ_END[name]
       if (FEATURE[nxtn]~feat) {
         if (gname==GROUP[nxtn]) {
           bori=SQ_END[name]; bend=SQ_ORI[nxtn]; jprt=0
           if (isq) {
             if (ChkXlim(bori,bend)) {
               bori=max(bori,OSQ1); bend=min(bend,ESQ1); jprt=1 }
             }
           else { 
             if (ChkYlim(bori,bend)) {
               bori=max(bori,OSQ2); bend=min(bend,ESQ2); jprt=1 }
             }  
           if (jprt) printf "%s %s %s Join\n", Var["Join-Lines_COLOR"], bori, bend
           }
         else G_ORI[GROUP[nxtn]]=SQ_ORI[nxtn]
         }
       }
     }
     if ((G_END[gname]<SQ_END[SEQ,"-",LAST[SEQ]]) && FEATURE[SEQ,"-",LAST[SEQ]]==feat) {
       G_END[gname]=SQ_END[SEQ,"-",LAST[SEQ]] }
   }  # if Joins & FullBoxes 
  #
  if (Var["Display_GENE_LABEL"]) {
   printf "%% (label) TagFont ori end GnBanner\n"
    if (isq) s_nm=SEQ1LABEL;
    else s_nm=SEQ2LABEL;     
    for (nm=1;nm<=gpsqcnt[s_nm];nm++) {
     gpn=s_nm SUBSEP nm;
     glbl=GP_NAME[gpn];
     gori=GP_ORI[gpn];
     gend=GP_END[gpn];
     goprt=0;
     if (Var["GROUP_LABELS_LENGTH"]>0) glabel=substr(glbl,1,Var["GROUP_LABELS_LENGTH"]);
     else glabel=glbl;
     if (isq) {
       if (ChkXlim(gori,gend)) { gori=max(gori,OSQ1); gend=min(gend,ESQ1); goprt=1 } }
     else {
       if (ChkYlim(gori,gend)) { gori=max(gori,OSQ2); gend=min(gend,ESQ2); goprt=1 } }
     if (goprt) {
       printf "(%s) TagFont %s %s %s GnBanner\n", checklbl(glabel), gori, gend, Var["Display_GENE_RULE"];
       }
     } # for
   }  # if GENE_LABEL
}  # function
function PLOTREMARKS(SEQ,isr) {
 for (h=1;h<=LAST[SEQ];h++) {
   xtname=SEQ SUBSEP "-" SUBSEP h
   bori=SQ_ORI[xtname]; bend=SQ_END[xtname];
   grpcnt[SEQ,"-",GROUP[xtname]]++
   if (FEATURE[xtname]~FTRectangle || FEATURE[xtname]~FTCircle || FEATURE[xtname]~FTText) {
     if (ChkColor(SOURCE[xtname])) xtcolor=SOURCE[xtname]
     else xtcolor=Var["FOREGROUND_COLOR"]
     xto=split(SQ_ORI[xtname],o,":")
     if (xto==1) o[2]=0
     xte=split(SQ_END[xtname],e,":")
     if (xte==1) e[2]=0
     }
   goprt=0
   toprt=0
   if (FTRectangle!~"##DEFAULT##" && FEATURE[xtname]~FTRectangle) {
     if (isr) {
       if (ChkXlim(o[1],e[1])) {
         o[1]=max(o[1],OSQ1); e[1]=min(e[1],ESQ1); goprt=1 }
       if (ChkYlim(o[2],e[2])) {
         o[2]=max(o[2],OSQ2); e[2]=min(e[2],ESQ2); toprt=1 }
       }
     else {
       if (ChkXlim(o[2],e[2])) {
         o[2]=max(o[2],OSQ1); e[2]=min(e[2],ESQ1); goprt=1 }
       if (ChkYlim(o[1],e[1])) {
         o[1]=max(o[1],OSQ2); e[1]=min(e[1],ESQ2); toprt=1 }
       }
     if (goprt && toprt) {
       printf "%s %s %s %s %s %s Msquare\n",SCORE[xtname],xtcolor,o[1],e[1],o[2],e[2] }
     }
   if (FTCircle!~"##DEFAULT##" && FEATURE[xtname]~FTCircle) {
     if (ChkXlim(o[1],o[1])) { goprt=1 }
     if (ChkYlim(e[1],e[1])) { toprt=1 }
     if (goprt && toprt) printf "%s %s %s %s %s Mcircle\n",SCORE[xtname],xtcolor,o[2],o[1],e[1]
     }
   if (FTText!~"##DEFAULT##" && FEATURE[xtname]~FTText) {
     if (ChkXlim(o[1],o[1])) { goprt=1 }
     if (ChkYlim(e[1],e[1])) { toprt=1 }
     if (goprt && toprt) printf "(%s) %s %s Xscm %s Yscm %s %s tshow\n",GROUP[xtname],SCORE[xtname],o[1]+o[2],e[1]+e[2],"TagFont",xtcolor
     }
   }
 }
function PLOTLINES() {
 if (hlcnt>0 && Var["Display_RIBBON"]) {
   for (h=0;h<hlcnt;h++) { 
     PRTLine(HLary[h], HLary[h], HLWary[h], HLWcol[h]);
     PrintRPT(sprintf("************PLOTLINES***%s:%s-%s(%s):%s\n",h,HLary[h],HLary[h],HLWary[h],HLWcol[h]));
     delete HLary[h]; delete HLary[h]; delete HLWary[h]; delete HLWcol[h];
     }
   }
 }
function PRTLine(ori,end,pct,col) {
 if (ChkXlim(ori,end)) {
   ori=max(ori,OSQ1); end=min(end,ESQ1)
   printf "%s y0 %s y1 %s %s Line\n", ori, end, pct, col
   }
 }
function PRTLineV(ori,end,pct,col) {
  if (ChkYlim(ori,end)) {
   ori=max(ori,OSQ2); end=min(end,ESQ2)
   printf "X0 %s X1 %s %s %s Line\n", ori, end, pct, col
   }
 }
function prtReport() {
  printf "\n**************************************\n" | "cat 1>&2"
  printf ">>>>>>>> VARIABLE DEFINITIONS <<<<<<<<\n" | "cat 1>&2"
  printf "\nPlot X-Limits: %s %s - Plot Y-Limits: %s %s\n",OSQ1,ESQ1,OSQ2,ESQ2 | "cat 1>&2"
  for (names in Def) {
    printf "%-25s : %8s <<\n", names, Var[names] | "sort 1>&2"
    }
  close("sort 1>&2")
  printf "\n**************************************\n" | "cat 1>&2"
  printf ">>>>>>>> FEATURES DEFINITIONS <<<<<<<<\n\n" | "cat 1>&2"
  for (names in FTindex) { 
    printf ">>> %-14s - %s - %s - %s - %s - %s - %s - %s - %-10s - %-10s\n", 
      FTindex[names],FTputEXTRA[names],FTBoxType[names],FTLineType[names], 
      FTputJoin[names],FTputArrow[names],FTputLabel[names],FTLineWidth[names], 
      FTColor[names],FTRbnColor[names] | "cat 1>&2" 
    }
  print "There are "FTcounter" features..." | "cat 1>&2"
  printf "\n************************************************\n" | "cat 1>&2"
  printf ">>>>>>>> Sequences Defined on gff Files <<<<<<<<\n\n" | "cat 1>&2"
  inc=0
  for (names in SEQNAME) printf "Sequence %s : %s\n",inc++,SEQNAME[names] | "cat 1>&2"
  printf "\n**********************************\n" | "cat 1>&2"
  printf ">>>>>>>> Genomic Data Set <<<<<<<<\n" | "cat 1>&2"
  for (seq in SEQNAME) {
    if (seq==SEQ1LABEL || seq==SEQ2LABEL || seq==ALIGNname)
         printf "\nSequence: %s ### USED on PLOT.\n", seq | "cat 1>&2"
    else printf "\nSequence: %s ### NOT USED on PLOT.\n", seq | "cat 1>&2"
    for (i=1;i<=LAST[seq];i++) {
      name=seq SUBSEP "-" SUBSEP i
      if (!ChkFT(FEATURE[name])) {
        printf "%-10s - %-10s - %-10s - %8s - %8s - %4s - %3s - %3s - %-10s - %-10s\n",   
        name, SOURCE[name], FEATURE[name], SQ_ORI[name], SQ_END[name], 
        SCORE[name], STRAND[name], FRAME[name], GROUP[name], LABEL[name] | "cat 1>&2"
        }
      }
    }
  printf "\n*****************************************\n" | "cat 1>&2"
  printf ">>>>>>>> EXTRA Features Data Set <<<<<<<<\n" | "cat 1>&2"
  for (seq in SEQNAME) {
    if (seq==SEQ1LABEL || seq==SEQ2LABEL || seq==ALIGNname)
         printf "\nSequence: %s ### USED on PLOT.\n", seq | "cat 1>&2"
    else printf "\nSequence: %s ### NOT USED on PLOT.\n", seq | "cat 1>&2"
    for (i=1;i<=LAST[seq];i++) {
      name=seq SUBSEP "-" SUBSEP i
      if (ChkFT(FEATURE[name])) {
        printf "%s: %-10s - %-10s - %-10s - %8s - %8s - %4s - %3s - %3s - %-10s - %-10s\n",  
        i, name, SOURCE[name], FEATURE[name], SQ_ORI[name], SQ_END[name], 
        SCORE[name], STRAND[name], FRAME[name], GROUP[name], LABEL[name] | "cat 1>&2"
        }
      }
    }
 }
#
#############################################
######## PostScript Code DEFINITION #########
#
function PageSizesDEF() {
  # Default PageSizes:
  PsizeX["a0"]=2384; PsizeY["a0"]=3370;
  PsizeX["a1"]=1684; PsizeY["a1"]=2384;
  PsizeX["a2"]=1190; PsizeY["a2"]=1684;
  PsizeX["a3"]=842; PsizeY["a3"]=1190;
  PsizeX["a4"]=595; PsizeY["a4"]=842;
  PsizeX["a5"]=420; PsizeY["a5"]=595;
  PsizeX["a6"]=297; PsizeY["a6"]=420;
  PsizeX["a7"]=210; PsizeY["a7"]=297;
  PsizeX["a8"]=148; PsizeY["a8"]=210;
  PsizeX["a9"]=105; PsizeY["a9"]=148;
  PsizeX["a10"]=73; PsizeY["a10"]=105;
  PsizeX["b0"]=2920; PsizeY["b0"]=4127;
  PsizeX["b1"]=2064; PsizeY["b1"]=2920;
  PsizeX["b2"]=1460; PsizeY["b2"]=2064;
  PsizeX["b3"]=1032; PsizeY["b3"]=1460;
  PsizeX["b4"]=729; PsizeY["b4"]=1032;
  PsizeX["b5"]=516; PsizeY["b5"]=729;
  PsizeX["b6"]=363; PsizeY["b6"]=516;
  PsizeX["b7"]=258; PsizeY["b7"]=363;
  PsizeX["b8"]=181; PsizeY["b8"]=258;
  PsizeX["b9"]=127; PsizeY["b9"]=181;
  PsizeX["b10"]=91; PsizeY["b10"]=127;
  PsizeX["10x14"]=720; PsizeY["10x14"]=1008;
  PsizeX["executive"]=540; PsizeY["executive"]=720;
  PsizeX["folio"]=612; PsizeY["folio"]=936;
  # PsizeX["ledger"]=1224; PsizeY["ledger"]=792;
  PsizeX["legal"]=612; PsizeY["legal"]=1008;
  PsizeX["letter"]=612; PsizeY["letter"]=792;
  PsizeX["quarto"]=610; PsizeY["quarto"]=780;
  PsizeX["statement"]=396; PsizeY["statement"]=612;
  PsizeX["tabloid"]=792; PsizeY["tabloid"]=1224;
  PsizeX["userdefined"]=595; PsizeY["userdefined"]=2384;
  NumPGSZ=34; # 32 fixed + 2 variable
  Var["Page_Orientation"]="Portrait";
} # End of function PageSizesDEF
#
function PSheader() {
  # Printing PostScript Header...
  printf "%%\!PS-Adobe-3.0\n";
  printf "%%%%Title: %s\n", title;
  printf "%%%%Creator: %s\n", Var["PROGRAM"];
  printf "%%%%Version: %s\n", Var["VERSION"];
  printf "%%%%CreationDate: %s\n", date" "time;
  printf "%%%%For: %s\n", usr;
  printf "%%%%Pages: 1\n";
  printf "%%%%Orientation: %s\n", Var["Page_Orientation"];
  printf "%%%%BoundingBox: 0 0 %s %s\n", bbx, bby;
  printf "%%%%EndComments\n%%\n";
  printf "%%    Author : %s\n", Var["AUTHOR"];
  printf "%%    e-mail :        %s\n%%\n", Var["EMAIL"];
  # title, ARGV[2], ARGV[3], date, usr, ARGV[8], bbary[2], bbary[3], ARGV[4], ARGV[5], ARGV[6];
  printf "%% ------------------------------------------------------------------------\n";
  printf "%%                     %s\n", Var["PSPROGRAM"];
  printf "%% ------------------------------------------------------------------------\n";
  # Writing PostScript Header...
  system("cat "Var["PS_Header_FN"]);
  close("cat "Var["PS_Header_FN"]);
  # Generating Page-sizes table...
  printf "%%  Paper Sizes  (in points)\n";
  printf "/pagedict %s dict def pagedict begin %% %s+2 sizes defined\n", NumPGSZ, NumPGSZ-2;
  for (pasize in PsizeX)
	printf "/pg%-12s { %4s %4s } def\n", pasize, PsizeX[pasize], PsizeY[pasize] | "sort" ;
  close("sort");
  printf "end %% pagedict\n%%%%EndProcSet:   Constants 1.0 0\n";
} # End of function PSheader
#
function PSprologue() { 
  # Printing PostScript Variables from Setup
  printf "/flglscape %s def\n", chkpo(Var["Page_Orientation"]);
  printf "/flgcrd %s def\n", TxtBool(OnOff(Var["Show_Credits"]));
  printf "%%%% page size in points used for plot % pgA4 == 595  842\n";
  printf "/Dpage { pagedict begin pg%s flglscape { exch } if end } bdf\n", bbpgsz;
  printf "%% margins (1 cm) (Up Down Left Right - margins are XY independent)\n";
  printf "/UpM %s def\n",     "1 cm"; # chkun(Var["margin_upper"]);
  printf "/DnM %s def\n",     "1 cm"; # chkun(Var["margin_lower"]);
  printf "/LtM %s def\n",     "1 cm"; # chkun(Var["margin_left"]);
  printf "/RtM %s def\n%%\n", "1 cm"; # chkun(Var["margin_right"]);
  printf "%% Defining background-color for objects.\n";
  printf "/BGcolor { %s } def\n", Var["BACKGROUND_COLOR"];
  printf "/FGcolor { %s } def\n", Var["FOREGROUND_COLOR"];
  printf "/BBoxcol { %s } def\n", Var["APlotBox_BGCOLOR"];
  printf "/SBoxcol { %s } def\n", Var["PercentBox_BGCOLOR"];
  printf "/XBoxcol { %s } def\n", Var["ExtraBox_BGCOLOR"];
  printf "/BBXtickflg %s def  %% Blocks TickFlags\n", Var["Display_APlot_X-Ticks"];
  printf "/SBXtickflg %s def  %% 0:no tickscale\n", Var["Display_Percent_X-Ticks"];
  printf "/XBXtickflg %s def  %% 1:put tickscale\n", Var["Display_ExtraBox_X-Ticks"];
  printf "/BBYtickflg %s def\n", Var["Display_APlot_Y-Ticks"];
  printf "/SBYtickflg %s def\n", Var["Display_Percent_Y-Ticks"];
  printf "/XBYtickflg %s def\n", Var["Display_ExtraBox_Y-Ticks"];
  printf "/ShowTicks %s def\n", Var["Display_TickMark-LABEL"];
  printf "/axesp  %s def %% axesp 0 => Y==X : 1 => X=14 Y=14\n", Var["XY_AXES_Same-SIZE"];
  printf "/ZoomON %s def %% 0 Switch off zoom-marks - 1 Switch on zoom-marks\n", Var["Zoom_Marks"];
  printf "/GridON %s def %% 0 Switch off grid - 1 Switch on grid\n", Var["Display_GRID"];
  printf "/tickmx %s def   %% tickmarks\n", tmtck;
  printf "/tickmn %s def\n", tntck;
  printf "/maxtck %s def\n", smtck;
  printf "/mintck %s def\n", sntck;
  printf "/pctmxt %s def\n", pmtck;
  printf "/pctmnt %s def\n", pntck;
  printf "/xtrmxt %s def\n", xmtck;
  printf "/xtrmnt %s def\n", xntck;
  printf "/SBoxLab (%s) def\n", checklbl(SBLbl);
  printf "/XBoxLab (%s) def\n", checklbl(XBLbl);
  printf "/SBoxSLab (%s) def\n", checklbl(SBSLbl);
  printf "/XBoxSLab (%s) def\n%%\n", checklbl(XBSLbl);
  printf "/FTXangle %s def\n", Var["FEATURE_X-LABELS_ANGLE"];
  printf "/GPXangle %s def\n", Var["GROUP_X-LABELS_ANGLE"];
  printf "/FTYangle %s def\n", Var["FEATURE_Y-LABELS_ANGLE"];
  printf "/GPYangle %s def\n", Var["GROUP_Y-LABELS_ANGLE"];
  printf "/FTLbsc  %s def\n", Var["FEATURE_LABELS_FONTSIZE"];
  printf "/GPLbsc  %s def\n", Var["GROUP_LABELS_FONTSIZE"];
  printf "/MxFtLBL %s def\n",MxFtLBL;
  printf "/MxGpLBL %s def\n",MxGpLBL;
  printf "/putExon  %s def\n", tmpflag;
  printf "/putExLbl %s def\n", Var["Display_BOX_LABEL"];
  printf "/putGnLbl %s def\n", Var["Display_GENE_LABEL"];
  #
  # PostScript Main Procs.
  system("cat "Var["PS_Main_FN"]);
  close("cat "Var["PS_Main_FN"]);
}
#
function startPSpage(num,tot,vpg,vtot) {
  printf "%%%%Page: 1 1\n";
  printf "%%%%BeginPageSetup\n%%\n";
  printf "%% Saving current page settings\n";
  printf "/pgsave save def\n";
  printf "%% Setting BGcolor for sheet \n";
  printf "Dpage 0 0 bbox S BGcolor scmyk fill R clip newpath\n";
  printf "%% Setting page-size scale\n";
  printf "1 CSF dup F\n";
  printf "%%%%EndPageSetup\n";
  printf "%%\n";
} # End of function startPSpage
#
function endPSpage(p,vp) {
  printf "%%\nflgcrd { s_credits } if\ngrestoreall\npgsave restore\nshowpage\n";
  printf "%%\n%% PageEND: 1 1\n%%\n";
} # End of function endPSpage
#
function PSTrailer() {
  printf "%%%%Trailer\n%%\n";
  printf "%%%%Pages: 1\n";
  printf "%%%%Orientation: %s\n", Var["Page_Orientation"];
  printf "%%%%BoundingBox: 0 0 %s %s\n", bbx, bby;
  printf "%%%%EOF\n";
} # End of function PSTrailer
@@@EndPROGRAM@@@

############################################################
#### Main GFF2APLOT GNU awk Program : START             ####
#                                                          #

gawk -v CUSTOMFILE=$v96 -v PRPT=$v98 -v PQTM=$v99 -f $GWKPRG $GWKOPT $GFF_INPUT_FILES ;

#                                                          #
#### Main GFF2APLOT GNU awk Program : DONE...           ####
############################################################

#
# Removing all temporal files...
rm -f $GWKPRG $GWKOPT $PSHEAD $PSMAIN 2>/dev/null;

#
# Timing GFF2APLOT...
T_end=`date +%s`;
if [ $v99 -eq 1 ];
then
  { echo "";
    echo "********************************************";
    echo "* GFF2APLOT Execution Time";
    echo "********************************************"; echo "";
    gawk 'BEGIN{
      t1=ARGV[1]; t2=ARGV[2]; T1=ARGV[3];
      ARGV[1]=ARGV[2]=ARGV[3]="";
      s=t2-t1;
      secs=s%60;
      m=int(s/60);
      mins=m%60;
      hours=int(m/60);
      printf "> Program started  at: %s\n",T1; 
      printf ">>>>>> Execution time: %s:%s:%s\n\n", substr("00",1,2-length(hours)) hours, substr("00",1,2-length(mins)) mins, substr("00",1,2-length(secs)) secs;
      }' $T_start $T_end $TT_start;
	echo "********************************************"; echo "";
	echo "************** End of Report ***************"; } 1>&2;
fi;

#
##################### EOF #####################
exit 0
